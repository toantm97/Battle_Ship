L 1 "..\..\..\Library\StdDriver\src\sys.c"
N/**************************************************************************//**
N * @file     sys.c
N * @version  V3.00
N * $Revision: 8 $
N * $Date: 14/12/25 11:26a $
N * @brief    NUC131 series SYS driver source file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#include "NUC131.h"
L 1 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 1
N/**************************************************************************//**
N * @file     NUC131.h
N * @version  V3.0
N * $Revision: 62 $
N * $Date: 15/05/22 9:06a $
N * @brief    NUC131 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of NUC131 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N  */
N
N
N/**
N  * \page PG_REV Revision History
N  *
N  * <b>Revision 3.00.002</b>
N  * \li Fix PWM driver bug for output low when duty is 100%
N  * \li Fix BPWM driver bug for output low when duty is 100%
N  * \li Fix CLK driver bug in CLK_SetCoreClock():
N  * \li Fix CLK driver constant definitions error of (B)PWM0/1_MODULE clock source selection.
N  * \li Fix GPIO_ENABLE_DOUT_MASK() and GPIO_DISABLE_DOUT_MASK() bug of GPIO driver.
N  * \li Fix PWM driver bug of PWM_MASK_OUTPUT() to remove redundant parenthesis.
N  * \li Fix BPWM driver bug of BPWM_MASK_OUTPUT() to remove redundant parenthesis.
N  * \li Fix UART driver clear flag bug in UART_ClearIntFlag().
N  * \li Fix I2C driver module reset bug of I2C_Close().
N  * \li Fix clear RS-485 address byte detection flag bug in UART_RS485_CLEAR_ADDR_FLAG() of UART driver.
N  * \li Fix SYS_IS_SYSTEM_RST() bug, it is "SYS_RSTSRC_RSTS_SYS_Msk" but "SYS_RSTSRC_RSTS_MCU_Msk".
N  * \li Fix clear RS-485 address byte detection flag clear bug in RS485_HANDLE() of UART_RS485_Slave sample code.
N  * \li Fix UART RS485 RTS active level to high level active in RS485_9bitModeMaster() of UART RS485 Sample code.
N  * \li Fix NVIC_EnableIRQ() to NVIC_DisableIRQ() after CHIP wake-up in I2C_Wakeup_Slave sample code
N  * \li Add PWM_EnableLoadMode() and PWM_DisableLoadMode() functions to PWM driver
N  * \li Add PWM_SetBrakePinSource() function to PWM driver
N  * \li Add CLK_GetPCLKFreq() function to CLK driver
N  * \li Add new macro PWM_SET_DEADZONE_CLK_SRC() to PWM driver
N  * \li Add new macro SYS_IS_LVR_RST() to SYS driver.
N  * \li Add non-blocking printf implementation and use predefine compiler option to enable/disable it.
N  *
N  * <b>Revision 3.00.001</b>
N  * \li Updated to support new API
N*/
N
N
N
N#ifndef __NUC131_H__
N#define __NUC131_H__
N
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @addtogroup Definitions Definitions for CMSIS
N  This file defines all structures and symbols:
N    - registers and bitfields
N    - peripheral base address
N    - peripheral ID
N    - Peripheral definitions
N  @{
N*/
N
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N*/
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
N
Ntypedef enum IRQn
N{
N    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N    NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
N    HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
N    SVCall_IRQn                 = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                       */
N    PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                       */
N    SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                   */
N
N    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
N    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
N    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
N    EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
N    EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
N    GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                 */
N    GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                           */
N    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
N    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
N    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
N    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
N    UART02_IRQn               = 12,       /*!< UART0/UART2 Interrupt                                */
N    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
N    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
N    UART3_IRQn                = 15,       /*!< UART3 Interrupt                                      */
N    UART4_IRQn                = 16,       /*!< UART4 Interrupt                                      */
N    UART5_IRQn                = 17,       /*!< UART5 Interrupt                                      */
N    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
N    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
N    CAN0_IRQn                 = 20,       /*!< CAN0 Interrupt                                       */
N    CAN1_IRQn                 = 21,       /*!< CAN1 Interrupt                                       */
N    PWM0_IRQn                 = 22,       /*!< PWM0 Interrupt                                       */
N    PWM1_IRQn                 = 23,       /*!< PWM1 Interrupt                                       */
N    BPWM0_IRQn                = 24,       /*!< BPWM0 Interrupt                                      */
N    BPWM1_IRQn                = 25,       /*!< BPWM1 Interrupt                                      */
N    BRAKE0_IRQn               = 26,       /*!< PWM0 Brake Interrupt                                 */
N    BRAKE1_IRQn               = 27,       /*!< PWM1 Brake Interrupt                                 */
N    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
N    ADC_IRQn                  = 29,       /*!< ADC Interrupt                                        */
N    CKD_IRQn                  = 30,       /*!< Clock detection Interrupt                            */
N} IRQn_Type;                                            
N                                                        
N                                                        
N/*                                                      
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N
N
N/*@}*/ /* end of group CMSIS */
N
N
N#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
L 1 "..\..\..\Library\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.01
N * @date     13. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 116 "..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "..\..\..\Library\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060750 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMINSTR_H */
L 117 "..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "..\..\..\Library\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060750 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMFUNC_H */
L 118 "..\..\..\Library\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
L 152 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "system_NUC131.h"               /* NUC131 System                                           */
L 1 "..\..\..\Library\Device\Nuvoton\NUC131\Include\system_NUC131.h" 1
N/**************************************************************************//**
N * @file     system_NUC131.h
N * @version  V3.0
N * $Revision: 2 $
N * $Date: 14/07/22 9:41a $
N * @brief    NUC131 Series CMSIS System Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYSTEM_NUC131_H
N#define __SYSTEM_NUC131_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* Using UART0 or UART1 */
N#define DEBUG_PORT   UART0
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __HXT       (12000000UL)    /*!< External Crystal Clock Frequency     */
N#define __LXT       (32768UL)       /*!< External Crystal Clock Frequency 32.768KHz */
N#define __HIRC      (22118400UL)    /*!< Internal 22M RC Oscillator Frequency */
N#define __LIRC      (10000UL)       /*!< Internal 10K RC Oscillator Frequency */
N#define __HSI       (50000000UL)    /*!< PLL default output is 50MHz */
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;        /*!< Cycles per micro second              */
Nextern uint32_t PllClock;           /*!< PLL Output Clock Frequency           */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system
N *         Initialize GPIO directions and values
N */
Nextern void SystemInit(void);
N
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from CPU registers.
N */
Nextern void SystemCoreClockUpdate(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 153 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N/** @addtogroup REGISTER Control Register
N
N  @{
N
N*/
N
N
N/*---------------------- Analog to Digital Converter -------------------------*/
N/**
N    @addtogroup ADC Analog to Digital Converter (ADC)
N    Memory Mapped Structure for ADC Controller
N@{ */
Ntypedef struct
N{
N
N    /**
N     * ADDR
N     * ===================================================================================================
N     * Offset: 0x00-0x1C  ADC Data Register 0~7
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RSLT      |A/D Conversion Result
N     * |        |          |This field contains conversion result of ADC.
N     * |        |          |When DMOF bit (ADCR[31]) set to 0, 12-bit ADC conversion result with unsigned format will be filled in RSLT (ADDRx[11:0], x=0~7) and zero will be filled in RSLT (ADDRx[15:12], x=0~7).
N     * |        |          |When DMOF bit (ADCR[31]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RSLT(ADDRx[11:0], x=0~7) and signed bits to will be filled in RSLT (ADDRx[15:12], x=0~7).
N     * |[16]    |OVERRUN   |Overrun Flag
N     * |        |          |0 = Data in RSLT (ADDRx[15:0], x=0~7) is recent conversion result.
N     * |        |          |1 = Data in RSLT (ADDRx[15:0], x=0~7) is overwritten.
N     * |        |          |If converted data in RSLT has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone.
N     * |        |          |It is cleared by hardware after ADDR register is read.
N     * |        |          |This is a read only bit.
N     * |[17]    |VALID     |Valid Flag
N     * |        |          |0 = Data in RSLT bits (ADDRx[15:0], x=0~7) is not valid.
N     * |        |          |1 = Data in RSLT bits (ADDRx[15:0], x=0~7) is valid.
N     * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
N     * |        |          |This is a read only bit
N     */
N    __I  uint32_t ADDR[8];
X    volatile const  uint32_t ADDR[8];
N
N    /**
N     * ADCR
N     * ===================================================================================================
N     * Offset: 0x20  ADC Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADEN      |A/D Converter Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Before starting A/D conversion function, this bit should be set to 1.
N     * |        |          |Clear it to 0 to disable A/D converter analog circuit for saving power consumption.
N     * |[1]     |ADIE      |A/D Interrupt Enable
N     * |        |          |0 = A/D interrupt function Disabled.
N     * |        |          |1 = A/D interrupt function Enabled.
N     * |        |          |A/D conversion end interrupt request is generated if ADIE bit (ADCR[1]) is set to 1.
N     * |[3:2]   |ADMD      |A/D Converter Operation Mode
N     * |        |          |00 = Single conversion.
N     * |        |          |01 = Reserved.
N     * |        |          |10 = Single-cycle scan.
N     * |        |          |11 = Continuous scan.
N     * |        |          |When changing the operation mode, software should disable ADST bit (ADCR[11]) firstly.
N     * |[5:4]   |TRGS      |Hardware Trigger Source
N     * |        |          |00 = A/D conversion is started by external STADC pin.
N     * |        |          |11 = A/D conversion is started by PWM Center-aligned trigger.
N     * |        |          |Others = Reserved.
N     * |        |          |Software should disable TRGEN (ADCR[8]) and ADST (ADCR[11]) before change TRGS.
N     * |[7:6]   |TRGCOND   |External Trigger Condition
N     * |        |          |These two bits decide external pin STADC trigger event is level or edge.
N     * |        |          |The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state for edge trigger.
N     * |        |          |00 = Low level.
N     * |        |          |01 = High level.
N     * |        |          |10 = Falling edge.
N     * |        |          |11 = Rising edge.
N     * |[8]     |TRGEN     |Hardware Trigger Enable
N     * |        |          |Enable or disable triggering of A/D conversion by hardware (external STADC pin or PWM Center-aligned trigger).
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |ADC hardware trigger function is only supported in single-cycle scan mode.
N     * |        |          |If hardware trigger mode, the ADST bit (ADCR[11]) can be set to 1 by the selected hardware trigger source.
N     * |[10]    |DIFFEN    |Differential Input Mode Enable
N     * |        |          |0 = Single-end analog input mode.
N     * |        |          |1 = Differential analog input mode.
N     * |        |          |Differential   input Paired Channel
N     * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus, where Vplus
N     * |        |          |is the analog input; Vminus is the inverted analog input.
N     * |        |          |In differential input mode, only the even number of the two corresponding channels needs to be enabled in ADCHER.
N     * |        |          |The conversion result will be placed to the corresponding data register of the enabled channel.
N     * |[11]    |ADST      |A/D Conversion Start
N     * |        |          |0 = Conversion stops and A/D converter enter idle state.
N     * |        |          |1 = Conversion starts.
N     * |        |          |ADST bit can be set to 1 from three sources: software, PWM Center-aligned trigger and external pin STADC.
N     * |        |          |ADST will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode.
N     * |        |          |In continuous scan mode, A/D conversion is continuously performed until software writes 0 to this bit or chip reset.
N     * |[31]    |DMOF      |A/D Differential Input Mode Output Format
N     * |        |          |0 = A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format.
N     * |        |          |1 = A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format.
N     */
N    __IO uint32_t ADCR;
X    volatile uint32_t ADCR;
N
N    /**
N     * ADCHER
N     * ===================================================================================================
N     * Offset: 0x24  ADC Channel Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |CHEN      |Analog Input Channel Enable
N     * |        |          |Set CHEN[7:0] to enable the corresponding analog input channel 7 ~ 0.
N     * |        |          |If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.
N     * |        |          |0 = ADC input channel Disabled.
N     * |        |          |1 = ADC input channel Enabled.
N     * |[9:8]   |PRESEL    |Analog Input Channel 7 Select
N     * |        |          |00 = External analog input.
N     * |        |          |01 = Internal band-gap voltage.
N     * |        |          |10 = Internal temperature sensor.
N     * |        |          |11 = Reserved.
N     * |        |          |Note:
N     * |        |          |When software select the band-gap voltage as the analog input source of ADC channel 7, ADC clock rate needs to be limited to slower than 300 kHz.
N     */
N    __IO uint32_t ADCHER;
X    volatile uint32_t ADCHER;
N
N    /**
N     * ADCMPR
N     * ===================================================================================================
N     * Offset: 0x28, 0x2C  ADC Compare Register 0 & 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CMPEN     |Compare Enable
N     * |        |          |0 = Compare function Disabled.
N     * |        |          |1 = Compare function Enabled.
N     * |        |          |Set this bit to 1 to enable ADC controller to compare CMPD (ADCMPR0/1[27:16]) with specified channel conversion result when converted data is loaded into ADDR register.
N     * |[1]     |CMPIE     |Compare Interrupt Enable
N     * |        |          |0 = Compare function interrupt Disabled.
N     * |        |          |1 = Compare function interrupt Enabled.
N     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (ADCMPR0/1[2]) and CMPMATCNT (ADCMPR0/1[11:8]), CMPF0/1 bit (ADSR[1]/[2]) will be asserted, in the meanwhile, if CMPIE (ADCMPR0/1[1]) is set to 1, a compare interrupt request is generated.
N     * |[2]     |CMPCOND   |Compare Condition
N     * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
N     * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
N     * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8])+1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.
N     * |[5:3]   |CMPCH     |Compare Channel Selection
N     * |        |          |000 = Channel 0 conversion result is selected to be compared.
N     * |        |          |001 = Channel 1 conversion result is selected to be compared.
N     * |        |          |010 = Channel 2 conversion result is selected to be compared.
N     * |        |          |011 = Channel 3 conversion result is selected to be compared.
N     * |        |          |100 = Channel 4 conversion result is selected to be compared.
N     * |        |          |101 = Channel 5 conversion result is selected to be compared.
N     * |        |          |110 = Channel 6 conversion result is selected to be compared.
N     * |        |          |111 = Channel 7 conversion result is selected to be compared.
N     * |[11:8]  |CMPMATCNT |Compare Match Count
N     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND (ADCMPR0/1[2]), the internal match counter will increase 1.
N     * |        |          |When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) +1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.
N     * |[27:16] |CMPD      |Comparison Data
N     * |        |          |The 12-bit data is used to compare with conversion result of specified channel.
N     * |        |          |When DMOF bit (ADCR[31]) is set to 0, ADC comparator compares CMPD with conversion result with unsigned format.
N     * |        |          |CMPD should be filled in unsigned format.
N     * |        |          |When DMOF bit (ADCR[31]) is set to 1, ADC comparator compares CMPD with conversion result with 2'complement format.
N     * |        |          |CMPD should be filled in 2'complement format.
N     */
N    __IO uint32_t ADCMPR[2];
X    volatile uint32_t ADCMPR[2];
N
N    /**
N     * ADSR
N     * ===================================================================================================
N     * Offset: 0x30  ADC Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ADF       |A/D Conversion End Flag
N     * |        |          |A status flag that indicates the end of A/D conversion.
N     * |        |          |ADF is set to 1 at these two conditions:
N     * |        |          |1. When A/D conversion ends in Single mode.
N     * |        |          |2. When A/D conversion ends on all specified channels in Scan mode.
N     * |        |          |This flag can be cleared by writing 1 to itself.
N     * |[1]     |CMPF0     |Compare Flag
N     * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1.
N     * |        |          |And it is cleared by writing 1 to self.
N     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting.
N     * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting.
N     * |[2]     |CMPF1     |Compare Flag
N     * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1.
N     * |        |          |And it is cleared by writing 1 to self.
N     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting.
N     * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting.
N     * |[3]     |BUSY      |BUSY/IDLE
N     * |        |          |0 = A/D converter is in idle state.
N     * |        |          |1 = A/D converter is busy at conversion.
N     * |        |          |This bit is mirror of as ADST bit (ADCR[11]).
N     * |        |          |It is read only.
N     * |[6:4]   |CHANNEL   |Current Conversion Channel
N     * |        |          |This field reflects the current conversion channel when BUSY = 1 (ADSR[3]).
N     * |        |          |When BUSY = 0, it shows the number of the next converted channel.
N     * |        |          |It is read only.
N     * |[15:8]  |VALID     |Data Valid Flag
N     * |        |          |It is a mirror of VALID bit (ADDR0~7[17]).
N     * |        |          |It is read only.
N     * |[23:16] |OVERRUN   |Overrun Flag
N     * |        |          |It is a mirror to OVERRUN bit (ADDR0~7[16]).
N     * |        |          |It is read only.
N     */
N    __IO uint32_t ADSR;
X    volatile uint32_t ADSR;
N
N} ADC_T;
N
N/**
N    @addtogroup ADC_CONST ADC Bit Field Definition
N    Constant Definitions for ADC Controller
N@{ */
N
N
N/* ADDR Bit Field Definitions */
N#define ADC_ADDR_VALID_Pos      17                                /*!< ADC_T::ADDR: VALID Position */
N#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC_T::ADDR: VALID Mask */
N
N#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC_T::ADDR: OVERRUN Position */
N#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC_T::ADDR: OVERRUN Mask */
N
N#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC_T::ADDR: RSLT Position */
N#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC_T::ADDR: RSLT Mask */
N
N/* ADCR Bit Field Definitions */
N#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC_T::ADCR: DMOF Position */
N#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC_T::ADCR: DMOF Mask */
N
N#define ADC_ADCR_ADST_Pos       11                                /*!< ADC_T::ADCR: ADST Position */
N#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC_T::ADCR: ADST Mask */
N
N#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC_T::ADCR: DIFFEN Position */
N#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC_T::ADCR: DIFFEN Mask */
N
N#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC_T::ADCR: TRGEN Position */
N#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC_T::ADCR: TRGEN Mask */
N
N#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC_T::ADCR: TRGCOND Position */
N#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC_T::ADCR: TRGCOND Mask */
N
N#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC_T::ADCR: TRGS Position */
N#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC_T::ADCR: TRGS Mask */
N
N#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC_T::ADCR: ADMD Position */
N#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC_T::ADCR: ADMD Mask */
N
N#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC_T::ADCR: ADIE Position */
N#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC_T::ADCR: ADIE Mask */
N
N#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC_T::ADCR: ADEN Position */
N#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC_T::ADCR: ADEN Mask */
N
N/* ADCHER Bit Field Definitions */
N#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC_T::ADCHER: PRESEL Position */
N#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC_T::ADCHER: PRESEL Mask */
N
N#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC_T::ADCHER: CHEN Position */
N#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC_T::ADCHER: CHEN Mask */
N
N/* ADCMPR Bit Field Definitions */
N#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC_T::ADCMPR: CMPD Position */
N#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC_T::ADCMPR: CMPD Mask */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC_T::ADCMPR: CMPMATCNT Position */
N#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC_T::ADCMPR: CMPMATCNT Mask */
N
N#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC_T::ADCMPR: CMPCH Position */
N#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC_T::ADCMPR: CMPCH Mask */
N
N#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC_T::ADCMPR: CMPCOND Position */
N#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC_T::ADCMPR: CMPCOND Mask */
N
N#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC_T::ADCMPR: CMPIE Position */
N#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC_T::ADCMPR: CMPIE Mask */
N
N#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC_T::ADCMPR: CMPEN Position */
N#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC_T::ADCMPR: CMPEN Mask */
N
N/* ADSR Bit Field Definitions */
N#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC_T::ADSR: OVERRUN Position */
N#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC_T::ADSR: OVERRUN Mask */
N
N#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC_T::ADSR: VALID Position */
N#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC_T::ADSR: VALID Mask */
N
N#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC_T::ADSR: CHANNEL Position */
N#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC_T::ADSR: CHANNEL Mask */
N
N#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC_T::ADSR: BUSY Position */
N#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC_T::ADSR: BUSY Mask */
N
N#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC_T::ADSR: CMPF1 Position */
N#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC_T::ADSR: CMPF1 Mask */
N
N#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC_T::ADSR: CMPF0 Position */
N#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC_T::ADSR: CMPF0 Mask */
N
N#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC_T::ADSR: ADF Position */
N#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC_T::ADSR: ADF Mask */
N
N/*@}*/ /* end of group ADC_CONST */
N/*@}*/ /* end of group ADC */
N
N
N
N/*---------------------- Basic Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup BPWM Basic Pulse Width Modulation Controller (BPWM)
N    Memory Mapped Structure for BPWM Controller
N@{ */
Ntypedef struct
N{
N    /**
N     * BPWM_CTL0
N     * ===================================================================================================
N     * Offset: 0x00  BPWM Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CTRLDn    |Center Re-Load
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period. CMPDAT
N     * |        |          |will load to CMPBUF at the center point of a period.
N     * |[21:16] |IMMLDENn  |Immediately Load Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF
N     * |        |          |at the end point or center point of each period by setting CTRLD bit.
N     * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
N     * |        |          |Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
N     * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
N     * |        |          |If counter halt is enabled, BPWM all counters will keep current value until exit
N     * |        |          |ICE debug mode.
N     * |        |          |0 = ICE debug mode counter halt disable.
N     * |        |          |1 = ICE debug mode counter halt enable.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgment effects BPWM output.
N     * |        |          |BPWM pin will be forced as tri-state while ICE debug mode acknowledged.
N     * |        |          |1 = ICE debug mode acknowledgment disabled.
N     * |        |          |BPWM pin will keep output no matter ICE debug mode acknowledged or not.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     */
N    __IO uint32_t CTL0;
X    volatile uint32_t CTL0;
N
N    /**
N     * BPWM_CTL1
N     * ===================================================================================================
N     * Offset: 0x04  BPWM Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |CNTTYPE0  |BPWM Counter Behavior Type 0
N     * |        |          |Each bit n controls corresponding BPWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     */
N    __IO uint32_t CTL1;
X    volatile uint32_t CTL1;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED0
N     * ===================================================================================================
N     * Offset: 0x0008 ~ 0x000C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED0[2];
X    volatile const  uint32_t RESERVED0[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_CLKSRC
N     * ===================================================================================================
N     * Offset: 0x10  BPWM Clock Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |ECLKSRC0  |BPWM_CH01 External Clock Source Select
N     * |        |          |000 = BPWMx_CLK, x denotes 0 or 1.
N     * |        |          |001 = TIMER0 overflow.
N     * |        |          |010 = TIMER1 overflow.
N     * |        |          |011 = TIMER2 overflow.
N     * |        |          |100 = TIMER3 overflow.
N     * |        |          |Others = Reserved.
N     */
N    __IO uint32_t CLKSRC;
X    volatile uint32_t CLKSRC;
N
N    /**
N     * BPWM_CLKPSC
N     * ===================================================================================================
N     * Offset: 0x14  BPWM Clock Pre-scale Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CLKPSC    |BPWM Counter Clock Pre-Scale
N     * |        |          |The clock of BPWM counter is decided by clock prescaler. Each BPWM pair share one BPWM
N     * |        |          |counter clock prescaler. The clock of BPWM counter is divided by (CLKPSC+ 1).
N     */
N    __IO uint32_t CLKPSC;
X    volatile uint32_t CLKPSC;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED1
N     * ===================================================================================================
N     * Offset: 0x0018 ~ 0x001C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED1[2];
X    volatile const  uint32_t RESERVED1[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_CNTEN
N     * ===================================================================================================
N     * Offset: 0x20  BPWM Counter Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTEN0    |BPWM Counter Enable 0
N     * |        |          |0 = BPWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = BPWM Counter and clock prescaler Start Running.
N     */
N    __IO uint32_t CNTEN;
X    volatile uint32_t CNTEN;
N
N    /**
N     * BPWM_CNTCLR
N     * ===================================================================================================
N     * Offset: 0x24  BPWM Clear Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTCLR0   |Clear BPWM Counter Control Bit 0
N     * |        |          |It is automatically cleared by hardware.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit BPWM counter to 0000H.
N     */
N    __IO uint32_t CNTCLR;
X    volatile uint32_t CNTCLR;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED2
N     * ===================================================================================================
N     * Offset: 0x0028 ~ 0x002C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED2[2];
X    volatile const  uint32_t RESERVED2[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_PERIOD
N     * ===================================================================================================
N     * Offset: 0x30  BPWM Period Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD    |BPWM Period Register
N     * |        |          |Up-Count mode: In this mode, BPWM counter counts from 0 to PERIOD, and restarts from 0.
N     * |        |          |Down-Count mode: In this mode, BPWM counter counts from PERIOD to 0, and restarts from PERIOD.
N     * |        |          |BPWM period time = (PERIOD+1) * BPWM_CLK period.
N     * |        |          |Up-Down-Count mode: In this mode, BPWM counter counts from 0 to PERIOD, then decrements to 0
N     * |        |          |and repeats again.
N     * |        |          |BPWM period time = 2 * PERIOD * BPWM_CLK period.
N     */
N    __IO uint32_t PERIOD;
X    volatile uint32_t PERIOD;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED3
N     * ===================================================================================================
N     * Offset: 0x0034 ~ 0x004C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED3[7];
X    volatile const  uint32_t RESERVED3[7];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_CMPDAT0~5
N     * ===================================================================================================
N     * Offset: 0x50~0x64  BPWM Comparator Register 0~5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMPDAT    |BPWM Comparator Register
N     * |        |          |CMPDAT use to compare with CNT to generate BPWM waveform, interrupt and trigger ADC.
N     * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent BPWM_CH0~5 compared point.
N     * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1,
N     * |        |          |3, 5 denote as second compared point for the corresponding 3 complementary
N     * |        |          |pairs BPWM_CH0 and BPWM_CH1, BPWM_CH2 and BPWM_CH3, BPWM_CH4 and BPWM_CH5.
N     */
N    __IO uint32_t CMPDAT[6];
X    volatile uint32_t CMPDAT[6];
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED4
N     * ===================================================================================================
N     * Offset: 0x0068 ~ 0x008C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED4[10];
X    volatile const  uint32_t RESERVED4[10];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_CNT
N     * ===================================================================================================
N     * Offset: 0x90  BPWM Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNT       |BPWM Data Register (Read Only)
N     * |        |          |User can monitor CNT to know the current value in 16-bit period counter.
N     * |[16]    |DIRF      |BPWM Direction Indicator Flag (Read Only)
N     * |        |          |0 = Counter is Down count.
N     * |        |          |1 = Counter is UP count.
N     */
N    __IO uint32_t CNT;
X    volatile uint32_t CNT;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED5
N     * ===================================================================================================
N     * Offset: 0x0094 ~ 0x00AC
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED5[7];
X    volatile const  uint32_t RESERVED5[7];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_WGCTL0
N     * ===================================================================================================
N     * Offset: 0xB0  BPWM Generation Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |ZPCTLn    |BPWM Zero Point Control
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = BPWM zero point output Low.
N     * |        |          |10 = BPWM zero point output High.
N     * |        |          |11 = BPWM zero point output Toggle.
N     * |        |          |BPWM can control output level when BPWM counter count to zero.
N     * |[27:16] |PRDPCTLn  |BPWM Period (Center) Point Control
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = BPWM period (center) point output Low.
N     * |        |          |10 = BPWM period (center) point output High.
N     * |        |          |11 = BPWM period (center) point output Toggle.
N     * |        |          |BPWM can control output level when BPWM counter count to (PERIODn+1).
N     * |        |          |Note: This bit is center point control when BPWM counter operating in up-down counter type.
N     */
N    __IO uint32_t WGCTL0;
X    volatile uint32_t WGCTL0;
N
N
N    /**
N     * BPWM_WGCTL1
N     * ===================================================================================================
N     * Offset: 0xB4  BPWM Generation Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CMPUCTLn  |BPWM Compare Up Point Control
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = BPWM compare up point output Low.
N     * |        |          |10 = BPWM compare up point output High.
N     * |        |          |11 = BPWM compare up point output Toggle.
N     * |        |          |BPWM can control output level when BPWM counter up count to CMPDAT.
N     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N     * |[27:16] |CMPDCTLn  |BPWM Compare Down Point Control
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = BPWM compare down point output Low.
N     * |        |          |10 = BPWM compare down point output High.
N     * |        |          |11 = BPWM compare down point output Toggle.
N     * |        |          |BPWM can control output level when BPWM counter down count to CMPDAT.
N     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N     */
N    __IO uint32_t WGCTL1;
X    volatile uint32_t WGCTL1;
N
N    /**
N     * BPWM_MSKEN
N     * ===================================================================================================
N     * Offset: 0xB8  BPWM Mask Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MSKENn    |BPWM Mask Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |The BPWM output signal will be masked when this bit is enabled. The corresponding BPWM
N     * |        |          |channel n will output MSKDATn (BPWM_MSK[5:0]) data.
N     * |        |          |0 = BPWM output signal is non-masked.
N     * |        |          |1 = BPWM output signal is masked and output MSKDATn data.
N     */
N    __IO uint32_t MSKEN;
X    volatile uint32_t MSKEN;
N
N    /**
N     * BPWM_MSK
N     * ===================================================================================================
N     * Offset: 0xBC  BPWM Mask Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MSKDATn   |BPWM Mask Data Bit
N     * |        |          |This data bit control the state of BPWMn output pin, if corresponding mask function
N     * |        |          |is enabled. Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Output logic low to BPWMn.
N     * |        |          |1 = Output logic high to BPWMn.
N     */
N    __IO uint32_t MSK;
X    volatile uint32_t MSK;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED6
N     * ===================================================================================================
N     * Offset: 0x00C0 ~ 0x00D0
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED6[5];
X    volatile const  uint32_t RESERVED6[5];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_POLCTL
N     * ===================================================================================================
N     * Offset: 0xD4  BPWM Pin Polar Inverse Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |PINVn     |BPWM PIN Polar Inverse Control
N     * |        |          |The register controls polarity state of BPWM output. Each bit n controls the
N     * |        |          |corresponding BPWM channel n.
N     * |        |          |0 = BPWM output polar inverse Disabled.
N     * |        |          |1 = BPWM output polar inverse Enabled.
N     */
N    __IO uint32_t POLCTL;
X    volatile uint32_t POLCTL;
N
N    /**
N     * BPWM_POEN
N     * ===================================================================================================
N     * Offset: 0xD8  BPWM Output Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |POENn     |BPWM Pin Output Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = BPWM pin at tri-state.
N     * |        |          |1 = BPWM pin in output mode.
N     */
N    __IO uint32_t POEN;
X    volatile uint32_t POEN;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED7
N     * ===================================================================================================
N     * Offset: 0x00DC
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED7[1];
X    volatile const  uint32_t RESERVED7[1];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_INTEN
N     * ===================================================================================================
N     * Offset: 0xE0  BPWM Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ZIEN0     |BPWM Zero Point Interrupt Enable 0
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[8]     |PIEN0     |BPWM Period Point Interrupt Enable 0
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note: When up-down counter type period point means center point.
N     * |[21:16] |CMPUIENn  |BPWM Compare Up Count Interrupt Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N     * |[29:24] |CMPDIENn  |BPWM Compare Down Count Interrupt Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N     */
N    __IO uint32_t INTEN;
X    volatile uint32_t INTEN;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED8
N     * ===================================================================================================
N     * Offset: 0x00E4
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED8[1];
X    volatile const  uint32_t RESERVED8[1];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_INTSTS
N     * ===================================================================================================
N     * Offset: 0xE8  BPWM Interrupt Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ZIF0      |BPWM Zero Point Interrupt Flag 0
N     * |        |          |This bit is set by hardware when BPWM_CH0 counter reaches zero, software can write 1
N     * |        |          |to clear this bit to zero.
N     * |[8]     |PIF0      |BPWM Period Point Interrupt Flag 0
N     * |        |          |This bit is set by hardware when BPWM_CH0 counter reaches BPWM_PERIOD0, software can
N     * |        |          |write 1 to clear this bit to zero.
N     * |[21:16] |CMPUIFn   |BPWM Compare Up Count Interrupt Flag
N     * |        |          |Flag is set by hardware when BPWM counter up count and reaches BPWM_CMPDATn,
N     * |        |          |software can clear this bit by writing 1 to it. Each bit n controls the
N     * |        |          |corresponding BPWM channel n.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N     * |[29:24] |CMPDIFn   |BPWM Compare Down Count Interrupt Flag
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |Flag is set by hardware when BPWM counter down count and reaches BPWM_CMPDATn,
N     * |        |          |software can clear this bit by writing 1 to it.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
N     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N     */
N    __IO uint32_t INTSTS;
X    volatile uint32_t INTSTS;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED9
N     * ===================================================================================================
N     * Offset: 0x00EC ~ 0x00F4
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED9[3];
X    volatile const  uint32_t RESERVED9[3];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_ADCTS0
N     * ===================================================================================================
N     * Offset: 0xF8  BPWM Trigger ADC Source Select Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |TRGSEL0   |BPWM_CH0 Trigger ADC Source Select
N     * |        |          |0000 = BPWM_CH0 zero point.
N     * |        |          |0001 = BPWM_CH0 period point.
N     * |        |          |0010 = BPWM_CH0 zero or period point.
N     * |        |          |0011 = BPWM_CH0 up-count CMPDAT point.
N     * |        |          |0100 = BPWM_CH0 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = BPWM_CH1 up-count CMPDAT point.
N     * |        |          |1001 = BPWM_CH1 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[7]     |TRGEN0    |BPWM_CH0 Trigger ADC Enable Bit
N     * |[11:8]  |TRGSEL1   |BPWM_CH1 Trigger ADC Source Select
N     * |        |          |0000 = BPWM_CH0 zero point.
N     * |        |          |0001 = BPWM_CH0 period point.
N     * |        |          |0010 = BPWM_CH0 zero or period point.
N     * |        |          |0011 = BPWM_CH0 up-count CMPDAT point.
N     * |        |          |0100 = BPWM_CH0 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = BPWM_CH1 up-count CMPDAT point.
N     * |        |          |1001 = BPWM_CH1 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[15]    |TRGEN1    |BPWM_CH1 Trigger ADC Enable Bit
N     * |[19:16] |TRGSEL2   |BPWM_CH2 Trigger ADC Source Select
N     * |        |          |0000 = BPWM_CH2 zero point.
N     * |        |          |0001 = BPWM_CH2 period point.
N     * |        |          |0010 = BPWM_CH2 zero or period point.
N     * |        |          |0011 = BPWM_CH2 up-count CMPDAT point.
N     * |        |          |0100 = BPWM_CH2 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = BPWM_CH3 up-count CMPDAT point.
N     * |        |          |1001 = BPWM_CH3 down-count CMPDAT point.
N     * |        |          |Others = Reserved.
N     * |[23]    |TRGEN2    |BPWM_CH2 Trigger ADC Enable Bit
N     * |[27:24] |TRGSEL3   |BPWM_CH3 Trigger ADC Source Select
N     * |        |          |0000 = BPWM_CH2 zero point.
N     * |        |          |0001 = BPWM_CH2 period point.
N     * |        |          |0010 = BPWM_CH2 zero or period point.
N     * |        |          |0011 = BPWM_CH2 up-count CMPDAT point.
N     * |        |          |0100 = BPWM_CH2 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = BPWM_CH3 up-count CMPDAT point.
N     * |        |          |1001 = BPWM_CH3 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[31]    |TRGEN3    |BPWM_CH3 Trigger ADC Enable Bit
N     */
N    __IO uint32_t ADCTS0;
X    volatile uint32_t ADCTS0;
N
N    /**
N     * BPWM_ADCTS1
N     * ===================================================================================================
N     * Offset: 0xFC  BPWM Trigger ADC Source Select Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |TRGSEL4   |BPWM_CH4 Trigger ADC Source Select
N     * |        |          |0000 = BPWM_CH4 zero point.
N     * |        |          |0001 = BPWM_CH4 period point.
N     * |        |          |0010 = BPWM_CH4 zero or period point.
N     * |        |          |0011 = BPWM_CH4 up-count CMPDAT point.
N     * |        |          |0100 = BPWM_CH4 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = BPWM_CH5 up-count CMPDAT point.
N     * |        |          |1001 = BPWM_CH5 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[7]     |TRGEN4    |BPWM_CH4 Trigger ADC Enable Bit
N     * |[11:8]  |TRGSEL5   |BPWM_CH5 Trigger ADC Source Select
N     * |        |          |0000 = BPWM_CH4 zero point.
N     * |        |          |0001 = BPWM_CH4 period point.
N     * |        |          |0010 = BPWM_CH4 zero or period point.
N     * |        |          |0011 = BPWM_CH4 up-count CMPDAT point.
N     * |        |          |0100 = BPWM_CH4 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = BPWM_CH5 up-count CMPDAT point.
N     * |        |          |1001 = BPWM_CH5 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[15]    |TRGEN5    |BPWM_CH5 Trigger ADC Enable Bit
N     */
N    __IO uint32_t ADCTS1;
X    volatile uint32_t ADCTS1;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED10
N     * ===================================================================================================
N     * Offset: 0x0100 ~ 0x010C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED10[4];
X    volatile const  uint32_t RESERVED10[4];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_SSCTL
N     * ===================================================================================================
N     * Offset: 0x110  BPWM Synchronous Start Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SSEN0     |BPWM Synchronous Start Function Enable 0
N     * |        |          |When synchronous start function is enabled, the BPWM_CH0 counter enable bit (CNTEN0)
N     * |        |          |can be enabled by writing BPWM synchronous start trigger bit (CNTSEN).
N     * |        |          |0 = BPWM synchronous start function Disabled.
N     * |        |          |1 = BPWM synchronous start function Enabled.
N     * |[9:8]   |SSRC      |BPWM Synchronous Start Source Select
N     * |        |          |00 = Synchronous start source come from BPWM0.
N     * |        |          |01 = Synchronous start source come from BPWM1.
N     * |        |          |10 = Synchronous start source come from BPWM0.
N     * |        |          |11 = Synchronous start source come from BPWM1.
N     */
N    __IO uint32_t SSCTL;
X    volatile uint32_t SSCTL;
N
N    /**
N     * BPWM_SSTRG
N     * ===================================================================================================
N     * Offset: 0x114  BPWM Synchronous Start Trigger Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTSEN    |BPWM Counter Synchronous Start Enable (Write Only)
N     * |        |          |PMW counter synchronous enable function is used to make selected BPWM channels
N     * |        |          |(include BPWM0_CHx and BPWM1_CHx) start counting at the same time.
N     * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0
N     * |        |          |to 5) if correlated BPWM channel counter synchronous start function is enabled.
N     * |        |          |Note: This bit only present in BPWM0_BA.
N     */
N    __IO uint32_t SSTRG;
X    volatile uint32_t SSTRG;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED11
N     * ===================================================================================================
N     * Offset: 0x0118 ~ 0x011C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED11[2];
X    volatile const  uint32_t RESERVED11[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_STATUS
N     * ===================================================================================================
N     * Offset: 0x120  BPWM Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTMAX0   |Time-Base Counter 0 Equal To 0xFFFF Latched Status
N     * |        |          |0 = Indicates the time-base counter never reached its maximum value 0xFFFF.
N     * |        |          |1 = Indicates the time-base counter reached its maximum value, software can write 1 to clear
N     * |        |          |this bit.
N     * |[21:16] |ADCTRGn   |ADC Start Of Conversion Status
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can
N     * |        |          |write 1 to clear this bit.
N     */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED12
N     * ===================================================================================================
N     * Offset: 0x0124 ~ 0x01FC
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED12[55];
X    volatile const  uint32_t RESERVED12[55];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_CAPINEN
N     * ===================================================================================================
N     * Offset: 0x200  BPWM Capture Input Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CAPINENn  |Capture Input Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = BPWM Channel capture input path Disabled. The input of BPWM channel capture function
N     * |        |          |is always regarded as 0.
N     * |        |          |1 = BPWM Channel capture input path Enabled. The input of BPWM channel capture function
N     * |        |          |comes from correlative multifunction pin.
N     */
N    __IO uint32_t CAPINEN;
X    volatile uint32_t CAPINEN;
N
N    /**
N     * BPWM_CAPCTL
N     * ===================================================================================================
N     * Offset: 0x204  BPWM Capture Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CAPENn    |Capture Function Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
N     * |        |          |1 = Capture function Enabled. Capture latched the BPWM counter value when detected
N     * |        |          |rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT
N     * |        |          |(Falling latch).
N     * |[13:8]  |CAPINVn   |Capture Inverter Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Capture source inverter Disabled.
N     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N     * |[21:16] |RCRLDENn  |Rising Capture Reload Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Rising capture reload counter Disabled.
N     * |        |          |1 = Rising capture reload counter Enabled.
N     * |[29:24] |FCRLDENn  |Falling Capture Reload Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Falling capture reload counter Disabled.
N     * |        |          |1 = Falling capture reload counter Enabled.
N     */
N    __IO uint32_t CAPCTL;
X    volatile uint32_t CAPCTL;
N
N    /**
N     * BPWM_CAPSTS
N     * ===================================================================================================
N     * Offset: 0x208  BPWM Capture Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CRIFOVn   |Capture Rising Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if rising latch happened when the corresponding CAPRIF is 1.
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CAPRIF.
N     * |[13:8]  |CFIFOVn   |Capture Falling Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if falling latch happened when the corresponding CAPFIF is 1.
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CAPFIF.
N     */
N    __IO uint32_t CAPSTS;
X    volatile uint32_t CAPSTS;
N
N    /**
N     * BPWM_RCAPDAT0
N     * ===================================================================================================
N     * Offset: 0x20C  BPWM Rising Capture Data Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT0;
X    volatile uint32_t RCAPDAT0;
N
N    /**
N     * BPWM_FCAPDAT0
N     * ===================================================================================================
N     * Offset: 0x210  BPWM Falling Capture Data Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT0;
X    volatile uint32_t FCAPDAT0;
N
N    /**
N     * BPWM_RCAPDAT1
N     * ===================================================================================================
N     * Offset: 0x214  BPWM Rising Capture Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT1;
X    volatile uint32_t RCAPDAT1;
N
N    /**
N     * BPWM_FCAPDAT1
N     * ===================================================================================================
N     * Offset: 0x218  BPWM Falling Capture Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT1;
X    volatile uint32_t FCAPDAT1;
N
N    /**
N     * BPWM_RCAPDAT2
N     * ===================================================================================================
N     * Offset: 0x21C  BPWM Rising Capture Data Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT2;
X    volatile uint32_t RCAPDAT2;
N
N    /**
N     * BPWM_FCAPDAT2
N     * ===================================================================================================
N     * Offset: 0x220  BPWM Falling Capture Data Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT2;
X    volatile uint32_t FCAPDAT2;
N
N    /**
N     * BPWM_RCAPDAT3
N     * ===================================================================================================
N     * Offset: 0x224  BPWM Rising Capture Data Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT3;
X    volatile uint32_t RCAPDAT3;
N
N    /**
N     * BPWM_FCAPDAT3
N     * ===================================================================================================
N     * Offset: 0x228  BPWM Falling Capture Data Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT3;
X    volatile uint32_t FCAPDAT3;
N
N
N    /**
N     * BPWM_RCAPDAT4
N     * ===================================================================================================
N     * Offset: 0x22C  BPWM Rising Capture Data Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT4;
X    volatile uint32_t RCAPDAT4;
N
N    /**
N     * BPWM_FCAPDAT4
N     * ===================================================================================================
N     * Offset: 0x230  BPWM Falling Capture Data Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT4;
X    volatile uint32_t FCAPDAT4;
N
N    /**
N     * BPWM_RCAPDAT5
N     * ===================================================================================================
N     * Offset: 0x234  BPWM Rising Capture Data Register 5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT5;
X    volatile uint32_t RCAPDAT5;
N
N    /**
N     * BPWM_FCAPDAT5
N     * ===================================================================================================
N     * Offset: 0x238  BPWM Falling Capture Data Register 5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT5;
X    volatile uint32_t FCAPDAT5;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED13
N     * ===================================================================================================
N     * Offset: 0x023C ~ 0x024C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED13[5];
X    volatile const  uint32_t RESERVED13[5];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_CAPIEN
N     * ===================================================================================================
N     * Offset: 0x250  BPWM Capture Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CAPRIENn  |BPWM Capture Rising Latch Interrupt Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Capture rising edge latch interrupt Disabled.
N     * |        |          |1 = Capture rising edge latch interrupt Enabled.
N     * |[13:8]  |CAPFIENn  |BPWM Capture Falling Latch Interrupt Enable
N     * |        |          |Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = Capture falling edge latch interrupt Disabled.
N     * |        |          |1 = Capture falling edge latch interrupt Enabled.
N     */
N    __IO uint32_t CAPIEN;
X    volatile uint32_t CAPIEN;
N
N
N    /**
N     * BPWM_CAPIF
N     * ===================================================================================================
N     * Offset: 0x254  BPWM Capture Interrupt Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CAPRIFn   |BPWM Capture Rising Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = No capture rising latch condition happened.
N     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N     * |[13:8]  |CAPFIFn   |BPWM Capture Falling Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding BPWM channel n.
N     * |        |          |0 = No capture falling latch condition happened.
N     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N     */
N    __IO uint32_t CAPIF;
X    volatile uint32_t CAPIF;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED14
N     * ===================================================================================================
N     * Offset: 0x0258 ~ 0x0300
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED14[43];
X    volatile const  uint32_t RESERVED14[43];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_PBUF
N     * ===================================================================================================
N     * Offset: 0x304  BPWM PERIOD Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PBUF      |BPWM Period Register Buffer (Read Only)
N     * |        |          |Used as PERIOD active register.
N     */
N    __I  uint32_t PBUF;
X    volatile const  uint32_t PBUF;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED15
N     * ===================================================================================================
N     * Offset: 0x0308 ~ 0x0318
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED15[5];
X    volatile const  uint32_t RESERVED15[5];
N    /**
N     * @endcond
N     */
N
N    /**
N     * BPWM_CMPBUF0~5
N     * ===================================================================================================
N     * Offset: 0x31C~0x330  BPWM CMP0~5 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMPBUF    |BPWM Comparator Register Buffer (Read Only)
N     * |        |          |Used as CMP active register.
N     */
N    __I  uint32_t CMPBUF[6];
X    volatile const  uint32_t CMPBUF[6];
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED16
N     * ===================================================================================================
N     * Offset: 0x0334 ~ 0x0FFC
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED16[819];
X    volatile const  uint32_t RESERVED16[819];
N    /**
N     * @endcond
N     */
N} BPWM_T;
N
N/**
N    @addtogroup BPWM_CONST BPWM Bit Field Definition
N    Constant Definitions for BPWM Controller
N@{ */
N
N#define BPWM_CTL0_CTRLDn_Pos             (0)                                                /*!< BPWM_T::CTL0: CTRLDn Position              */
N#define BPWM_CTL0_CTRLDn_Msk             (0x3ful << BPWM_CTL0_CTRLDn_Pos)                   /*!< BPWM_T::CTL0: CTRLDn Mask                  */
N
N#define BPWM_CTL0_CTRLD0_Pos             (0)                                                /*!< BPWM_T::CTL0: CTRLD0 Position              */
N#define BPWM_CTL0_CTRLD0_Msk             (0x1ul << BPWM_CTL0_CTRLD0_Pos)                    /*!< BPWM_T::CTL0: CTRLD0 Mask                  */
N
N#define BPWM_CTL0_CTRLD1_Pos             (1)                                                /*!< BPWM_T::CTL0: CTRLD1 Position              */
N#define BPWM_CTL0_CTRLD1_Msk             (0x1ul << BPWM_CTL0_CTRLD1_Pos)                    /*!< BPWM_T::CTL0: CTRLD1 Mask                  */
N
N#define BPWM_CTL0_CTRLD2_Pos             (2)                                                /*!< BPWM_T::CTL0: CTRLD2 Position              */
N#define BPWM_CTL0_CTRLD2_Msk             (0x1ul << BPWM_CTL0_CTRLD2_Pos)                    /*!< BPWM_T::CTL0: CTRLD2 Mask                  */
N
N#define BPWM_CTL0_CTRLD3_Pos             (3)                                                /*!< BPWM_T::CTL0: CTRLD3 Position              */
N#define BPWM_CTL0_CTRLD3_Msk             (0x1ul << BPWM_CTL0_CTRLD3_Pos)                    /*!< BPWM_T::CTL0: CTRLD3 Mask                  */
N
N#define BPWM_CTL0_CTRLD4_Pos             (4)                                                /*!< BPWM_T::CTL0: CTRLD4 Position              */
N#define BPWM_CTL0_CTRLD4_Msk             (0x1ul << BPWM_CTL0_CTRLD4_Pos)                    /*!< BPWM_T::CTL0: CTRLD4 Mask                  */
N
N#define BPWM_CTL0_CTRLD5_Pos             (5)                                                /*!< BPWM_T::CTL0: CTRLD5 Position              */
N#define BPWM_CTL0_CTRLD5_Msk             (0x1ul << BPWM_CTL0_CTRLD5_Pos)                    /*!< BPWM_T::CTL0: CTRLD5 Mask                  */
N
N#define BPWM_CTL0_IMMLDENn_Pos           (16)                                               /*!< BPWM_T::CTL0: IMMLDENn Position            */
N#define BPWM_CTL0_IMMLDENn_Msk           (0x3ful << BPWM_CTL0_IMMLDENn_Pos)                 /*!< BPWM_T::CTL0: IMMLDENn Mask                */
N
N#define BPWM_CTL0_IMMLDEN0_Pos           (16)                                               /*!< BPWM_T::CTL0: IMMLDEN0 Position            */
N#define BPWM_CTL0_IMMLDEN0_Msk           (0x1ul << BPWM_CTL0_IMMLDEN0_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN0 Mask                */
N
N#define BPWM_CTL0_IMMLDEN1_Pos           (17)                                               /*!< BPWM_T::CTL0: IMMLDEN1 Position            */
N#define BPWM_CTL0_IMMLDEN1_Msk           (0x1ul << BPWM_CTL0_IMMLDEN1_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN1 Mask                */
N
N#define BPWM_CTL0_IMMLDEN2_Pos           (18)                                               /*!< BPWM_T::CTL0: IMMLDEN2 Position            */
N#define BPWM_CTL0_IMMLDEN2_Msk           (0x1ul << BPWM_CTL0_IMMLDEN2_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN2 Mask                */
N
N#define BPWM_CTL0_IMMLDEN3_Pos           (19)                                               /*!< BPWM_T::CTL0: IMMLDEN3 Position            */
N#define BPWM_CTL0_IMMLDEN3_Msk           (0x1ul << BPWM_CTL0_IMMLDEN3_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN3 Mask                */
N
N#define BPWM_CTL0_IMMLDEN4_Pos           (20)                                               /*!< BPWM_T::CTL0: IMMLDEN4 Position            */
N#define BPWM_CTL0_IMMLDEN4_Msk           (0x1ul << BPWM_CTL0_IMMLDEN4_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN4 Mask                */
N
N#define BPWM_CTL0_IMMLDEN5_Pos           (21)                                               /*!< BPWM_T::CTL0: IMMLDEN5 Position            */
N#define BPWM_CTL0_IMMLDEN5_Msk           (0x1ul << BPWM_CTL0_IMMLDEN5_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN5 Mask                */
N
N#define BPWM_CTL0_DBGHALT_Pos            (30)                                               /*!< BPWM_T::CTL0: DBGHALT Position             */
N#define BPWM_CTL0_DBGHALT_Msk            (0x1ul << BPWM_CTL0_DBGHALT_Pos)                   /*!< BPWM_T::CTL0: DBGHALT Mask                 */
N
N#define BPWM_CTL0_DBGTRIOFF_Pos          (31)                                               /*!< BPWM_T::CTL0: DBGTRIOFF Position           */
N#define BPWM_CTL0_DBGTRIOFF_Msk          (0x1ul << BPWM_CTL0_DBGTRIOFF_Pos)                 /*!< BPWM_T::CTL0: DBGTRIOFF Mask               */
N
N#define BPWM_CTL1_CNTTYPE0_Pos           (0)                                                /*!< BPWM_T::CTL1: CNTTYPE0 Position            */
N#define BPWM_CTL1_CNTTYPE0_Msk           (0x3ul << BPWM_CTL1_CNTTYPE0_Pos)                  /*!< BPWM_T::CTL1: CNTTYPE0 Mask                */
N
N#define BPWM_CLKSRC_ECLKSRC0_Pos         (0)                                                /*!< BPWM_T::CLKSRC: ECLKSRC0 Position          */
N#define BPWM_CLKSRC_ECLKSRC0_Msk         (0x7ul << BPWM_CLKSRC_ECLKSRC0_Pos)                /*!< BPWM_T::CLKSRC: ECLKSRC0 Mask              */
N
N#define BPWM_CLKPSC_CLKPSC_Pos           (0)                                                /*!< BPWM_T::CLKSRC: CLKPSC Position            */
N#define BPWM_CLKPSC_CLKPSC_Msk           (0xffful << BPWM_CLKPSC_CLKPSC_Pos)                /*!< BPWM_T::CLKSRC: CLKPSC Mask                */
N
N#define BPWM_CNTEN_CNTEN0_Pos            (0)                                                /*!< BPWM_T::CNTEN: CNTEN0 Position             */
N#define BPWM_CNTEN_CNTEN0_Msk            (0x1ul << BPWM_CNTEN_CNTEN0_Pos)                   /*!< BPWM_T::CNTEN: CNTEN0 Mask                 */
N
N#define BPWM_CNTCLR_CNTCLR0_Pos          (0)                                                /*!< BPWM_T::CNTCLR: CNTCLR0 Position           */
N#define BPWM_CNTCLR_CNTCLR0_Msk          (0x1ul << BPWM_CNTCLR_CNTCLR0_Pos)                 /*!< BPWM_T::CNTCLR: CNTCLR0 Mask               */
N
N#define BPWM_PERIOD_PERIOD_Pos           (0)                                                /*!< BPWM_T::PERIOD: PERIOD Position            */
N#define BPWM_PERIOD_PERIOD_Msk           (0xfffful << BPWM_PERIOD_PERIOD_Pos)               /*!< BPWM_T::PERIOD: PERIOD Mask                */
N
N#define BPWM_CMPDAT_CMP_Pos              (0)                                                /*!< BPWM_T::CMPDAT: CMP Position               */
N#define BPWM_CMPDAT_CMP_Msk              (0xfffful << BPWM_CMPDAT_CMP_Pos)                  /*!< BPWM_T::CMPDAT: CMP Mask                   */
N
N#define BPWM_CNT_CNT_Pos                 (0)                                                /*!< BPWM_T::CNT: CNT Position                  */
N#define BPWM_CNT_CNT_Msk                 (0xfffful << BPWM_CNT_CNT_Pos)                     /*!< BPWM_T::CNT: CNT Mask                      */
N
N#define BPWM_CNT_DIRF_Pos                (16)                                               /*!< BPWM_T::CNT: DIRF Position                 */
N#define BPWM_CNT_DIRF_Msk                (0x1ul << BPWM_CNT_DIRF_Pos)                       /*!< BPWM_T::CNT: DIRF Mask                     */
N
N#define BPWM_WGCTL0_ZPCTLn_Pos           (0)                                                /*!< BPWM_T::WGCTL0: ZPCTLn Position            */
N#define BPWM_WGCTL0_ZPCTLn_Msk           (0xffful << BPWM_WGCTL0_ZPCTLn_Pos)                /*!< BPWM_T::WGCTL0: ZPCTLn Mask                */
N
N#define BPWM_WGCTL0_ZPCTL0_Pos           (0)                                                /*!< BPWM_T::WGCTL0: ZPCTL0 Position            */
N#define BPWM_WGCTL0_ZPCTL0_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL0_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL0 Mask                */
N
N#define BPWM_WGCTL0_ZPCTL1_Pos           (2)                                                /*!< BPWM_T::WGCTL0: ZPCTL1 Position            */
N#define BPWM_WGCTL0_ZPCTL1_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL1_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL1 Mask                */
N
N#define BPWM_WGCTL0_ZPCTL2_Pos           (4)                                                /*!< BPWM_T::WGCTL0: ZPCTL2 Position            */
N#define BPWM_WGCTL0_ZPCTL2_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL2_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL2 Mask                */
N
N#define BPWM_WGCTL0_ZPCTL3_Pos           (6)                                                /*!< BPWM_T::WGCTL0: ZPCTL3 Position            */
N#define BPWM_WGCTL0_ZPCTL3_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL3_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL3 Mask                */
N
N#define BPWM_WGCTL0_ZPCTL4_Pos           (8)                                                /*!< BPWM_T::WGCTL0: ZPCTL4 Position            */
N#define BPWM_WGCTL0_ZPCTL4_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL4_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL4 Mask                */
N
N#define BPWM_WGCTL0_ZPCTL5_Pos           (10)                                               /*!< BPWM_T::WGCTL0: ZPCTL5 Position            */
N#define BPWM_WGCTL0_ZPCTL5_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL5_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL5 Mask                */
N
N#define BPWM_WGCTL0_PRDPCTLn_Pos         (16)                                               /*!< BPWM_T::WGCTL0: PRDPCTLn Position          */
N#define BPWM_WGCTL0_PRDPCTLn_Msk         (0xffful << BPWM_WGCTL0_PRDPCTLn_Pos)              /*!< BPWM_T::WGCTL0: PRDPCTLn Mask              */
N
N#define BPWM_WGCTL0_PRDPCTL0_Pos         (16)                                               /*!< BPWM_T::WGCTL0: PRDPCTL0 Position          */
N#define BPWM_WGCTL0_PRDPCTL0_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL0_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL0 Mask              */
N
N#define BPWM_WGCTL0_PRDPCTL1_Pos         (18)                                               /*!< BPWM_T::WGCTL0: PRDPCTL1 Position          */
N#define BPWM_WGCTL0_PRDPCTL1_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL1_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL1 Mask              */
N
N#define BPWM_WGCTL0_PRDPCTL2_Pos         (20)                                               /*!< BPWM_T::WGCTL0: PRDPCTL2 Position          */
N#define BPWM_WGCTL0_PRDPCTL2_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL2_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL2 Mask              */
N
N#define BPWM_WGCTL0_PRDPCTL3_Pos         (22)                                               /*!< BPWM_T::WGCTL0: PRDPCTL3 Position          */
N#define BPWM_WGCTL0_PRDPCTL3_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL3_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL3 Mask              */
N
N#define BPWM_WGCTL0_PRDPCTL4_Pos         (24)                                               /*!< BPWM_T::WGCTL0: PRDPCTL4 Position          */
N#define BPWM_WGCTL0_PRDPCTL4_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL4_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL4 Mask              */
N
N#define BPWM_WGCTL0_PRDPCTL5_Pos         (26)                                               /*!< BPWM_T::WGCTL0: PRDPCTL5 Position          */
N#define BPWM_WGCTL0_PRDPCTL5_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL5_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL5 Mask              */
N
N#define BPWM_WGCTL1_CMPUCTLn_Pos         (0)                                                /*!< BPWM_T::WGCTL1: CMPUCTLn Position          */
N#define BPWM_WGCTL1_CMPUCTLn_Msk         (0xffful << BPWM_WGCTL1_CMPUCTLn_Pos)              /*!< BPWM_T::WGCTL1: CMPUCTLn Mask              */
N
N#define BPWM_WGCTL1_CMPUCTL0_Pos         (0)                                                /*!< BPWM_T::WGCTL1: CMPUCTL0 Position          */
N#define BPWM_WGCTL1_CMPUCTL0_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL0_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL0 Mask              */
N
N#define BPWM_WGCTL1_CMPUCTL1_Pos         (2)                                                /*!< BPWM_T::WGCTL1: CMPUCTL1 Position          */
N#define BPWM_WGCTL1_CMPUCTL1_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL1_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL1 Mask              */
N
N#define BPWM_WGCTL1_CMPUCTL2_Pos         (4)                                                /*!< BPWM_T::WGCTL1: CMPUCTL2 Position          */
N#define BPWM_WGCTL1_CMPUCTL2_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL2_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL2 Mask              */
N
N#define BPWM_WGCTL1_CMPUCTL3_Pos         (6)                                                /*!< BPWM_T::WGCTL1: CMPUCTL3 Position          */
N#define BPWM_WGCTL1_CMPUCTL3_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL3_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL3 Mask              */
N
N#define BPWM_WGCTL1_CMPUCTL4_Pos         (8)                                                /*!< BPWM_T::WGCTL1: CMPUCTL4 Position          */
N#define BPWM_WGCTL1_CMPUCTL4_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL4_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL4 Mask              */
N
N#define BPWM_WGCTL1_CMPUCTL5_Pos         (10)                                               /*!< BPWM_T::WGCTL1: CMPUCTL5 Position          */
N#define BPWM_WGCTL1_CMPUCTL5_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL5_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL5 Mask              */
N
N#define BPWM_WGCTL1_CMPDCTLn_Pos         (16)                                               /*!< BPWM_T::WGCTL1: CMPDCTLn Position          */
N#define BPWM_WGCTL1_CMPDCTLn_Msk         (0xffful << BPWM_WGCTL1_CMPDCTLn_Pos)              /*!< BPWM_T::WGCTL1: CMPDCTLn Mask              */
N
N#define BPWM_WGCTL1_CMPDCTL0_Pos         (16)                                               /*!< BPWM_T::WGCTL1: CMPDCTL0 Position          */
N#define BPWM_WGCTL1_CMPDCTL0_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL0_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL0 Mask              */
N
N#define BPWM_WGCTL1_CMPDCTL1_Pos         (18)                                               /*!< BPWM_T::WGCTL1: CMPDCTL1 Position          */
N#define BPWM_WGCTL1_CMPDCTL1_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL1_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL1 Mask              */
N
N#define BPWM_WGCTL1_CMPDCTL2_Pos         (20)                                               /*!< BPWM_T::WGCTL1: CMPDCTL2 Position          */
N#define BPWM_WGCTL1_CMPDCTL2_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL2_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL2 Mask              */
N
N#define BPWM_WGCTL1_CMPDCTL3_Pos         (22)                                               /*!< BPWM_T::WGCTL1: CMPDCTL3 Position          */
N#define BPWM_WGCTL1_CMPDCTL3_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL3_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL3 Mask              */
N
N#define BPWM_WGCTL1_CMPDCTL4_Pos         (24)                                               /*!< BPWM_T::WGCTL1: CMPDCTL4 Position          */
N#define BPWM_WGCTL1_CMPDCTL4_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL4_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL4 Mask              */
N
N#define BPWM_WGCTL1_CMPDCTL5_Pos         (26)                                               /*!< BPWM_T::WGCTL1: CMPDCTL5 Position          */
N#define BPWM_WGCTL1_CMPDCTL5_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL5_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL5 Mask              */
N
N#define BPWM_MSKEN_MSKENn_Pos            (0)                                                /*!< BPWM_T::MSKEN: MSKENn Position             */
N#define BPWM_MSKEN_MSKENn_Msk            (0x3ful << BPWM_MSKEN_MSKENn_Pos)                  /*!< BPWM_T::MSKEN: MSKENn Mask                 */
N
N#define BPWM_MSKEN_MSKEN0_Pos            (0)                                                /*!< BPWM_T::MSKEN: MSKEN0 Position             */
N#define BPWM_MSKEN_MSKEN0_Msk            (0x1ul << BPWM_MSKEN_MSKEN0_Pos)                   /*!< BPWM_T::MSKEN: MSKEN0 Mask                 */
N
N#define BPWM_MSKEN_MSKEN1_Pos            (1)                                                /*!< BPWM_T::MSKEN: MSKEN1 Position             */
N#define BPWM_MSKEN_MSKEN1_Msk            (0x1ul << BPWM_MSKEN_MSKEN1_Pos)                   /*!< BPWM_T::MSKEN: MSKEN1 Mask                 */
N
N#define BPWM_MSKEN_MSKEN2_Pos            (2)                                                /*!< BPWM_T::MSKEN: MSKEN2 Position             */
N#define BPWM_MSKEN_MSKEN2_Msk            (0x1ul << BPWM_MSKEN_MSKEN2_Pos)                   /*!< BPWM_T::MSKEN: MSKEN2 Mask                 */
N
N#define BPWM_MSKEN_MSKEN3_Pos            (3)                                                /*!< BPWM_T::MSKEN: MSKEN3 Position             */
N#define BPWM_MSKEN_MSKEN3_Msk            (0x1ul << BPWM_MSKEN_MSKEN3_Pos)                   /*!< BPWM_T::MSKEN: MSKEN3 Mask                 */
N
N#define BPWM_MSKEN_MSKEN4_Pos            (4)                                                /*!< BPWM_T::MSKEN: MSKEN4 Position             */
N#define BPWM_MSKEN_MSKEN4_Msk            (0x1ul << BPWM_MSKEN_MSKEN4_Pos)                   /*!< BPWM_T::MSKEN: MSKEN4 Mask                 */
N
N#define BPWM_MSKEN_MSKEN5_Pos            (5)                                                /*!< BPWM_T::MSKEN: MSKEN5 Position             */
N#define BPWM_MSKEN_MSKEN5_Msk            (0x1ul << BPWM_MSKEN_MSKEN5_Pos)                   /*!< BPWM_T::MSKEN: MSKEN5 Mask                 */
N
N#define BPWM_MSK_MSKDATn_Pos             (0)                                                /*!< BPWM_T::MSK: MSKDATn Position              */
N#define BPWM_MSK_MSKDATn_Msk             (0x3ful << BPWM_MSK_MSKDATn_Pos)                   /*!< BPWM_T::MSK: MSKDATn Mask                  */
N
N#define BPWM_MSK_MSKDAT0_Pos             (0)                                                /*!< BPWM_T::MSK: MSKDAT0 Position              */
N#define BPWM_MSK_MSKDAT0_Msk             (0x1ul << BPWM_MSK_MSKDAT0_Pos)                    /*!< BPWM_T::MSK: MSKDAT0 Mask                  */
N
N#define BPWM_MSK_MSKDAT1_Pos             (1)                                                /*!< BPWM_T::MSK: MSKDAT1 Position              */
N#define BPWM_MSK_MSKDAT1_Msk             (0x1ul << BPWM_MSK_MSKDAT1_Pos)                    /*!< BPWM_T::MSK: MSKDAT1 Mask                  */
N
N#define BPWM_MSK_MSKDAT2_Pos             (2)                                                /*!< BPWM_T::MSK: MSKDAT2 Position              */
N#define BPWM_MSK_MSKDAT2_Msk             (0x1ul << BPWM_MSK_MSKDAT2_Pos)                    /*!< BPWM_T::MSK: MSKDAT2 Mask                  */
N
N#define BPWM_MSK_MSKDAT3_Pos             (3)                                                /*!< BPWM_T::MSK: MSKDAT3 Position              */
N#define BPWM_MSK_MSKDAT3_Msk             (0x1ul << BPWM_MSK_MSKDAT3_Pos)                    /*!< BPWM_T::MSK: MSKDAT3 Mask                  */
N
N#define BPWM_MSK_MSKDAT4_Pos             (4)                                                /*!< BPWM_T::MSK: MSKDAT4 Position              */
N#define BPWM_MSK_MSKDAT4_Msk             (0x1ul << BPWM_MSK_MSKDAT4_Pos)                    /*!< BPWM_T::MSK: MSKDAT4 Mask                  */
N
N#define BPWM_MSK_MSKDAT5_Pos             (5)                                                /*!< BPWM_T::MSK: MSKDAT5 Position              */
N#define BPWM_MSK_MSKDAT5_Msk             (0x1ul << BPWM_MSK_MSKDAT5_Pos)                    /*!< BPWM_T::MSK: MSKDAT5 Mask                  */
N
N#define BPWM_POLCTL_PINVn_Pos            (0)                                                /*!< BPWM_T::POLCTL: PINVn Position             */
N#define BPWM_POLCTL_PINVn_Msk            (0x3ful << BPWM_POLCTL_PINVn_Pos)                  /*!< BPWM_T::POLCTL: PINVn Mask                 */
N
N#define BPWM_POLCTL_PINV0_Pos            (0)                                                /*!< BPWM_T::POLCTL: PINV0 Position             */
N#define BPWM_POLCTL_PINV0_Msk            (0x1ul << BPWM_POLCTL_PINV0_Pos)                   /*!< BPWM_T::POLCTL: PINV0 Mask                 */
N
N#define BPWM_POLCTL_PINV1_Pos            (1)                                                /*!< BPWM_T::POLCTL: PINV1 Position             */
N#define BPWM_POLCTL_PINV1_Msk            (0x1ul << BPWM_POLCTL_PINV1_Pos)                   /*!< BPWM_T::POLCTL: PINV1 Mask                 */
N
N#define BPWM_POLCTL_PINV2_Pos            (2)                                                /*!< BPWM_T::POLCTL: PINV2 Position             */
N#define BPWM_POLCTL_PINV2_Msk            (0x1ul << BPWM_POLCTL_PINV2_Pos)                   /*!< BPWM_T::POLCTL: PINV2 Mask                 */
N
N#define BPWM_POLCTL_PINV3_Pos            (3)                                                /*!< BPWM_T::POLCTL: PINV3 Position             */
N#define BPWM_POLCTL_PINV3_Msk            (0x1ul << BPWM_POLCTL_PINV3_Pos)                   /*!< BPWM_T::POLCTL: PINV3 Mask                 */
N
N#define BPWM_POLCTL_PINV4_Pos            (4)                                                /*!< BPWM_T::POLCTL: PINV4 Position             */
N#define BPWM_POLCTL_PINV4_Msk            (0x1ul << BPWM_POLCTL_PINV4_Pos)                   /*!< BPWM_T::POLCTL: PINV4 Mask                 */
N
N#define BPWM_POLCTL_PINV5_Pos            (5)                                                /*!< BPWM_T::POLCTL: PINV5 Position             */
N#define BPWM_POLCTL_PINV5_Msk            (0x1ul << BPWM_POLCTL_PINV5_Pos)                   /*!< BPWM_T::POLCTL: PINV5 Mask                 */
N
N#define BPWM_POEN_POENn_Pos              (0)                                                /*!< BPWM_T::POEN: POENn Position               */
N#define BPWM_POEN_POENn_Msk              (0x3ful << BPWM_POEN_POENn_Pos)                    /*!< BPWM_T::POEN: POENn Mask                   */
N
N#define BPWM_POEN_POEN0_Pos              (0)                                                /*!< BPWM_T::POEN: POEN0 Position               */
N#define BPWM_POEN_POEN0_Msk              (0x1ul << BPWM_POEN_POEN0_Pos)                     /*!< BPWM_T::POEN: POEN0 Mask                   */
N
N#define BPWM_POEN_POEN1_Pos              (1)                                                /*!< BPWM_T::POEN: POEN1 Position               */
N#define BPWM_POEN_POEN1_Msk              (0x1ul << BPWM_POEN_POEN1_Pos)                     /*!< BPWM_T::POEN: POEN1 Mask                   */
N
N#define BPWM_POEN_POEN2_Pos              (2)                                                /*!< BPWM_T::POEN: POEN2 Position               */
N#define BPWM_POEN_POEN2_Msk              (0x1ul << BPWM_POEN_POEN2_Pos)                     /*!< BPWM_T::POEN: POEN2 Mask                   */
N
N#define BPWM_POEN_POEN3_Pos              (3)                                                /*!< BPWM_T::POEN: POEN3 Position               */
N#define BPWM_POEN_POEN3_Msk              (0x1ul << BPWM_POEN_POEN3_Pos)                     /*!< BPWM_T::POEN: POEN3 Mask                   */
N
N#define BPWM_POEN_POEN4_Pos              (4)                                                /*!< BPWM_T::POEN: POEN4 Position               */
N#define BPWM_POEN_POEN4_Msk              (0x1ul << BPWM_POEN_POEN4_Pos)                     /*!< BPWM_T::POEN: POEN4 Mask                   */
N
N#define BPWM_POEN_POEN5_Pos              (5)                                                /*!< BPWM_T::POEN: POEN5 Position               */
N#define BPWM_POEN_POEN5_Msk              (0x1ul << BPWM_POEN_POEN5_Pos)                     /*!< BPWM_T::POEN: POEN5 Mask                   */
N
N#define BPWM_INTEN_ZIEN0_Pos             (0)                                                /*!< BPWM_T::INTEN: ZIEN0 Position              */
N#define BPWM_INTEN_ZIEN0_Msk             (0x1ul << BPWM_INTEN_ZIEN0_Pos)                    /*!< BPWM_T::INTEN: ZIEN0 Mask                  */
N
N#define BPWM_INTEN_PIEN0_Pos             (8)                                                /*!< BPWM_T::INTEN: PIEN0 Position              */
N#define BPWM_INTEN_PIEN0_Msk             (0x1ul << BPWM_INTEN_PIEN0_Pos)                    /*!< BPWM_T::INTEN: PIEN0 Mask                  */
N
N#define BPWM_INTEN_CMPUIENn_Pos          (16)                                               /*!< BPWM_T::INTEN: CMPUIENn Position           */
N#define BPWM_INTEN_CMPUIENn_Msk          (0x3ful << BPWM_INTEN_CMPUIENn_Pos)                /*!< BPWM_T::INTEN: CMPUIENn Mask               */
N
N#define BPWM_INTEN_CMPUIEN0_Pos          (16)                                               /*!< BPWM_T::INTEN: CMPUIEN0 Position           */
N#define BPWM_INTEN_CMPUIEN0_Msk          (0x1ul << BPWM_INTEN_CMPUIEN0_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN0 Mask               */
N
N#define BPWM_INTEN_CMPUIEN1_Pos          (17)                                               /*!< BPWM_T::INTEN: CMPUIEN1 Position           */
N#define BPWM_INTEN_CMPUIEN1_Msk          (0x1ul << BPWM_INTEN_CMPUIEN1_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN1 Mask               */
N
N#define BPWM_INTEN_CMPUIEN2_Pos          (18)                                               /*!< BPWM_T::INTEN: CMPUIEN2 Position           */
N#define BPWM_INTEN_CMPUIEN2_Msk          (0x1ul << BPWM_INTEN_CMPUIEN2_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN2 Mask               */
N
N#define BPWM_INTEN_CMPUIEN3_Pos          (19)                                               /*!< BPWM_T::INTEN: CMPUIEN3 Position           */
N#define BPWM_INTEN_CMPUIEN3_Msk          (0x1ul << BPWM_INTEN_CMPUIEN3_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN3 Mask               */
N
N#define BPWM_INTEN_CMPUIEN4_Pos          (20)                                               /*!< BPWM_T::INTEN: CMPUIEN4 Position           */
N#define BPWM_INTEN_CMPUIEN4_Msk          (0x1ul << BPWM_INTEN_CMPUIEN4_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN4 Mask               */
N
N#define BPWM_INTEN_CMPUIEN5_Pos          (21)                                               /*!< BPWM_T::INTEN: CMPUIEN5 Position           */
N#define BPWM_INTEN_CMPUIEN5_Msk          (0x1ul << BPWM_INTEN_CMPUIEN5_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN5 Mask               */
N
N#define BPWM_INTEN_CMPDIENn_Pos          (24)                                               /*!< BPWM_T::INTEN: CMPDIENn Position           */
N#define BPWM_INTEN_CMPDIENn_Msk          (0x3ful << BPWM_INTEN_CMPDIENn_Pos)                /*!< BPWM_T::INTEN: CMPDIENn Mask               */
N
N#define BPWM_INTEN_CMPDIEN0_Pos          (24)                                               /*!< BPWM_T::INTEN: CMPDIEN0 Position           */
N#define BPWM_INTEN_CMPDIEN0_Msk          (0x1ul << BPWM_INTEN_CMPDIEN0_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN0 Mask               */
N
N#define BPWM_INTEN_CMPDIEN1_Pos          (25)                                               /*!< BPWM_T::INTEN: CMPDIEN1 Position           */
N#define BPWM_INTEN_CMPDIEN1_Msk          (0x1ul << BPWM_INTEN_CMPDIEN1_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN1 Mask               */
N
N#define BPWM_INTEN_CMPDIEN2_Pos          (26)                                               /*!< BPWM_T::INTEN: CMPDIEN2 Position           */
N#define BPWM_INTEN_CMPDIEN2_Msk          (0x1ul << BPWM_INTEN_CMPDIEN2_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN2 Mask               */
N
N#define BPWM_INTEN_CMPDIEN3_Pos          (27)                                               /*!< BPWM_T::INTEN: CMPDIEN3 Position           */
N#define BPWM_INTEN_CMPDIEN3_Msk          (0x1ul << BPWM_INTEN_CMPDIEN3_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN3 Mask               */
N
N#define BPWM_INTEN_CMPDIEN4_Pos          (28)                                               /*!< BPWM_T::INTEN: CMPDIEN4 Position           */
N#define BPWM_INTEN_CMPDIEN4_Msk          (0x1ul << BPWM_INTEN_CMPDIEN4_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN4 Mask               */
N
N#define BPWM_INTEN_CMPDIEN5_Pos          (29)                                               /*!< BPWM_T::INTEN: CMPDIEN5 Position           */
N#define BPWM_INTEN_CMPDIEN5_Msk          (0x1ul << BPWM_INTEN_CMPDIEN5_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN5 Mask               */
N
N#define BPWM_INTSTS_ZIF0_Pos             (0)                                                /*!< BPWM_T::INTSTS: ZIF0 Position              */
N#define BPWM_INTSTS_ZIF0_Msk             (0x1ul << BPWM_INTSTS_ZIF0_Pos)                    /*!< BPWM_T::INTSTS: ZIF0 Mask                  */
N
N#define BPWM_INTSTS_PIF0_Pos             (8)                                                /*!< BPWM_T::INTSTS: PIF0 Position              */
N#define BPWM_INTSTS_PIF0_Msk             (0x1ul << BPWM_INTSTS_PIF0_Pos)                    /*!< BPWM_T::INTSTS: PIF0 Mask                  */
N
N#define BPWM_INTSTS_CMPUIFn_Pos          (16)                                               /*!< BPWM_T::INTSTS: CMPUIFn Position           */
N#define BPWM_INTSTS_CMPUIFn_Msk          (0x3ful << BPWM_INTSTS_CMPUIFn_Pos)                /*!< BPWM_T::INTSTS: CMPUIFn Mask               */
N
N#define BPWM_INTSTS_CMPUIF0_Pos          (16)                                               /*!< BPWM_T::INTSTS: CMPUIF0 Position           */
N#define BPWM_INTSTS_CMPUIF0_Msk          (0x1ul << BPWM_INTSTS_CMPUIF0_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF0 Mask               */
N
N#define BPWM_INTSTS_CMPUIF1_Pos          (17)                                               /*!< BPWM_T::INTSTS: CMPUIF1 Position           */
N#define BPWM_INTSTS_CMPUIF1_Msk          (0x1ul << BPWM_INTSTS_CMPUIF1_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF1 Mask               */
N
N#define BPWM_INTSTS_CMPUIF2_Pos          (18)                                               /*!< BPWM_T::INTSTS: CMPUIF2 Position           */
N#define BPWM_INTSTS_CMPUIF2_Msk          (0x1ul << BPWM_INTSTS_CMPUIF2_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF2 Mask               */
N
N#define BPWM_INTSTS_CMPUIF3_Pos          (19)                                               /*!< BPWM_T::INTSTS: CMPUIF3 Position           */
N#define BPWM_INTSTS_CMPUIF3_Msk          (0x1ul << BPWM_INTSTS_CMPUIF3_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF3 Mask               */
N
N#define BPWM_INTSTS_CMPUIF4_Pos          (20)                                               /*!< BPWM_T::INTSTS: CMPUIF4 Position           */
N#define BPWM_INTSTS_CMPUIF4_Msk          (0x1ul << BPWM_INTSTS_CMPUIF4_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF4 Mask               */
N
N#define BPWM_INTSTS_CMPUIF5_Pos          (21)                                               /*!< BPWM_T::INTSTS: CMPUIF5 Position           */
N#define BPWM_INTSTS_CMPUIF5_Msk          (0x1ul << BPWM_INTSTS_CMPUIF5_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF5 Mask               */
N
N#define BPWM_INTSTS_CMPDIFn_Pos          (24)                                               /*!< BPWM_T::INTSTS: CMPDIFn Position           */
N#define BPWM_INTSTS_CMPDIFn_Msk          (0x3ful << BPWM_INTSTS_CMPDIFn_Pos)                /*!< BPWM_T::INTSTS: CMPDIFn Mask               */
N
N#define BPWM_INTSTS_CMPDIF0_Pos          (24)                                               /*!< BPWM_T::INTSTS: CMPDIF0 Position           */
N#define BPWM_INTSTS_CMPDIF0_Msk          (0x1ul << BPWM_INTSTS_CMPDIF0_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF0 Mask               */
N
N#define BPWM_INTSTS_CMPDIF1_Pos          (25)                                               /*!< BPWM_T::INTSTS: CMPDIF1 Position           */
N#define BPWM_INTSTS_CMPDIF1_Msk          (0x1ul << BPWM_INTSTS_CMPDIF1_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF1 Mask               */
N
N#define BPWM_INTSTS_CMPDIF2_Pos          (26)                                               /*!< BPWM_T::INTSTS: CMPDIF2 Position           */
N#define BPWM_INTSTS_CMPDIF2_Msk          (0x1ul << BPWM_INTSTS_CMPDIF2_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF2 Mask               */
N
N#define BPWM_INTSTS_CMPDIF3_Pos          (27)                                               /*!< BPWM_T::INTSTS: CMPDIF3 Position           */
N#define BPWM_INTSTS_CMPDIF3_Msk          (0x1ul << BPWM_INTSTS_CMPDIF3_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF3 Mask               */
N
N#define BPWM_INTSTS_CMPDIF4_Pos          (28)                                               /*!< BPWM_T::INTSTS: CMPDIF4 Position           */
N#define BPWM_INTSTS_CMPDIF4_Msk          (0x1ul << BPWM_INTSTS_CMPDIF4_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF4 Mask               */
N
N#define BPWM_INTSTS_CMPDIF5_Pos          (29)                                               /*!< BPWM_T::INTSTS: CMPDIF5 Position           */
N#define BPWM_INTSTS_CMPDIF5_Msk          (0x1ul << BPWM_INTSTS_CMPDIF5_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF5 Mask               */
N
N#define BPWM_ADCTS0_TRGSEL0_Pos          (0)                                                /*!< BPWM_T::ADCTS0: TRGSEL0 Position           */
N#define BPWM_ADCTS0_TRGSEL0_Msk          (0xful << BPWM_ADCTS0_TRGSEL0_Pos)                 /*!< BPWM_T::ADCTS0: TRGSEL0 Mask               */
N
N#define BPWM_ADCTS0_TRGEN0_Pos           (7)                                                /*!< BPWM_T::ADCTS0: TRGEN0 Position            */
N#define BPWM_ADCTS0_TRGEN0_Msk           (0x1ul << BPWM_ADCTS0_TRGEN0_Pos)                  /*!< BPWM_T::ADCTS0: TRGEN0 Mask                */
N
N#define BPWM_ADCTS0_TRGSEL1_Pos          (8)                                                /*!< BPWM_T::ADCTS0: TRGSEL1 Position           */
N#define BPWM_ADCTS0_TRGSEL1_Msk          (0xful << BPWM_ADCTS0_TRGSEL1_Pos)                 /*!< BPWM_T::ADCTS0: TRGSEL1 Mask               */
N
N#define BPWM_ADCTS0_TRGEN1_Pos           (15)                                               /*!< BPWM_T::ADCTS0: TRGEN1 Position            */
N#define BPWM_ADCTS0_TRGEN1_Msk           (0x1ul << BPWM_ADCTS0_TRGEN1_Pos)                  /*!< BPWM_T::ADCTS0: TRGEN1 Mask                */
N
N#define BPWM_ADCTS0_TRGSEL2_Pos          (16)                                               /*!< BPWM_T::ADCTS0: TRGSEL2 Position           */
N#define BPWM_ADCTS0_TRGSEL2_Msk          (0xful << BPWM_ADCTS0_TRGSEL2_Pos)                 /*!< BPWM_T::ADCTS0: TRGSEL2 Mask               */
N
N#define BPWM_ADCTS0_TRGEN2_Pos           (23)                                               /*!< BPWM_T::ADCTS0: TRGEN2 Position            */
N#define BPWM_ADCTS0_TRGEN2_Msk           (0x1ul << BPWM_ADCTS0_TRGEN2_Pos)                  /*!< BPWM_T::ADCTS0: TRGEN2 Mask                */
N
N#define BPWM_ADCTS0_TRGSEL3_Pos          (24)                                               /*!< BPWM_T::ADCTS0: TRGSEL3 Position           */
N#define BPWM_ADCTS0_TRGSEL3_Msk          (0xful << BPWM_ADCTS0_TRGSEL3_Pos)                 /*!< BPWM_T::ADCTS0: TRGSEL3 Mask               */
N
N#define BPWM_ADCTS0_TRGEN3_Pos           (31)                                               /*!< BPWM_T::ADCTS0: TRGEN3 Position            */
N#define BPWM_ADCTS0_TRGEN3_Msk           (0x1ul << BPWM_ADCTS0_TRGEN3_Pos)                  /*!< BPWM_T::ADCTS0: TRGEN3 Mask                */
N
N#define BPWM_ADCTS1_TRGSEL4_Pos          (0)                                                /*!< BPWM_T::ADCTS1: TRGSEL4 Position           */
N#define BPWM_ADCTS1_TRGSEL4_Msk          (0xful << BPWM_ADCTS1_TRGSEL4_Pos)                 /*!< BPWM_T::ADCTS1: TRGSEL4 Mask               */
N
N#define BPWM_ADCTS1_TRGEN4_Pos           (7)                                                /*!< BPWM_T::ADCTS1: TRGEN4 Position            */
N#define BPWM_ADCTS1_TRGEN4_Msk           (0x1ul << BPWM_ADCTS1_TRGEN4_Pos)                  /*!< BPWM_T::ADCTS1: TRGEN4 Mask                */
N
N#define BPWM_ADCTS1_TRGSEL5_Pos          (8)                                                /*!< BPWM_T::ADCTS1: TRGSEL5 Position           */
N#define BPWM_ADCTS1_TRGSEL5_Msk          (0xful << BPWM_ADCTS1_TRGSEL5_Pos)                 /*!< BPWM_T::ADCTS1: TRGSEL5 Mask               */
N
N#define BPWM_ADCTS1_TRGEN5_Pos           (15)                                               /*!< BPWM_T::ADCTS1: TRGEN5 Position            */
N#define BPWM_ADCTS1_TRGEN5_Msk           (0x1ul << BPWM_ADCTS1_TRGEN5_Pos)                  /*!< BPWM_T::ADCTS1: TRGEN5 Mask                */
N
N#define BPWM_SSCTL_SSEN0_Pos             (0)                                                /*!< BPWM_T::SSCTL: SSEN0 Position              */
N#define BPWM_SSCTL_SSEN0_Msk             (0x1ul << BPWM_SSCTL_SSEN0_Pos)                    /*!< BPWM_T::SSCTL: SSEN0 Mask                  */
N
N#define BPWM_SSCTL_SSRC_Pos              (8)                                                /*!< BPWM_T::SSCTL: SSRC Position               */
N#define BPWM_SSCTL_SSRC_Msk              (0x3ul << BPWM_SSCTL_SSRC_Pos)                     /*!< BPWM_T::SSCTL: SSRC Mask                   */
N
N#define BPWM_SSTRG_CNTSEN_Pos            (0)                                                /*!< BPWM_T::SSTRG: CNTSEN Position             */
N#define BPWM_SSTRG_CNTSEN_Msk            (0x1ul << BPWM_SSTRG_CNTSEN_Pos)                   /*!< BPWM_T::SSTRG: CNTSEN Mask                 */
N
N#define BPWM_STATUS_CNTMAXF0_Pos         (0)                                                /*!< BPWM_T::STATUS: CNTMAXF0 Position          */
N#define BPWM_STATUS_CNTMAXF0_Msk         (0x1ul << BPWM_STATUS_CNTMAXF0_Pos)                /*!< BPWM_T::STATUS: CNTMAXF0 Mask              */
N
N#define BPWM_STATUS_ADCTRGFn_Pos         (16)                                               /*!< BPWM_T::STATUS: ADCTRGFn Position          */
N#define BPWM_STATUS_ADCTRGFn_Msk         (0x3ful << BPWM_STATUS_ADCTRGFn_Pos)               /*!< BPWM_T::STATUS: ADCTRGFn Mask              */
N
N#define BPWM_STATUS_ADCTRGF0_Pos         (16)                                               /*!< BPWM_T::STATUS: ADCTRGF0 Position          */
N#define BPWM_STATUS_ADCTRGF0_Msk         (0x1ul << BPWM_STATUS_ADCTRGF0_Pos)                /*!< BPWM_T::STATUS: ADCTRGF0 Mask              */
N
N#define BPWM_STATUS_ADCTRGF1_Pos         (17)                                               /*!< BPWM_T::STATUS: ADCTRGF1 Position          */
N#define BPWM_STATUS_ADCTRGF1_Msk         (0x1ul << BPWM_STATUS_ADCTRGF1_Pos)                /*!< BPWM_T::STATUS: ADCTRGF1 Mask              */
N
N#define BPWM_STATUS_ADCTRGF2_Pos         (18)                                               /*!< BPWM_T::STATUS: ADCTRGF2 Position          */
N#define BPWM_STATUS_ADCTRGF2_Msk         (0x1ul << BPWM_STATUS_ADCTRGF2_Pos)                /*!< BPWM_T::STATUS: ADCTRGF2 Mask              */
N
N#define BPWM_STATUS_ADCTRGF3_Pos         (19)                                               /*!< BPWM_T::STATUS: ADCTRGF3 Position          */
N#define BPWM_STATUS_ADCTRGF3_Msk         (0x1ul << BPWM_STATUS_ADCTRGF3_Pos)                /*!< BPWM_T::STATUS: ADCTRGF3 Mask              */
N
N#define BPWM_STATUS_ADCTRGF4_Pos         (20)                                               /*!< BPWM_T::STATUS: ADCTRGF4 Position          */
N#define BPWM_STATUS_ADCTRGF4_Msk         (0x1ul << BPWM_STATUS_ADCTRGF4_Pos)                /*!< BPWM_T::STATUS: ADCTRGF4 Mask              */
N
N#define BPWM_STATUS_ADCTRGF5_Pos         (21)                                               /*!< BPWM_T::STATUS: ADCTRGF5 Position          */
N#define BPWM_STATUS_ADCTRGF5_Msk         (0x1ul << BPWM_STATUS_ADCTRGF5_Pos)                /*!< BPWM_T::STATUS: ADCTRGF5 Mask              */
N
N#define BPWM_CAPINEN_CAPINENn_Pos        (0)                                                /*!< BPWM_T::CAPINEN: CAPINENn Position         */
N#define BPWM_CAPINEN_CAPINENn_Msk        (0x3ful << BPWM_CAPINEN_CAPINENn_Pos)              /*!< BPWM_T::CAPINEN: CAPINENn Mask             */
N
N#define BPWM_CAPINEN_CAPINEN0_Pos        (0)                                                /*!< BPWM_T::CAPINEN: CAPINEN0 Position         */
N#define BPWM_CAPINEN_CAPINEN0_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN0_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN0 Mask             */
N
N#define BPWM_CAPINEN_CAPINEN1_Pos        (1)                                                /*!< BPWM_T::CAPINEN: CAPINEN1 Position         */
N#define BPWM_CAPINEN_CAPINEN1_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN1_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN1 Mask             */
N
N#define BPWM_CAPINEN_CAPINEN2_Pos        (2)                                                /*!< BPWM_T::CAPINEN: CAPINEN2 Position         */
N#define BPWM_CAPINEN_CAPINEN2_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN2_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN2 Mask             */
N
N#define BPWM_CAPINEN_CAPINEN3_Pos        (3)                                                /*!< BPWM_T::CAPINEN: CAPINEN3 Position         */
N#define BPWM_CAPINEN_CAPINEN3_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN3_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN3 Mask             */
N
N#define BPWM_CAPINEN_CAPINEN4_Pos        (4)                                                /*!< BPWM_T::CAPINEN: CAPINEN4 Position         */
N#define BPWM_CAPINEN_CAPINEN4_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN4_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN4 Mask             */
N
N#define BPWM_CAPINEN_CAPINEN5_Pos        (5)                                                /*!< BPWM_T::CAPINEN: CAPINEN5 Position         */
N#define BPWM_CAPINEN_CAPINEN5_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN5_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN5 Mask             */
N
N#define BPWM_CAPCTL_CAPENn_Pos           (0)                                                /*!< BPWM_T::CAPCTL: CAPENn Position            */
N#define BPWM_CAPCTL_CAPENn_Msk           (0x3ful << BPWM_CAPCTL_CAPENn_Pos)                 /*!< BPWM_T::CAPCTL: CAPENn Mask                */
N
N#define BPWM_CAPCTL_CAPEN0_Pos           (0)                                                /*!< BPWM_T::CAPCTL: CAPEN0 Position            */
N#define BPWM_CAPCTL_CAPEN0_Msk           (0x1ul << BPWM_CAPCTL_CAPEN0_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN0 Mask                */
N
N#define BPWM_CAPCTL_CAPEN1_Pos           (1)                                                /*!< BPWM_T::CAPCTL: CAPEN1 Position            */
N#define BPWM_CAPCTL_CAPEN1_Msk           (0x1ul << BPWM_CAPCTL_CAPEN1_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN1 Mask                */
N
N#define BPWM_CAPCTL_CAPEN2_Pos           (2)                                                /*!< BPWM_T::CAPCTL: CAPEN2 Position            */
N#define BPWM_CAPCTL_CAPEN2_Msk           (0x1ul << BPWM_CAPCTL_CAPEN2_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN2 Mask                */
N
N#define BPWM_CAPCTL_CAPEN3_Pos           (3)                                                /*!< BPWM_T::CAPCTL: CAPEN3 Position            */
N#define BPWM_CAPCTL_CAPEN3_Msk           (0x1ul << BPWM_CAPCTL_CAPEN3_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN3 Mask                */
N
N#define BPWM_CAPCTL_CAPEN4_Pos           (4)                                                /*!< BPWM_T::CAPCTL: CAPEN4 Position            */
N#define BPWM_CAPCTL_CAPEN4_Msk           (0x1ul << BPWM_CAPCTL_CAPEN4_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN4 Mask                */
N
N#define BPWM_CAPCTL_CAPEN5_Pos           (5)                                                /*!< BPWM_T::CAPCTL: CAPEN5 Position            */
N#define BPWM_CAPCTL_CAPEN5_Msk           (0x1ul << BPWM_CAPCTL_CAPEN5_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN5 Mask                */
N
N#define BPWM_CAPCTL_CAPINVn_Pos          (8)                                                /*!< BPWM_T::CAPCTL: CAPINVn Position           */
N#define BPWM_CAPCTL_CAPINVn_Msk          (0x3ful << BPWM_CAPCTL_CAPINVn_Pos)                /*!< BPWM_T::CAPCTL: CAPINVn Mask               */
N
N#define BPWM_CAPCTL_CAPINV0_Pos          (8)                                                /*!< BPWM_T::CAPCTL: CAPINV0 Position           */
N#define BPWM_CAPCTL_CAPINV0_Msk          (0x1ul << BPWM_CAPCTL_CAPINV0_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV0 Mask               */
N
N#define BPWM_CAPCTL_CAPINV1_Pos          (9)                                                /*!< BPWM_T::CAPCTL: CAPINV1 Position           */
N#define BPWM_CAPCTL_CAPINV1_Msk          (0x1ul << BPWM_CAPCTL_CAPINV1_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV1 Mask               */
N
N#define BPWM_CAPCTL_CAPINV2_Pos          (10)                                               /*!< BPWM_T::CAPCTL: CAPINV2 Position           */
N#define BPWM_CAPCTL_CAPINV2_Msk          (0x1ul << BPWM_CAPCTL_CAPINV2_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV2 Mask               */
N
N#define BPWM_CAPCTL_CAPINV3_Pos          (11)                                               /*!< BPWM_T::CAPCTL: CAPINV3 Position           */
N#define BPWM_CAPCTL_CAPINV3_Msk          (0x1ul << BPWM_CAPCTL_CAPINV3_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV3 Mask               */
N
N#define BPWM_CAPCTL_CAPINV4_Pos          (12)                                               /*!< BPWM_T::CAPCTL: CAPINV4 Position           */
N#define BPWM_CAPCTL_CAPINV4_Msk          (0x1ul << BPWM_CAPCTL_CAPINV4_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV4 Mask               */
N
N#define BPWM_CAPCTL_CAPINV5_Pos          (13)                                               /*!< BPWM_T::CAPCTL: CAPINV5 Position           */
N#define BPWM_CAPCTL_CAPINV5_Msk          (0x1ul << BPWM_CAPCTL_CAPINV5_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV5 Mask               */
N
N#define BPWM_CAPCTL_RCRLDENn_Pos         (16)                                               /*!< BPWM_T::CAPCTL: RCRLDENn Position          */
N#define BPWM_CAPCTL_RCRLDENn_Msk         (0x3ful << BPWM_CAPCTL_RCRLDENn_Pos)               /*!< BPWM_T::CAPCTL: RCRLDENn Mask              */
N
N#define BPWM_CAPCTL_RCRLDEN0_Pos         (16)                                               /*!< BPWM_T::CAPCTL: RCRLDEN0 Position          */
N#define BPWM_CAPCTL_RCRLDEN0_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN0_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN0 Mask              */
N
N#define BPWM_CAPCTL_RCRLDEN1_Pos         (17)                                               /*!< BPWM_T::CAPCTL: RCRLDEN1 Position          */
N#define BPWM_CAPCTL_RCRLDEN1_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN1_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN1 Mask              */
N
N#define BPWM_CAPCTL_RCRLDEN2_Pos         (18)                                               /*!< BPWM_T::CAPCTL: RCRLDEN2 Position          */
N#define BPWM_CAPCTL_RCRLDEN2_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN2_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN2 Mask              */
N
N#define BPWM_CAPCTL_RCRLDEN3_Pos         (19)                                               /*!< BPWM_T::CAPCTL: RCRLDEN3 Position          */
N#define BPWM_CAPCTL_RCRLDEN3_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN3_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN3 Mask              */
N
N#define BPWM_CAPCTL_RCRLDEN4_Pos         (20)                                               /*!< BPWM_T::CAPCTL: RCRLDEN4 Position          */
N#define BPWM_CAPCTL_RCRLDEN4_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN4_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN4 Mask              */
N
N#define BPWM_CAPCTL_RCRLDEN5_Pos         (21)                                               /*!< BPWM_T::CAPCTL: RCRLDEN5 Position          */
N#define BPWM_CAPCTL_RCRLDEN5_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN5_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN5 Mask              */
N
N#define BPWM_CAPCTL_FCRLDENn_Pos         (24)                                               /*!< BPWM_T::CAPCTL: FCRLDENn Position          */
N#define BPWM_CAPCTL_FCRLDENn_Msk         (0x3ful << BPWM_CAPCTL_FCRLDENn_Pos)               /*!< BPWM_T::CAPCTL: FCRLDENn Mask              */
N
N#define BPWM_CAPCTL_FCRLDEN0_Pos         (24)                                               /*!< BPWM_T::CAPCTL: FCRLDEN0 Position          */
N#define BPWM_CAPCTL_FCRLDEN0_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN0_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN0 Mask              */
N
N#define BPWM_CAPCTL_FCRLDEN1_Pos         (25)                                               /*!< BPWM_T::CAPCTL: FCRLDEN1 Position          */
N#define BPWM_CAPCTL_FCRLDEN1_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN1_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN1 Mask              */
N
N#define BPWM_CAPCTL_FCRLDEN2_Pos         (26)                                               /*!< BPWM_T::CAPCTL: FCRLDEN2 Position          */
N#define BPWM_CAPCTL_FCRLDEN2_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN2_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN2 Mask              */
N
N#define BPWM_CAPCTL_FCRLDEN3_Pos         (27)                                               /*!< BPWM_T::CAPCTL: FCRLDEN3 Position          */
N#define BPWM_CAPCTL_FCRLDEN3_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN3_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN3 Mask              */
N
N#define BPWM_CAPCTL_FCRLDEN4_Pos         (28)                                               /*!< BPWM_T::CAPCTL: FCRLDEN4 Position          */
N#define BPWM_CAPCTL_FCRLDEN4_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN4_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN4 Mask              */
N
N#define BPWM_CAPCTL_FCRLDEN5_Pos         (29)                                               /*!< BPWM_T::CAPCTL: FCRLDEN5 Position          */
N#define BPWM_CAPCTL_FCRLDEN5_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN5_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN5 Mask              */
N
N#define BPWM_CAPSTS_CRLIFOVn_Pos         (0)                                                /*!< BPWM_T::CAPSTS: CRLIFOVn Position          */
N#define BPWM_CAPSTS_CRLIFOVn_Msk         (0x3ful << BPWM_CAPSTS_CRLIFOVn_Pos)               /*!< BPWM_T::CAPSTS: CRLIFOVn Mask              */
N
N#define BPWM_CAPSTS_CRLIFOV0_Pos         (0)                                                /*!< BPWM_T::CAPSTS: CRLIFOV0 Position          */
N#define BPWM_CAPSTS_CRLIFOV0_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV0_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV0 Mask              */
N
N#define BPWM_CAPSTS_CRLIFOV1_Pos         (1)                                                /*!< BPWM_T::CAPSTS: CRLIFOV1 Position          */
N#define BPWM_CAPSTS_CRLIFOV1_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV1_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV1 Mask              */
N
N#define BPWM_CAPSTS_CRLIFOV2_Pos         (2)                                                /*!< BPWM_T::CAPSTS: CRLIFOV2 Position          */
N#define BPWM_CAPSTS_CRLIFOV2_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV2_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV2 Mask              */
N
N#define BPWM_CAPSTS_CRLIFOV3_Pos         (3)                                                /*!< BPWM_T::CAPSTS: CRLIFOV3 Position          */
N#define BPWM_CAPSTS_CRLIFOV3_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV3_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV3 Mask              */
N
N#define BPWM_CAPSTS_CRLIFOV4_Pos         (4)                                                /*!< BPWM_T::CAPSTS: CRLIFOV4 Position          */
N#define BPWM_CAPSTS_CRLIFOV4_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV4_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV4 Mask              */
N
N#define BPWM_CAPSTS_CRLIFOV5_Pos         (5)                                                /*!< BPWM_T::CAPSTS: CRLIFOV5 Position          */
N#define BPWM_CAPSTS_CRLIFOV5_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV5_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV5 Mask              */
N
N#define BPWM_CAPSTS_CFLIFOVn_Pos         (8)                                                /*!< BPWM_T::CAPSTS: CFLIFOVn Position          */
N#define BPWM_CAPSTS_CFLIFOVn_Msk         (0x3ful << BPWM_CAPSTS_CFLIFOVn_Pos)               /*!< BPWM_T::CAPSTS: CFLIFOVn Mask              */
N
N#define BPWM_CAPSTS_CFLIFOV0_Pos         (8)                                                /*!< BPWM_T::CAPSTS: CFLIFOV0 Position          */
N#define BPWM_CAPSTS_CFLIFOV0_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV0_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV0 Mask              */
N
N#define BPWM_CAPSTS_CFLIFOV1_Pos         (9)                                                /*!< BPWM_T::CAPSTS: CFLIFOV1 Position          */
N#define BPWM_CAPSTS_CFLIFOV1_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV1_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV1 Mask              */
N
N#define BPWM_CAPSTS_CFLIFOV2_Pos         (10)                                               /*!< BPWM_T::CAPSTS: CFLIFOV2 Position          */
N#define BPWM_CAPSTS_CFLIFOV2_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV2_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV2 Mask              */
N
N#define BPWM_CAPSTS_CFLIFOV3_Pos         (11)                                               /*!< BPWM_T::CAPSTS: CFLIFOV3 Position          */
N#define BPWM_CAPSTS_CFLIFOV3_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV3_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV3 Mask              */
N
N#define BPWM_CAPSTS_CFLIFOV4_Pos         (12)                                               /*!< BPWM_T::CAPSTS: CFLIFOV4 Position          */
N#define BPWM_CAPSTS_CFLIFOV4_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV4_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV4 Mask              */
N
N#define BPWM_CAPSTS_CFLIFOV5_Pos         (13)                                               /*!< BPWM_T::CAPSTS: CFLIFOV5 Position          */
N#define BPWM_CAPSTS_CFLIFOV5_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV5_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV5 Mask              */
N
N#define BPWM_RCAPDAT0_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT0: RCAPDAT Position         */
N#define BPWM_RCAPDAT0_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT0_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT0: RCAPDAT Mask             */
N
N#define BPWM_FCAPDAT0_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT0: FCAPDAT Position         */
N#define BPWM_FCAPDAT0_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT0_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT0: FCAPDAT Mask             */
N
N#define BPWM_RCAPDAT1_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT1: RCAPDAT Position         */
N#define BPWM_RCAPDAT1_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT1_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT1: RCAPDAT Mask             */
N
N#define BPWM_FCAPDAT1_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT1: FCAPDAT Position         */
N#define BPWM_FCAPDAT1_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT1_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT1: FCAPDAT Mask             */
N
N#define BPWM_RCAPDAT2_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT2: RCAPDAT Position         */
N#define BPWM_RCAPDAT2_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT2_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT2: RCAPDAT Mask             */
N
N#define BPWM_FCAPDAT2_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT2: FCAPDAT Position         */
N#define BPWM_FCAPDAT2_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT2_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT2: FCAPDAT Mask             */
N
N#define BPWM_RCAPDAT3_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT3: RCAPDAT Position         */
N#define BPWM_RCAPDAT3_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT3_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT3: RCAPDAT Mask             */
N
N#define BPWM_FCAPDAT3_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT3: FCAPDAT Position         */
N#define BPWM_FCAPDAT3_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT3_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT3: FCAPDAT Mask             */
N
N#define BPWM_RCAPDAT4_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT4: RCAPDAT Position         */
N#define BPWM_RCAPDAT4_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT4_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT4: RCAPDAT Mask             */
N
N#define BPWM_FCAPDAT4_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT4: FCAPDAT Position         */
N#define BPWM_FCAPDAT4_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT4_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT4: FCAPDAT Mask             */
N
N#define BPWM_RCAPDAT5_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT5: RCAPDAT Position         */
N#define BPWM_RCAPDAT5_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT5_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT5: RCAPDAT Mask             */
N
N#define BPWM_FCAPDAT5_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT5: FCAPDAT Position         */
N#define BPWM_FCAPDAT5_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT5_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT5: FCAPDAT Mask             */
N
N#define BPWM_CAPIEN_CAPRIENn_Pos         (0)                                                /*!< BPWM_T::CAPIEN: CAPRIENn Position          */
N#define BPWM_CAPIEN_CAPRIENn_Msk         (0x3ful << BPWM_CAPIEN_CAPRIENn_Pos)               /*!< BPWM_T::CAPIEN: CAPRIENn Mask              */
N
N#define BPWM_CAPIEN_CAPRIEN0_Pos         (0)                                                /*!< BPWM_T::CAPIEN: CAPRIEN0 Position          */
N#define BPWM_CAPIEN_CAPRIEN0_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN0_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN0 Mask              */
N
N#define BPWM_CAPIEN_CAPRIEN1_Pos         (1)                                                /*!< BPWM_T::CAPIEN: CAPRIEN1 Position          */
N#define BPWM_CAPIEN_CAPRIEN1_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN1_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN1 Mask              */
N
N#define BPWM_CAPIEN_CAPRIEN2_Pos         (2)                                                /*!< BPWM_T::CAPIEN: CAPRIEN2 Position          */
N#define BPWM_CAPIEN_CAPRIEN2_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN2_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN2 Mask              */
N
N#define BPWM_CAPIEN_CAPRIEN3_Pos         (3)                                                /*!< BPWM_T::CAPIEN: CAPRIEN3 Position          */
N#define BPWM_CAPIEN_CAPRIEN3_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN3_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN3 Mask              */
N
N#define BPWM_CAPIEN_CAPRIEN4_Pos         (4)                                                /*!< BPWM_T::CAPIEN: CAPRIEN4 Position          */
N#define BPWM_CAPIEN_CAPRIEN4_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN4_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN4 Mask              */
N
N#define BPWM_CAPIEN_CAPRIEN5_Pos         (5)                                                /*!< BPWM_T::CAPIEN: CAPRIEN5 Position          */
N#define BPWM_CAPIEN_CAPRIEN5_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN5_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN5 Mask              */
N
N#define BPWM_CAPIEN_CAPFIENn_Pos         (8)                                                /*!< BPWM_T::CAPIEN: CAPFIENn Position          */
N#define BPWM_CAPIEN_CAPFIENn_Msk         (0x3ful << BPWM_CAPIEN_CAPFIENn_Pos)               /*!< BPWM_T::CAPIEN: CAPFIENn Mask              */
N
N#define BPWM_CAPIEN_CAPFIEN0_Pos         (8)                                                /*!< BPWM_T::CAPIEN: CAPFIEN0 Position          */
N#define BPWM_CAPIEN_CAPFIEN0_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN0_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN0 Mask              */
N
N#define BPWM_CAPIEN_CAPFIEN1_Pos         (9)                                                /*!< BPWM_T::CAPIEN: CAPFIEN1 Position          */
N#define BPWM_CAPIEN_CAPFIEN1_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN1_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN1 Mask              */
N
N#define BPWM_CAPIEN_CAPFIEN2_Pos         (10)                                               /*!< BPWM_T::CAPIEN: CAPFIEN2 Position          */
N#define BPWM_CAPIEN_CAPFIEN2_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN2_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN2 Mask              */
N
N#define BPWM_CAPIEN_CAPFIEN3_Pos         (11)                                               /*!< BPWM_T::CAPIEN: CAPFIEN3 Position          */
N#define BPWM_CAPIEN_CAPFIEN3_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN3_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN3 Mask              */
N
N#define BPWM_CAPIEN_CAPFIEN4_Pos         (12)                                               /*!< BPWM_T::CAPIEN: CAPFIEN4 Position          */
N#define BPWM_CAPIEN_CAPFIEN4_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN4_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN4 Mask              */
N
N#define BPWM_CAPIEN_CAPFIEN5_Pos         (13)                                               /*!< BPWM_T::CAPIEN: CAPFIEN5 Position          */
N#define BPWM_CAPIEN_CAPFIEN5_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN5_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN5 Mask              */
N
N#define BPWM_CAPIF_CRLIFn_Pos            (0)                                                /*!< BPWM_T::CAPIF: CRLIFn Position             */
N#define BPWM_CAPIF_CRLIFn_Msk            (0x3ful << BPWM_CAPIF_CRLIFn_Pos)                  /*!< BPWM_T::CAPIF: CRLIFn Mask                 */
N
N#define BPWM_CAPIF_CRLIF0_Pos            (0)                                                /*!< BPWM_T::CAPIF: CRLIF0 Position             */
N#define BPWM_CAPIF_CRLIF0_Msk            (0x1ul << BPWM_CAPIF_CRLIF0_Pos)                   /*!< BPWM_T::CAPIF: CRLIF0 Mask                 */
N
N#define BPWM_CAPIF_CRLIF1_Pos            (1)                                                /*!< BPWM_T::CAPIF: CRLIF1 Position             */
N#define BPWM_CAPIF_CRLIF1_Msk            (0x1ul << BPWM_CAPIF_CRLIF1_Pos)                   /*!< BPWM_T::CAPIF: CRLIF1 Mask                 */
N
N#define BPWM_CAPIF_CRLIF2_Pos            (2)                                                /*!< BPWM_T::CAPIF: CRLIF2 Position             */
N#define BPWM_CAPIF_CRLIF2_Msk            (0x1ul << BPWM_CAPIF_CRLIF2_Pos)                   /*!< BPWM_T::CAPIF: CRLIF2 Mask                 */
N
N#define BPWM_CAPIF_CRLIF3_Pos            (3)                                                /*!< BPWM_T::CAPIF: CRLIF3 Position             */
N#define BPWM_CAPIF_CRLIF3_Msk            (0x1ul << BPWM_CAPIF_CRLIF3_Pos)                   /*!< BPWM_T::CAPIF: CRLIF3 Mask                 */
N
N#define BPWM_CAPIF_CRLIF4_Pos            (4)                                                /*!< BPWM_T::CAPIF: CRLIF4 Position             */
N#define BPWM_CAPIF_CRLIF4_Msk            (0x1ul << BPWM_CAPIF_CRLIF4_Pos)                   /*!< BPWM_T::CAPIF: CRLIF4 Mask                 */
N
N#define BPWM_CAPIF_CRLIF5_Pos            (5)                                                /*!< BPWM_T::CAPIF: CRLIF5 Position             */
N#define BPWM_CAPIF_CRLIF5_Msk            (0x1ul << BPWM_CAPIF_CRLIF5_Pos)                   /*!< BPWM_T::CAPIF: CRLIF5 Mask                 */
N
N#define BPWM_CAPIF_CFLIFn_Pos            (8)                                                /*!< BPWM_T::CAPIF: CFLIFn Position             */
N#define BPWM_CAPIF_CFLIFn_Msk            (0x3ful << BPWM_CAPIF_CFLIFn_Pos)                  /*!< BPWM_T::CAPIF: CFLIFn Mask                 */
N
N#define BPWM_CAPIF_CFLIF0_Pos            (8)                                                /*!< BPWM_T::CAPIF: CFLIF0 Position             */
N#define BPWM_CAPIF_CFLIF0_Msk            (0x1ul << BPWM_CAPIF_CFLIF0_Pos)                   /*!< BPWM_T::CAPIF: CFLIF0 Mask                 */
N
N#define BPWM_CAPIF_CFLIF1_Pos            (9)                                                /*!< BPWM_T::CAPIF: CFLIF1 Position             */
N#define BPWM_CAPIF_CFLIF1_Msk            (0x1ul << BPWM_CAPIF_CFLIF1_Pos)                   /*!< BPWM_T::CAPIF: CFLIF1 Mask                 */
N
N#define BPWM_CAPIF_CFLIF2_Pos            (10)                                               /*!< BPWM_T::CAPIF: CFLIF2 Position             */
N#define BPWM_CAPIF_CFLIF2_Msk            (0x1ul << BPWM_CAPIF_CFLIF2_Pos)                   /*!< BPWM_T::CAPIF: CFLIF2 Mask                 */
N
N#define BPWM_CAPIF_CFLIF3_Pos            (11)                                               /*!< BPWM_T::CAPIF: CFLIF3 Position             */
N#define BPWM_CAPIF_CFLIF3_Msk            (0x1ul << BPWM_CAPIF_CFLIF3_Pos)                   /*!< BPWM_T::CAPIF: CFLIF3 Mask                 */
N
N#define BPWM_CAPIF_CFLIF4_Pos            (12)                                               /*!< BPWM_T::CAPIF: CFLIF4 Position             */
N#define BPWM_CAPIF_CFLIF4_Msk            (0x1ul << BPWM_CAPIF_CFLIF4_Pos)                   /*!< BPWM_T::CAPIF: CFLIF4 Mask                 */
N
N#define BPWM_CAPIF_CFLIF5_Pos            (13)                                               /*!< BPWM_T::CAPIF: CFLIF5 Position             */
N#define BPWM_CAPIF_CFLIF5_Msk            (0x1ul << BPWM_CAPIF_CFLIF5_Pos)                   /*!< BPWM_T::CAPIF: CFLIF5 Mask                 */
N
N#define BPWM_PBUF_PBUF_Pos               (0)                                                /*!< BPWM_T::PBUF: PBUF Position                */
N#define BPWM_PBUF_PBUF_Msk               (0xfffful << BPWM_PBUF_PBUF_Pos)                   /*!< BPWM_T::PBUF: PBUF Mask                    */
N
N#define BPWM_CMPBUF_CMPBUF_Pos           (0)                                                /*!< BPWM_T::CMPBUF: CMPBUF Position            */
N#define BPWM_CMPBUF_CMPBUF_Msk           (0xfffful << BPWM_CMPBUF_CMPBUF_Pos)               /*!< BPWM_T::CMPBUF: CMPBUF Mask                */
N
N/*@}*/ /* end of group BPWM_CONST */
N/*@}*/ /* end of group BPWM */
N
N
N/*----------------------------- CAN Controller ------------------------------*/
N/** @addtogroup NUC131_CAN Controller Area Network (CAN)
N  Register Structure for CAN Device Controller
N  @{
N */
N
Ntypedef struct
N{
N
N    /**
N     * CAN_IFn_CREQ
N     * ===================================================================================================
N     * Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MessageNumber|Message Number
N     * |        |          |0x01-0x20: Valid Message Number, the Message Object in the Message
N     * |        |          |RAM is selected for data transfer.
N     * |        |          |0x00: Not a valid Message Number, interpreted as 0x20.
N     * |        |          |0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.
N     * |[15]    |Busy      |Busy Flag
N     * |        |          |0 = Read/write action has finished.
N     * |        |          |1 = Writing to the IFn Command Request Register is in progress.
N     * |        |          |This bit can only be read by the software.
N     */
N    __IO uint32_t CREQ;
X    volatile uint32_t CREQ;
N
N    /**
N     * CAN_IFn_CMASK
N     * ===================================================================================================
N     * Offset: 0x24, 0x84  IFn Command Mask Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DAT_B     |Access Data Bytes [7:4]
N     * |        |          |Write Operation:
N     * |        |          |0 = Data Bytes [7:4] unchanged.
N     * |        |          |1 = Transfer Data Bytes [7:4] to Message Object.
N     * |        |          |Read Operation:
N     * |        |          |0 = Data Bytes [7:4] unchanged.
N     * |        |          |1 = Transfer Data Bytes [7:4] to IFn Message Buffer Register.
N     * |[1]     |DAT_A     |Access Data Bytes [3:0]
N     * |        |          |Write Operation:
N     * |        |          |0 = Data Bytes [3:0] unchanged.
N     * |        |          |1 = Transfer Data Bytes [3:0] to Message Object.
N     * |        |          |Read Operation:
N     * |        |          |0 = Data Bytes [3:0] unchanged.
N     * |        |          |1 = Transfer Data Bytes [3:0] to IFn Message Buffer Register.
N     * |[2]     |TxRqst_NewDat|Access Transmission Request Bit When Write Operation
N     * |        |          |0 = TxRqst bit unchanged.
N     * |        |          |1 = Set TxRqst bit.
N     * |        |          |Note: If a transmission is requested by programming bit TxRqst/NewDat in the IFn Command Mask Register, bit TxRqst in the IFn Message Control Register will be ignored.
N     * |        |          |Access New Data Bit when Read Operation.
N     * |        |          |0 = NewDat bit remains unchanged.
N     * |        |          |1 = Clear NewDat bit in the Message Object.
N     * |        |          |Note: A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat.
N     * |        |          |The values of these bits transferred to the IFn Message Control Register always reflect the status before resetting these bits.
N     * |[3]     |ClrIntPnd |Clear Interrupt Pending Bit
N     * |        |          |Write Operation:
N     * |        |          |When writing to a Message Object, this bit is ignored.
N     * |        |          |Read Operation:
N     * |        |          |0 = IntPnd bit (CAN_IFn_MCON[13]) remains unchanged.
N     * |        |          |1 = Clear IntPnd bit in the Message Object.
N     * |[4]     |Control   |Control Access Control Bits
N     * |        |          |Write Operation:
N     * |        |          |0 = Control Bits unchanged.
N     * |        |          |1 = Transfer Control Bits to Message Object.
N     * |        |          |Read Operation:
N     * |        |          |0 = Control Bits unchanged.
N     * |        |          |1 = Transfer Control Bits to IFn Message Buffer Register.
N     * |[5]     |Arb       |Access Arbitration Bits
N     * |        |          |Write Operation:
N     * |        |          |0 = Arbitration bits unchanged.
N     * |        |          |1 = Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal (CAN_IFn_APB2[15]) to Message Object.
N     * |        |          |Read Operation:
N     * |        |          |0 = Arbitration bits unchanged.
N     * |        |          |1 = Transfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register.
N     * |[6]     |Mask      |Access Mask Bits
N     * |        |          |Write Operation:
N     * |        |          |0 = Mask bits unchanged.
N     * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
N     * |        |          |Read Operation:
N     * |        |          |0 = Mask bits unchanged.
N     * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register.
N     * |[7]     |WR_RD     |Write / Read Mode
N     * |        |          |0 = Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers.
N     * |        |          |1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register.
N     */
N    __IO uint32_t CMASK;
X    volatile uint32_t CMASK;
N
N    /**
N     * CAN_IFn_MASK1
N     * ===================================================================================================
N     * Offset: 0x28, 0x88  IFn Mask 1 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |Msk[15:0] |Identifier Mask 15-0
N     * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
N     * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
N     */
N    __IO uint32_t MASK1;
X    volatile uint32_t MASK1;
N
N    /**
N     * CAN_IFn_MASK2
N     * ===================================================================================================
N     * Offset: 0x2C, 0x8C  IFn Mask 2 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[12:0]  |Msk[28:16]|Identifier Mask 28-16
N     * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
N     * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
N     * |[14]    |MDir      |Mask Message Direction
N     * |        |          |0 = The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance filtering.
N     * |        |          |1 = The message direction bit (Dir) is used for acceptance filtering.
N     * |[15]    |MXtd      |Mask Extended Identifier
N     * |        |          |0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
N     * |        |          |1 = The extended identifier bit (IDE) is used for acceptance filtering.
N     * |        |          |Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]).
N     * |        |          |For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 (CAN_IFn_MASK2[12:2]) are considered.
N     */
N    __IO uint32_t MASK2;
X    volatile uint32_t MASK2;
N
N    /**
N     * CAN_IFn_ARB1
N     * ===================================================================================================
N     * Offset: 0x30, 0x90  IFn Arbitration 1 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |ID[15:0]  |Message Identifier 15-0
N     * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
N     * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
N     */
N    __IO uint32_t ARB1;
X    volatile uint32_t ARB1;
N
N    /**
N     * CAN_IFn_ARB2
N     * ===================================================================================================
N     * Offset: 0x34, 0x94  IFn Arbitration 2 Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[12:0]  |ID[28:16] |Message Identifier 28-16
N     * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
N     * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
N     * |[13]    |Dir       |Message Direction
N     * |        |          |0 = Direction is receive.
N     * |        |          |On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted.
N     * |        |          |On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
N     * |        |          |1 = Direction is transmit.
N     * |        |          |On TxRqst, the respective Message Object is transmitted as a Data Frame.
N     * |        |          |On reception of a Remote Frame with matching identifier, the TxRqst bit (CAN_IFn_CMASK[2]) of this Message Object is set (if RmtEn (CAN_IFn_MCON[9]) = one).
N     * |[14]    |Xtd       |Extended Identifier
N     * |        |          |0 = The 11-bit ("standard") Identifier will be used for this Message Object.
N     * |        |          |1 = The 29-bit ("extended") Identifier will be used for this Message Object.
N     * |[15]    |MsgVal    |Message Valid
N     * |        |          |0 = The Message Object is ignored by the Message Handler.
N     * |        |          |1 = The Message Object is configured and should be considered by the Message Handler.
N     * |        |          |Note: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init (CAN_CON[0]).
N     * |        |          |This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd (CAN_IFn_ARB2[14]), Dir (CAN_IFn_APB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0]) are modified, or if the Messages Object is no longer required.
N     */
N    __IO uint32_t ARB2;
X    volatile uint32_t ARB2;
N
N    /**
N     * CAN_IFn_MCON
N     * ===================================================================================================
N     * Offset: 0x38, 0x98  IFn Message Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |DLC       |Data Length Code
N     * |        |          |0-8: Data Frame has 0-8 data bytes.
N     * |        |          |9-15: Data Frame has 8 data bytes
N     * |        |          |Note: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes.
N     * |        |          |When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.
N     * |        |          |Data 0: 1st data byte of a CAN Data Frame
N     * |        |          |Data 1: 2nd data byte of a CAN Data Frame
N     * |        |          |Data 2: 3rd data byte of a CAN Data Frame
N     * |        |          |Data 3: 4th data byte of a CAN Data Frame
N     * |        |          |Data 4: 5th data byte of a CAN Data Frame
N     * |        |          |Data 5: 6th data byte of a CAN Data Frame
N     * |        |          |Data 6: 7th data byte of a CAN Data Frame
N     * |        |          |Data 7 : 8th data byte of a CAN Data Frame
N     * |        |          |Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last.
N     * |        |          |When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object.
N     * |        |          |If the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.
N     * |[7]     |EoB       |End Of Buffer
N     * |        |          |0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer.
N     * |        |          |1 = Single Message Object or last Message Object of a FIFO Buffer.
N     * |        |          |Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer.
N     * |        |          |For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.
N     * |[8]     |TxRqst    |Transmit Request
N     * |        |          |0 = This Message Object is not waiting for transmission.
N     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N     * |[9]     |RmtEn     |Remote Enable Control
N     * |        |          |0 = At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged.
N     * |        |          |1 = At the reception of a Remote Frame, TxRqst is set.
N     * |[10]    |RxIE      |Receive Interrupt Enable Control
N     * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame.
N     * |        |          |1 = IntPnd will be set after a successful reception of a frame.
N     * |[11]    |TxIE      |Transmit Interrupt Enable Control
N     * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a frame.
N     * |        |          |1 = IntPnd will be set after a successful transmission of a frame.
N     * |[12]    |UMask     |Use Acceptance Mask
N     * |        |          |0 = Mask ignored.
N     * |        |          |1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
N     * |        |          |Note: If the UMask bit is set to one, the Message Object's mask bits have to be programmed during initialization of the Message Object before MsgVal bit (CAN_IFn_APB2[15]) is set to one.
N     * |[13]    |IntPnd    |Interrupt Pending
N     * |        |          |0 = This message object is not the source of an interrupt.
N     * |        |          |1 = This message object is the source of an interrupt.
N     * |        |          |The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
N     * |[14]    |MsgLst    |Message Lost (only valid for Message Objects with direction = receive).
N     * |        |          |0 = No message lost since last time this bit was reset by the CPU.
N     * |        |          |1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message.
N     * |[15]    |NewDat    |New Data
N     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software.
N     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
N     */
N    __IO uint32_t MCON;
X    volatile uint32_t MCON;
N
N    /**
N     * CAN_IFn_DAT_A1
N     * ===================================================================================================
N     * Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |Data0     |Data Byte 0
N     * |        |          |1st data byte of a CAN Data Frame
N     * |[15:8]  |Data1     |Data Byte 1
N     * |        |          |2nd data byte of a CAN Data Frame
N     */
N    __IO uint32_t DAT_A1;
X    volatile uint32_t DAT_A1;
N
N    /**
N     * CAN_IFn_DAT_A2
N     * ===================================================================================================
N     * Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |Data2     |Data Byte 2
N     * |        |          |3rd data byte of CAN Data Frame
N     * |[15:8]  |Data3     |Data Byte 3
N     * |        |          |4th data byte of CAN Data Frame
N     */
N    __IO uint32_t DAT_A2;
X    volatile uint32_t DAT_A2;
N
N    /**
N     * CAN_IFn_DAT_B1
N     * ===================================================================================================
N     * Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |Data4     |Data Byte 4
N     * |        |          |5th data byte of CAN Data Frame
N     * |[15:8]  |Data5     |Data Byte 5
N     * |        |          |6th data byte of CAN Data Frame
N     */
N    __IO uint32_t DAT_B1;
X    volatile uint32_t DAT_B1;
N
N    /**
N     * CAN_IFn_DAT_B2
N     * ===================================================================================================
N     * Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |Data6     |Data Byte 6
N     * |        |          |7th data byte of CAN Data Frame.
N     * |[15:8]  |Data7     |Data Byte 7
N     * |        |          |8th data byte of CAN Data Frame.
N     */
N    __IO uint32_t DAT_B2;
X    volatile uint32_t DAT_B2;
N
N    /**
N     * @cond HIDDEN_SYMBOLS     
N     */    
N    __I uint32_t RESERVE0[13];
X    volatile const uint32_t RESERVE0[13];
N    /**
N     * @endcond
N     */
N
N} CAN_IF_T;
N
Ntypedef struct
N{
N
N    /**
N     * CAN_CON
N     * ===================================================================================================
N     * Offset: 0x00  Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |Init      |Init Initialization
N     * |        |          |0 = Normal Operation.
N     * |        |          |1 = Initialization is started.
N     * |[1]     |IE        |Module Interrupt Enable Control
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |[2]     |SIE       |Status Change Interrupt Enable Control
N     * |        |          |0 = Disabled - No Status Change Interrupt will be generated.
N     * |        |          |1 = Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
N     * |[3]     |EIE       |Error Interrupt Enable Control
N     * |        |          |0 = Disabled - No Error Status Interrupt will be generated.
N     * |        |          |1 = Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status Register will generate an interrupt.
N     * |[5]     |DAR       |Automatic Re-Transmission Disable Control
N     * |        |          |0 = Automatic Retransmission of disturbed messages enabled.
N     * |        |          |1 = Automatic Retransmission disabled.
N     * |[6]     |CCE       |Configuration Change Enable Control
N     * |        |          |0 = No write access to the Bit Timing Register.
N     * |        |          |1 = Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1).
N     * |[7]     |Test      |Test Mode Enable Control
N     * |        |          |0 = Normal Operation.
N     * |        |          |1 = Test Mode.
N     */
N    __IO uint32_t   CON;
X    volatile uint32_t   CON;
N
N    /**
N     * CAN_STATUS
N     * ===================================================================================================
N     * Offset: 0x04  Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |LEC       |Last Error Code (Type Of The Last Error To Occur On The CAN Bus)
N     * |        |          |The LEC field holds a code, which indicates the type of the last error to occur on the CAN bus.
N     * |        |          |This field will be cleared to '0' when a message has been transferred (reception or transmission) without error.
N     * |        |          |The unused code '7' may be written by the CPU to check for updates.
N     * |        |          |The following table describes the error code.
N     * |[3]     |TxOK      |Transmitted A Message Successfully
N     * |        |          |0 = Since this bit was reset by the CPU, no message has been successfully transmitted.
N     * |        |          |This bit is never reset by the CAN Core.
N     * |        |          |1 = Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted.
N     * |[4]     |RxOK      |Received A Message Successfully
N     * |        |          |0 = No message has been successfully received since this bit was last reset by the CPU.
N     * |        |          |This bit is never reset by the CAN Core.
N     * |        |          |1 = A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering).
N     * |[5]     |EPass     |Error Passive (Read Only)
N     * |        |          |0 = The CAN Core is error active.
N     * |        |          |1 = The CAN Core is in the error passive state as defined in the CAN Specification.
N     * |[6]     |EWarn     |Error Warning Status (Read Only)
N     * |        |          |0 = Both error counters are below the error warning limit of 96.
N     * |        |          |1 = At least one of the error counters in the EML has reached the error warning limit of 96.
N     * |[7]     |BOff      |Bus-Off Status (Read Only)
N     * |        |          |0 = The CAN module is not in bus-off state.
N     * |        |          |1 = The CAN module is in bus-off state.
N     */
N    __IO uint32_t   STATUS;
X    volatile uint32_t   STATUS;
N
N    /**
N     * CAN_ERR
N     * ===================================================================================================
N     * Offset: 0x08  Error Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |TEC       |Transmit Error Counter
N     * |        |          |Actual state of the Transmit Error Counter. Values between 0 and 255.
N     * |[14:8]  |REC       |Receive Error Counter
N     * |        |          |Actual state of the Receive Error Counter. Values between 0 and 127.
N     * |[15]    |RP        |Receive Error Passive
N     * |        |          |0 = The Receive Error Counter is below the error passive level.
N     * |        |          |1 = The Receive Error Counter has reached the error passive level as defined in the CAN Specification.
N     */
N    __IO uint32_t   ERR;
X    volatile uint32_t   ERR;
N
N    /**
N     * CAN_BTIME
N     * ===================================================================================================
N     * Offset: 0x0C  Bit Timing Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |BRP       |Baud Rate Prescaler
N     * |        |          |0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta.
N     * |        |          |The bit time is built up from a multiple of this quanta.
N     * |        |          |Valid values for the Baud Rate Prescaler are [ 0 ... 63 ].
N     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
N     * |[7:6]   |SJW       |(Re)Synchronization Jump Width
N     * |        |          |0x0-0x3: Valid programmed values are [0 ... 3].
N     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
N     * |[11:8]  |TSeg1     |Time Segment Before The Sample Point Minus Sync_Seg
N     * |        |          |0x01-0x0F: valid values for TSeg1 are [1 ... 15].
N     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed is used.
N     * |[14:12] |TSeg2     |Time Segment After Sample Point
N     * |        |          |0x0-0x7: Valid values for TSeg2 are [0 ... 7].
N     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
N     */
N    __IO uint32_t   BTIME;
X    volatile uint32_t   BTIME;
N
N    /**
N     * CAN_IIDR
N     * ===================================================================================================
N     * Offset: 0x10  Interrupt Identifier Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |IntId     |Interrupt Identifier (Indicates The Source Of The Interrupt)
N     * |        |          |If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order.
N     * |        |          |An interrupt remains pending until the application software has cleared it.
N     * |        |          |If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to the EIC is active.
N     * |        |          |The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.
N     * |        |          |The Status Interrupt has the highest priority.
N     * |        |          |Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.
N     * |        |          |A message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]).
N     * |        |          |The Status Interrupt is cleared by reading the Status Register.
N     */
N    __IO uint32_t   IIDR;
X    volatile uint32_t   IIDR;
N
N    /**
N     * CAN_TEST
N     * ===================================================================================================
N     * Offset: 0x14  Test Register (Register Map Note 1)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |Res       |Reserved
N     * |        |          |There are reserved bits.
N     * |        |          |These bits are always read as '0' and must always be written with '0'.
N     * |[2]     |Basic     |Basic Mode
N     * |        |          |0 = Basic Mode disabled.
N     * |        |          |1= IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer.
N     * |[3]     |Silent    |Silent Mode
N     * |        |          |0 = Normal operation.
N     * |        |          |1 = The module is in Silent Mode.
N     * |[4]     |LBack     |Loop Back Mode Enable Control
N     * |        |          |0 = Loop Back Mode is disabled.
N     * |        |          |1 = Loop Back Mode is enabled.
N     * |[6:5]   |Tx10      |Tx[1:0]: Control Of CAN_TX Pin
N     * |        |          |00 = Reset value, CAN_TX pin is controlled by the CAN Core.
N     * |        |          |01 = Sample Point can be monitored at CAN_TX pin.
N     * |        |          |10 = CAN_TX pin drives a dominant ('0') value.
N     * |        |          |11 = CAN_TX pin drives a recessive ('1') value.
N     * |[7]     |Rx        |Monitors The Actual Value Of CAN_RX Pin (Read Only)
N     * |        |          |0 = The CAN bus is dominant (CAN_RX = '0').
N     * |        |          |1 = The CAN bus is recessive (CAN_RX = '1').
N     */
N    __IO uint32_t   TEST;
X    volatile uint32_t   TEST;
N
N    /**
N     * CAN_BRPE
N     * ===================================================================================================
N     * Offset: 0x18  Baud Rate Prescaler Extension Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |BRPE      |BRPE: Baud Rate Prescaler Extension
N     * |        |          |0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023.
N     * |        |          |The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.
N     */
N    __IO uint32_t   BRPE;
X    volatile uint32_t   BRPE;
N
N    /**
N     * @cond HIDDEN_SYMBOLS     
N     */
N    __I uint32_t    RESERVE0[1];
X    volatile const uint32_t    RESERVE0[1];
N    /**
N     * @endcond
N     */
N
N    __IO CAN_IF_T   IF[2];
X    volatile CAN_IF_T   IF[2];
N
N    /**
N     * @cond HIDDEN_SYMBOLS     
N     */
N    __I uint32_t    RESERVE1[8];
X    volatile const uint32_t    RESERVE1[8];
N    /**
N     * @endcond
N     */
N    
N
N    /**
N     * CAN_TXREQ1
N     * ===================================================================================================
N     * Offset: 0x100  Transmission Request Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |TxRqst161 |Transmission Request Bits 16-1 (Of All Message Objects)
N     * |        |          |0 = This Message Object is not waiting for transmission.
N     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N     * |        |          |These bits are read only.
N     */
N    __IO uint32_t   TXREQ1;
X    volatile uint32_t   TXREQ1;
N
N    /**
N     * CAN_TXREQ2
N     * ===================================================================================================
N     * Offset: 0x104  Transmission Request Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |TxRqst3217|Transmission Request Bits 32-17 (Of All Message Objects)
N     * |        |          |0 = This Message Object is not waiting for transmission.
N     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N     * |        |          |These bits are read only.
N     */
N    __IO uint32_t   TXREQ2;
X    volatile uint32_t   TXREQ2;
N
N    /**
N     * @cond HIDDEN_SYMBOLS     
N     */
N    __I uint32_t    RESERVE2[6];
X    volatile const uint32_t    RESERVE2[6];
N    /**
N     * @endcond
N     */
N
N    /**
N     * CAN_NDAT1
N     * ===================================================================================================
N     * Offset: 0x120  New Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |NewData161|New Data Bits 16-1 (Of All Message Objects)
N     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
N     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
N     */
N    __IO uint32_t   NDAT1;
X    volatile uint32_t   NDAT1;
N
N    /**
N     * CAN_NDAT2
N     * ===================================================================================================
N     * Offset: 0x124  New Data Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |NewData3217|New Data Bits 32-17 (Of All Message Objects)
N     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
N     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
N     */
N    __IO uint32_t   NDAT2;
X    volatile uint32_t   NDAT2;
N
N    /**
N     * @cond HIDDEN_SYMBOLS     
N     */
N    __I uint32_t    RESERVE3[6];
X    volatile const uint32_t    RESERVE3[6];
N    /**
N     * @endcond
N     */
N    
N
N    /**
N     * CAN_IPND1
N     * ===================================================================================================
N     * Offset: 0x140  Interrupt Pending Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |IntPnd161 |Interrupt Pending Bits 16-1 (Of All Message Objects)
N     * |        |          |0 = This message object is not the source of an interrupt.
N     * |        |          |1 = This message object is the source of an interrupt.
N     */
N    __IO uint32_t   IPND1;
X    volatile uint32_t   IPND1;
N
N    /**
N     * CAN_IPND2
N     * ===================================================================================================
N     * Offset: 0x144  Interrupt Pending Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |IntPnd3217|Interrupt Pending Bits 32-17(Of All Message Objects)
N     * |        |          |0 = This message object is not the source of an interrupt.
N     * |        |          |1 = This message object is the source of an interrupt.
N     */
N    __IO uint32_t   IPND2;
X    volatile uint32_t   IPND2;
N
N    /**
N     * @cond HIDDEN_SYMBOLS     
N     */
N    __I uint32_t    RESERVE4[6];
X    volatile const uint32_t    RESERVE4[6];
N    /**
N     * @endcond
N     */
N
N    /**
N     * CAN_MVLD1
N     * ===================================================================================================
N     * Offset: 0x160  Message Valid Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |MsgVal161 |Message Valid Bits 16-1 (Of All Message Objects) (Read Only)
N     * |        |          |0 = This Message Object is ignored by the Message Handler.
N     * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
N     * |        |          |Ex.
N     * |        |          |CAN_MVLD1[0] means Message object No.1 is valid or not.
N     * |        |          |If CAN_MVLD1[0] is set, message object No.1 is configured.
N     */
N    __IO uint32_t   MVLD1;
X    volatile uint32_t   MVLD1;
N
N    /**
N     * CAN_MVLD2
N     * ===================================================================================================
N     * Offset: 0x164  Message Valid Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |MsgVal3217|Message Valid Bits 32-17 (Of All Message Objects) (Read Only)
N     * |        |          |0 = This Message Object is ignored by the Message Handler.
N     * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
N     * |        |          |Ex.CAN_MVLD2[15] means Message object No.32 is valid or not.
N     * |        |          |If CAN_MVLD2[15] is set, message object No.32 is configured.
N     */
N    __IO uint32_t   MVLD2;
X    volatile uint32_t   MVLD2;
N
N    /**
N     * CAN_WU_EN
N     * ===================================================================================================
N     * Offset: 0x168  Wake-up Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WAKUP_EN  |Wake-Up Enable Control
N     * |        |          |0 = The wake-up function Disabled.
N     * |        |          |1 = The wake-up function Enabled.
N     * |        |          |Note: User can wake-up system when there is a falling edge in the CAN_Rx pin.
N     */
N    __IO uint32_t   WU_EN;
X    volatile uint32_t   WU_EN;
N
N    /**
N     * CAN_WU_STATUS
N     * ===================================================================================================
N     * Offset: 0x16C  Wake-up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WAKUP_STS |Wake-Up Status
N     * |        |          |0 = No wake-up event occurred.
N     * |        |          |1 = Wake-up event occurred.
N     * |        |          |Note: This bit can be cleared by writing '0'.
N     */
N    __IO uint32_t   WU_STATUS;
X    volatile uint32_t   WU_STATUS;
N} CAN_T;
N
N/** @addtogroup CAN_CONST CAN Bit Field Definition
N    Constant Definitions for CAN Controller
N  @{
N */
N
N
N
N
N/* CAN CON Bit Field Definitions */
N#define CAN_CON_TEST_Pos           7                                    /*!< CAN_T::CON: TEST Position */
N#define CAN_CON_TEST_Msk           (1ul << CAN_CON_TEST_Pos)            /*!< CAN_T::CON: TEST Mask     */
N
N#define CAN_CON_CCE_Pos            6                                    /*!< CAN_T::CON: CCE Position  */
N#define CAN_CON_CCE_Msk            (1ul << CAN_CON_CCE_Pos)             /*!< CAN_T::CON: CCE Mask      */
N
N#define CAN_CON_DAR_Pos            5                                    /*!< CAN_T::CON: DAR Position  */
N#define CAN_CON_DAR_Msk            (1ul << CAN_CON_DAR_Pos)             /*!< CAN_T::CON: DAR Mask      */
N
N#define CAN_CON_EIE_Pos            3                                    /*!< CAN_T::CON: EIE Position  */
N#define CAN_CON_EIE_Msk            (1ul << CAN_CON_EIE_Pos)             /*!< CAN_T::CON: EIE Mask      */
N
N#define CAN_CON_SIE_Pos            2                                    /*!< CAN_T::CON: SIE Position  */
N#define CAN_CON_SIE_Msk            (1ul << CAN_CON_SIE_Pos)             /*!< CAN_T::CON: SIE Mask      */
N
N#define CAN_CON_IE_Pos             1                                    /*!< CAN_T::CON: IE Position   */
N#define CAN_CON_IE_Msk             (1ul << CAN_CON_IE_Pos)              /*!< CAN_T::CON: IE Mask       */
N
N#define CAN_CON_INIT_Pos           0                                    /*!< CAN_T::CON: INIT Position */
N#define CAN_CON_INIT_Msk           (1ul << CAN_CON_INIT_Pos)            /*!< CAN_T::CON: INIT Mask     */
N
N/* CAN STATUS Bit Field Definitions */
N#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN_T::STATUS: BOFF Position  */
N#define CAN_STATUS_BOFF_Msk        (1ul << CAN_STATUS_BOFF_Pos)         /*!< CAN_T::STATUS: BOFF Mask      */
N
N#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN_T::STATUS: EWARN Position */
N#define CAN_STATUS_EWARN_Msk       (1ul << CAN_STATUS_EWARN_Pos)        /*!< CAN_T::STATUS: EWARN Mask     */
N
N#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN_T::STATUS: EPASS Position */
N#define CAN_STATUS_EPASS_Msk       (1ul << CAN_STATUS_EPASS_Pos)        /*!< CAN_T::STATUS: EPASS Mask     */
N
N#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN_T::STATUS: RXOK Position  */
N#define CAN_STATUS_RXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN_T::STATUS: RXOK Mask      */
N
N#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN_T::STATUS: TXOK Position  */
N#define CAN_STATUS_TXOK_Msk        (1ul << CAN_STATUS_TXOK_Pos)         /*!< CAN_T::STATUS: TXOK Mask      */
N
N#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN_T::STATUS: LEC Position   */
N#define CAN_STATUS_LEC_Msk         (0x3ul << CAN_STATUS_LEC_Pos)        /*!< CAN_T::STATUS: LEC Mask       */
N
N/* CAN ERR Bit Field Definitions */                                             
N#define CAN_ERR_RP_Pos             15                                   /*!< CAN_T::ERR: RP Position       */
N#define CAN_ERR_RP_Msk             (1ul << CAN_ERR_RP_Pos)              /*!< CAN_T::ERR: RP Mask           */
N
N#define CAN_ERR_REC_Pos            8                                    /*!< CAN_T::ERR: REC Position      */
N#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN_T::ERR: REC Mask          */
N
N#define CAN_ERR_TEC_Pos            0                                    /*!< CAN_T::ERR: TEC Position      */
N#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN_T::ERR: TEC Mask          */
N
N/* CAN BTIME Bit Field Definitions */                                           
N#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN_T::BTIME: TSEG2 Position  */
N#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN_T::BTIME: TSEG2 Mask      */
N
N#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN_T::BTIME: TSEG1 Position  */
N#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN_T::BTIME: TSEG1 Mask      */
N
N#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN_T::BTIME: SJW Position    */
N#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN_T::BTIME: SJW Mask        */
N
N#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN_T::BTIME: BRP Position    */
N#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN_T::BTIME: BRP Mask        */
N
N/* CAN IIDR Bit Field Definitions */                                            
N#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN_T::IIDR: INTID Position   */
N#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN_T::IIDR: INTID Mask       */
N
N/* CAN TEST Bit Field Definitions */                                            
N#define CAN_TEST_RX_Pos            7                                    /*!< CAN_T::TEST: RX Position      */
N#define CAN_TEST_RX_Msk            (1ul << CAN_TEST_RX_Pos)             /*!< CAN_T::TEST: RX Mask          */
N
N#define CAN_TEST_TX_Pos            5                                    /*!< CAN_T::TEST: TX Position      */
N#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN_T::TEST: TX Mask          */
N
N#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN_T::TEST: LBACK Position   */
N#define CAN_TEST_LBACK_Msk         (1ul << CAN_TEST_LBACK_Pos)          /*!< CAN_T::TEST: LBACK Mask       */
N
N#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN_T::TEST: Silent Position  */
N#define CAN_TEST_SILENT_Msk        (1ul << CAN_TEST_SILENT_Pos)         /*!< CAN_T::TEST: Silent Mask      */
N
N#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN_T::TEST: Basic Position   */
N#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)          /*!< CAN_T::TEST: Basic Mask       */
N
N/* CAN BPRE Bit Field Definitions */                                            
N#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN_T::BRPE: BRPE Position    */
N#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN_T::BRPE: BRPE Mask        */
N
N/* CAN IFn_CREQ Bit Field Definitions */                                        
N#define CAN_IF_CREQ_BUSY_Pos       15                                   /*!< CAN_T::IFnCREQ: BUSY Position */
N#define CAN_IF_CREQ_BUSY_Msk       (1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN_T::IFnCREQ: BUSY Mask     */
N
N#define CAN_IF_CREQ_MSGNUM_Pos     0                                    /*!< CAN_T::IFnCREQ: MSGNUM Position */
N#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)   /*!< CAN_T::IFnCREQ: MSGNUM Mask     */
N
N/* CAN IFn_CMASK Bit Field Definitions */                                      
N#define CAN_IF_CMASK_WRRD_Pos      7                                    /*!< CAN_T::IFnCMASK: WRRD Position */
N#define CAN_IF_CMASK_WRRD_Msk      (1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN_T::IFnCMASK: WRRD Mask     */
N
N#define CAN_IF_CMASK_MASK_Pos      6                                    /*!< CAN_T::IFnCMASK: MASK Position */
N#define CAN_IF_CMASK_MASK_Msk      (1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN_T::IFnCMASK: MASK Mask     */
N
N#define CAN_IF_CMASK_ARB_Pos       5                                    /*!< CAN_T::IFnCMASK: ARB Position  */
N#define CAN_IF_CMASK_ARB_Msk       (1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN_T::IFnCMASK: ARB Mask      */
N
N#define CAN_IF_CMASK_CONTROL_Pos   4                                    /*!< CAN_T::IFnCMASK: CONTROL Position */
N#define CAN_IF_CMASK_CONTROL_Msk   (1ul << CAN_IF_CMASK_CONTROL_Pos)    /*!< CAN_T::IFnCMASK: CONTROL Mask */
N
N#define CAN_IF_CMASK_CLRINTPND_Pos 3                                    /*!< CAN_T::IFnCMASK: CLRINTPND Position */
N#define CAN_IF_CMASK_CLRINTPND_Msk (1ul << CAN_IF_CMASK_CLRINTPND_Pos)  /*!< CAN_T::IFnCMASK: CLRINTPND Mask */
N
N#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN_T::IFnCMASK: TXRQSTNEWDAT Position */
N#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)    /*!< CAN_T::IFnCMASK: TXRQSTNEWDAT Mask     */
N
N#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN_T::IFnCMASK: DATAA Position */
N#define CAN_IF_CMASK_DATAA_Msk     (1ul << CAN_IF_CMASK_DATAA_Pos)      /*!< CAN_T::IFnCMASK: DATAA Mask     */
N
N#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN_T::IFnCMASK: DATAB Position */
N#define CAN_IF_CMASK_DATAB_Msk     (1ul << CAN_IF_CMASK_DATAB_Pos)      /*!< CAN_T::IFnCMASK: DATAB Mask     */
N
N/* CAN IFn_MASK1 Bit Field Definitions */                                       
N#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN_T::IFnMASK1: MSK Position   */
N#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN_T::IFnMASK1: MSK Mask       */
N
N/* CAN IFn_MASK2 Bit Field Definitions */                                       
N#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN_T::IFnMASK2: MXTD Position */
N#define CAN_IF_MASK2_MXTD_Msk      (1ul << CAN_IF_MASK2_MXTD_Pos)       /*!< CAN_T::IFnMASK2: MXTD Mask     */
N
N#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN_T::IFnMASK2: MDIR Position */
N#define CAN_IF_MASK2_MDIR_Msk      (1ul << CAN_IF_MASK2_MDIR_Pos)       /*!< CAN_T::IFnMASK2: MDIR Mask     */
N
N#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN_T::IFnMASK2: MSK Position */
N#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN_T::IFnMASK2: MSK Mask     */
N
N/* CAN IFn_ARB1 Bit Field Definitions */                                        
N#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN_T::IFnARB1: ID Position   */
N#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN_T::IFnARB1: ID Mask       */
N
N/* CAN IFn_ARB2 Bit Field Definitions */                                        
N#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN_T::IFnARB2: MSGVAL Position */
N#define CAN_IF_ARB2_MSGVAL_Msk     (1ul << CAN_IF_ARB2_MSGVAL_Pos)      /*!< CAN_T::IFnARB2: MSGVAL Mask     */
N
N#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN_T::IFnARB2: XTD Position    */
N#define CAN_IF_ARB2_XTD_Msk        (1ul << CAN_IF_ARB2_XTD_Pos)         /*!< CAN_T::IFnARB2: XTD Mask        */
N
N#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN_T::IFnARB2: DIR Position    */
N#define CAN_IF_ARB2_DIR_Msk        (1ul << CAN_IF_ARB2_DIR_Pos)         /*!< CAN_T::IFnARB2: DIR Mask        */
N
N#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN_T::IFnARB2: ID Position     */
N#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN_T::IFnARB2: ID Mask         */
N
N/* CAN IFn_MCON Bit Field Definitions */                                        
N#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN_T::IFnMCON: NEWDAT Position */
N#define CAN_IF_MCON_NEWDAT_Msk     (1ul << CAN_IF_MCON_NEWDAT_Pos)      /*!< CAN_T::IFnMCON: NEWDAT Mask     */
N
N#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN_T::IFnMCON: MSGLST Position */
N#define CAN_IF_MCON_MSGLST_Msk     (1ul << CAN_IF_MCON_MSGLST_Pos)      /*!< CAN_T::IFnMCON: MSGLST Mask     */
N
N#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN_T::IFnMCON: INTPND Position */
N#define CAN_IF_MCON_INTPND_Msk     (1ul << CAN_IF_MCON_INTPND_Pos)      /*!< CAN_T::IFnMCON: INTPND Mask     */
N
N#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN_T::IFnMCON: UMASK Position  */
N#define CAN_IF_MCON_UMASK_Msk      (1ul << CAN_IF_MCON_UMASK_Pos)       /*!< CAN_T::IFnMCON: UMASK Mask      */
N
N#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN_T::IFnMCON: TXIE Position   */
N#define CAN_IF_MCON_TXIE_Msk       (1ul << CAN_IF_MCON_TXIE_Pos)        /*!< CAN_T::IFnMCON: TXIE Mask       */
N
N#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN_T::IFnMCON: RXIE Position   */
N#define CAN_IF_MCON_RXIE_Msk       (1ul << CAN_IF_MCON_RXIE_Pos)        /*!< CAN_T::IFnMCON: RXIE Mask       */
N
N#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN_T::IFnMCON: RMTEN Position  */
N#define CAN_IF_MCON_RMTEN_Msk      (1ul << CAN_IF_MCON_RMTEN_Pos)       /*!< CAN_T::IFnMCON: RMTEN Mask      */
N
N#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN_T::IFnMCON: TXRQST Position */
N#define CAN_IF_MCON_TXRQST_Msk     (1ul << CAN_IF_MCON_TXRQST_Pos)      /*!< CAN_T::IFnMCON: TXRQST Mask     */
N
N#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN_T::IFnMCON: EOB Position    */
N#define CAN_IF_MCON_EOB_Msk        (1ul << CAN_IF_MCON_EOB_Pos)         /*!< CAN_T::IFnMCON: EOB Mask        */
N
N#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN_T::IFnMCON: DLC Position    */
N#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN_T::IFnMCON: DLC Mask        */
N
N/* CAN IFn_DATA_A1 Bit Field Definitions */                                     
N#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN_T::IFnDATAA1: DATA1 Position */
N#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN_T::IFnDATAA1: DATA1 Mask     */
N
N#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN_T::IFnDATAA1: DATA0 Position */
N#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN_T::IFnDATAA1: DATA0 Mask     */
N
N/* CAN IFn_DATA_A2 Bit Field Definitions */                                     
N#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN_T::IFnDATAA1: DATA3 Position */
N#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN_T::IFnDATAA1: DATA3 Mask     */
N
N#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN_T::IFnDATAA1: DATA2 Position */
N#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN_T::IFnDATAA1: DATA2 Mask     */
N
N/* CAN IFn_DATA_B1 Bit Field Definitions */                                     
N#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN_T::IFnDATAB1: DATA5 Position */
N#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN_T::IFnDATAB1: DATA5 Mask */
N
N#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN_T::IFnDATAB1: DATA4 Position */
N#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN_T::IFnDATAB1: DATA4 Mask */
N
N/* CAN IFn_DATA_B2 Bit Field Definitions */                                     
N#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN_T::IFnDATAB2: DATA7 Position */
N#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN_T::IFnDATAB2: DATA7 Mask     */
N
N#define CAN_IF_DAT_B2_DATA6_Pos    0                                    /*!< CAN_T::IFnDATAB2: DATA6 Position */
N#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN_T::IFnDATAB2: DATA6 Mask     */
N
N/* CAN IFn_TXRQST1 Bit Field Definitions */
N#define CAN_IF_TXRQST1_TXRQST_Pos  0                                        /*!< CAN_T::IFnTXRQST1: TXRQST Position */
N#define CAN_IF_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST1_TXRQST_Pos)  /*!< CAN_T::IFnTXRQST1: TXRQST Mask     */
N
N/* CAN IFn_TXRQST2 Bit Field Definitions */                                         
N#define CAN_IF_TXRQST2_TXRQST_Pos  0                                        /*!< CAN_T::IFnTXRQST2: TXRQST Position  */
N#define CAN_IF_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST2_TXRQST_Pos)  /*!< CAN_T::IFnTXRQST2: TXRQST Mask      */
N
N/* CAN IFn_NDAT1 Bit Field Definitions */                                           
N#define CAN_IF_NDAT1_NEWDATA_Pos   0                                        /*!< CAN_T::IFnNDAT1: NEWDATA Position */
N#define CAN_IF_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT1_NEWDATA_Pos)   /*!< CAN_T::IFnNDAT1: NEWDATA Mask     */
N
N/* CAN IFn_NDAT2 Bit Field Definitions */                                           
N#define CAN_IF_NDAT2_NEWDATA_Pos   0                                        /*!< CAN_T::IFnNDAT2: NEWDATA Position */
N#define CAN_IF_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT2_NEWDATA_Pos)   /*!< CAN_T::IFnNDAT2: NEWDATA Mask     */
N
N/* CAN IFn_IPND1 Bit Field Definitions */                                           
N#define CAN_IF_IPND1_INTPND_Pos   0                                         /*!< CAN_T::IFnIPND1: INTPND Position */
N#define CAN_IF_IPND1_INTPND_Msk   (0xFFFFul << CAN_IF_IPND1_INTPND_Pos)     /*!< CAN_T::IFnIPND1: INTPND Mask     */
N
N/* CAN IFn_IPND2 Bit Field Definitions */                                           
N#define CAN_IF_IPND2_INTPND_Pos   0                                         /*!< CAN_T::IFnIPND2: INTPND Position */
N#define CAN_IF_IPND2_INTPND_Msk   (0xFFFFul << CAN_IF_IPND2_INTPND_Pos)     /*!< CAN_T::IFnIPND2: INTPND Mask     */
N
N/* CAN IFn_MVLD1 Bit Field Definitions */                                           
N#define CAN_IF_MVLD1_MSGVAL_Pos   0                                         /*!< CAN_T::IFnMVLD1: MSGVAL Position */
N#define CAN_IF_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD1_MSGVAL_Pos)     /*!< CAN_T::IFnMVLD1: MSGVAL Mask     */
N
N/* CAN IFn_MVLD2 Bit Field Definitions */                                           
N#define CAN_IF_MVLD2_MSGVAL_Pos   0                                         /*!< CAN_T::IFnMVLD2: MSGVAL Position */
N#define CAN_IF_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD2_MSGVAL_Pos)     /*!< CAN_T::IFnMVLD2: MSGVAL Mask     */
N
N/* CAN WUEN Bit Field Definitions */                                                
N#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN_T::WUEN: WAKUP_EN Position */
N#define CAN_WUEN_WAKUP_EN_Msk    (1ul << CAN_WUEN_WAKUP_EN_Pos)             /*!< CAN_T::WUEN: WAKUP_EN Mask     */
N
N/* CAN WUSTATUS Bit Field Definitions */                                           
N#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                    /*!< CAN_T::WUSTATUS: WAKUP_STS Position */
N#define CAN_WUSTATUS_WAKUP_STS_Msk    (1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN_T::WUSTATUS: WAKUP_STS Mask     */
N/*@}*/ /* end of group CAN_CONST */
N/*@}*/ /* end of group CAN */
N
N
N
N
N/*---------------------- System Clock Controller -------------------------*/
N/**
N    @addtogroup CLK System Clock Controller (CLK)
N    Memory Mapped Structure for CLK Controller
N@{ */
Ntypedef struct
N{
N
N    /**
N     * PWRCON
N     * ===================================================================================================
N     * Offset: 0x00  System Power-down Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |XTL12M_EN |External 4~24 MHz High Speed Crystal Enable (HXT) Control (Write Protect)
N     * |        |          |The bit default value is set by flash controller user configuration register CONFIG0 [26:24].
N     * |        |          |When the default clock source is from external 4~24 MHz high speed crystal, this bit is set to 1 automatically.
N     * |        |          |0 = External 4~24 MHz high speed crystal oscillator (HXT) Disabled.
N     * |        |          |1 = External 4~24 MHz high speed crystal oscillator (HXT) Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[2]     |OSC22M_EN |Internal 22.1184 MHz High Speed Oscillator (HIRC) Enable Control (Write Protect)
N     * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) Disabled.
N     * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[3]     |OSC10K_EN |Internal 10 KHz Low Speed Oscillator (LIRC) Enable Control (Write Protect)
N     * |        |          |0 = Internal 10 kHz low speed oscillator (LIRC) Disabled.
N     * |        |          |1 = Internal 10 kHz low speed oscillator (LIRC) Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[4]     |PD_WU_DLY |Wake-up Delay Counter Enable Control (Write Protect)
N     * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
N     * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.
N     * |        |          |0 = Clock cycles delay Disabled.
N     * |        |          |1 = Clock cycles delay Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[5]     |PD_WU_INT_EN|Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Note1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.
N     * |        |          |Note2: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[6]     |PD_WU_STS |Power-Down Mode Wake-Up Interrupt Status
N     * |        |          |Set by "Power-down wake-up event", it indicates that resume from Power-down mode.
N     * |        |          |The flag is set if the GPIO, UART, WDT, I2C, TIMER or BOD wake-up occurred. Write 1 to clear the bit to 0.
N     * |        |          |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.
N     * |[7]     |PWR_DOWN_EN|System Power-Down Enable Bit (Write Protect)
N     * |        |          |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depends on the PD_WAIT_CPU bit
N     * |        |          |(a) If the PD_WAIT_CPU is 0, then the chip enters Power-down mode immediately after the PWR_DOWN_EN bit set.
N     * |        |          |(b) if the PD_WAIT_CPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode (recommend)
N     * |        |          |When chip wakes up from Power-down mode, this bit is cleared by hardware.
N     * |        |          |User needs to set this bit again for next Power-down.
N     * |        |          |In Power-down mode, external 4~24 MHz high speed crystal oscillator and the internal 22.1184 MHz high speed oscillator will be disabled in this mode, but the internal 10 kHz low speed oscillator are not controlled by Power-down mode.
N     * |        |          |In Power- down mode, the PLL and system clock are disabled, and ignored the clock source selection.
N     * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from the internal 10 kHz low speed oscillator.
N     * |        |          |0 = Chip operating normally or chip in Idle mode because of WFI command.
N     * |        |          |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[8]     |PD_WAIT_CPU|This Bit Control The Power-Down Entry Condition (Write Protect)
N     * |        |          |0 = Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1.
N     * |        |          |1 = Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and CPU run WFI instruction.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     */
N    __IO uint32_t PWRCON;
X    volatile uint32_t PWRCON;
N
N    /**
N    * AHBCLK
N    * ===================================================================================================
N    * Offset: 0x04  AHB Devices Clock Enable Control Register
N    * ---------------------------------------------------------------------------------------------------
N    * |Bits    |Field     |Descriptions
N    * | :----: | :----:   | :---- |
N    * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control
N    * |        |          |0 = Flash ISP peripheral clock Disabled.
N    * |        |          |1 = Flash ISP peripheral clock Enabled.
N    */
N    __IO uint32_t AHBCLK;
X    volatile uint32_t AHBCLK;
N
N    /**
N     * APBCLK
N     * ===================================================================================================
N     * Offset: 0x08  APB Devices Clock Enable Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control (Write Protect)
N     * |        |          |0 = Watchdog Timer clock Disabled.
N     * |        |          |1 = Watchdog Timer clock Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
N     * |        |          |0 = Timer0 clock Disabled.
N     * |        |          |1 = Timer0 clock Enabled.
N     * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
N     * |        |          |0 = Timer1 clock Disabled.
N     * |        |          |1 = Timer1 clock Enabled.
N     * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
N     * |        |          |0 = Timer2 clock Disabled.
N     * |        |          |1 = Timer2 clock Enabled.
N     * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
N     * |        |          |0 = Timer3 clock Disabled.
N     * |        |          |1 = Timer3 clock Enabled.
N     * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
N     * |        |          |0 = FDIV clock Disabled.
N     * |        |          |1 = FDIV clock Enabled.
N     * |[8]     |I2C0_EN   |I2C0 Clock Enable Control
N     * |        |          |0 = I2C0 clock Disabled.
N     * |        |          |1 = I2C0 clock Enabled.
N     * |[9]     |I2C1_EN   |I2C1 Clock Enable Control
N     * |        |          |0 = I2C1 clock Disabled.
N     * |        |          |1 = I2C1 clock Enabled.
N     * |[12]    |SPI0_EN   |SPI0 Clock Enable Control
N     * |        |          |0 = SPI0 clock Disabled.
N     * |        |          |1 = SPI0 clock Enabled.
N     * |[16]    |UART0_EN  |UART0 Clock Enable Control
N     * |        |          |0 = UART0 clock Disabled.
N     * |        |          |1 = UART0 clock Enabled.
N     * |[17]    |UART1_EN  |UART1 Clock Enable Control
N     * |        |          |0 = UART1 clock Disabled.
N     * |        |          |1 = UART1 clock Enabled.
N     * |[18]    |UART2_EN  |UART2 Clock Enable Control
N     * |        |          |0 = UART2 clock Disabled.
N     * |        |          |1 = UART2 clock Enabled.
N     * |[24]    |CAN0_EN   |CAN Bus Controller-0 Clock Enable Control
N     * |        |          |0 = CAN0 clock Disabled.
N     * |        |          |1 = CAN0 clock Enable.     
N     * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control
N     * |        |          |0 = ADC clock Disabled.
N     * |        |          |1 = ADC clock Enabled.
N     */
N    __IO uint32_t APBCLK;
X    volatile uint32_t APBCLK;
N
N    /**
N     * CLKSTATUS
N     * ===================================================================================================
N     * Offset: 0x0C  Clock status monitor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |XTL12M_STB|External 4~24 MHz High Speed Crystal (HXT) Clock Source Stable Flag (Read Only)
N     * |        |          |0 = External 4~24 MHz high speed crystal clock (HXT) is not stable or disabled.
N     * |        |          |1 = External 4~24 MHz high speed crystal clock (HXT) is stable.
N     * |[2]     |PLL_STB   |Internal PLL Clock Source Stable Flag (Read Only)
N     * |        |          |0 = Internal PLL clock is not stable or disabled.
N     * |        |          |1 = Internal PLL clock is stable.
N     * |[3]     |OSC10K_STB|Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)
N     * |        |          |0 = Internal 10 kHz low speed oscillator clock (LIRC) is not stable or disabled.
N     * |        |          |1 = Internal 10 kHz low speed oscillator clock (LIRC) is stable.
N     * |[4]     |OSC22M_STB|Internal 22.1184 MHz High Speed Oscillator (HIRC) Clock Source Stable Flag (Read Only)
N     * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is not stable or disabled.
N     * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is stable.
N     * |[7]     |CLK_SW_FAIL|Clock Switching Fail Flag (Read Only)
N     * |        |          |0 = Clock switching success.
N     * |        |          |1 = Clock switching failure.
N     * |        |          |This bit is an index that if current system clock source is match as user defined at HCLK_S (CLKSEL[2:0]).
N     * |        |          |When user switch system clock, the system clock source will keep old clock until the new clock is stable.
N     * |        |          |During the period that waiting new clock stable, this bit will be an index shows system clock source is not match as user wanted.
N     */
N    __IO uint32_t CLKSTATUS;
X    volatile uint32_t CLKSTATUS;
N
N    /**
N     * CLKSEL0
N     * ===================================================================================================
N     * Offset: 0x10  Clock Source Select Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |HCLK_S    |HCLK Clock Source Select (Write Protect)
N     * |        |          |1. Before clock switching, the related clock sources (both pre-select and new-select) must be turn on.
N     * |        |          |2. The 3-bit default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.
N     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N     * |        |          |010 = Clock source from PLL clock.
N     * |        |          |011 = Clock source from internal 10 kHz low speed oscillator clock.
N     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[5:3]   |STCLK_S   |Cortex-M0 SysTick Clock Source Select (Write Protect)
N     * |        |          |If SYST_CSR[2] = 1, SysTick clock source is from HCLK.
N     * |        |          |If SYST_CSR[2] = 0, SysTick clock source is defined by STCLK_S(CLKSEL0[5:3]).
N     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N     * |        |          |010 = Clock source from external 4~24 MHz high speed crystal clock/2.
N     * |        |          |011 = Clock source from HCLK/2.
N     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock/2.
N     * |        |          |Note1: These bits are protected bit. It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |        |          |Note2: if SysTick clock source is not from HCLK (i.e. SYST_CSR[2] = 0), SysTick clock source must less than or equal to HCLK/2.
N     */
N    __IO uint32_t CLKSEL0;
X    volatile uint32_t CLKSEL0;
N
N    /**
N     * CLKSEL1
N     * ===================================================================================================
N     * Offset: 0x14  Clock Source Select Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WDT_S     |Watchdog Timer Clock Source Select (Write Protect)
N     * |        |          |10 = Clock source from HCLK/2048 clock.
N     * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[3:2]   |ADC_S     |ADC Clock Source Select
N     * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N     * |        |          |01 = Clock source from PLL clock.
N     * |        |          |10 = Clock source from HCLK.
N     * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N     * |[4]     |SPI0_S    |SPI0 Clock Source Selection
N     * |        |          |0 = Clock source from PLL clock.
N     * |        |          |1 = Clock source from HCLK.
N     * |[10:8]  |TMR0_S    |TIMER0 Clock Source Selection
N     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N     * |        |          |010 = Clock source from HCLK.
N     * |        |          |011 = Clock source from external trigger.
N     * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N     * |        |          |Others = reserved.
N     * |[14:12] |TMR1_S    |TIMER1 Clock Source Selection
N     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N     * |        |          |010 = Clock source from HCLK.
N     * |        |          |011 = Clock source from external trigger.
N     * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N     * |        |          |Others = reserved.
N     * |[18:16] |TMR2_S    |TIMER2 Clock Source Selection
N     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N     * |        |          |010 = Clock source from HCLK.
N     * |        |          |011 = Clock source from external trigger.
N     * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N     * |        |          |Others = reserved.
N     * |[22:20] |TMR3_S    |TIMER3 Clock Source Selection
N     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N     * |        |          |010 = Clock source from HCLK.
N     * |        |          |011 = Clock source from external trigger.
N     * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N     * |        |          |Others = reserved.
N     * |[25:24] |UART_S    |UART Clock Source Selection
N     * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N     * |        |          |01 = Clock source from PLL clock.
N     * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N     */
N    __IO uint32_t CLKSEL1;
X    volatile uint32_t CLKSEL1;
N
N    /**
N     * CLKDIV
N     * ===================================================================================================
N     * Offset: 0x18  Clock Divider Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |HCLK_N    |HCLK Clock Divide Number From HCLK Clock Source
N     * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1).
N     * |[11:8]  |UART_N    |UART Clock Divide Number From UART Clock Source
N     * |        |          |UART clock frequency = (UART clock source frequency) / (UART_N + 1).
N     * |[23:16] |ADC_N     |ADC Clock Divide Number From ADC Clock Source
N     * |        |          |ADC clock frequency = (ADC clock source frequency) / (ADC_N + 1).
N     */
N    __IO uint32_t CLKDIV;
X    volatile uint32_t CLKDIV;
N
N    /**
N     * CLKSEL2
N     * ===================================================================================================
N     * Offset: 0x1C  Clock Source Select Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Selection
N     * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N     * |        |          |10 = Clock source from HCLK.
N     * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N     * |[17:16] |WWDT_S    |Window Watchdog Timer Clock Source Selection
N     * |        |          |10 = Clock source from HCLK/2048 clock.
N     * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N     */
N    __IO uint32_t CLKSEL2;
X    volatile uint32_t CLKSEL2;
N
N    /**
N     * PLLCON
N     * ===================================================================================================
N     * Offset: 0x20  PLL Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8:0]   |FB_DV     |PLL Feedback Divider Control Bits
N     * |        |          |Refer to the formulas below the table.
N     * |[13:9]  |IN_DV     |PLL Input Divider Control Bits
N     * |        |          |Refer to the formulas below the table.
N     * |[15:14] |OUT_DV    |PLL Output Divider Control Bits
N     * |        |          |Refer to the formulas below the table.
N     * |[16]    |PD        |Power-Down Mode
N     * |        |          |If the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too.
N     * |        |          |0 = PLL is in Normal mode.
N     * |        |          |1 = PLL is in Power-down mode (default).
N     * |[17]    |BP        |PLL Bypass Control
N     * |        |          |0 = PLL is in Normal mode (default).
N     * |        |          |1 = PLL clock output is same as PLL source clock input.
N     * |[18]    |OE        |PLL OE (FOUT Enable) Pin Control
N     * |        |          |0 = PLL FOUT Enabled.
N     * |        |          |1 = PLL FOUT is fixed low.
N     * |[19]    |PLL_SRC   |PLL Source Clock Selection
N     * |        |          |0 = PLL source clock from external 4~24 MHz high speed crystal.
N     * |        |          |1 = PLL source clock from internal 22.1184 MHz high speed oscillator.
N     */
N    __IO uint32_t PLLCON;
X    volatile uint32_t PLLCON;
N
N    /**
N     * FRQDIV
N     * ===================================================================================================
N     * Offset: 0x24  Frequency Divider Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
N     * |        |          |The formula of output frequency is Fout = Fin/2(N+1).
N     * |        |          |Fin is the input clock frequency.
N     * |        |          |Fout is the frequency of divider output clock.
N     * |        |          |N is the 4-bit value of FSEL[3:0].
N     * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
N     * |        |          |0 = Frequency Divider function Disabled.
N     * |        |          |1 = Frequency Divider function Enabled.
N     * |[5]     |DIVIDER1  |Frequency Divider One Enable Bit
N     * |        |          |0 = Frequency divider will output clock with source frequency divided by FSEL.
N     * |        |          |1 = Frequency divider will output clock with source frequency.
N     */
N    __IO uint32_t FRQDIV;
X    volatile uint32_t FRQDIV;
N
N    __IO uint32_t RESERVE0[2];
X    volatile uint32_t RESERVE0[2];
N
N    /**
N     * APBCLK1
N     * ===================================================================================================
N     * Offset: 0x30  APB Devices Clock Enable Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |UART3_EN  |UART3 Clock Enable Bit
N     * |        |          |0 = UART3 clock Disabled.
N     * |        |          |1 = UART3 clock Enabled.
N     * |[9]     |UART4_EN  |UART4 Clock Enable Bit
N     * |        |          |0 = UART4 clock Disabled.
N     * |        |          |1 = UART4 clock Enabled.
N     * |[10]    |UART5_EN  |UART5 Clock Enable Bit
N     * |        |          |0 = UART5 clock Disabled.
N     * |        |          |1 = UART5 clock Enabled.
N     * |[16]    |PWM0_EN   |PWM0 Clock Enable Bit
N     * |        |          |0 = PWM0 clock Disabled.
N     * |        |          |1 = PWM0 clock Enabled.
N     * |[17]    |PWM1_EN   |PWM1 Clock Enable Bit
N     * |        |          |0 = PWM1 clock Disabled.
N     * |        |          |1 = PWM1 clock Enabled.
N     * |[18]    |BPWM0_EN  |BPWM0 Clock Enable Bit
N     * |        |          |0 = BPWM0 clock Disabled.
N     * |        |          |1 = BPWM0 clock Enabled.
N     * |[19]    |BPWM1_EN  |BPWM1 Clock Enable Bit
N     * |        |          |0 = BPWM1 clock Disabled.
N     * |        |          |1 = BPWM1 clock Enabled.
N     */
N    __IO uint32_t APBCLK1;
X    volatile uint32_t APBCLK1;
N
N    /**
N     * CLKSEL3
N     * ===================================================================================================
N     * Offset: 0x34  Clock Source Select Control Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[16]    |PWM0_S    |PWM0 Clock Source Selection
N     * |        |          |The peripheral clock source of PWM0 is defined by PWM0_S.
N     * |        |          |0 = Clock source from PLL.
N     * |        |          |1 = Clock source from PCLK.
N     * |[17]    |PWM1_S    |PWM1 Clock Source Selection
N     * |        |          |The peripheral clock source of PWM1 is defined by PWM1_S.
N     * |        |          |0 = Clock source from PLL.
N     * |        |          |1 = Clock source from PCLK.
N     * |[18]    |BPWM0_S   |BPWM0 Clock Source Selection
N     * |        |          |The peripheral clock source of BPWM0 is defined by BPWM0_S.
N     * |        |          |0 = Clock source from PLL.
N     * |        |          |1 = Clock source from PCLK.
N     * |[19]    |BPWM1_S   |BPWM1 Clock Source Selection
N     * |        |          |The peripheral clock source of BPWM1 is defined by BPWM1_S.
N     * |        |          |0 = Clock source from PLL.
N     * |        |          |1 = Clock source from PCLK.
N     */
N    __IO uint32_t CLKSEL3;
X    volatile uint32_t CLKSEL3;
N
N    __IO uint32_t RESERVE1[14];
X    volatile uint32_t RESERVE1[14];
N
N    /**
N     * CLKDCTL
N     * ===================================================================================================
N     * Offset: 0x70  Clock Fail Detector Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |HXTFDEN   |HXT Clock Fail Detector Enable Bit
N     * |        |          |0 = HXT clock Fail detector Disabled.
N     * |        |          |1 = HXT clock Fail detector Enabled.
N     * |[5]     |HXTFIEN   |HXT Clock Fail Interrupt Enable Bit
N     * |        |          |0 = HXT clock Fail interrupt Disabled.
N     * |        |          |1 = HXT clock Fail interrupt Enabled.
N     * |[16]    |HXTFQDEN  |HXT Clock Frequency Monitor Enable Bit
N     * |        |          |0 = HXT clock frequency monitor Disabled.
N     * |        |          |1 = HXT clock frequency monitor Enabled.
N     * |[17]    |HXTFQIEN  |HXT Clock Frequency Monitor Interrupt Enable Bit
N     * |        |          |0 = HXT clock frequency monitor fail interrupt Disabled.
N     * |        |          |1 = HXT clock frequency monitor fail interrupt Enabled.
N     */
N    __IO uint32_t CLKDCTL;
X    volatile uint32_t CLKDCTL;
N
N    /**
N     * CLKDSTS
N     * ===================================================================================================
N     * Offset: 0x74  Clock Fail Detector Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |HXTFIF    |HXT Clock Fail Interrupt Flag
N     * |        |          |0 = HXT clock normal.
N     * |        |          |1 = HXT clock stop (write "1" to clear).
N     * |[8]     |HXTFQIF   |HXT Clock Frequency Monitor Interrupt Flag
N     * |        |          |0 = HXT clock normal.
N     * |        |          |1 = HXT clock frequency abnormal (write "1" to clear).
N     */
N    __IO uint32_t CLKDSTS;
X    volatile uint32_t CLKDSTS;
N
N    /**
N     * CDUPB
N     * ===================================================================================================
N     * Offset: 0x78  Clock Frequency Detector Upper Boundary Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |UPERBD    |HXT Clock Frequency Detector Upper Boundary
N     * |        |          |The bits define the high value of frequency monitor window.
N     * |        |          |When HXT frequency monitor value higher than this register,
N     * |        |          |the HXT frequency detect fail interrupt flag will set to 1.
N     */
N    __IO uint32_t CDUPB;
X    volatile uint32_t CDUPB;
N
N    /**
N     * CDLOWB
N     * ===================================================================================================
N     * Offset: 0x7C  Clock Frequency Detector Lower Boundary Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[9:0]   |LOWERBD   |HXT Clock Frequency Detector Lower Boundary
N     * |        |          |The bits define the low value of frequency monitor window.
N     * |        |          |When HXT frequency monitor values lower than this register,
N     * |        |          |the HXT frequency detect fail interrupt flag will set to 1.
N     */
N    __IO uint32_t CDLOWB;
X    volatile uint32_t CDLOWB;
N
N
N} CLK_T;
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N/* CLK PWRCON Bit Field Definitions */
N#define CLK_PWRCON_PD_WAIT_CPU_Pos           8                                    /*!< CLK_T::PWRCON: PD_WAIT_CPU Position */
N#define CLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << CLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< CLK_T::PWRCON: PD_WAIT_CPU Mask */
N
N#define CLK_PWRCON_PWR_DOWN_EN_Pos           7                                    /*!< CLK_T::PWRCON: PWR_DOWN_EN Position */
N#define CLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< CLK_T::PWRCON: PWR_DOWN_EN Mask */
N
N#define CLK_PWRCON_PD_WU_STS_Pos             6                                    /*!< CLK_T::PWRCON: PD_WU_STS Position */
N#define CLK_PWRCON_PD_WU_STS_Msk             (1ul << CLK_PWRCON_PD_WU_STS_Pos)    /*!< CLK_T::PWRCON: PD_WU_STS Mask */
N
N#define CLK_PWRCON_PD_WU_INT_EN_Pos          5                                    /*!< CLK_T::PWRCON: PD_WU_INT_EN Position */
N#define CLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << CLK_PWRCON_PD_WU_INT_EN_Pos) /*!< CLK_T::PWRCON: PD_WU_INT_EN Mask */
N
N#define CLK_PWRCON_PD_WU_DLY_Pos             4                                    /*!< CLK_T::PWRCON: PD_WU_DLY Position */
N#define CLK_PWRCON_PD_WU_DLY_Msk             (1ul << CLK_PWRCON_PD_WU_DLY_Pos)    /*!< CLK_T::PWRCON: PD_WU_DLY Mask */
N
N#define CLK_PWRCON_OSC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
N#define CLK_PWRCON_OSC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
N#define CLK_PWRCON_IRC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: IRC10K_EN Position */
N#define CLK_PWRCON_IRC10K_EN_Msk             (1ul << CLK_PWRCON_IRC10K_EN_Pos)    /*!< CLK_T::PWRCON: IRC10K_EN Mask */
N
N#define CLK_PWRCON_OSC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
N#define CLK_PWRCON_OSC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
N#define CLK_PWRCON_IRC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: IRC22M_EN Position */
N#define CLK_PWRCON_IRC22M_EN_Msk             (1ul << CLK_PWRCON_IRC22M_EN_Pos)    /*!< CLK_T::PWRCON: IRC22M_EN Mask */
N
N#define CLK_PWRCON_XTL12M_EN_Pos             0                                    /*!< CLK_T::PWRCON: XTL12M_EN Position */
N#define CLK_PWRCON_XTL12M_EN_Msk             (1ul << CLK_PWRCON_XTL12M_EN_Pos)    /*!< CLK_T::PWRCON: XTL12M_EN Mask */
N
N/* CLK AHBCLK Bit Field Definitions */
N#define CLK_AHBCLK_ISP_EN_Pos                2                                    /*!< CLK_T::AHBCLK: ISP_EN Position */
N#define CLK_AHBCLK_ISP_EN_Msk                (1ul << CLK_AHBCLK_ISP_EN_Pos)       /*!< CLK_T::AHBCLK: ISP_EN Mask */
N
N/* CLK APBCLK Bit Field Definitions */
N#define CLK_APBCLK_ADC_EN_Pos                28                                   /*!< CLK_T::APBCLK: ADC_EN Position */
N#define CLK_APBCLK_ADC_EN_Msk                (1ul << CLK_APBCLK_ADC_EN_Pos)       /*!< CLK_T::APBCLK: ADC_EN Mask */
N
N#define CLK_APBCLK_CAN0_EN_Pos               24                                   /*!< CLK APBCLK: CAN0_EN Position */
N#define CLK_APBCLK_CAN0_EN_Msk               (1ul << CLK_APBCLK_CAN0_EN_Pos)      /*!< CLK APBCLK: CAN0_EN Mask */
N
N#define CLK_APBCLK_UART2_EN_Pos              18                                   /*!< CLK_T::APBCLK: UART2_EN Position */
N#define CLK_APBCLK_UART2_EN_Msk              (1ul << CLK_APBCLK_UART2_EN_Pos)     /*!< CLK_T::APBCLK: UART2_EN Mask */
N
N#define CLK_APBCLK_UART1_EN_Pos              17                                   /*!< CLK_T::APBCLK: UART1_EN Position */
N#define CLK_APBCLK_UART1_EN_Msk              (1ul << CLK_APBCLK_UART1_EN_Pos)     /*!< CLK_T::APBCLK: UART1_EN Mask */
N
N#define CLK_APBCLK_UART0_EN_Pos              16                                   /*!< CLK_T::APBCLK: UART0_EN Position */
N#define CLK_APBCLK_UART0_EN_Msk              (1ul << CLK_APBCLK_UART0_EN_Pos)     /*!< CLK_T::APBCLK: UART0_EN Mask */
N
N#define CLK_APBCLK_SPI0_EN_Pos               12                                   /*!< CLK_T::APBCLK: SPI0_EN Position */
N#define CLK_APBCLK_SPI0_EN_Msk               (1ul << CLK_APBCLK_SPI0_EN_Pos)      /*!< CLK_T::APBCLK: SPI0_EN Mask */
N
N#define CLK_APBCLK_I2C1_EN_Pos               9                                    /*!< CLK_T::APBCLK: I2C1_EN Position */
N#define CLK_APBCLK_I2C1_EN_Msk               (1ul << CLK_APBCLK_I2C1_EN_Pos)      /*!< CLK_T::APBCLK: I2C1_EN Mask */
N
N#define CLK_APBCLK_I2C0_EN_Pos               8                                    /*!< CLK_T::APBCLK: I2C0_EN_ Position */
N#define CLK_APBCLK_I2C0_EN_Msk               (1ul << CLK_APBCLK_I2C0_EN_Pos)      /*!< CLK_T::APBCLK: I2C0_EN_ Mask */
N
N#define CLK_APBCLK_FDIV_EN_Pos               6                                    /*!< CLK_T::APBCLK: FDIV_EN Position */
N#define CLK_APBCLK_FDIV_EN_Msk               (1ul << CLK_APBCLK_FDIV_EN_Pos)      /*!< CLK_T::APBCLK: FDIV_EN Mask */
N
N#define CLK_APBCLK_TMR3_EN_Pos               5                                    /*!< CLK_T::APBCLK: TMR3_EN Position */
N#define CLK_APBCLK_TMR3_EN_Msk               (1ul << CLK_APBCLK_TMR3_EN_Pos)      /*!< CLK_T::APBCLK: TMR3_EN Mask */
N
N#define CLK_APBCLK_TMR2_EN_Pos               4                                    /*!< CLK_T::APBCLK: TMR2_EN Position */
N#define CLK_APBCLK_TMR2_EN_Msk               (1ul << CLK_APBCLK_TMR2_EN_Pos)      /*!< CLK_T::APBCLK: TMR2_EN Mask */
N
N#define CLK_APBCLK_TMR1_EN_Pos               3                                    /*!< CLK_T::APBCLK: TMR1_EN Position */
N#define CLK_APBCLK_TMR1_EN_Msk               (1ul << CLK_APBCLK_TMR1_EN_Pos)      /*!< CLK_T::APBCLK: TMR1_EN Mask */
N
N#define CLK_APBCLK_TMR0_EN_Pos               2                                    /*!< CLK_T::APBCLK: TMR0_EN Position */
N#define CLK_APBCLK_TMR0_EN_Msk               (1ul << CLK_APBCLK_TMR0_EN_Pos)      /*!< CLK_T::APBCLK: TMR0_EN Mask */
N
N#define CLK_APBCLK_WDT_EN_Pos                0                                    /*!< CLK_T::APBCLK: WDT_EN Position */
N#define CLK_APBCLK_WDT_EN_Msk                (1ul << CLK_APBCLK_WDT_EN_Pos)       /*!< CLK_T::APBCLK: WDT_EN Mask */
N
N/* CLK APBCLK1 Bit Field Definitions */
N#define CLK_APBCLK1_BPWM1_EN_Pos             19                                   /*!< CLK_T::APBCLK1: BPWM1_EN Position */
N#define CLK_APBCLK1_BPWM1_EN_Msk             (1ul << CLK_APBCLK1_BPWM1_EN_Pos)    /*!< CLK_T::APBCLK1: BPWM1_EN Mask */
N
N#define CLK_APBCLK1_BPWM0_EN_Pos             18                                   /*!< CLK_T::APBCLK1: BPWM0_EN Position */
N#define CLK_APBCLK1_BPWM0_EN_Msk             (1ul << CLK_APBCLK1_BPWM0_EN_Pos)    /*!< CLK_T::APBCLK1: BPWM0_EN Mask */
N
N#define CLK_APBCLK1_PWM1_EN_Pos              17                                   /*!< CLK_T::APBCLK1: PWM1_EN Position */
N#define CLK_APBCLK1_PWM1_EN_Msk              (1ul << CLK_APBCLK1_PWM1_EN_Pos)     /*!< CLK_T::APBCLK1: PWM1_EN Mask */
N
N#define CLK_APBCLK1_PWM0_EN_Pos              16                                   /*!< CLK_T::APBCLK1: PWM0_EN Position */
N#define CLK_APBCLK1_PWM0_EN_Msk              (1ul << CLK_APBCLK1_PWM0_EN_Pos)     /*!< CLK_T::APBCLK1: PWM0_EN Mask */
N
N#define CLK_APBCLK1_UART5_EN_Pos             10                                   /*!< CLK_T::APBCLK1: UART5_EN Position */
N#define CLK_APBCLK1_UART5_EN_Msk             (1ul << CLK_APBCLK1_UART5_EN_Pos)    /*!< CLK_T::APBCLK1: UART5_EN Mask */
N
N#define CLK_APBCLK1_UART4_EN_Pos             9                                    /*!< CLK_T::APBCLK1: UART4_EN Position */
N#define CLK_APBCLK1_UART4_EN_Msk             (1ul << CLK_APBCLK1_UART4_EN_Pos)    /*!< CLK_T::APBCLK1: UART4_EN Mask */
N
N#define CLK_APBCLK1_UART3_EN_Pos             8                                    /*!< CLK_T::APBCLK1: UART3_EN Position */
N#define CLK_APBCLK1_UART3_EN_Msk             (1ul << CLK_APBCLK1_UART3_EN_Pos)    /*!< CLK_T::APBCLK1: UART3_EN Mask */
N
N/* CLK CLKSTATUS Bit Field Definitions */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                        /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask */
N
N#define CLK_CLKSTATUS_OSC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: OSC22M_STB Position */
N#define CLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC22M_STB Mask */
N#define CLK_CLKSTATUS_IRC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: IRC22M_STB Position */
N#define CLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << CLK_CLKSTATUS_IRC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC22M_STB Mask */
N
N#define CLK_CLKSTATUS_OSC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: OSC10K_STB Position */
N#define CLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC10K_STB Mask */
N#define CLK_CLKSTATUS_IRC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: IRC10K_STB Position */
N#define CLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << CLK_CLKSTATUS_IRC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC10K_STB Mask */
N
N#define CLK_CLKSTATUS_PLL_STB_Pos            2                                        /*!< CLK_T::CLKSTATUS: PLL_STB Position */
N#define CLK_CLKSTATUS_PLL_STB_Msk            (1ul << CLK_CLKSTATUS_PLL_STB_Pos)       /*!< CLK_T::CLKSTATUS: PLL_STB Mask */
N
N#define CLK_CLKSTATUS_XTL12M_STB_Pos         0                                        /*!< CLK_T::CLKSTATUS: XTL12M_STB Position */
N#define CLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << CLK_CLKSTATUS_XTL12M_STB_Pos)    /*!< CLK_T::CLKSTATUS: XTL12M_STB Mask */
N
N/* CLK CLKSEL0 Bit Field Definitions */
N#define CLK_CLKSEL0_STCLK_S_Pos              3                                        /*!< CLK_T::CLKSEL0: STCLK_S Position */
N#define CLK_CLKSEL0_STCLK_S_Msk              (7ul << CLK_CLKSEL0_STCLK_S_Pos)         /*!< CLK_T::CLKSEL0: STCLK_S Mask */
N
N#define CLK_CLKSEL0_HCLK_S_Pos               0                                        /*!< CLK_T::CLKSEL0: HCLK_S Position */
N#define CLK_CLKSEL0_HCLK_S_Msk               (7ul << CLK_CLKSEL0_HCLK_S_Pos)          /*!< CLK_T::CLKSEL0: HCLK_S Mask */
N
N/* CLK CLKSEL1 Bit Field Definitions */
N#define CLK_CLKSEL1_UART_S_Pos               24                                       /*!< CLK_T::CLKSEL1: UART_S Position */
N#define CLK_CLKSEL1_UART_S_Msk               (3ul << CLK_CLKSEL1_UART_S_Pos)          /*!< CLK_T::CLKSEL1: UART_S Mask */
N
N#define CLK_CLKSEL1_TMR3_S_Pos               20                                       /*!< CLK_T::CLKSEL1: TMR3_S Position */
N#define CLK_CLKSEL1_TMR3_S_Msk               (7ul << CLK_CLKSEL1_TMR3_S_Pos)          /*!< CLK_T::CLKSEL1: TMR3_S Mask */
N
N#define CLK_CLKSEL1_TMR2_S_Pos               16                                       /*!< CLK_T::CLKSEL1: TMR2_S Position */
N#define CLK_CLKSEL1_TMR2_S_Msk               (7ul << CLK_CLKSEL1_TMR2_S_Pos)          /*!< CLK_T::CLKSEL1: TMR2_S Mask */
N
N#define CLK_CLKSEL1_TMR1_S_Pos               12                                       /*!< CLK_T::CLKSEL1: TMR1_S Position */
N#define CLK_CLKSEL1_TMR1_S_Msk               (7ul << CLK_CLKSEL1_TMR1_S_Pos)          /*!< CLK_T::CLKSEL1: TMR1_S Mask */
N
N#define CLK_CLKSEL1_TMR0_S_Pos               8                                        /*!< CLK_T::CLKSEL1: TMR0_S Position */
N#define CLK_CLKSEL1_TMR0_S_Msk               (7ul << CLK_CLKSEL1_TMR0_S_Pos)          /*!< CLK_T::CLKSEL1: TMR0_S Mask */
N
N#define CLK_CLKSEL1_SPI0_S_Pos               4                                        /*!< CLK_T::CLKSEL1: SPI0_S Position */
N#define CLK_CLKSEL1_SPI0_S_Msk               (1ul << CLK_CLKSEL1_SPI0_S_Pos)          /*!< CLK_T::CLKSEL1: SPI0_S Mask */
N
N#define CLK_CLKSEL1_ADC_S_Pos                2                                        /*!< CLK_T::CLKSEL1: ADC_S Position */
N#define CLK_CLKSEL1_ADC_S_Msk                (3ul << CLK_CLKSEL1_ADC_S_Pos)           /*!< CLK_T::CLKSEL1: ADC_S Mask */
N
N#define CLK_CLKSEL1_WDT_S_Pos                0                                        /*!< CLK_T::CLKSEL1: WDT_S Position */
N#define CLK_CLKSEL1_WDT_S_Msk                (3ul << CLK_CLKSEL1_WDT_S_Pos)           /*!< CLK_T::CLKSEL1: WDT_S Mask */
N
N/* CLK CLKSEL2 Bit Field Definitions */
N#define CLK_CLKSEL2_WWDT_S_Pos               16                                       /*!< CLK_T::CLKSEL2: WWDT_S Position */
N#define CLK_CLKSEL2_WWDT_S_Msk               (3ul << CLK_CLKSEL2_WWDT_S_Pos)          /*!< CLK_T::CLKSEL2: WWDT_S Mask */
N
N#define CLK_CLKSEL2_FRQDIV_S_Pos             2                                        /*!< CLK_T::CLKSEL2: FRQDIV_S Position */
N#define CLK_CLKSEL2_FRQDIV_S_Msk             (3ul << CLK_CLKSEL2_FRQDIV_S_Pos)        /*!< CLK_T::CLKSEL2: FRQDIV_S Mask */
N
N/* CLK CLKSEL3 Bit Field Definitions */
N#define CLK_CLKSEL3_BPWM1_S_Pos              19                                       /*!< CLK_T::CLKSEL3: BPWM1_S Position */
N#define CLK_CLKSEL3_BPWM1_S_Msk              (1ul << CLK_CLKSEL3_BPWM1_S_Pos)         /*!< CLK_T::CLKSEL3: BPWM1_S Mask */
N
N#define CLK_CLKSEL3_BPWM0_S_Pos              18                                       /*!< CLK_T::CLKSEL3: BPWM0_S Position */
N#define CLK_CLKSEL3_BPWM0_S_Msk              (1ul << CLK_CLKSEL3_BPWM0_S_Pos)         /*!< CLK_T::CLKSEL3: BPWM0_S Mask */
N
N#define CLK_CLKSEL3_PWM1_S_Pos               17                                       /*!< CLK_T::CLKSEL3: PWM1_S Position */
N#define CLK_CLKSEL3_PWM1_S_Msk               (1ul << CLK_CLKSEL3_PWM1_S_Pos)          /*!< CLK_T::CLKSEL3: PWM1_S Mask */
N
N#define CLK_CLKSEL3_PWM0_S_Pos               16                                       /*!< CLK_T::CLKSEL3: PWM0_S Position */
N#define CLK_CLKSEL3_PWM0_S_Msk               (1ul << CLK_CLKSEL3_PWM0_S_Pos)          /*!< CLK_T::CLKSEL3: PWM0_S Mask */
N
N/* CLK CLKDIV Bit Field Definitions */
N#define CLK_CLKDIV_ADC_N_Pos                 16                                       /*!< CLK_T::CLKDIV: ADC_N Position */
N#define CLK_CLKDIV_ADC_N_Msk                 (0xFFul << CLK_CLKDIV_ADC_N_Pos)         /*!< CLK_T::CLKDIV: ADC_N Mask */
N
N#define CLK_CLKDIV_UART_N_Pos                8                                        /*!< CLK_T::CLKDIV: UART_N Position */
N#define CLK_CLKDIV_UART_N_Msk                (0xFul << CLK_CLKDIV_UART_N_Pos)         /*!< CLK_T::CLKDIV: UART_N Mask */
N
N#define CLK_CLKDIV_HCLK_N_Pos                0                                        /*!< CLK_T::CLKDIV: HCLK_N Position */
N#define CLK_CLKDIV_HCLK_N_Msk                (0xFul << CLK_CLKDIV_HCLK_N_Pos)         /*!< CLK_T::CLKDIV: HCLK_N Mask */
N
N/* CLK PLLCON Bit Field Definitions */
N#define CLK_PLLCON_PLL_SRC_Pos               19                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
N#define CLK_PLLCON_PLL_SRC_Msk               (1ul << CLK_PLLCON_PLL_SRC_Pos)          /*!< CLK_T::PLLCON: PLL_SRC Mask */
N
N#define CLK_PLLCON_OE_Pos                    18                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
N#define CLK_PLLCON_OE_Msk                    (1ul << CLK_PLLCON_OE_Pos)               /*!< CLK_T::PLLCON: PLL_SRC Mask */
N
N#define CLK_PLLCON_BP_Pos                    17                                       /*!< CLK_T::PLLCON: OE Position */
N#define CLK_PLLCON_BP_Msk                    (1ul << CLK_PLLCON_BP_Pos)               /*!< CLK_T::PLLCON: OE Mask */
N
N#define CLK_PLLCON_PD_Pos                    16                                       /*!< CLK_T::PLLCON: PD Position */
N#define CLK_PLLCON_PD_Msk                    (1ul << CLK_PLLCON_PD_Pos)               /*!< CLK_T::PLLCON: PD Mask */
N
N#define CLK_PLLCON_OUT_DV_Pos                14                                       /*!< CLK_T::PLLCON: OUT_DV Position */
N#define CLK_PLLCON_OUT_DV_Msk                (3ul << CLK_PLLCON_OUT_DV_Pos)           /*!< CLK_T::PLLCON: OUT_DV Mask */
N
N#define CLK_PLLCON_IN_DV_Pos                 9                                        /*!< CLK_T::PLLCON: IN_DV Position */
N#define CLK_PLLCON_IN_DV_Msk                 (0x1Ful << CLK_PLLCON_IN_DV_Pos)         /*!< CLK_T::PLLCON: IN_DV Mask */
N
N#define CLK_PLLCON_FB_DV_Pos                 0                                        /*!< CLK_T::PLLCON: FB_DV Position */
N#define CLK_PLLCON_FB_DV_Msk                 (0x1FFul << CLK_PLLCON_FB_DV_Pos)        /*!< CLK_T::PLLCON: FB_DV Mask */
N
N/* CLK FRQDIV Bit Field Definitions */
N#define CLK_FRQDIV_DIVIDER1_Pos              5                                        /*!< CLK_T::FRQDIV: DIVIDER1 Position */
N#define CLK_FRQDIV_DIVIDER1_Msk              (1ul << CLK_FRQDIV_DIVIDER1_Pos)         /*!< CLK_T::FRQDIV: DIVIDER1 Mask */
N
N#define CLK_FRQDIV_DIVIDER_EN_Pos            4                                        /*!< CLK_T::FRQDIV: DIVIDER_EN Position */
N#define CLK_FRQDIV_DIVIDER_EN_Msk            (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)       /*!< CLK_T::FRQDIV: DIVIDER_EN Mask */
N
N#define CLK_FRQDIV_FSEL_Pos                  0                                        /*!< CLK_T::FRQDIV: FRQDIV_FSEL Position */
N#define CLK_FRQDIV_FSEL_Msk                  (0xFul << CLK_FRQDIV_FSEL_Pos)           /*!< CLK_T::FRQDIV: FRQDIV_FSEL Mask */
N
N/* CLK CLKDCTL Bit Field Definitions */
N#define CLK_CLKDCTL_HXTFQIEN_Pos           17                                         /*!< CLK_T::CLKDCTL: HXTFQIEN Position */
N#define CLK_CLKDCTL_HXTFQIEN_Msk           (1ul << CLK_CLKDCTL_HXTFQIEN_Pos)          /*!< CLK_T::CLKDCTL: HXTFQIEN Mask */
N
N#define CLK_CLKDCTL_HXTFQDEN_Pos           16                                         /*!< CLK_T::CLKDCTL: HXTFQDEN Position */
N#define CLK_CLKDCTL_HXTFQDEN_Msk           (1ul << CLK_CLKDCTL_HXTFQDEN_Pos)          /*!< CLK_T::CLKDCTL: HXTFQDEN Mask */
N
N#define CLK_CLKDCTL_HXTFIEN_Pos           5                                           /*!< CLK_T::CLKDCTL: HXTFIEN Position */
N#define CLK_CLKDCTL_HXTFIEN_Msk           (1ul << CLK_CLKDCTL_HXTFIEN_Pos)            /*!< CLK_T::CLKDCTL: HXTFIEN Mask */
N                                                                                    
N#define CLK_CLKDCTL_HXTFDEN_Pos           4                                           /*!< CLK_T::CLKDCTL: HXTFDEN Position */
N#define CLK_CLKDCTL_HXTFDEN_Msk           (1ul << CLK_CLKDCTL_HXTFDEN_Pos)            /*!< CLK_T::CLKDCTL: HXTFDEN Mask */
N
N/* CLK CLKDSTS Bit Field Definitions */
N#define CLK_CLKDSTS_HXTFQIF_Pos           8                                           /*!< CLK_T::CLKDSTS: HXTFQIF Position */
N#define CLK_CLKDSTS_HXTFQIF_Msk           (1ul << CLK_CLKDSTS_HXTFQIF_Pos)            /*!< CLK_T::CLKDSTS: HXTFQIF Mask */
N
N#define CLK_CLKDSTS_HXTFIF_Pos           0                                            /*!< CLK_T::CLKDSTS: HXTFIF Position */
N#define CLK_CLKDSTS_HXTFIF_Msk           (1ul << CLK_CLKDSTS_HXTFIF_Pos)              /*!< CLK_T::CLKDSTS: HXTFIF Mask */
N
N/* CLK CDUPB Bit Field Definitions */
N#define CLK_CDUPB_UPERBD_Pos           0                                             /*!< CLK_T::CDUPB: UPERBD Position */
N#define CLK_CDUPB_UPERBD_Msk           (0x3Ful << CLK_CDUPB_UPERBD_Pos)              /*!< CLK_T::CDUPB: UPERBD Mask */
N
N/* CLK CDLOWB Bit Field Definitions */
N#define CLK_CDLOWB_UPERBD_Pos           0                                            /*!< CLK_T::CDLOWB: LOWRBD Position */
N#define CLK_CDLOWB_UPERBD_Msk           (0x3Ful << CLK_CDLOWB_LOWERBD_Pos)           /*!< CLK_T::CDLOWB: LOWERBD Mask */
N
N/*@}*/ /* end of group CLK_CONST */
N/*@}*/ /* end of group CLK */
N
N
N
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller (FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
Ntypedef struct
N{
N    /**
N     * ISPCON
N     * ===================================================================================================
N     * Offset: 0x00  ISP Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPEN     |ISP Enable (Write Protect)
N     * |        |          |ISP function enable bit. Set this bit to enable ISP function.
N     * |        |          |0 = ISP function Disabled.     
N     * |        |          |1 = ISP function Enabled.
N     * |[1]     |BS        |Boot Select (Write Protect)
N     * |        |          |Set/clear this bit to select next booting from LDROM/APROM,
N     * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check where
N     * |        |          |MCU booted from. This bit is initiated with the inverted value of CBS in Config0 after power-
N     * |        |          |on reset; It keeps the same value at other reset.
N     * |        |          |0 = boot from APROM     
N     * |        |          |1 = boot from LDROM
N     * |[3]     |APUEN     |APROM Update Enable Bit (Write Protect)
N     * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
N     * |        |          |1 = APROM can be updated when the chip runs in APROM.
N     * |[4]     |CFGUEN    |Config Update Enable (Write Protect)
N     * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program
N     * |        |          |code is running in APROM or LDROM.
N     * |        |          |0 = Config update disable     
N     * |        |          |1 = Config update enable
N     * |[5]     |LDUEN     |LDROM Update Enable (Write Protect)
N     * |        |          |LDROM update enable bit.
N     * |        |          |0 = LDROM cannot be updated
N     * |        |          |1 = LDROM can be updated when chip runs in APROM.     
N     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N     * |        |          |(4) Destination address is illegal, such as over an available range.
N     * |        |          |Note: Write 1 to clear.
N     */
N    __IO uint32_t ISPCON;
X    volatile uint32_t ISPCON;
N
N    /**
N     * ISPADR
N     * ===================================================================================================
N     * Offset: 0x04  ISP Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPADR    |ISP Address
N     * |        |          |NuMicro NUC131 series has a maximum of 17Kx32(68KB) embedded Flash, which supports word program only.
N     * |        |          |ISPADR[1:0] must be kept 00b for ISP operation.
N     */
N    __IO uint32_t ISPADR;
X    volatile uint32_t ISPADR;
N
N    /**
N     * ISPDAT
N     * ===================================================================================================
N     * Offset: 0x08  ISP Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |ISPDAT    |ISP Data
N     * |        |          |Write data to this register before ISP program operation
N     * |        |          |Read data from this register after ISP read operation
N     */
N    __IO uint32_t ISPDAT;
X    volatile uint32_t ISPDAT;
N
N    /**
N     * ISPCMD
N     * ===================================================================================================
N     * Offset: 0x0C  ISP Command Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |ISPCMD    |ISP Command
N     * |        |          |ISP command table is shown below:
N     * |        |          |0x00 = Read.
N     * |        |          |0x04 = Read Unique ID.
N     * |        |          |0x0B = Read Company ID (0xDA).
N     * |        |          |0x21 = Program.
N     * |        |          |0x22 = Page Erase.
N     * |        |          |0x2E = Set Vector Page Re-Map.
N     */
N    __IO uint32_t ISPCMD;
X    volatile uint32_t ISPCMD;
N
N    /**
N     * ISPTRG
N     * ===================================================================================================
N     * Offset: 0x10  IISP Trigger Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP
N     * |        |          |operation is finish.
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP is in progress.     
N     */
N    __IO uint32_t ISPTRG;
X    volatile uint32_t ISPTRG;
N
N    /**
N     * DFBADR
N     * ===================================================================================================
N     * Offset: 0x14  Data Flash Base Address Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |DFBA      |Data Flash Base Address
N     * |        |          |This register indicates data flash start address.
N     * |        |          |It is a read only register.
N     * |        |          |When DFVSEN is set to 0, the data flash is shared with APROM. The data flash size is defined by user configuration and the content of this register is loaded from Config1.
N     * |        |          |When DFVSEN is set to 1, the data flash size is fixed as 4K and the start address can be read from this register is fixed at 0x0001_F000.
N     */
N    __I  uint32_t DFBADR;
X    volatile const  uint32_t DFBADR;
N
N    /**
N     * FATCON
N     * ===================================================================================================
N     * Offset: 0x18  Flash Access Time Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |FOMSEL0   |Chip Frequency Optimization Mode Select 0 (Write Protect)
N     * |        |          |When CPU frequency is lower than 25MHz, user can modify flash access delay cycle by FOMSEL1 and FOMSEL0 to improve system performance.
N     * |        |          |00 = CPU runs up to 50MHz with zero wait cycle for continuous address read access.
N     * |        |          |01 = CPU runs up to 25MHz with zero wait cycle for random address read access.
N     * |        |          |10 = Reserved.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: Where 00 means FOMSEL1=0, FOMSEL0=0; 01 means FOMSEL1 = 0, FOMSEL0=1 and etc.
N     * |[6]     |FOMSEL1   |Chip Frequency Optimization Mode Select 1 (Write Protect)
N     * |        |          |When CPU frequency is lower than 25MHz, user can modify flash access delay cycle by FOMSEL1 and FOMSEL0 to improve system performance.
N     * |        |          |00 = CPU runs up to 50MHz with zero wait cycle for continuous address read access.
N     * |        |          |01 = CPU runs up to 25MHz with zero wait cycle for random address read access.
N     * |        |          |10 = Reserved.
N     * |        |          |11 = Reserved.
N     * |        |          |Note: Where 00 means FOMSEL1=0, FOMSEL0=0; 01 means FOMSEL1 = 0, FOMSEL0=1 and etc.
N     */
N    __IO uint32_t FATCON;
X    volatile uint32_t FATCON;
N
N    __I  uint32_t  RESERVED[9];
X    volatile const  uint32_t  RESERVED[9];
N
N    /**
N     * ISPSTA
N     * ===================================================================================================
N     * Offset: 0x40  ISP Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ISPGO     |ISP Start Trigger (Read Only)
N     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
N     * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
N     * |        |          |0 = ISP operation is finished.
N     * |        |          |1 = ISP operation is progressed.
N     * |[2:1]   |CBS       |Boot Selection Of CONFIG (Read Only)
N     * |        |          |This bit is initiated with the CBS (CONFIG0[7:6]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
N     * |        |          |00 = LDROM with IAP mode.
N     * |        |          |01 = LDROM without IAP mode.
N     * |        |          |10 = APROM with IAP mode.
N     * |        |          |11 = APROM without IAP mode.
N     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
N     * |        |          |This bit is the mirror of ISPFF (FMC_ISPCON[6]), it needs to be cleared by writing 1 to FMC_ISPCON[6] or FMC_ISPSTA[6].
N     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
N     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
N     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
N     * |        |          |(4) Destination address is illegal, such as over an available range.
N     * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
N     * |        |          |All access to 0x0000_0000~0x0000_01FF is remapped to the flash memory address {VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}
N    */
N    __IO uint32_t ISPSTA;
X    volatile uint32_t ISPSTA;
N
N} FMC_T;
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N
N/* FMC ISPCON Bit Field Definitions */
N#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC_T::ISPCON: ISPFF Position */
N#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC_T::ISPCON: ISPFF Mask */
N
N#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC_T::ISPCON: LDUEN Position */
N#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC_T::ISPCON: LDUEN Mask */
N
N#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC_T::ISPCON: CFGUEN Position */
N#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC_T::ISPCON: CFGUEN Mask */
N
N#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC_T::ISPCON: APUEN Position */
N#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC_T::ISPCON: APUEN Mask */
N
N#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC_T::ISPCON: BS Position */
N#define FMC_ISPCON_BS_Msk                       (0x1ul << FMC_ISPCON_BS_Pos)            /*!< FMC_T::ISPCON: BS Mask */
N
N#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC_T::ISPCON: ISPEN Position */
N#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC_T::ISPCON: ISPEN Mask */
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPADR_ISPADR_Pos                   0                                       /*!< FMC_T::ISPADR: ISPADR Position */
N#define FMC_ISPADR_ISPADR_Msk                   (0xFFFFFFFFul << FMC_ISPADR_ISPADR_Pos) /*!< FMC_T::ISPADR: ISPADR Mask */
N
N/* FMC ISPDAT Bit Field Definitions */
N#define FMC_ISPDAT_ISPDAT_Pos                   0                                       /*!< FMC_T::ISPDAT: ISPDAT Position */
N#define FMC_ISPDAT_ISPDAT_Msk                   (0xFFFFFFFFul << FMC_ISPDAT_ISPDAT_Pos) /*!< FMC_T::ISPDAT: ISPDAT Mask */
N
N/* FMC ISPCMD Bit Field Definitions */
N#define FMC_ISPCMD_ISPCMD_Pos                   0                                       /*!< FMC_T::ISPCMD: ISPCMD Position */
N#define FMC_ISPCMD_ISPCMD_Msk                   (0xFul << FMC_ISPCMD_ISPCMD_Pos)        /*!< FMC_T::ISPCMD: ISPCMD Mask */
N
N/* FMC ISPTRG Bit Field Definitions */
N#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC_T::ISPTRG: ISPGO Position */
N#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC_T::ISPTRG: ISPGO Mask */
N
N/* FMC DFBADR Bit Field Definitions */
N#define FMC_DFBADR_DFBA_Pos                     0                                       /*!< FMC_T::DFBADR: DFBA Position */
N#define FMC_DFBADR_DFBA_Msk                     (0xFFFFFFFFul << FMC_DFBADR_DFBA_Pos)   /*!< FMC_T::DFBADR: DFBA Mask */
N
N/* FMC FATCON Bit Field Definitions */
N#define FMC_FATCON_FOMSEL1_Pos                  6                                       /*!< FMC_T::FATCON: FOMSEL1 Position */
N#define FMC_FATCON_FOMSEL1_Msk                  (1ul << FMC_FATCON_FOMSEL1_Pos)         /*!< FMC_T::FATCON: FOMSEL1 Mask */
N
N#define FMC_FATCON_FOMSEL0_Pos                  4                                       /*!< FMC_T::FATCON: FOMSEL0 Position */
N#define FMC_FATCON_FOMSEL0_Msk                  (1ul << FMC_FATCON_FOMSEL0_Pos)         /*!< FMC_T::FATCON: FOMSEL0 Mask */
N
N/* FMC ISPSTA Bit Field Definitions */
N#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC_T::ISPSTA: VECMAP Position */
N#define FMC_ISPSTA_VECMAP_Msk                   (0xFFFul << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC_T::ISPSTA: VECMAP Mask */
N
N#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC_T::ISPSTA: ISPFF Position */
N#define FMC_ISPSTA_ISPFF_Msk                    (0x3ul << FMC_ISPSTA_ISPFF_Pos)         /*!< FMC_T::ISPSTA: ISPFF Mask */
N
N#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC_T::ISPSTA: CBS Position */
N#define FMC_ISPSTA_CBS_Msk                      (0x3ul << FMC_ISPSTA_CBS_Pos)           /*!< FMC_T::ISPSTA: CBS Mask */
N
N#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC_T::ISPSTA: ISPGO Position */
N#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC_T::ISPSTA: ISPGO Mask */
N/*@}*/ /* end of group FMC_CONST */
N/*@}*/ /* end of group FMC */
N
N
N
N
N
N/*--------------------- General Purpose I/O (GPIO) ---------------------*/
N/** @addtogroup GPIO General purpose I/O (GPIO)
N  Memory Mapped Structure for NUC131 Series General Purpose I/O
N  @{
N */
Ntypedef struct
N{
N    /**
N     * GPIOx_PMD
N     * ===================================================================================================
N     * Offset: 0x00  GPIO Port [A/B/C/D/E/F] Pin I/O Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2n+1:2n]|PMDn     |GPIOx I/O Pin[n] Mode Control
N     * |        |          |Determine each I/O mode of GPIOx pins.
N     * |        |          |00 = GPIO port [n] pin is in Input mode.
N     * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N     * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N     * |        |          |Note1:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     * |        |          |Note2:
N     * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
N     * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on.
N     * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.
N     */
N    __IO uint32_t  PMD;
X    volatile uint32_t  PMD;
N
N    /**
N     * GPIOx_OFFD
N     * ===================================================================================================
N     * Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:16] |OFFD      |GPIOx Pin[n] Digital Input Path Disable Control
N     * |        |          |Each of these bits is used to control if the digital input path of corresponding GPIO pin is disabled.
N     * |        |          |If input is analog signal, users can disable GPIO digital input path to avoid current leakage.
N     * |        |          |0 = I/O digital input path Enabled.
N     * |        |          |1 = I/O digital input path Disabled (digital input tied to low).
N     * |        |          |Note:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     */
N    __IO uint32_t  OFFD;
X    volatile uint32_t  OFFD;
N
N    /**
N     * GPIOx_DOUT
N     * ===================================================================================================
N     * Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |DOUTn     |GPIOx Pin[n] Output Value
N     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.
N     * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
N     * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode.
N     * |        |          |Note:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     */
N    __IO uint32_t  DOUT;
X    volatile uint32_t  DOUT;
N
N    /**
N     * GPIOx_DMASK
N     * ===================================================================================================
N     * Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |DMASKn    |Port [A/B/C/D/E/F] Data Output Write Mask
N     * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N     * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N     * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N     * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N     * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N     * |        |          |Note1: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT and GPIOFx_DOUT).
N     * |        |          |Note2:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     */
N    __IO uint32_t  DMASK;
X    volatile uint32_t  DMASK;
N
N    /**
N     * GPIOx_PIN
N     * ===================================================================================================
N     * Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |PINn      |Port [A/B/C/D/E/F] Pin Values
N     * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N     * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
N     * |        |          |Note:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     */
N    __I  uint32_t  PIN;
X    volatile const  uint32_t  PIN;
N
N    /**
N     * GPIOx_DBEN
N     * ===================================================================================================
N     * Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |DBENn     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N     * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
N     * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].
N     * |        |          |0 = Bit[n] de-bounce function Disabled.
N     * |        |          |1 = Bit[n] de-bounce function Enabled.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N     * |        |          |Note:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     */
N    __IO uint32_t  DBEN;
X    volatile uint32_t  DBEN;
N
N    /**
N     * GPIOA_IMD
N     * ===================================================================================================
N     * Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |IMDn      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N     * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N     * |        |          |clock and generates the interrupt.
N     * |        |          |0 = Edge trigger interrupt.
N     * |        |          |1 = Level trigger interrupt.
N     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN.
N     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N     * |        |          |Note:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     */
N    __IO uint32_t  IMD;
X    volatile uint32_t  IMD;
N
N    /**
N     * GPIOx_IEN
N     * ===================================================================================================
N     * Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |IF_ENn    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N     * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the IF_EN[n] bit to 1:
N     * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
N     * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
N     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     * |[n+16]  |IR_ENn    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N     * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N     * |        |          |Set bit to 1 also enable the pin wake-up function.
N     * |        |          |When setting the IR_EN[n] bit to 1:
N     * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
N     * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
N     * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N     * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N     * |        |          |Note:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     */
N    __IO uint32_t  IEN;
X    volatile uint32_t  IEN;
N
N    /**
N     * GPIOx_ISRC
N     * ===================================================================================================
N     * Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[n]     |ISRCn     |Port [A/B/C/D/E/F] Interrupt Source Flag
N     * |        |          |Read :
N     * |        |          |0 = No interrupt at GPIOx[n].
N     * |        |          |1 = GPIOx[n] generates an interrupt.
N     * |        |          |Write :
N     * |        |          |0= No action.
N     * |        |          |1= Clear the corresponding pending interrupt.
N     * |        |          |Note:
N     * |        |          |n = 0~15 for GPIOA/GPIOB;
N     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
N     * |        |          |n = 6, 7, 14, 15 for GPIOD;
N     * |        |          |n = 5 for GPIOE;
N     * |        |          |n = 0, 1, 4~8 for GPIOF.
N     */
N    __IO uint32_t  ISRC;
X    volatile uint32_t  ISRC;
N} GPIO_T;
N
Ntypedef struct
N{
N    /**
N     * DBNCECON
N     * ===================================================================================================
N     * Offset: 0x180  External Interrupt De-bounce Control
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |DBCLKSEL  |De-Bounce Sampling Cycle Selection
N     * |        |          |0000 = Sample interrupt input once per 1 clocks
N     * |        |          |0001 = Sample interrupt input once per 2 clocks
N     * |        |          |0010 = Sample interrupt input once per 4 clocks
N     * |        |          |0011 = Sample interrupt input once per 8 clocks
N     * |        |          |0100 = Sample interrupt input once per 16 clocks
N     * |        |          |0101 = Sample interrupt input once per 32 clocks
N     * |        |          |0110 = Sample interrupt input once per 64 clocks
N     * |        |          |0111 = Sample interrupt input once per 128 clocks
N     * |        |          |1000 = Sample interrupt input once per 256 clocks
N     * |        |          |1001 = Sample interrupt input once per 2*256 clocks
N     * |        |          |1010 = Sample interrupt input once per 4*256clocks
N     * |        |          |1011 = Sample interrupt input once per 8*256 clocks
N     * |        |          |1100 = Sample interrupt input once per 16*256 clocks
N     * |        |          |1101 = Sample interrupt input once per 32*256 clocks
N     * |        |          |1110 = Sample interrupt input once per 64*256 clocks
N     * |        |          |1111 = Sample interrupt input once per 128*256 clocks
N     * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
N     * |        |          |0 = De-bounce counter clock source is the HCLK.
N     * |        |          |1 = De-bounce counter clock source is the internal 10 kHz low speed oscillator.
N     * |[5]     |ICLK_ON   |Interrupt Clock On Mode
N     * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to 1.
N     * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
N     * |        |          |It is recommended to turn off this bit to save system power if no special application concern.
N     */
N    __IO uint32_t  DBNCECON;
X    volatile uint32_t  DBNCECON;
N} GPIO_DBNCECON_T;
N
N/** @addtogroup GPIO_CONST GPIO Bit Field Definition
N    Constant Definitions for GPIO Controller
N  @{
N */
N
N/* GPIO PMD Bit Field Definitions */
N#define GPIO_PMD_PMD15_Pos          30                                          /*!< GPIO_T::PMD: PMD15 Position */
N#define GPIO_PMD_PMD15_Msk          (0x3ul << GPIO_PMD_PMD15_Pos)               /*!< GPIO_T::PMD: PMD15 Mask */
N
N#define GPIO_PMD_PMD14_Pos          28                                          /*!< GPIO_T::PMD: PMD14 Position */
N#define GPIO_PMD_PMD14_Msk          (0x3ul << GPIO_PMD_PMD14_Pos)               /*!< GPIO_T::PMD: PMD14 Mask */
N
N#define GPIO_PMD_PMD13_Pos          26                                          /*!< GPIO_T::PMD: PMD13 Position */
N#define GPIO_PMD_PMD13_Msk          (0x3ul << GPIO_PMD_PMD13_Pos)               /*!< GPIO_T::PMD: PMD13 Mask */
N
N#define GPIO_PMD_PMD12_Pos          24                                          /*!< GPIO_T::PMD: PMD12 Position */
N#define GPIO_PMD_PMD12_Msk          (0x3ul << GPIO_PMD_PMD12_Pos)               /*!< GPIO_T::PMD: PMD12 Mask */
N
N#define GPIO_PMD_PMD11_Pos          22                                          /*!< GPIO_T::PMD: PMD11 Position */
N#define GPIO_PMD_PMD11_Msk          (0x3ul << GPIO_PMD_PMD11_Pos)               /*!< GPIO_T::PMD: PMD11 Mask */
N
N#define GPIO_PMD_PMD10_Pos          20                                          /*!< GPIO_T::PMD: PMD10 Position */
N#define GPIO_PMD_PMD10_Msk          (0x3ul << GPIO_PMD_PMD10_Pos)               /*!< GPIO_T::PMD: PMD10 Mask */
N
N#define GPIO_PMD_PMD9_Pos           18                                          /*!< GPIO_T::PMD: PMD9 Position */
N#define GPIO_PMD_PMD9_Msk           (0x3ul << GPIO_PMD_PMD9_Pos)                /*!< GPIO_T::PMD: PMD9 Mask */
N
N#define GPIO_PMD_PMD8_Pos           16                                          /*!< GPIO_T::PMD: PMD8 Position */
N#define GPIO_PMD_PMD8_Msk           (0x3ul << GPIO_PMD_PMD8_Pos)                /*!< GPIO_T::PMD: PMD8 Mask */
N
N#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO_T::PMD: PMD7 Position */
N#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO_T::PMD: PMD7 Mask */
N
N#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO_T::PMD: PMD6 Position */
N#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO_T::PMD: PMD6 Mask */
N
N#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO_T::PMD: PMD5 Position */
N#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO_T::PMD: PMD5 Mask */
N
N#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO_T::PMD: PMD4 Position */
N#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO_T::PMD: PMD4 Mask */
N
N#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO_T::PMD: PMD3 Position */
N#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO_T::PMD: PMD3 Mask */
N
N#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO_T::PMD: PMD2 Position */
N#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO_T::PMD: PMD2 Mask */
N
N#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO_T::PMD: PMD1 Position */
N#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO_T::PMD: PMD1 Mask */
N
N#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO_T::PMD: PMD0 Position */
N#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO_T::PMD: PMD0 Mask */
N
N/* GPIO OFFD Bit Field Definitions */
N#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO_T::OFFD: OFFD Position */
N#define GPIO_OFFD_OFFD_Msk          (0xFFFFul << GPIO_OFFD_OFFD_Pos)            /*!< GPIO_T::OFFD: OFFD Mask */
N
N/* GPIO DOUT Bit Field Definitions */
N#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO_T::DOUT: DOUT Position */
N#define GPIO_DOUT_DOUT_Msk          (0xFFFFul << GPIO_DOUT_DOUT_Pos)            /*!< GPIO_T::DOUT: DOUT Mask */
N
N/* GPIO DMASK Bit Field Definitions */
N#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO_T::DMASK: DMASK Position */
N#define GPIO_DMASK_DMASK_Msk        (0xFFFFul << GPIO_DMASK_DMASK_Pos)          /*!< GPIO_T::DMASK: DMASK Mask */
N
N/* GPIO PIN Bit Field Definitions */
N#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO_T::PIN: PIN Position */
N#define GPIO_PIN_PIN_Msk            (0xFFFFul << GPIO_PIN_PIN_Pos)              /*!< GPIO_T::PIN: PIN Mask */
N
N/* GPIO DBEN Bit Field Definitions */
N#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO_T::DBEN: DBEN Position */
N#define GPIO_DBEN_DBEN_Msk          (0xFFFFul << GPIO_DBEN_DBEN_Pos)            /*!< GPIO_T::DBEN: DBEN Mask */
N
N/* GPIO IMD Bit Field Definitions */
N#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO_T::IMD: IMD Position */
N#define GPIO_IMD_IMD_Msk            (0xFFFFul << GPIO_IMD_IMD_Pos)              /*!< GPIO_T::IMD: IMD Mask */
N
N/* GPIO IEN Bit Field Definitions */
N#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO_T::IEN: IR_EN Position */
N#define GPIO_IEN_IR_EN_Msk          (0xFFFFul << GPIO_IEN_IR_EN_Pos)            /*!< GPIO_T::IEN: IR_EN Mask */
N
N#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO_T::IEN: IF_EN Position */
N#define GPIO_IEN_IF_EN_Msk          (0xFFFFul << GPIO_IEN_IF_EN_Pos)            /*!< GPIO_T::IEN: IF_EN Mask */
N
N/* GPIO ISRC Bit Field Definitions */
N#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO_T::ISRC: ISRC Position */
N#define GPIO_ISRC_ISRC_Msk          (0xFFFFul << GPIO_ISRC_ISRC_Pos)            /*!< GPIO_T::ISRC: ISRC Mask */
N
N/* GPIO DBNCECON Bit Field Definitions */
N#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO_T::DBNCECON: ICLK_ON  Position */
N#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO_T::DBNCECON: ICLK_ON  Mask */
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO_T::DBNCECON: DBCLKSRC Position */
N#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO_T::DBNCECON: DBCLKSRC Mask */
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO_T::DBNCECON: DBCLKSEL Position */
N#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO_T::DBNCECON: DBCLKSEL Mask */
N/*@}*/ /* end of group GPIO_CONST */
N/*@}*/ /* end of group NUC131_GPIO */
N
N
N
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller (I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
Ntypedef struct
N{
N    /**
N     * I2CON
N     * ===================================================================================================
N     * Offset: 0x00  I2C Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |AA        |Assert Acknowledge Control
N     * |        |          |When AA = 0 prior to address or data received, a Not acknowledged (high level to I2Cn_SDA) will be returned during the acknowledge clock pulse on the I2Cn_SCL line.     
N     * |        |          |When AA = 1 prior to address or data received, an acknowledged (low level to I2Cn_SDA) will be returned during the acknowledge clock pulse on the I2Cn_SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter.
N     * |[3]     |SI        |I2C Interrupt Flag
N     * |        |          |When a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested.
N     * |        |          |SI must be cleared by software.
N     * |        |          |Clear SI by writing 1 to this bit.
N     * |[4]     |STO       |I2C STOP Control
N     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically.
N     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode.
N     * |        |          |This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
N     * |[5]     |STA       |I2C START Control
N     * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
N     * |[6]     |ENS1      |I2C Controller Enable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |Set to enable I2C serial function controller.
N     * |        |          |When ENS1=1 the I2C serial function enables.
N     * |        |          |The multi-function pin function of I2Cn_SDA and I2Cn_SCL must set to I2C function first.
N     * |[7]     |EI        |Enable Interrupt
N     * |        |          |0 = I2C interrupt Disabled.
N     * |        |          |1 = I2C interrupt Enabled.
N     */
N    __IO uint32_t I2CON;
X    volatile uint32_t I2CON;
N
N    /**
N     * I2CADDR0
N     * ===================================================================================================
N     * Offset: 0x04  I2C Slave Address Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     */
N    __IO uint32_t I2CADDR0;
X    volatile uint32_t I2CADDR0;
N
N    /**
N     * I2CDAT
N     * ===================================================================================================
N     * Offset: 0x08  I2C Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CDAT    |I2C Data Register
N     * |        |          |Bit [7:0] is located with the 8-bit transferred data of I2C serial port.
N     */
N    __IO uint32_t I2CDAT;
X    volatile uint32_t I2CDAT;
N
N    /**
N     * I2CSTATUS
N     * ===================================================================================================
N     * Offset: 0x0C  I2C Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CSTATUS |I2C Status Register
N     * |        |          |The status register of I2C:
N     * |        |          |There are 26 possible status codes.
N     * |        |          |When I2CSTATUS contains F8H, no serial interrupt is requested.
N     * |        |          |All other I2CSTATUS values correspond to defined I2C states.
N     * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
N     * |        |          |A valid status code is present in I2CSTATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.
N     * |        |          |In addition, states 00H stands for a Bus Error.
N     * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
N     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
N     */
N    __I  uint32_t I2CSTATUS;
X    volatile const  uint32_t I2CSTATUS;
N
N    /**
N     * I2CLK
N     * ===================================================================================================
N     * Offset: 0x10  I2C Clock Divided Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |I2CLK     |I2C Clock Divided Register
N     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4x (I2CLK+1)).
N     * |        |          |Note: The minimum value of I2CLK is 4.
N     */
N    __IO uint32_t I2CLK;
X    volatile uint32_t I2CLK;
N
N    /**
N     * I2CTOC
N     * ===================================================================================================
N     * Offset: 0x14  I2C Time-out Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Time-out Flag
N     * |        |          |This bit is set by H/W when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (EI) is set to 1.
N     * |        |          |Note: Write 1 to clear this bit.
N     * |[1]     |DIV4      |Time-out Counter Input Clock Divided by 4
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |When Enabled, The time-out period is extend 4 times.
N     * |[2]     |ENTI      |Time-out Counter Enable/Disable
N     * |        |          |0 = Disabled.
N     * |        |          |1 = Enabled.
N     * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
N     * |        |          |Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
N     */
N    __IO uint32_t I2CTOC;
X    volatile uint32_t I2CTOC;
N
N    /**
N     * I2CADDR1
N     * ===================================================================================================
N     * Offset: 0x18  I2C Slave Address Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     */
N    __IO uint32_t I2CADDR1;
X    volatile uint32_t I2CADDR1;
N
N    /**
N     * I2CADDR2
N     * ===================================================================================================
N     * Offset: 0x1C  I2C Slave Address Register2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     */
N    __IO uint32_t I2CADDR2;
X    volatile uint32_t I2CADDR2;
N
N    /**
N     * I2CADDR3
N     * ===================================================================================================
N     * Offset: 0x20  I2C Slave Address Register3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GC        |General Call Function
N     * |        |          |0 = General Call Function Disabled.
N     * |        |          |1 = General Call Function Enabled.
N     * |[7:1]   |I2CADDR   |I2C Address Register
N     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N     * |        |          |The I2C hardware will react if either of the address is matched.
N     */
N    __IO uint32_t I2CADDR3;
X    volatile uint32_t I2CADDR3;
N
N    /**
N     * I2CADM0
N     * ===================================================================================================
N     * Offset: 0x24  I2C Slave Address Mask Register0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2CADM    |I2C Address Mask Register
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     */
N    __IO uint32_t I2CADM0;
X    volatile uint32_t I2CADM0;
N
N    /**
N     * I2CADM1
N     * ===================================================================================================
N     * Offset: 0x28  I2C Slave Address Mask Register1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2CADM    |I2C Address Mask Register
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     */
N    __IO uint32_t I2CADM1;
X    volatile uint32_t I2CADM1;
N
N    /**
N     * I2CADM2
N     * ===================================================================================================
N     * Offset: 0x2C  I2C Slave Address Mask Register2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2CADM    |I2C Address Mask Register
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     */
N    __IO uint32_t I2CADM2;
X    volatile uint32_t I2CADM2;
N
N    /**
N     * I2CADM3
N     * ===================================================================================================
N     * Offset: 0x30  I2C Slave Address Mask Register3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:1]   |I2CADM    |I2C Address Mask Register
N     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
N     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
N     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
N     */
N    __IO uint32_t I2CADM3;
X    volatile uint32_t I2CADM3;
N
N    /**
N     * RESERVED0
N     * ===================================================================================================
N     *
N     * ---------------------------------------------------------------------------------------------------
N     */
N    uint32_t RESERVED0[2];
N
N    /**
N     * I2CWKUPCON
N     * ===================================================================================================
N     * Offset: 0x3C  I2C Wake-up Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKUPEN    |I2C Wake-up Enable
N     * |        |          |0 = I2C wake-up function Disabled.
N     * |        |          |1 = I2C wake-up function Enabled.
N     */
N    __IO uint32_t I2CWKUPCON;
X    volatile uint32_t I2CWKUPCON;
N
N    /**
N     * I2CWKUPSTS
N     * ===================================================================================================
N     * Offset: 0x40  I2C Wake-up Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WKUPIF    |I2C Wake-up Flag
N     * |        |          |0 = Chip is not woken-up from Power-down mode by I2C.
N     * |        |          |1 = Chip is woken-up from Power-down mode by I2C.
N     * |        |          |Note: Software can write 1 to clear this bit.
N     */
N    __IO uint32_t I2CWKUPSTS;
X    volatile uint32_t I2CWKUPSTS;
N} I2C_T;
N
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N
N/* I2C I2CON Bit Field Definitions */
N#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C_T::I2CON: EI Position */
N#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C_T::I2CON: EI Mask */
N
N#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C_T::I2CON: ENS1 Position */
N#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C_T::I2CON: ENS1 Mask */
N
N#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C_T::I2CON: STA Position */
N#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C_T::I2CON: STA Mask */
N
N#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C_T::I2CON: STO Position */
N#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C_T::I2CON: STO Mask */
N
N#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C_T::I2CON: SI Position */
N#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C_T::I2CON: SI Mask */
N
N#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C_T::I2CON: AA Position */
N#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C_T::I2CON: AA Mask */
N
N/* I2C I2CADDR Bit Field Definitions */
N#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C_T::I2CADDR0: I2CADDR Position */
N#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C_T::I2CADDR0: I2CADDR Mask */
N
N#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C_T::I2CADDR0: GC Position */
N#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C_T::I2CADDR0: GC Mask */
N
N/* I2C I2CDAT Bit Field Definitions */
N#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C_T::I2CDAT: I2CDAT Position */
N#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C_T::I2CDAT: I2CDAT Mask */
N
N/* I2C I2CSTATUS Bit Field Definitions */
N#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C_T::I2CSTATUS: I2CSTATUS Position */
N#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C_T::I2CSTATUS: I2CSTATUS Mask */
N
N/* I2C I2CLK Bit Field Definitions */
N#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C_T::I2CLK: I2CLK Position */
N#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C_T::I2CLK: I2CLK Mask */
N
N/* I2C I2CTOC Bit Field Definitions */
N#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C_T::I2CTOC: ENTI Position */
N#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C_T::I2CTOC: ENTI Mask */
N
N#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C_T::I2CTOC: DIV4 Position */
N#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C_T::I2CTOC: DIV4 Mask */
N
N#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C_T::I2CTOC: TIF Position */
N#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C_T::I2CTOC: TIF Mask */
N
N/* I2C I2CADM Bit Field Definitions */
N#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C_T::I2CADM0: I2CADM Position */
N#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C_T::I2CADM0: I2CADM Mask */
N
N/* I2C I2CWKUPCON Bit Field Definitions */
N#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C_T::I2CWKUPCON: WKUPEN Position */
N#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C_T::I2CWKUPCON: WKUPEN Mask */
N
N/* I2C I2CWKUPSTS Bit Field Definitions */
N#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C_T::I2CWKUPSTS: WKUPIF Position */
N#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C_T::I2CWKUPSTS: WKUPIF Mask */
N/*@}*/ /* end of group I2C_CONST */
N/*@}*/ /* end of group I2C */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller (PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
Ntypedef struct
N{
N    /**
N     * CTL0
N     * ===================================================================================================
N     * Offset: 0x00  PWM Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CTRLDn    |Center Re-Load
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period.
N     * |        |          |CMPDAT will load to CMPBUF at the center point of a period.
N     * |[21:16] |IMMLDENn  |Immediately Load Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PERIOD will load to PBUF at the end point of each period.
N     * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
N     * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
N     * |        |          |Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
N     * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
N     * |        |          |If counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
N     * |        |          |0 = ICE debug mode counter halt disable.
N     * |        |          |1 = ICE debug mode counter halt enable.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgment effects PWM output.
N     * |        |          |PWM pin will be forced as tri-state while ICE debug mode acknowledged.
N     * |        |          |1 = ICE debug mode acknowledgment disabled.
N     * |        |          |PWM pin will keep output no matter ICE debug mode acknowledged or not.
N     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
N     */
N    __IO uint32_t CTL0;
X    volatile uint32_t CTL0;
N
N    /**
N     * CTL1
N     * ===================================================================================================
N     * Offset: 0x04  PWM Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |CNTTYPE0  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[5:4]   |CNTTYPE2  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[9:8]   |CNTTYPE4  |PWM Counter Behavior Type
N     * |        |          |Each bit n controls corresponding PWM channel n.
N     * |        |          |00 = Up counter type (supports in capture mode).
N     * |        |          |01 = Down count type (supports in capture mode).
N     * |        |          |10 = Up-down counter type.
N     * |        |          |11 = Reserved.
N     * |[26:24] |OUTMODEn  |PWM Output Mode
N     * |        |          |Each bit n controls the output mode of corresponding PWM channel n.
N     * |        |          |0 = PWM independent mode.
N     * |        |          |1 = PWM complementary mode.
N     * |        |          |Note: When operating in group function, these bits must all set to the same mode.
N     */
N    __IO uint32_t CTL1;
X    volatile uint32_t CTL1;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED0
N     * ===================================================================================================
N     * Offset: 0x0008 ~ 0x000C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED0[2];
X    volatile const  uint32_t RESERVED0[2];
N    /**
N      @endcond
N     */
N
N
N    /**
N     * CLKSRC
N     * ===================================================================================================
N     * Offset: 0x10  PWM Clock Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |ECLKSRC0  |PWM_CH01 External Clock Source Select
N     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N     * |        |          |001 = TIMER0 overflow.
N     * |        |          |010 = TIMER1 overflow.
N     * |        |          |011 = TIMER2 overflow.
N     * |        |          |100 = TIMER3 overflow.
N     * |        |          |Others = Reserved.
N     * |[10:8]  |ECLKSRC2  |PWM_CH23 External Clock Source Select
N     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N     * |        |          |001 = TIMER0 overflow.
N     * |        |          |010 = TIMER1 overflow.
N     * |        |          |011 = TIMER2 overflow.
N     * |        |          |100 = TIMER3 overflow.
N     * |        |          |Others = Reserved.
N     * |[18:16] |ECLKSRC4  |PWM_CH45 External Clock Source Select
N     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
N     * |        |          |001 = TIMER0 overflow.
N     * |        |          |010 = TIMER1 overflow.
N     * |        |          |011 = TIMER2 overflow.
N     * |        |          |100 = TIMER3 overflow.
N     * |        |          |Others = Reserved.
N     */
N    __IO uint32_t CLKSRC;
X    volatile uint32_t CLKSRC;
N
N    /**
N     * CLKPSC0_1
N     * ===================================================================================================
N     * Offset: 0x14  PWM Clock Pre-scale Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
N     * |        |          |The clock of PWM counter is decided by clock prescaler.
N     * |        |          |Each PWM pair share one PWM counter clock prescaler.
N     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N     */
N    __IO uint32_t CLKPSC0_1;
X    volatile uint32_t CLKPSC0_1;
N
N    /**
N     * CLKPSC2_3
N     * ===================================================================================================
N     * Offset: 0x18  PWM Clock Pre-scale Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
N     * |        |          |The clock of PWM counter is decided by clock prescaler.
N     * |        |          |Each PWM pair share one PWM counter clock prescaler.
N     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N     */
N    __IO uint32_t CLKPSC2_3;
X    volatile uint32_t CLKPSC2_3;
N
N    /**
N     * CLKPSC4_5
N     * ===================================================================================================
N     * Offset: 0x1C  PWM Clock Pre-scale Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
N     * |        |          |The clock of PWM counter is decided by clock prescaler.
N     * |        |          |Each PWM pair share one PWM counter clock prescaler.
N     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
N     */
N    __IO uint32_t CLKPSC4_5;
X    volatile uint32_t CLKPSC4_5;
N
N    /**
N     * CNTEN
N     * ===================================================================================================
N     * Offset: 0x20  PWM Counter Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTEN0    |PWM Counter Enable 0
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     * |[2]     |CNTEN2    |PWM Counter Enable 2
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     * |[4]     |CNTEN0    |PWM Counter Enable 4
N     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
N     * |        |          |1 = PWM Counter and clock prescaler Start Running.
N     */
N    __IO uint32_t CNTEN;
X    volatile uint32_t CNTEN;
N
N    /**
N     * CNTCLR
N     * ===================================================================================================
N     * Offset: 0x24  PWM Clear Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTCLR0   |Clear PWM Counter Control Bit 0
N     * |        |          |It is automatically cleared by hardware.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0000H.
N     * |[2]     |CNTCLR2   |Clear PWM Counter Control Bit 2
N     * |        |          |It is automatically cleared by hardware.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0000H.
N     * |[4]     |CNTCLR4   |Clear PWM Counter Control Bit 4
N     * |        |          |It is automatically cleared by hardware.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear 16-bit PWM counter to 0000H.
N     */
N    __IO uint32_t CNTCLR;
X    volatile uint32_t CNTCLR;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED1
N     * ===================================================================================================
N     * Offset: 0x0028 ~ 0x002C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED1[2];
X    volatile const  uint32_t RESERVED1[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * PERIOD0, 2, 4
N     * ===================================================================================================
N     * Offset: 0x30, 0x38, 0x40  PWM Period Register 0, 2, 4 (offset: 0x34, 0x3C, 0x44 are reserved)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PERIOD    |PWM Period Register
N     * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
N     * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
N     * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
N     * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
N     * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
N     */
N    __IO uint32_t PERIOD[6];
X    volatile uint32_t PERIOD[6];
N
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED2
N     * ===================================================================================================
N     * Offset: 0x0048 ~ 0x004C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED2[2];
X    volatile const  uint32_t RESERVED2[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * CMPDAT0~5
N     * ===================================================================================================
N     * Offset: 0x50~0x64  PWM Comparator Register 0~5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMP       |PWM Comparator Register
N     * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger ADC.
N     * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
N     * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5
N     * |        |          |denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
N     */
N    __IO uint32_t CMPDAT[6];
X    volatile uint32_t CMPDAT[6];
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED3
N     * ===================================================================================================
N     * Offset: 0x0068 ~ 0x006C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED3[2];
X    volatile const  uint32_t RESERVED3[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * DTCTL0_1
N     * ===================================================================================================
N     * Offset: 0x70  PWM Dead-Time Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
N     * |        |          |The dead-time can be calculated from the following formula:
N     * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3)
N     * |        |          |(PWM_CH4, PWM_CH5) (Write Protect)
N     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled. If
N     * |        |          |dead-time insertion is inactive, the outputs of pin pair are complementary
N     * |        |          |without any delay.
N     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect)
N     * |        |          |0 = Dead-time clock source from PWM_CLK.
N     * |        |          |1 = Dead-time clock source from prescaler output.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     */
N    __IO uint32_t DTCTL0_1;
X    volatile uint32_t DTCTL0_1;
N
N    /**
N     * DTCTL2_3
N     * ===================================================================================================
N     * Offset: 0x74  PWM Dead-Time Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
N     * |        |          |The dead-time can be calculated from the following formula:
N     * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3)
N     * |        |          |(PWM_CH4, PWM_CH5) (Write Protect)
N     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled. If
N     * |        |          |dead-time insertion is inactive, the outputs of pin pair are complementary
N     * |        |          |without any delay.
N     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect)
N     * |        |          |0 = Dead-time clock source from PWM_CLK.
N     * |        |          |1 = Dead-time clock source from prescaler output.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     */
N    __IO uint32_t DTCTL2_3;
X    volatile uint32_t DTCTL2_3;
N
N    /**
N     * DTCTL4_5
N     * ===================================================================================================
N     * Offset: 0x78  PWM Dead-Time Control Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
N     * |        |          |The dead-time can be calculated from the following formula:
N     * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3)
N     * |        |          |(PWM_CH4, PWM_CH5) (Write Protect)
N     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled. If
N     * |        |          |dead- time insertion is inactive, the outputs of pin pair are complementary
N     * |        |          |without any delay.
N     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
N     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect)
N     * |        |          |0 = Dead-time clock source from PWM_CLK.
N     * |        |          |1 = Dead-time clock source from prescaler output.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     */
N    __IO uint32_t DTCTL4_5;
X    volatile uint32_t DTCTL4_5;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED4
N     * ===================================================================================================
N     * Offset: 0x007C ~ 0x008C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED4[5];
X    volatile const  uint32_t RESERVED4[5];
N    /**
N     * @endcond
N     */
N
N    /**
N     * CNT0, 2, 4
N     * ===================================================================================================
N     * Offset: 0x90, 0x98, 0xA0  PWM Counter Register 0, 2, 4 (offset: 0x94, 0x9C, 0xA4 are reserved)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CNT       |PWM Data Register (Read Only)
N     * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
N     * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
N     * |        |          |0 = Counter is Down count.
N     * |        |          |1 = Counter is UP count.
N     */
N    __IO uint32_t CNT[6];
X    volatile uint32_t CNT[6];
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED5
N     * ===================================================================================================
N     * Offset: 0x00A8 ~ 0x00AC
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED5[2];
X    volatile const  uint32_t RESERVED5[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * WGCTL0
N     * ===================================================================================================
N     * Offset: 0xB0  PWM Generation Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |ZPCTLn    |PWM Zero Point Control
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM zero point output Low.
N     * |        |          |10 = PWM zero point output High.
N     * |        |          |11 = PWM zero point output Toggle.
N     * |        |          |PWM can control output level when PWM counter count to zero.
N     * |[27:16] |PRDPCTLn  |PWM Period (Center) Point Control
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM period (center) point output Low.
N     * |        |          |10 = PWM period (center) point output High.
N     * |        |          |11 = PWM period (center) point output Toggle.
N     * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
N     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
N     */
N    __IO uint32_t WGCTL0;
X    volatile uint32_t WGCTL0;
N
N    /**
N     * WGCTL1
N     * ===================================================================================================
N     * Offset: 0xB4  PWM Generation Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[11:0]  |CMPUCTLn  |PWM Compare Up Point Control
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare up point output Low.
N     * |        |          |10 = PWM compare up point output High.
N     * |        |          |11 = PWM compare up point output Toggle.
N     * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
N     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
N     * |[27:16] |CMPDCTLn  |PWM Compare Down Point Control
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |00 = Do nothing.
N     * |        |          |01 = PWM compare down point output Low.
N     * |        |          |10 = PWM compare down point output High.
N     * |        |          |11 = PWM compare down point output Toggle.
N     * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
N     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
N     */
N    __IO uint32_t WGCTL1;
X    volatile uint32_t WGCTL1;
N
N    /**
N     * MSKEN
N     * ===================================================================================================
N     * Offset: 0xB8  PWM Mask Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MSKENn    |PWM Mask Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |The PWM output signal will be masked when this bit is enabled.
N     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
N     * |        |          |0 = PWM output signal is non-masked.
N     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
N     */
N    __IO uint32_t MSKEN;
X    volatile uint32_t MSKEN;
N
N    /**
N     * MSK
N     * ===================================================================================================
N     * Offset: 0xBC  PWM Mask Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |MSKDATn   |PWM Mask Data Bit
N     * |        |          |This data bit control the state of PWMn output pin, if corresponding mask function is enabled.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Output logic low to PWMn.
N     * |        |          |1 = Output logic high to PWMn.
N     */
N    __IO uint32_t MSK;
X    volatile uint32_t MSK;
N
N    /**
N     * BNF
N     * ===================================================================================================
N     * Offset: 0xC0  PWM Brake Noise Filter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRK0FEN   |PWM Brake 0 Noise Filter Enable
N     * |        |          |0 = Noise filter of PWM Brake 0 Disabled.
N     * |        |          |1 = Noise filter of PWM Brake 0 Enabled.
N     * |[3:1]   |BRK0FCS   |Brake 0 Edge Detector Filter Clock Selection
N     * |        |          |000 = Filter clock = HCLK.
N     * |        |          |001 = Filter clock = HCLK/2.
N     * |        |          |010 = Filter clock = HCLK/4.
N     * |        |          |011 = Filter clock = HCLK/8.
N     * |        |          |100 = Filter clock = HCLK/16.
N     * |        |          |101 = Filter clock = HCLK/32.
N     * |        |          |110 = Filter clock = HCLK/64.
N     * |        |          |111 = Filter clock = HCLK/128.
N     * |[6:4]   |BRK0FCNT  |Brake 0 Edge Detector Filter Count
N     * |        |          |The register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.
N     * |[7]     |BRK0PINV  |Brake 0 Pin Inverse
N     * |        |          |0 = The state of pin PWMx_BRAKE0 is passed to the negative edge detector.
N     * |        |          |1 = The inverted state of pin PWMx_BRAKE10 is passed to the negative edge detector.
N     * |[8]     |BRK1FEN   |PWM Brake 1 Noise Filter Enable
N     * |        |          |0 = Noise filter of PWM Brake 1 Disabled.
N     * |        |          |1 = Noise filter of PWM Brake 1 Enabled.
N     * |[11:9]  |BRK1FCS   |Brake 1 Edge Detector Filter Clock Selection
N     * |        |          |000 = Filter clock = HCLK.
N     * |        |          |001 = Filter clock = HCLK/2.
N     * |        |          |010 = Filter clock = HCLK/4.
N     * |        |          |011 = Filter clock = HCLK/8.
N     * |        |          |100 = Filter clock = HCLK/16.
N     * |        |          |101 = Filter clock = HCLK/32.
N     * |        |          |110 = Filter clock = HCLK/64.
N     * |        |          |111 = Filter clock = HCLK/128.
N     * |[14:12] |BRK1FCNT  |Brake 1 Edge Detector Filter Count
N     * |        |          |The register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.
N     * |[15]    |BRK1PINV  |Brake 1 Pin Inverse
N     * |        |          |0 = The state of pin PWMx_BRAKE1 is passed to the negative edge detector.
N     * |        |          |1 = The inverted state of pin PWMx_BRAKE1 is passed to the negative edge detector.
N     * |[16]    |BK0SRC    |Brake 0 Pin Source Select
N     * |        |          |For PWM0 setting:
N     * |        |          |0 = Brake 0 pin source come from PWM0_BRAKE0.
N     * |        |          |1 = Brake 0 pin source come from PWM1_BRAKE0.
N     * |        |          |For PWM1 setting:
N     * |        |          |0 = Brake 0 pin source come from PWM1_BRAKE0.
N     * |        |          |1 = Brake 0 pin source come from PWM0_BRAKE0.
N     * |[24]    |BK1SRC    |Brake 1 Pin Source Select
N     * |        |          |For PWM0 setting:
N     * |        |          |0 = Brake 1 pin source come from PWM0_BRAKE1.
N     * |        |          |1 = Brake 1 pin source come from PWM1_BRAKE1.
N     * |        |          |For PWM1 setting:
N     * |        |          |0 = Brake 1 pin source come from PWM1_BRAKE1.
N     * |        |          |1 = Brake 1 pin source come from PWM0_BRAKE1.
N     */
N    __IO uint32_t BNF;
X    volatile uint32_t BNF;
N
N    /**
N     * FAILBRK
N     * ===================================================================================================
N     * Offset: 0xC4  PWM System Fail Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function 0 Enable
N     * |        |          |0 = Brake Function triggered by CSS detection Disabled.
N     * |        |          |1 = Brake Function triggered by CSS detection Enabled.
N     * |[1]     |BODBRKEN  |Brown-Out Detection Trigger PWM Brake Function 0 Enable
N     * |        |          |0 = Brake Function triggered by BOD Disabled.
N     * |        |          |1 = Brake Function triggered by BOD Enabled.
N     * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function 0 Enable
N     * |        |          |0 = Brake Function triggered by Core lockup detection Disabled.
N     * |        |          |1 = Brake Function triggered by Core lockup detection Enabled.
N     */
N    __IO uint32_t FAILBRK;
X    volatile uint32_t FAILBRK;
N
N    /**
N     * BRKCTL0_1
N     * ===================================================================================================
N     * Offset: 0xC8  PWM Brake Edge Detect Control Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
N     * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
N     * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[7]     |SYSEEN    |Enable System Fail As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[15]    |SYSLEN    |Enable System Fail As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
N     * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
N     * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
N     * |        |          |10 = PWM even channel output low level when level-detect brake happened.
N     * |        |          |11 = PWM even channel output high level when level-detect brake happened.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
N     * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
N     * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
N     * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
N     * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     */
N    __IO uint32_t BRKCTL0_1;
X    volatile uint32_t BRKCTL0_1;
N
N    /**
N     * PWM_BRKCTL2_3
N     * ===================================================================================================
N     * Offset: 0xCC  PWM Brake Edge Detect Control Register 2_3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
N     * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
N     * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[7]     |SYSEEN    |Enable System Fail As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[15]    |SYSLEN    |Enable System Fail As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
N     * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
N     * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
N     * |        |          |10 = PWM even channel output low level when level-detect brake happened.
N     * |        |          |11 = PWM even channel output high level when level-detect brake happened.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
N     * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
N     * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
N     * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
N     * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     */
N    __IO uint32_t BRKCTL2_3;
X    volatile uint32_t BRKCTL2_3;
N
N    /**
N     * PWM_BRKCTL4_5
N     * ===================================================================================================
N     * Offset: 0xD0  PWM Brake Edge Detect Control Register 4_5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
N     * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
N     * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[7]     |SYSEEN    |Enable System Fail As Edge-Detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
N     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[15]    |SYSLEN    |Enable System Fail As Level-Detect Brake Source (Write Protect)
N     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
N     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
N     * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
N     * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
N     * |        |          |10 = PWM even channel output low level when level-detect brake happened.
N     * |        |          |11 = PWM even channel output high level when level-detect brake happened.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
N     * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
N     * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
N     * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
N     * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     */
N    __IO uint32_t BRKCTL4_5;
X    volatile uint32_t BRKCTL4_5;
N
N    /**
N     * POLCTL
N     * ===================================================================================================
N     * Offset: 0xD4  PWM Pin Polar Inverse Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |PINVn     |PWM PIN Polar Inverse Control
N     * |        |          |The register controls polarity state of PWM output.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM output polar inverse Disabled.
N     * |        |          |1 = PWM output polar inverse Enabled.
N     */
N    __IO uint32_t POLCTL;
X    volatile uint32_t POLCTL;
N
N    /**
N     * POEN
N     * ===================================================================================================
N     * Offset: 0xD8  PWM Output Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |POENn     |PWM Pin Output Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM pin at tri-state.
N     * |        |          |1 = PWM pin in output mode.
N     */
N    __IO uint32_t POEN;
X    volatile uint32_t POEN;
N
N    /**
N     * SWBRK
N     * ===================================================================================================
N     * Offset: 0xDC  PWM Software Brake Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2:0]   |BRKETRGn  |PWM Edge Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Each bit n controls the corresponding PWM pair n.
N     * |        |          |Write 1 to this bit will trigger Edge brake, and set BRKEIFn to 1 in PWM_INTSTS1 register.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[10:8]  |BRKLTRGn  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
N     * |        |          |Each bit n controls the corresponding PWM pair n.
N     * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn to 1 in PWM_INTSTS1 register.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     */
N    __IO uint32_t SWBRK;
X    volatile uint32_t SWBRK;
N
N    /**
N     * PWM_INTEN0
N     * ===================================================================================================
N     * Offset: 0xE0  PWM Interrupt Enable Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ZIEN0     |PWM Zero Point Interrupt Enable 0
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[2]     |ZIEN2     |PWM Zero Point Interrupt Enable 2
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[4]     |ZIEN4     |PWM Zero Point Interrupt Enable 4
N     * |        |          |0 = Zero point interrupt Disabled.
N     * |        |          |1 = Zero point interrupt Enabled.
N     * |        |          |Note: Odd channels will read always 0 at complementary mode.
N     * |[8]     |PIEN0     |PWM Period Point Interrupt Enable 0
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note: When up-down counter type period point means center point.
N     * |[10]    |PIEN2     |PWM Period Point Interrupt Enable 2
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note: When up-down counter type period point means center point.
N     * |[12]    |PIEN4     |PWM Period Point Interrupt Enable 4
N     * |        |          |0 = Period point interrupt Disabled.
N     * |        |          |1 = Period point interrupt Enabled.
N     * |        |          |Note: When up-down counter type period point means center point.
N     * |[21:16] |CMPUIENn  |PWM Compare Up Count Interrupt Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare up count interrupt Disabled.
N     * |        |          |1 = Compare up count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
N     * |[29:24] |CMPDIENn  |PWM Compare Down Count Interrupt Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Compare down count interrupt Disabled.
N     * |        |          |1 = Compare down count interrupt Enabled.
N     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
N     */
N    __IO uint32_t INTEN0;
X    volatile uint32_t INTEN0;
N
N    /**
N     * PWM_INTEN1
N     * ===================================================================================================
N     * Offset: 0xE4  PWM Interrupt Enable Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKEIEN0_1|PWM Edge-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
N     * |        |          |0 = Edge-detect Brake interrupt for channel0/1 Disabled.
N     * |        |          |1 = Edge-detect Brake interrupt for channel0/1 Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[1]     |BRKEIEN2_3|PWM Edge-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)
N     * |        |          |0 = Edge-detect Brake interrupt for channel2/3 Disabled.
N     * |        |          |1 = Edge-detect Brake interrupt for channel2/3 Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[2]     |BRKEIEN4_5|PWM Edge-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)
N     * |        |          |0 = Edge-detect Brake interrupt for channel4/5 Disabled.
N     * |        |          |1 = Edge-detect Brake interrupt for channel4/5 Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[8]     |BRKLIEN0_1|PWM Level-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
N     * |        |          |0 = Level-detect Brake interrupt for channel0/1 Disabled.
N     * |        |          |1 = Level-detect Brake interrupt for channel0/1 Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[9]     |BRKLIEN2_3|PWM Level-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)
N     * |        |          |0 = Level-detect Brake interrupt for channel2/3 Disabled.
N     * |        |          |1 = Level-detect Brake interrupt for channel2/3 Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[10]    |BRKLIEN4_5|PWM Level-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)
N     * |        |          |0 = Level-detect Brake interrupt for channel4/5 Disabled.
N     * |        |          |1 = Level-detect Brake interrupt for channel4/5 Enabled.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     */
N    __IO uint32_t INTEN1;
X    volatile uint32_t INTEN1;
N
N    /**
N     * PWM_INTSTS0
N     * ===================================================================================================
N     * Offset: 0xE8  PWM Interrupt Flag Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |ZIF0      |PWM Zero Point Interrupt Flag 0
N     * |        |          |This bit is set by hardware when PWM_CH0 counter reaches zero, software can write 1
N     * |        |          |to clear this bit to zero.
N     * |[2]     |ZIF2      |PWM Zero Point Interrupt Flag 2
N     * |        |          |This bit is set by hardware when PWM_CH2 counter reaches zero, software can write 1
N     * |        |          |to clear this bit to zero.
N     * |[4]     |ZIF4      |PWM Zero Point Interrupt Flag 4
N     * |        |          |This bit is set by hardware when PWM_CH4 counter reaches zero, software can write 1
N     * |        |          |to clear this bit to zero.
N     * |[8]     |PIF0      |PWM Period Point Interrupt Flag 0
N     * |        |          |This bit is set by hardware when PWM_CH0 counter reaches PWM_PERIOD0, software can
N     * |        |          |write 1 to clear this bit to zero.
N     * |[10]    |PIF2      |PWM Period Point Interrupt Flag 2
N     * |        |          |This bit is set by hardware when PWM_CH2 counter reaches PWM_PERIOD2, software can
N     * |        |          |write 1 to clear this bit to zero.
N     * |[12]    |PIF4      |PWM Period Point Interrupt Flag 4
N     * |        |          |This bit is set by hardware when PWM_CH4 counter reaches PWM_PERIOD4, software can write
N     * |        |          |1 to clear this bit to zero.
N     * |[21:16] |CMPUIFn   |PWM Compare Up Count Interrupt Flag
N     * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDATn, software
N     * |        |          |can clear this bit by writing 1 to it. Each bit n controls the corresponding
N     * |        |          |PWM channel n.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
N     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
N     * |[29:24] |CMPDIFn   |PWM Compare Down Count Interrupt Flag
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDATn,
N     * |        |          |software can clear this bit by writing 1 to it.
N     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
N     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
N     */
N    __IO uint32_t INTSTS0;
X    volatile uint32_t INTSTS0;
N
N    /**
N     * PWM_INTSTS1
N     * ===================================================================================================
N     * Offset: 0xEC  PWM Interrupt Flag Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BRKEIF0   |PWM Channel0 Edge-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel0 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel0 edge-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[1]     |BRKEIF1   |PWM Channel1 Edge-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel1 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel1 edge-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[2]     |BRKEIF2   |PWM Channel2 Edge-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel2 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel2 edge-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[3]     |BRKEIF3   |PWM Channel3 Edge-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel3 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel3 edge-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[4]     |BRKEIF4   |PWM Channel4 Edge-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel4 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel4 edge-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[5]     |BRKEIF5   |PWM Channel5 Edge-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel5 edge-detect brake event do not happened.
N     * |        |          |1 = When PWM channel5 edge-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[8]     |BRKLIF0   |PWM Channel0 Level-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel0 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel0 level-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[9]     |BRKLIF1   |PWM Channel1 Level-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel1 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel1 level-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[10]    |BRKLIF2   |PWM Channel2 Level-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel2 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel2 level-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[11]    |BRKLIF3   |PWM Channel3 Level-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel3 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel3 level-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[12]    |BRKLIF4   |PWM Channel4 Level-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel4 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel4 level-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
N     * |[13]    |BRKLIF5   |PWM Channel5 Level-Detect Brake Interrupt Flag (Write Protect)
N     * |        |          |0 = PWM channel5 level-detect brake event do not happened.
N     * |        |          |1 = When PWM channel5 level-detect brake event happened, this bit is set to 1,
N     * |        |          |writing 1 to clear.
N     * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
N     * |[16]    |BRKESTS0  |PWM Channel0 Edge-Detect Brake Status
N     * |        |          |0 = PWM channel0 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel0 edge-detect brake detects a falling edge of any enabled brake
N     * |        |          |source; this flag will be set to indicate the PWM channel0 at brake state,
N     * |        |          |writing 1 to clear.
N     * |[17]    |BRKESTS1  |PWM Channel1 Edge-Detect Brake Status
N     * |        |          |0 = PWM channel1 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel1 edge-detect brake detects a falling edge of any enabled brake
N     * |        |          |source; this flag will be set to indicate the PWM channel1 at brake state,
N     * |        |          |writing 1 to clear.
N     * |[18]    |BRKESTS2  |PWM Channel2 Edge-Detect Brake Status
N     * |        |          |0 = PWM channel2 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel2 edge-detect brake detects a falling edge of any enabled brake
N     * |        |          |source; this flag will be set to indicate the PWM channel2 at brake state,
N     * |        |          |writing 1 to clear.
N     * |[19]    |BRKESTS3  |PWM Channel3 Edge-Detect Brake Status
N     * |        |          |0 = PWM channel3 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel3 edge-detect brake detects a falling edge of any enabled brake
N     * |        |          |source; this flag will be set to indicate the PWM channel3 at brake state,
N     * |        |          |writing 1 to clear.
N     * |[20]    |BRKESTS4  |PWM Channel4 Edge-Detect Brake Status
N     * |        |          |0 = PWM channel4 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel4 edge-detect brake detects a falling edge of any enabled brake
N     * |        |          |source; this flag will be set to indicate the PWM channel4 at brake state,
N     * |        |          |writing 1 to clear.
N     * |[21]    |BRKESTS5  |PWM Channel5 Edge-Detect Brake Status
N     * |        |          |0 = PWM channel5 edge-detect brake state is released.
N     * |        |          |1 = When PWM channel5 edge-detect brake detects a falling edge of any enabled brake
N     * |        |          |source; this flag will be set to indicate the PWM channel5 at brake state,
N     * |        |          |writing 1 to clear.
N     * |[24]    |BRKLSTS0  |PWM Channel0 Level-Detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel0 level-detect brake state is released.
N     * |        |          |1 = When PWM channel0 level-detect brake detects a falling edge of any enabled
N     * |        |          |brake source; this flag will be set to indicate the PWM channel0 at brake state.
N     * |        |          |Note: This bit is read only and auto
N     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
N     * |        |          |release brake state until current PWM period finished. The PWM waveform will
N     * |        |          |start output from next full PWM period.
N     * |[25]    |BRKLSTS1  |PWM Channel1 Level-Detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel1 level-detect brake state is released.
N     * |        |          |1 = When PWM channel1 level-detect brake detects a falling edge of any enabled
N     * |        |          |brake source; this flag will be set to indicate the PWM channel1 at brake state.
N     * |        |          |Note: This bit is read only and auto
N     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
N     * |        |          |release brake state until current PWM period finished. The PWM waveform will
N     * |        |          |start output from next full PWM period.
N     * |[26]    |BRKLSTS2  |PWM Channel2 Level-Detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel2 level-detect brake state is released.
N     * |        |          |1 = When PWM channel2 level-detect brake detects a falling edge of any enabled
N     * |        |          |brake source; this flag will be set to indicate the PWM channel2 at brake
N     * |        |          |state.
N     * |        |          |Note: This bit is read only and auto
N     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
N     * |        |          |release brake state until current PWM period finished. The PWM waveform will
N     * |        |          |start output from next full PWM period.
N     * |[27]    |BRKLSTS3  |PWM Channel3 Level-Detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel3 level-detect brake state is released.
N     * |        |          |1 = When PWM channel3 level-detect brake detects a falling edge of any enabled
N     * |        |          |brake source; this flag will be set to indicate the PWM channel3 at brake
N     * |        |          |state.
N     * |        |          |Note: This bit is read only and auto
N     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
N     * |        |          |release brake state until current PWM period finished. The PWM waveform will
N     * |        |          |start output from next full PWM period.
N     * |[28]    |BRKLSTS4  |PWM Channel4 Level-Detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel4 level-detect brake state is released.
N     * |        |          |1 = When PWM channel4 level-detect brake detects a falling edge of any enabled
N     * |        |          |brake source; this flag will be set to indicate the PWM channel4 at brake
N     * |        |          |state.
N     * |        |          |Note: This bit is read only and auto
N     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
N     * |        |          |release brake state until current PWM period finished. The PWM waveform will
N     * |        |          |start output from next full PWM period.
N     * |[29]    |BRKLSTS5  |PWM Channel5 Level-Detect Brake Status (Read Only)
N     * |        |          |0 = PWM channel5 level-detect brake state is released.
N     * |        |          |1 = When PWM channel5 level-detect brake detects a falling edge of any enabled
N     * |        |          |brake source; this flag will be set to indicate the PWM channel5 at brake
N     * |        |          |state.
N     * |        |          |Note: This bit is read only and auto
N     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
N     * |        |          |release brake state until current PWM period finished. The PWM waveform will
N     * |        |          |start output from next full PWM period.
N     */
N    __IO uint32_t INTSTS1;
X    volatile uint32_t INTSTS1;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED6
N     * ===================================================================================================
N     * Offset: 0x00F0 ~ 0x00F4
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED6[2];
X    volatile const  uint32_t RESERVED6[2];
N    /**
N     * @endcond
N     */
N
N    /**
N     * PWM_ADCTS0
N     * ===================================================================================================
N     * Offset: 0xF8  PWM Trigger ADC Source Select Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |TRGSEL0   |PWM_CH0 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH0 zero point.
N     * |        |          |0001 = PWM_CH0 period point.
N     * |        |          |0010 = PWM_CH0 zero or period point.
N     * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
N     * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
N     * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[7]     |TRGEN0    |PWM_CH0 Trigger ADC Enable Bit
N     * |[11:8]  |TRGSEL1   |PWM_CH1 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH0 zero point.
N     * |        |          |0001 = PWM_CH0 period point.
N     * |        |          |0010 = PWM_CH0 zero or period point.
N     * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
N     * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
N     * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[15]    |TRGEN1    |PWM_CH1 Trigger ADC Enable Bit
N     * |[19:16] |TRGSEL2   |PWM_CH2 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH2 zero point.
N     * |        |          |0001 = PWM_CH2 period point.
N     * |        |          |0010 = PWM_CH2 zero or period point.
N     * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
N     * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
N     * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[23]    |TRGEN2    |PWM_CH2 Trigger ADC Enable Bit
N     * |[27:24] |TRGSEL3   |PWM_CH3 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH2 zero point.
N     * |        |          |0001 = PWM_CH2 period point.
N     * |        |          |0010 = PWM_CH2 zero or period point.
N     * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
N     * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
N     * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[31]    |TRGEN3    |PWM_CH3 Trigger ADC Enable Bit
N     */
N    __IO uint32_t ADCTS0;
X    volatile uint32_t ADCTS0;
N
N    /**
N     * PWM_ADCTS1
N     * ===================================================================================================
N     * Offset: 0xFC  PWM Trigger ADC Source Select Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |TRGSEL4   |PWM_CH4 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH4 zero point.
N     * |        |          |0001 = PWM_CH4 period point.
N     * |        |          |0010 = PWM_CH4 zero or period point.
N     * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
N     * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
N     * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[7]     |TRGEN4    |PWM_CH4 Trigger ADC Enable Bit
N     * |[11:8]  |TRGSEL5   |PWM_CH5 Trigger ADC Source Select
N     * |        |          |0000 = PWM_CH4 zero point.
N     * |        |          |0001 = PWM_CH4 period point.
N     * |        |          |0010 = PWM_CH4 zero or period point.
N     * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
N     * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
N     * |        |          |0101 = Reserved.
N     * |        |          |0110 = Reserved.
N     * |        |          |0111 = Reserved.
N     * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
N     * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
N     * |        |          |Others = reserved.
N     * |[15]    |TRGEN5    |PWM_CH5 Trigger ADC Enable Bit
N     */
N    __IO uint32_t ADCTS1;
X    volatile uint32_t ADCTS1;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED7
N     * ===================================================================================================
N     * Offset: 0x0100 ~ 0x010C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED7[4];
X    volatile const  uint32_t RESERVED7[4];
N    /**
N     * @endcond
N     */
N
N    /**
N     * PWM_SSCTL
N     * ===================================================================================================
N     * Offset: 0x110  PWM Synchronous Start Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SSEN0     |PWM Synchronous Start Function Enable 0
N     * |        |          |When synchronous start function is enabled, the PWM_CH0 counter enable bit (CNTEN0)
N     * |        |          |can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[2]     |SSEN2     |PWM Synchronous Start Function Enable 2
N     * |        |          |When synchronous start function is enabled, the PWM_CH2 counter enable bit (CNTEN2)
N     * |        |          |can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[4]     |SSEN4     |PWM Synchronous Start Function Enable 4
N     * |        |          |When synchronous start function is enabled, the PWM_CH4 counter enable bit (CNTEN4)
N     * |        |          |can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
N     * |        |          |0 = PWM synchronous start function Disabled.
N     * |        |          |1 = PWM synchronous start function Enabled.
N     * |[9:8]   |SSRC      |PWM Synchronous Start Source Select
N     * |        |          |00 = Synchronous start source come from PWM0.
N     * |        |          |01 = Synchronous start source come from PWM1.
N     * |        |          |10 = Synchronous start source come from BPWM0.
N     * |        |          |11 = Synchronous start source come from BPWM1.
N     */
N    __IO uint32_t SSCTL;
X    volatile uint32_t SSCTL;
N
N    /**
N     * PWM_SSTRG
N     * ===================================================================================================
N     * Offset: 0x114  PWM Synchronous Start Trigger Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTSEN    |PWM Counter Synchronous Start Enable (Write Only)
N     * |        |          |PMW counter synchronous enable function is used to make selected PWM channels
N     * |        |          |(include PWM0_CHx and PWM1_CHx) start counting at the same time.
N     * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0
N     * |        |          |to 5) if correlated PWM channel counter synchronous start function is enabled.
N     * |        |          |Note: This bit only present in PWM0_BA.
N     */
N    __IO uint32_t SSTRG;
X    volatile uint32_t SSTRG;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED8
N     * ===================================================================================================
N     * Offset: 0x0118 ~ 0x011C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED8[2];
X    volatile const  uint32_t RESERVED8[2];
N    /**
N     * @endcond
N     */
N
N
N    /**
N     * PWM_STATUS
N     * ===================================================================================================
N     * Offset: 0x120  PWM Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CNTMAX0   |Time-Base Counter 0 Equal To 0xFFFF Latched Status
N     * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1
N     * |        |          |to clear this bit.
N     * |[2]     |CNTMAX2   |Time-Base Counter 2 Equal To 0xFFFF Latched Status
N     * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1
N     * |        |          |to clear this bit.
N     * |[4]     |CNTMAX4   |Time-Base Counter 4 Equal To 0xFFFF Latched Status
N     * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
N     * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1
N     * |        |          |to clear this bit.
N     * |[21:16] |ADCTRGn   |ADC Start Of Conversion Status
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
N     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can
N     * |        |          |write 1 to clear this bit.
N     */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED9
N     * ===================================================================================================
N     * Offset: 0x0124 ~ 0x01FC
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED9[55];
X    volatile const  uint32_t RESERVED9[55];
N    /**
N     * @endcond
N     */
N
N    /**
N     * PWM_CAPINEN
N     * ===================================================================================================
N     * Offset: 0x200  PWM Capture Input Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CAPINENn  |Capture Input Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = PWM Channel capture input path Disabled. The input of PWM channel capture
N     * |        |          |function is always regarded as 0.
N     * |        |          |1 = PWM Channel capture input path Enabled. The input of PWM channel capture
N     * |        |          |function comes from correlative multifunction pin.
N     */
N    __IO uint32_t CAPINEN;
X    volatile uint32_t CAPINEN;
N
N    /**
N     * PWM_CAPCTL
N     * ===================================================================================================
N     * Offset: 0x204  PWM Capture Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CAPENn    |Capture Function Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
N     * |        |          |1 = Capture function Enabled. Capture latched the PWM counter value when detected
N     * |        |          |rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT
N     * |        |          |(Falling latch).
N     * |[13:8]  |CAPINVn   |Capture Inverter Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture source inverter Disabled.
N     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
N     * |[21:16] |RCRLDENn  |Rising Capture Reload Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Rising capture reload counter Disabled.
N     * |        |          |1 = Rising capture reload counter Enabled.
N     * |[29:24] |FCRLDENn  |Falling Capture Reload Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Falling capture reload counter Disabled.
N     * |        |          |1 = Falling capture reload counter Enabled.
N     */
N    __IO uint32_t CAPCTL;
X    volatile uint32_t CAPCTL;
N
N    /**
N     * PWM_CAPSTS
N     * ===================================================================================================
N     * Offset: 0x208  PWM Capture Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CRIFOVn   |Capture Rising Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if rising latch happened when the corresponding CAPRIF is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CAPRIF.
N     * |[13:8]  |CFIFOVn   |Capture Falling Interrupt Flag Overrun Status (Read Only)
N     * |        |          |This flag indicates if falling latch happened when the corresponding CAPFIF is 1.
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CAPFIF.
N     */
N    __IO uint32_t CAPSTS;
X    volatile uint32_t CAPSTS;
N
N    /**
N     * PWM_RCAPDAT0
N     * ===================================================================================================
N     * Offset: 0x20C  PWM Rising Capture Data Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT0;
X    volatile uint32_t RCAPDAT0;
N
N    /**
N     * PWM_FCAPDAT0
N     * ===================================================================================================
N     * Offset: 0x210  PWM Falling Capture Data Register 0
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT0;
X    volatile uint32_t FCAPDAT0;
N
N    /**
N     * PWM_RCAPDAT1
N     * ===================================================================================================
N     * Offset: 0x214  PWM Rising Capture Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT1;
X    volatile uint32_t RCAPDAT1;
N
N    /**
N     * FCAPDAT1
N     * ===================================================================================================
N     * Offset: 0x218  PWM Falling Capture Data Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT1;
X    volatile uint32_t FCAPDAT1;
N
N    /**
N     * RCAPDAT2
N     * ===================================================================================================
N     * Offset: 0x21C  PWM Rising Capture Data Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT2;
X    volatile uint32_t RCAPDAT2;
N
N    /**
N     * FCAPDAT2
N     * ===================================================================================================
N     * Offset: 0x220  PWM Falling Capture Data Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT2;
X    volatile uint32_t FCAPDAT2;
N
N    /**
N     * RCAPDAT3
N     * ===================================================================================================
N     * Offset: 0x224  PWM Rising Capture Data Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT3;
X    volatile uint32_t RCAPDAT3;
N
N    /**
N     * FCAPDAT3
N     * ===================================================================================================
N     * Offset: 0x228  PWM Falling Capture Data Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT3;
X    volatile uint32_t FCAPDAT3;
N
N    /**
N     * RCAPDAT4
N     * ===================================================================================================
N     * Offset: 0x22C  PWM Rising Capture Data Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT4;
X    volatile uint32_t RCAPDAT4;
N
N    /**
N     * FCAPDAT4
N     * ===================================================================================================
N     * Offset: 0x230  PWM Falling Capture Data Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT4;
X    volatile uint32_t FCAPDAT4;
N
N    /**
N     * RCAPDAT5
N     * ===================================================================================================
N     * Offset: 0x234  PWM Rising Capture Data Register 5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
N     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t RCAPDAT5;
X    volatile uint32_t RCAPDAT5;
N
N    /**
N     * FCAPDAT5
N     * ===================================================================================================
N     * Offset: 0x238  PWM Falling Capture Data Register 5
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
N     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
N     */
N    __IO uint32_t FCAPDAT5;
X    volatile uint32_t FCAPDAT5;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED10
N     * ===================================================================================================
N     * Offset: 0x023C ~ 0x024C
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED10[5];
X    volatile const  uint32_t RESERVED10[5];
N    /**
N     * @endcond
N     */
N
N    /**
N     * CAPIEN
N     * ===================================================================================================
N     * Offset: 0x250  PWM Capture Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CAPRIENn  |PWM Capture Rising Latch Interrupt Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture rising edge latch interrupt Disabled.
N     * |        |          |1 = Capture rising edge latch interrupt Enabled.
N     * |[13:8]  |CAPFIENn  |PWM Capture Falling Latch Interrupt Enable
N     * |        |          |Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = Capture falling edge latch interrupt Disabled.
N     * |        |          |1 = Capture falling edge latch interrupt Enabled.
N     */
N    __IO uint32_t CAPIEN;
X    volatile uint32_t CAPIEN;
N
N    /**
N     * CAPIF
N     * ===================================================================================================
N     * Offset: 0x254  PWM Capture Interrupt Flag Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |CRLIFn    |PWM Capture Rising Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture rising latch condition happened.
N     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
N     * |[13:8]  |CFLIFn    |PWM Capture Falling Latch Interrupt Flag
N     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
N     * |        |          |0 = No capture falling latch condition happened.
N     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
N     */
N    __IO uint32_t CAPIF;
X    volatile uint32_t CAPIF;
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED11
N     * ===================================================================================================
N     * Offset: 0x0258 ~ 0x0300
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED11[43];
X    volatile const  uint32_t RESERVED11[43];
N    /**
N     * @endcond
N     */
N
N    /**
N     * PBUF0, 2, 4
N     * ===================================================================================================
N     * Offset: 0x304, 0x30C, 0x314  PWM PERIOD0, 2, 4 Buffer (offset: 0x308, 0x310, 0x318 are reserved)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
N     * |        |          |Used as PERIOD active register.
N     */
N    __I uint32_t PBUF[6];
X    volatile const uint32_t PBUF[6];
N
N    /**
N     * CMPBUF0~5
N     * ===================================================================================================
N     * Offset: 0x31C~0x330  PWM CMPDAT0~5 Buffer
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
N     * |        |          |Used as CMP active register.
N     */
N    __I uint32_t CMPBUF[6];
X    volatile const uint32_t CMPBUF[6];
N
N    /**
N     * @cond HIDDEN_SYMBOLS
N     * RESERVED12
N     * ===================================================================================================
N     * Offset: 0x0334 ~ 0x0FFC
N     * ---------------------------------------------------------------------------------------------------
N     */
N    __I  uint32_t RESERVED12[819];          /*!< Offset: 0x0334 ~ 0x0FFC    Reserved*/
X    volatile const  uint32_t RESERVED12[819];           
N    /**
N     * @endcond
N     */
N
N} PWM_T;
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N
N#define PWM_CTL0_CTRLDn_Pos              (0)                                                /*!< PWM_T::CTL0: CTRLDn Position              */
N#define PWM_CTL0_CTRLDn_Msk              (0x3ful << PWM_CTL0_CTRLDn_Pos)                    /*!< PWM_T::CTL0: CTRLDn Mask                  */
N
N#define PWM_CTL0_CTRLD0_Pos              (0)                                                /*!< PWM_T::CTL0: CTRLD0 Position              */
N#define PWM_CTL0_CTRLD0_Msk              (0x1ul << PWM_CTL0_CTRLD0_Pos)                     /*!< PWM_T::CTL0: CTRLD0 Mask                  */
N
N#define PWM_CTL0_CTRLD1_Pos              (1)                                                /*!< PWM_T::CTL0: CTRLD1 Position              */
N#define PWM_CTL0_CTRLD1_Msk              (0x1ul << PWM_CTL0_CTRLD1_Pos)                     /*!< PWM_T::CTL0: CTRLD1 Mask                  */
N
N#define PWM_CTL0_CTRLD2_Pos              (2)                                                /*!< PWM_T::CTL0: CTRLD2 Position              */
N#define PWM_CTL0_CTRLD2_Msk              (0x1ul << PWM_CTL0_CTRLD2_Pos)                     /*!< PWM_T::CTL0: CTRLD2 Mask                  */
N
N#define PWM_CTL0_CTRLD3_Pos              (3)                                                /*!< PWM_T::CTL0: CTRLD3 Position              */
N#define PWM_CTL0_CTRLD3_Msk              (0x1ul << PWM_CTL0_CTRLD3_Pos)                     /*!< PWM_T::CTL0: CTRLD3 Mask                  */
N
N#define PWM_CTL0_CTRLD4_Pos              (4)                                                /*!< PWM_T::CTL0: CTRLD4 Position              */
N#define PWM_CTL0_CTRLD4_Msk              (0x1ul << PWM_CTL0_CTRLD4_Pos)                     /*!< PWM_T::CTL0: CTRLD4 Mask                  */
N
N#define PWM_CTL0_CTRLD5_Pos              (5)                                                /*!< PWM_T::CTL0: CTRLD5 Position              */
N#define PWM_CTL0_CTRLD5_Msk              (0x1ul << PWM_CTL0_CTRLD5_Pos)                     /*!< PWM_T::CTL0: CTRLD5 Mask                  */
N
N#define PWM_CTL0_IMMLDENn_Pos            (16)                                               /*!< PWM_T::CTL0: IMMLDENn Position            */
N#define PWM_CTL0_IMMLDENn_Msk            (0x3ful << PWM_CTL0_IMMLDENn_Pos)                  /*!< PWM_T::CTL0: IMMLDENn Mask                */
N
N#define PWM_CTL0_IMMLDEN0_Pos            (16)                                               /*!< PWM_T::CTL0: IMMLDEN0 Position            */
N#define PWM_CTL0_IMMLDEN0_Msk            (0x1ul << PWM_CTL0_IMMLDEN0_Pos)                   /*!< PWM_T::CTL0: IMMLDEN0 Mask                */
N
N#define PWM_CTL0_IMMLDEN1_Pos            (17)                                               /*!< PWM_T::CTL0: IMMLDEN1 Position            */
N#define PWM_CTL0_IMMLDEN1_Msk            (0x1ul << PWM_CTL0_IMMLDEN1_Pos)                   /*!< PWM_T::CTL0: IMMLDEN1 Mask                */
N
N#define PWM_CTL0_IMMLDEN2_Pos            (18)                                               /*!< PWM_T::CTL0: IMMLDEN2 Position            */
N#define PWM_CTL0_IMMLDEN2_Msk            (0x1ul << PWM_CTL0_IMMLDEN2_Pos)                   /*!< PWM_T::CTL0: IMMLDEN2 Mask                */
N
N#define PWM_CTL0_IMMLDEN3_Pos            (19)                                               /*!< PWM_T::CTL0: IMMLDEN3 Position            */
N#define PWM_CTL0_IMMLDEN3_Msk            (0x1ul << PWM_CTL0_IMMLDEN3_Pos)                   /*!< PWM_T::CTL0: IMMLDEN3 Mask                */
N
N#define PWM_CTL0_IMMLDEN4_Pos            (20)                                               /*!< PWM_T::CTL0: IMMLDEN4 Position            */
N#define PWM_CTL0_IMMLDEN4_Msk            (0x1ul << PWM_CTL0_IMMLDEN4_Pos)                   /*!< PWM_T::CTL0: IMMLDEN4 Mask                */
N
N#define PWM_CTL0_IMMLDEN5_Pos            (21)                                               /*!< PWM_T::CTL0: IMMLDEN5 Position            */
N#define PWM_CTL0_IMMLDEN5_Msk            (0x1ul << PWM_CTL0_IMMLDEN5_Pos)                   /*!< PWM_T::CTL0: IMMLDEN5 Mask                */
N
N#define PWM_CTL0_DBGHALT_Pos             (30)                                               /*!< PWM_T::CTL0: DBGHALT Position             */
N#define PWM_CTL0_DBGHALT_Msk             (0x1ul << PWM_CTL0_DBGHALT_Pos)                    /*!< PWM_T::CTL0: DBGHALT Mask                 */
N
N#define PWM_CTL0_DBGTRIOFF_Pos           (31)                                               /*!< PWM_T::CTL0: DBGTRIOFF Position           */
N#define PWM_CTL0_DBGTRIOFF_Msk           (0x1ul << PWM_CTL0_DBGTRIOFF_Pos)                  /*!< PWM_T::CTL0: DBGTRIOFF Mask               */
N
N#define PWM_CTL1_CNTTYPEn_Pos            (0)                                                /*!< PWM_T::CTL1: CNTTYPEn Position            */
N#define PWM_CTL1_CNTTYPEn_Msk            (0x333ul << PWM_CTL1_CNTTYPEn_Pos)                 /*!< PWM_T::CTL1: CNTTYPEn Mask                */
N
N#define PWM_CTL1_CNTTYPE0_Pos            (0)                                                /*!< PWM_T::CTL1: CNTTYPE0 Position            */
N#define PWM_CTL1_CNTTYPE0_Msk            (0x3ul << PWM_CTL1_CNTTYPE0_Pos)                   /*!< PWM_T::CTL1: CNTTYPE0 Mask                */
N
N#define PWM_CTL1_CNTTYPE2_Pos            (4)                                                /*!< PWM_T::CTL1: CNTTYPE2 Position            */
N#define PWM_CTL1_CNTTYPE2_Msk            (0x3ul << PWM_CTL1_CNTTYPE2_Pos)                   /*!< PWM_T::CTL1: CNTTYPE2 Mask                */
N
N#define PWM_CTL1_CNTTYPE4_Pos            (8)                                                /*!< PWM_T::CTL1: CNTTYPE4 Position            */
N#define PWM_CTL1_CNTTYPE4_Msk            (0x3ul << PWM_CTL1_CNTTYPE4_Pos)                   /*!< PWM_T::CTL1: CNTTYPE4 Mask                */
N
N#define PWM_CTL1_OUTMODEn_Pos            (24)                                               /*!< PWM_T::CTL1: OUTMODEn Position            */
N#define PWM_CTL1_OUTMODEn_Msk            (0x7ul << PWM_CTL1_OUTMODEn_Pos)                   /*!< PWM_T::CTL1: OUTMODEn Mask                */
N
N#define PWM_CTL1_OUTMODE0_Pos            (24)                                               /*!< PWM_T::CTL1: OUTMODE0 Position            */
N#define PWM_CTL1_OUTMODE0_Msk            (0x1ul << PWM_CTL1_OUTMODE0_Pos)                   /*!< PWM_T::CTL1: OUTMODE0 Mask                */
N
N#define PWM_CTL1_OUTMODE2_Pos            (25)                                               /*!< PWM_T::CTL1: OUTMODE2 Position            */
N#define PWM_CTL1_OUTMODE2_Msk            (0x1ul << PWM_CTL1_OUTMODE2_Pos)                   /*!< PWM_T::CTL1: OUTMODE2 Mask                */
N
N#define PWM_CTL1_OUTMODE4_Pos            (26)                                               /*!< PWM_T::CTL1: OUTMODE4 Position            */
N#define PWM_CTL1_OUTMODE4_Msk            (0x1ul << PWM_CTL1_OUTMODE4_Pos)                   /*!< PWM_T::CTL1: OUTMODE4 Mask                */
N
N#define PWM_CLKSRC_ECLKSRC0_Pos          (0)                                                /*!< PWM_T::CLKSRC: ECLKSRC0 Position          */
N#define PWM_CLKSRC_ECLKSRC0_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC0_Pos)                 /*!< PWM_T::CLKSRC: ECLKSRC0 Mask              */
N
N#define PWM_CLKSRC_ECLKSRC2_Pos          (8)                                                /*!< PWM_T::CLKSRC: ECLKSRC2 Position          */
N#define PWM_CLKSRC_ECLKSRC2_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC2_Pos)                 /*!< PWM_T::CLKSRC: ECLKSRC2 Mask              */
N
N#define PWM_CLKSRC_ECLKSRC4_Pos          (16)                                               /*!< PWM_T::CLKSRC: ECLKSRC4 Position          */
N#define PWM_CLKSRC_ECLKSRC4_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC4_Pos)                 /*!< PWM_T::CLKSRC: ECLKSRC4 Mask              */
N
N#define PWM_CLKPSC0_1_CLKPSC_Pos         (0)                                                /*!< PWM_T::CLKPSC0_1: CLKPSC Position         */
N#define PWM_CLKPSC0_1_CLKPSC_Msk         (0xffful << PWM_CLKPSC0_1_CLKPSC_Pos)              /*!< PWM_T::CLKPSC0_1: CLKPSC Mask             */
N
N#define PWM_CLKPSC2_3_CLKPSC_Pos         (0)                                                /*!< PWM_T::CLKPSC2_3: CLKPSC Position         */
N#define PWM_CLKPSC2_3_CLKPSC_Msk         (0xffful << PWM_CLKPSC2_3_CLKPSC_Pos)              /*!< PWM_T::CLKPSC2_3: CLKPSC Mask             */
N
N#define PWM_CLKPSC4_5_CLKPSC_Pos         (0)                                                /*!< PWM_T::CLKPSC4_5: CLKPSC Position         */
N#define PWM_CLKPSC4_5_CLKPSC_Msk         (0xffful << PWM_CLKPSC4_5_CLKPSC_Pos)              /*!< PWM_T::CLKPSC4_5: CLKPSC Mask             */
N
N#define PWM_CNTEN_CNTENn_Pos             (0)                                                /*!< PWM_T::CNTEN: CNTENn Position             */
N#define PWM_CNTEN_CNTENn_Msk             (0x15ul << PWM_CNTEN_CNTENn_Pos)                   /*!< PWM_T::CNTEN: CNTENn Mask                 */
N
N#define PWM_CNTEN_CNTEN0_Pos             (0)                                                /*!< PWM_T::CNTEN: CNTEN0 Position             */
N#define PWM_CNTEN_CNTEN0_Msk             (0x1ul << PWM_CNTEN_CNTEN0_Pos)                    /*!< PWM_T::CNTEN: CNTEN0 Mask                 */
N
N#define PWM_CNTEN_CNTEN2_Pos             (2)                                                /*!< PWM_T::CNTEN: CNTEN2 Position             */
N#define PWM_CNTEN_CNTEN2_Msk             (0x1ul << PWM_CNTEN_CNTEN2_Pos)                    /*!< PWM_T::CNTEN: CNTEN2 Mask                 */
N
N#define PWM_CNTEN_CNTEN4_Pos             (4)                                                /*!< PWM_T::CNTEN: CNTEN4 Position             */
N#define PWM_CNTEN_CNTEN4_Msk             (0x1ul << PWM_CNTEN_CNTEN4_Pos)                    /*!< PWM_T::CNTEN: CNTEN4 Mask                 */
N
N#define PWM_CNTCLR_CNTCLRn_Pos           (0)                                                /*!< PWM_T::CNTCLR: CNTCLRn Position           */
N#define PWM_CNTCLR_CNTCLRn_Msk           (0x15ul << PWM_CNTCLR_CNTCLRn_Pos)                 /*!< PWM_T::CNTCLR: CNTCLRn Mask               */
N
N#define PWM_CNTCLR_CNTCLR0_Pos           (0)                                                /*!< PWM_T::CNTCLR: CNTCLR0 Position           */
N#define PWM_CNTCLR_CNTCLR0_Msk           (0x1ul << PWM_CNTCLR_CNTCLR0_Pos)                  /*!< PWM_T::CNTCLR: CNTCLR0 Mask               */
N
N#define PWM_CNTCLR_CNTCLR2_Pos           (2)                                                /*!< PWM_T::CNTCLR: CNTCLR2 Position           */
N#define PWM_CNTCLR_CNTCLR2_Msk           (0x1ul << PWM_CNTCLR_CNTCLR2_Pos)                  /*!< PWM_T::CNTCLR: CNTCLR2 Mask               */
N
N#define PWM_CNTCLR_CNTCLR4_Pos           (4)                                                /*!< PWM_T::CNTCLR: CNTCLR4 Position           */
N#define PWM_CNTCLR_CNTCLR4_Msk           (0x1ul << PWM_CNTCLR_CNTCLR4_Pos)                  /*!< PWM_T::CNTCLR: CNTCLR4 Mask               */
N
N#define PWM_PERIOD_PERIOD_Pos            (0)                                                /*!< PWM_T::PERIOD: PERIOD Position            */
N#define PWM_PERIOD_PERIOD_Msk            (0xfffful << PWM_PERIOD_PERIOD_Pos)                /*!< PWM_T::PERIOD: PERIOD Mask                */
N
N#define PWM_CMPDAT_CMP_Pos               (0)                                                /*!< PWM_T::CMPDAT: CMP Position               */
N#define PWM_CMPDAT_CMP_Msk               (0xfffful << PWM_CMPDAT_CMP_Pos)                   /*!< PWM_T::CMPDAT: CMP Mask                   */
N
N#define PWM_DTCTL0_1_DTCNT_Pos           (0)                                                /*!< PWM_T::DTCTL0_1: DTCNT Position           */
N#define PWM_DTCTL0_1_DTCNT_Msk           (0xffful << PWM_DTCTL0_1_DTCNT_Pos)                /*!< PWM_T::DTCTL0_1: DTCNT Mask               */
N
N#define PWM_DTCTL0_1_DTEN_Pos            (16)                                               /*!< PWM_T::DTCTL0_1: DTEN Position            */
N#define PWM_DTCTL0_1_DTEN_Msk            (0x1ul << PWM_DTCTL0_1_DTEN_Pos)                   /*!< PWM_T::DTCTL0_1: DTEN Mask                */
N
N#define PWM_DTCTL0_1_DTCKSEL_Pos         (24)                                               /*!< PWM_T::DTCTL0_1: DTCKSEL Position         */
N#define PWM_DTCTL0_1_DTCKSEL_Msk         (0x1ul << PWM_DTCTL0_1_DTCKSEL_Pos)                /*!< PWM_T::DTCTL0_1: DTCKSEL Mask             */
N
N#define PWM_DTCTL2_3_DTCNT_Pos           (0)                                                /*!< PWM_T::DTCTL2_3: DTCNT Position           */
N#define PWM_DTCTL2_3_DTCNT_Msk           (0xffful << PWM_DTCTL2_3_DTCNT_Pos)                /*!< PWM_T::DTCTL2_3: DTCNT Mask               */
N
N#define PWM_DTCTL2_3_DTEN_Pos            (16)                                               /*!< PWM_T::DTCTL2_3: DTEN Position            */
N#define PWM_DTCTL2_3_DTEN_Msk            (0x1ul << PWM_DTCTL2_3_DTEN_Pos)                   /*!< PWM_T::DTCTL2_3: DTEN Mask                */
N
N#define PWM_DTCTL2_3_DTCKSEL_Pos         (24)                                               /*!< PWM_T::DTCTL2_3: DTCKSEL Position         */
N#define PWM_DTCTL2_3_DTCKSEL_Msk         (0x1ul << PWM_DTCTL2_3_DTCKSEL_Pos)                /*!< PWM_T::DTCTL2_3: DTCKSEL Mask             */
N
N#define PWM_DTCTL4_5_DTCNT_Pos           (0)                                                /*!< PWM_T::DTCTL4_5: DTCNT Position           */
N#define PWM_DTCTL4_5_DTCNT_Msk           (0xffful << PWM_DTCTL4_5_DTCNT_Pos)                /*!< PWM_T::DTCTL4_5: DTCNT Mask               */
N
N#define PWM_DTCTL4_5_DTEN_Pos            (16)                                               /*!< PWM_T::DTCTL4_5: DTEN Position            */
N#define PWM_DTCTL4_5_DTEN_Msk            (0x1ul << PWM_DTCTL4_5_DTEN_Pos)                   /*!< PWM_T::DTCTL4_5: DTEN Mask                */
N
N#define PWM_DTCTL4_5_DTCKSEL_Pos         (24)                                               /*!< PWM_T::DTCTL4_5: DTCKSEL Position         */
N#define PWM_DTCTL4_5_DTCKSEL_Msk         (0x1ul << PWM_DTCTL4_5_DTCKSEL_Pos)                /*!< PWM_T::DTCTL4_5: DTCKSEL Mask             */
N
N#define PWM_CNT_CNT_Pos                  (0)                                                /*!< PWM_T::CNT: CNT Position                  */
N#define PWM_CNT_CNT_Msk                  (0xfffful << PWM_CNT_CNT_Pos)                      /*!< PWM_T::CNT: CNT Mask                      */
N
N#define PWM_CNT_DIRF_Pos                 (16)                                               /*!< PWM_T::CNT: DIRF Position                 */
N#define PWM_CNT_DIRF_Msk                 (0x1ul << PWM_CNT_DIRF_Pos)                        /*!< PWM_T::CNT: DIRF Mask                     */
N
N#define PWM_WGCTL0_ZPCTLn_Pos            (0)                                                /*!< PWM_T::WGCTL0: ZPCTLn Position            */
N#define PWM_WGCTL0_ZPCTLn_Msk            (0xffful << PWM_WGCTL0_ZPCTLn_Pos)                 /*!< PWM_T::WGCTL0: ZPCTLn Mask                */
N
N#define PWM_WGCTL0_ZPCTL0_Pos            (0)                                                /*!< PWM_T::WGCTL0: ZPCTL0 Position            */
N#define PWM_WGCTL0_ZPCTL0_Msk            (0x3ul << PWM_WGCTL0_ZPCTL0_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL0 Mask                */
N
N#define PWM_WGCTL0_ZPCTL1_Pos            (2)                                                /*!< PWM_T::WGCTL0: ZPCTL1 Position            */
N#define PWM_WGCTL0_ZPCTL1_Msk            (0x3ul << PWM_WGCTL0_ZPCTL1_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL1 Mask                */
N
N#define PWM_WGCTL0_ZPCTL2_Pos            (4)                                                /*!< PWM_T::WGCTL0: ZPCTL2 Position            */
N#define PWM_WGCTL0_ZPCTL2_Msk            (0x3ul << PWM_WGCTL0_ZPCTL2_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL2 Mask                */
N
N#define PWM_WGCTL0_ZPCTL3_Pos            (6)                                                /*!< PWM_T::WGCTL0: ZPCTL3 Position            */
N#define PWM_WGCTL0_ZPCTL3_Msk            (0x3ul << PWM_WGCTL0_ZPCTL3_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL3 Mask                */
N
N#define PWM_WGCTL0_ZPCTL4_Pos            (8)                                                /*!< PWM_T::WGCTL0: ZPCTL4 Position            */
N#define PWM_WGCTL0_ZPCTL4_Msk            (0x3ul << PWM_WGCTL0_ZPCTL4_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL4 Mask                */
N
N#define PWM_WGCTL0_ZPCTL5_Pos            (10)                                               /*!< PWM_T::WGCTL0: ZPCTL5 Position            */
N#define PWM_WGCTL0_ZPCTL5_Msk            (0x3ul << PWM_WGCTL0_ZPCTL5_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL5 Mask                */
N
N#define PWM_WGCTL0_PRDPCTLn_Pos          (16)                                               /*!< PWM_T::WGCTL0: PRDPCTLn Position          */
N#define PWM_WGCTL0_PRDPCTLn_Msk          (0xffful << PWM_WGCTL0_PRDPCTLn_Pos)               /*!< PWM_T::WGCTL0: PRDPCTLn Mask              */
N
N#define PWM_WGCTL0_PRDPCTL0_Pos          (16)                                               /*!< PWM_T::WGCTL0: PRDPCTL0 Position          */
N#define PWM_WGCTL0_PRDPCTL0_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL0_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL0 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL1_Pos          (18)                                               /*!< PWM_T::WGCTL0: PRDPCTL1 Position          */
N#define PWM_WGCTL0_PRDPCTL1_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL1_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL1 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL2_Pos          (20)                                               /*!< PWM_T::WGCTL0: PRDPCTL2 Position          */
N#define PWM_WGCTL0_PRDPCTL2_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL2_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL2 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL3_Pos          (22)                                               /*!< PWM_T::WGCTL0: PRDPCTL3 Position          */
N#define PWM_WGCTL0_PRDPCTL3_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL3_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL3 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL4_Pos          (24)                                               /*!< PWM_T::WGCTL0: PRDPCTL4 Position          */
N#define PWM_WGCTL0_PRDPCTL4_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL4_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL4 Mask              */
N
N#define PWM_WGCTL0_PRDPCTL5_Pos          (26)                                               /*!< PWM_T::WGCTL0: PRDPCTL5 Position          */
N#define PWM_WGCTL0_PRDPCTL5_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL5_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL5 Mask              */
N
N#define PWM_WGCTL1_CMPUCTLn_Pos          (0)                                                /*!< PWM_T::WGCTL1: CMPUCTLn Position          */
N#define PWM_WGCTL1_CMPUCTLn_Msk          (0xffful << PWM_WGCTL1_CMPUCTLn_Pos)               /*!< PWM_T::WGCTL1: CMPUCTLn Mask              */
N
N#define PWM_WGCTL1_CMPUCTL0_Pos          (0)                                                /*!< PWM_T::WGCTL1: CMPUCTL0 Position          */
N#define PWM_WGCTL1_CMPUCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL0_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL0 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL1_Pos          (2)                                                /*!< PWM_T::WGCTL1: CMPUCTL1 Position          */
N#define PWM_WGCTL1_CMPUCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL1_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL1 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL2_Pos          (4)                                                /*!< PWM_T::WGCTL1: CMPUCTL2 Position          */
N#define PWM_WGCTL1_CMPUCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL2_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL2 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL3_Pos          (6)                                                /*!< PWM_T::WGCTL1: CMPUCTL3 Position          */
N#define PWM_WGCTL1_CMPUCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL3_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL3 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL4_Pos          (8)                                                /*!< PWM_T::WGCTL1: CMPUCTL4 Position          */
N#define PWM_WGCTL1_CMPUCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL4_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL4 Mask              */
N
N#define PWM_WGCTL1_CMPUCTL5_Pos          (10)                                               /*!< PWM_T::WGCTL1: CMPUCTL5 Position          */
N#define PWM_WGCTL1_CMPUCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL5_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL5 Mask              */
N
N#define PWM_WGCTL1_CMPDCTLn_Pos          (16)                                               /*!< PWM_T::WGCTL1: CMPDCTLn Position          */
N#define PWM_WGCTL1_CMPDCTLn_Msk          (0xffful << PWM_WGCTL1_CMPDCTLn_Pos)               /*!< PWM_T::WGCTL1: CMPDCTLn Mask              */
N
N#define PWM_WGCTL1_CMPDCTL0_Pos          (16)                                               /*!< PWM_T::WGCTL1: CMPDCTL0 Position          */
N#define PWM_WGCTL1_CMPDCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL0_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL0 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL1_Pos          (18)                                               /*!< PWM_T::WGCTL1: CMPDCTL1 Position          */
N#define PWM_WGCTL1_CMPDCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL1_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL1 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL2_Pos          (20)                                               /*!< PWM_T::WGCTL1: CMPDCTL2 Position          */
N#define PWM_WGCTL1_CMPDCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL2_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL2 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL3_Pos          (22)                                               /*!< PWM_T::WGCTL1: CMPDCTL3 Position          */
N#define PWM_WGCTL1_CMPDCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL3_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL3 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL4_Pos          (24)                                               /*!< PWM_T::WGCTL1: CMPDCTL4 Position          */
N#define PWM_WGCTL1_CMPDCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL4_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL4 Mask              */
N
N#define PWM_WGCTL1_CMPDCTL5_Pos          (26)                                               /*!< PWM_T::WGCTL1: CMPDCTL5 Position          */
N#define PWM_WGCTL1_CMPDCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL5_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL5 Mask              */
N
N#define PWM_MSKEN_MSKENn_Pos             (0)                                                /*!< PWM_T::MSKEN: MSKENn Position             */
N#define PWM_MSKEN_MSKENn_Msk             (0x3ful << PWM_MSKEN_MSKENn_Pos)                   /*!< PWM_T::MSKEN: MSKENn Mask                 */
N
N#define PWM_MSKEN_MSKEN0_Pos             (0)                                                /*!< PWM_T::MSKEN: MSKEN0 Position             */
N#define PWM_MSKEN_MSKEN0_Msk             (0x1ul << PWM_MSKEN_MSKEN0_Pos)                    /*!< PWM_T::MSKEN: MSKEN0 Mask                 */
N
N#define PWM_MSKEN_MSKEN1_Pos             (1)                                                /*!< PWM_T::MSKEN: MSKEN1 Position             */
N#define PWM_MSKEN_MSKEN1_Msk             (0x1ul << PWM_MSKEN_MSKEN1_Pos)                    /*!< PWM_T::MSKEN: MSKEN1 Mask                 */
N
N#define PWM_MSKEN_MSKEN2_Pos             (2)                                                /*!< PWM_T::MSKEN: MSKEN2 Position             */
N#define PWM_MSKEN_MSKEN2_Msk             (0x1ul << PWM_MSKEN_MSKEN2_Pos)                    /*!< PWM_T::MSKEN: MSKEN2 Mask                 */
N
N#define PWM_MSKEN_MSKEN3_Pos             (3)                                                /*!< PWM_T::MSKEN: MSKEN3 Position             */
N#define PWM_MSKEN_MSKEN3_Msk             (0x1ul << PWM_MSKEN_MSKEN3_Pos)                    /*!< PWM_T::MSKEN: MSKEN3 Mask                 */
N
N#define PWM_MSKEN_MSKEN4_Pos             (4)                                                /*!< PWM_T::MSKEN: MSKEN4 Position             */
N#define PWM_MSKEN_MSKEN4_Msk             (0x1ul << PWM_MSKEN_MSKEN4_Pos)                    /*!< PWM_T::MSKEN: MSKEN4 Mask                 */
N
N#define PWM_MSKEN_MSKEN5_Pos             (5)                                                /*!< PWM_T::MSKEN: MSKEN5 Position             */
N#define PWM_MSKEN_MSKEN5_Msk             (0x1ul << PWM_MSKEN_MSKEN5_Pos)                    /*!< PWM_T::MSKEN: MSKEN5 Mask                 */
N
N#define PWM_MSK_MSKDATn_Pos              (0)                                                /*!< PWM_T::MSK: MSKDATn Position              */
N#define PWM_MSK_MSKDATn_Msk              (0x3ful << PWM_MSK_MSKDATn_Pos)                    /*!< PWM_T::MSK: MSKDATn Mask                  */
N
N#define PWM_MSK_MSKDAT0_Pos              (0)                                                /*!< PWM_T::MSK: MSKDAT0 Position              */
N#define PWM_MSK_MSKDAT0_Msk              (0x1ul << PWM_MSK_MSKDAT0_Pos)                     /*!< PWM_T::MSK: MSKDAT0 Mask                  */
N
N#define PWM_MSK_MSKDAT1_Pos              (1)                                                /*!< PWM_T::MSK: MSKDAT1 Position              */
N#define PWM_MSK_MSKDAT1_Msk              (0x1ul << PWM_MSK_MSKDAT1_Pos)                     /*!< PWM_T::MSK: MSKDAT1 Mask                  */
N
N#define PWM_MSK_MSKDAT2_Pos              (2)                                                /*!< PWM_T::MSK: MSKDAT2 Position              */
N#define PWM_MSK_MSKDAT2_Msk              (0x1ul << PWM_MSK_MSKDAT2_Pos)                     /*!< PWM_T::MSK: MSKDAT2 Mask                  */
N
N#define PWM_MSK_MSKDAT3_Pos              (3)                                                /*!< PWM_T::MSK: MSKDAT3 Position              */
N#define PWM_MSK_MSKDAT3_Msk              (0x1ul << PWM_MSK_MSKDAT3_Pos)                     /*!< PWM_T::MSK: MSKDAT3 Mask                  */
N
N#define PWM_MSK_MSKDAT4_Pos              (4)                                                /*!< PWM_T::MSK: MSKDAT4 Position              */
N#define PWM_MSK_MSKDAT4_Msk              (0x1ul << PWM_MSK_MSKDAT4_Pos)                     /*!< PWM_T::MSK: MSKDAT4 Mask                  */
N
N#define PWM_MSK_MSKDAT5_Pos              (5)                                                /*!< PWM_T::MSK: MSKDAT5 Position              */
N#define PWM_MSK_MSKDAT5_Msk              (0x1ul << PWM_MSK_MSKDAT5_Pos)                     /*!< PWM_T::MSK: MSKDAT5 Mask                  */
N
N#define PWM_BNF_BRK0NFEN_Pos             (0)                                                /*!< PWM_T::BNF: BRK0NFEN Position             */
N#define PWM_BNF_BRK0NFEN_Msk             (0x1ul << PWM_BNF_BRK0NFEN_Pos)                    /*!< PWM_T::BNF: BRK0NFEN Mask                 */
N
N#define PWM_BNF_BRK0NFSEL_Pos            (1)                                                /*!< PWM_T::BNF: BRK0NFSEL Position            */
N#define PWM_BNF_BRK0NFSEL_Msk            (0x7ul << PWM_BNF_BRK0NFSEL_Pos)                   /*!< PWM_T::BNF: BRK0NFSEL Mask                */
N
N#define PWM_BNF_BRK0FCNT_Pos             (4)                                                /*!< PWM_T::BNF: BRK0FCNT Position             */
N#define PWM_BNF_BRK0FCNT_Msk             (0x7ul << PWM_BNF_BRK0FCNT_Pos)                    /*!< PWM_T::BNF: BRK0FCNT Mask                 */
N
N#define PWM_BNF_BRK0PINV_Pos             (7)                                                /*!< PWM_T::BNF: BRK0PINV Position             */
N#define PWM_BNF_BRK0PINV_Msk             (0x1ul << PWM_BNF_BRK0PINV_Pos)                    /*!< PWM_T::BNF: BRK0PINV Mask                 */
N
N#define PWM_BNF_BRK1NFEN_Pos             (8)                                                /*!< PWM_T::BNF: BRK1NFEN Position             */
N#define PWM_BNF_BRK1NFEN_Msk             (0x1ul << PWM_BNF_BRK1NFEN_Pos)                    /*!< PWM_T::BNF: BRK1NFEN Mask                 */
N
N#define PWM_BNF_BRK1NFSEL_Pos            (9)                                                /*!< PWM_T::BNF: BRK1NFSEL Position            */
N#define PWM_BNF_BRK1NFSEL_Msk            (0x7ul << PWM_BNF_BRK1NFSEL_Pos)                   /*!< PWM_T::BNF: BRK1NFSEL Mask                */
N
N#define PWM_BNF_BRK1FCNT_Pos             (12)                                               /*!< PWM_T::BNF: BRK1FCNT Position             */
N#define PWM_BNF_BRK1FCNT_Msk             (0x7ul << PWM_BNF_BRK1FCNT_Pos)                    /*!< PWM_T::BNF: BRK1FCNT Mask                 */
N
N#define PWM_BNF_BRK1PINV_Pos             (15)                                               /*!< PWM_T::BNF: BRK1PINV Position             */
N#define PWM_BNF_BRK1PINV_Msk             (0x1ul << PWM_BNF_BRK1PINV_Pos)                    /*!< PWM_T::BNF: BRK1PINV Mask                 */
N
N#define PWM_BNF_BK0SRC_Pos               (16)                                               /*!< PWM_T::BNF: BK0SRC Position               */
N#define PWM_BNF_BK0SRC_Msk               (0x1ul << PWM_BNF_BK0SRC_Pos)                      /*!< PWM_T::BNF: BK0SRC Mask                   */
N
N#define PWM_BNF_BK1SRC_Pos               (24)                                               /*!< PWM_T::BNF: BK1SRC Position               */
N#define PWM_BNF_BK1SRC_Msk               (0x1ul << PWM_BNF_BK1SRC_Pos)                      /*!< PWM_T::BNF: BK1SRC Mask                   */
N
N#define PWM_FAILBRK_CSSBRKEN_Pos         (0)                                                /*!< PWM_T::FAILBRK: CSSBRKEN Position         */
N#define PWM_FAILBRK_CSSBRKEN_Msk         (0x1ul << PWM_FAILBRK_CSSBRKEN_Pos)                /*!< PWM_T::FAILBRK: CSSBRKEN Mask             */
N
N#define PWM_FAILBRK_BODBRKEN_Pos         (1)                                                /*!< PWM_T::FAILBRK: BODBRKEN Position         */
N#define PWM_FAILBRK_BODBRKEN_Msk         (0x1ul << PWM_FAILBRK_BODBRKEN_Pos)                /*!< PWM_T::FAILBRK: BODBRKEN Mask             */
N
N#define PWM_FAILBRK_RAMBRKEN_Pos         (2)                                                /*!< PWM_T::FAILBRK: RAMBRKEN Position         */
N#define PWM_FAILBRK_RAMBRKEN_Msk         (0x1ul << PWM_FAILBRK_RAMBRKEN_Pos)                /*!< PWM_T::FAILBRK: RAMBRKEN Mask             */
N
N#define PWM_FAILBRK_CORBRKEN_Pos         (3)                                                /*!< PWM_T::FAILBRK: CORBRKEN Position         */
N#define PWM_FAILBRK_CORBRKEN_Msk         (0x1ul << PWM_FAILBRK_CORBRKEN_Pos)                /*!< PWM_T::FAILBRK: CORBRKEN Mask             */
N
N#define PWM_BRKCTL0_1_BRKP0EEN_Pos       (4)                                                /*!< PWM_T::BRKCTL0_1: BRKP0EEN Position       */
N#define PWM_BRKCTL0_1_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0EEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKP0EEN Mask           */
N
N#define PWM_BRKCTL0_1_BRKP1EEN_Pos       (5)                                                /*!< PWM_T::BRKCTL0_1: BRKP1EEN Position       */
N#define PWM_BRKCTL0_1_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1EEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKP1EEN Mask           */
N
N#define PWM_BRKCTL0_1_SYSEBEN_Pos        (7)                                                /*!< PWM_T::BRKCTL0_1: SYSEBEN Position        */
N#define PWM_BRKCTL0_1_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSEBEN_Pos)               /*!< PWM_T::BRKCTL0_1: SYSEBEN Mask            */
N
N#define PWM_BRKCTL0_1_BRKP0LEN_Pos       (12)                                               /*!< PWM_T::BRKCTL0_1: BRKP0LEN Position       */
N#define PWM_BRKCTL0_1_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0LEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKP0LEN Mask           */
N
N#define PWM_BRKCTL0_1_BRKP1LEN_Pos       (13)                                               /*!< PWM_T::BRKCTL0_1: BRKP1LEN Position       */
N#define PWM_BRKCTL0_1_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1LEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKP1LEN Mask           */
N
N#define PWM_BRKCTL0_1_SYSLBEN_Pos        (15)                                               /*!< PWM_T::BRKCTL0_1: SYSLBEN Position        */
N#define PWM_BRKCTL0_1_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSLBEN_Pos)               /*!< PWM_T::BRKCTL0_1: SYSLBEN Mask            */
N
N#define PWM_BRKCTL0_1_BRKAEVEN_Pos       (16)                                               /*!< PWM_T::BRKCTL0_1: BRKAEVEN Position       */
N#define PWM_BRKCTL0_1_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL0_1_BRKAEVEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKAEVEN Mask           */
N
N#define PWM_BRKCTL0_1_BRKAODD_Pos        (18)                                               /*!< PWM_T::BRKCTL0_1: BRKAODD Position        */
N#define PWM_BRKCTL0_1_BRKAODD_Msk        (0x3ul << PWM_BRKCTL0_1_BRKAODD_Pos)               /*!< PWM_T::BRKCTL0_1: BRKAODD Mask            */
N
N#define PWM_BRKCTL2_3_BRKP0EEN_Pos       (4)                                                /*!< PWM_T::BRKCTL2_3: BRKP0EEN Position       */
N#define PWM_BRKCTL2_3_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0EEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKP0EEN Mask           */
N
N#define PWM_BRKCTL2_3_BRKP1EEN_Pos       (5)                                                /*!< PWM_T::BRKCTL2_3: BRKP1EEN Position       */
N#define PWM_BRKCTL2_3_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1EEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKP1EEN Mask           */
N
N#define PWM_BRKCTL2_3_SYSEBEN_Pos        (7)                                                /*!< PWM_T::BRKCTL2_3: SYSEBEN Position        */
N#define PWM_BRKCTL2_3_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSEBEN_Pos)               /*!< PWM_T::BRKCTL2_3: SYSEBEN Mask            */
N
N#define PWM_BRKCTL2_3_BRKP0LEN_Pos       (12)                                               /*!< PWM_T::BRKCTL2_3: BRKP0LEN Position       */
N#define PWM_BRKCTL2_3_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0LEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKP0LEN Mask           */
N
N#define PWM_BRKCTL2_3_BRKP1LEN_Pos       (13)                                               /*!< PWM_T::BRKCTL2_3: BRKP1LEN Position       */
N#define PWM_BRKCTL2_3_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1LEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKP1LEN Mask           */
N
N#define PWM_BRKCTL2_3_SYSLBEN_Pos        (15)                                               /*!< PWM_T::BRKCTL2_3: SYSLBEN Position        */
N#define PWM_BRKCTL2_3_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSLBEN_Pos)               /*!< PWM_T::BRKCTL2_3: SYSLBEN Mask            */
N
N#define PWM_BRKCTL2_3_BRKAEVEN_Pos       (16)                                               /*!< PWM_T::BRKCTL2_3: BRKAEVEN Position       */
N#define PWM_BRKCTL2_3_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL2_3_BRKAEVEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKAEVEN Mask           */
N
N#define PWM_BRKCTL2_3_BRKAODD_Pos        (18)                                               /*!< PWM_T::BRKCTL2_3: BRKAODD Position        */
N#define PWM_BRKCTL2_3_BRKAODD_Msk        (0x3ul << PWM_BRKCTL2_3_BRKAODD_Pos)               /*!< PWM_T::BRKCTL2_3: BRKAODD Mask            */
N
N#define PWM_BRKCTL4_5_BRKP0EEN_Pos       (4)                                                /*!< PWM_T::BRKCTL4_5: BRKP0EEN Position       */
N#define PWM_BRKCTL4_5_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0EEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKP0EEN Mask           */
N
N#define PWM_BRKCTL4_5_BRKP1EEN_Pos       (5)                                                /*!< PWM_T::BRKCTL4_5: BRKP1EEN Position       */
N#define PWM_BRKCTL4_5_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1EEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKP1EEN Mask           */
N
N#define PWM_BRKCTL4_5_SYSEBEN_Pos        (7)                                                /*!< PWM_T::BRKCTL4_5: SYSEBEN Position        */
N#define PWM_BRKCTL4_5_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSEBEN_Pos)               /*!< PWM_T::BRKCTL4_5: SYSEBEN Mask            */
N
N#define PWM_BRKCTL4_5_BRKP0LEN_Pos       (12)                                               /*!< PWM_T::BRKCTL4_5: BRKP0LEN Position       */
N#define PWM_BRKCTL4_5_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0LEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKP0LEN Mask           */
N
N#define PWM_BRKCTL4_5_BRKP1LEN_Pos       (13)                                               /*!< PWM_T::BRKCTL4_5: BRKP1LEN Position       */
N#define PWM_BRKCTL4_5_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1LEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKP1LEN Mask           */
N
N#define PWM_BRKCTL4_5_SYSLBEN_Pos        (15)                                               /*!< PWM_T::BRKCTL4_5: SYSLBEN Position        */
N#define PWM_BRKCTL4_5_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSLBEN_Pos)               /*!< PWM_T::BRKCTL4_5: SYSLBEN Mask            */
N
N#define PWM_BRKCTL4_5_BRKAEVEN_Pos       (16)                                               /*!< PWM_T::BRKCTL4_5: BRKAEVEN Position       */
N#define PWM_BRKCTL4_5_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL4_5_BRKAEVEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKAEVEN Mask           */
N
N#define PWM_BRKCTL4_5_BRKAODD_Pos        (18)                                               /*!< PWM_T::BRKCTL4_5: BRKAODD Position        */
N#define PWM_BRKCTL4_5_BRKAODD_Msk        (0x3ul << PWM_BRKCTL4_5_BRKAODD_Pos)               /*!< PWM_T::BRKCTL4_5: BRKAODD Mask            */
N
N#define PWM_POLCTL_PINVn_Pos             (0)                                                /*!< PWM_T::POLCTL: PINVn Position             */
N#define PWM_POLCTL_PINVn_Msk             (0x3ful << PWM_POLCTL_PINVn_Pos)                   /*!< PWM_T::POLCTL: PINVn Mask                 */
N
N#define PWM_POLCTL_PINV0_Pos             (0)                                                /*!< PWM_T::POLCTL: PINV0 Position             */
N#define PWM_POLCTL_PINV0_Msk             (0x1ul << PWM_POLCTL_PINV0_Pos)                    /*!< PWM_T::POLCTL: PINV0 Mask                 */
N
N#define PWM_POLCTL_PINV1_Pos             (1)                                                /*!< PWM_T::POLCTL: PINV1 Position             */
N#define PWM_POLCTL_PINV1_Msk             (0x1ul << PWM_POLCTL_PINV1_Pos)                    /*!< PWM_T::POLCTL: PINV1 Mask                 */
N
N#define PWM_POLCTL_PINV2_Pos             (2)                                                /*!< PWM_T::POLCTL: PINV2 Position             */
N#define PWM_POLCTL_PINV2_Msk             (0x1ul << PWM_POLCTL_PINV2_Pos)                    /*!< PWM_T::POLCTL: PINV2 Mask                 */
N
N#define PWM_POLCTL_PINV3_Pos             (3)                                                /*!< PWM_T::POLCTL: PINV3 Position             */
N#define PWM_POLCTL_PINV3_Msk             (0x1ul << PWM_POLCTL_PINV3_Pos)                    /*!< PWM_T::POLCTL: PINV3 Mask                 */
N
N#define PWM_POLCTL_PINV4_Pos             (4)                                                /*!< PWM_T::POLCTL: PINV4 Position             */
N#define PWM_POLCTL_PINV4_Msk             (0x1ul << PWM_POLCTL_PINV4_Pos)                    /*!< PWM_T::POLCTL: PINV4 Mask                 */
N
N#define PWM_POLCTL_PINV5_Pos             (5)                                                /*!< PWM_T::POLCTL: PINV5 Position             */
N#define PWM_POLCTL_PINV5_Msk             (0x1ul << PWM_POLCTL_PINV5_Pos)                    /*!< PWM_T::POLCTL: PINV5 Mask                 */
N
N#define PWM_POEN_POENn_Pos               (0)                                                /*!< PWM_T::POEN: POENn Position               */
N#define PWM_POEN_POENn_Msk               (0x3ful << PWM_POEN_POENn_Pos)                     /*!< PWM_T::POEN: POENn Mask                   */
N
N#define PWM_POEN_POEN0_Pos               (0)                                                /*!< PWM_T::POEN: POEN0 Position               */
N#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                      /*!< PWM_T::POEN: POEN0 Mask                   */
N
N#define PWM_POEN_POEN1_Pos               (1)                                                /*!< PWM_T::POEN: POEN1 Position               */
N#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                      /*!< PWM_T::POEN: POEN1 Mask                   */
N
N#define PWM_POEN_POEN2_Pos               (2)                                                /*!< PWM_T::POEN: POEN2 Position               */
N#define PWM_POEN_POEN2_Msk               (0x1ul << PWM_POEN_POEN2_Pos)                      /*!< PWM_T::POEN: POEN2 Mask                   */
N
N#define PWM_POEN_POEN3_Pos               (3)                                                /*!< PWM_T::POEN: POEN3 Position               */
N#define PWM_POEN_POEN3_Msk               (0x1ul << PWM_POEN_POEN3_Pos)                      /*!< PWM_T::POEN: POEN3 Mask                   */
N
N#define PWM_POEN_POEN4_Pos               (4)                                                /*!< PWM_T::POEN: POEN4 Position               */
N#define PWM_POEN_POEN4_Msk               (0x1ul << PWM_POEN_POEN4_Pos)                      /*!< PWM_T::POEN: POEN4 Mask                   */
N
N#define PWM_POEN_POEN5_Pos               (5)                                                /*!< PWM_T::POEN: POEN5 Position               */
N#define PWM_POEN_POEN5_Msk               (0x1ul << PWM_POEN_POEN5_Pos)                      /*!< PWM_T::POEN: POEN5 Mask                   */
N
N#define PWM_SWBRK_BRKETRGn_Pos           (0)                                                /*!< PWM_T::SWBRK: BRKETRGn Position           */
N#define PWM_SWBRK_BRKETRGn_Msk           (0x7ul << PWM_SWBRK_BRKETRGn_Pos)                  /*!< PWM_T::SWBRK: BRKETRGn Mask               */
N
N#define PWM_SWBRK_BRKETRG0_Pos           (0)                                                /*!< PWM_T::SWBRK: BRKETRG0 Position           */
N#define PWM_SWBRK_BRKETRG0_Msk           (0x1ul << PWM_SWBRK_BRKETRG0_Pos)                  /*!< PWM_T::SWBRK: BRKETRG0 Mask               */
N
N#define PWM_SWBRK_BRKETRG2_Pos           (1)                                                /*!< PWM_T::SWBRK: BRKETRG2 Position           */
N#define PWM_SWBRK_BRKETRG2_Msk           (0x1ul << PWM_SWBRK_BRKETRG2_Pos)                  /*!< PWM_T::SWBRK: BRKETRG2 Mask               */
N
N#define PWM_SWBRK_BRKETRG4_Pos           (2)                                                /*!< PWM_T::SWBRK: BRKETRG4 Position           */
N#define PWM_SWBRK_BRKETRG4_Msk           (0x1ul << PWM_SWBRK_BRKETRG4_Pos)                  /*!< PWM_T::SWBRK: BRKETRG4 Mask               */
N
N#define PWM_SWBRK_BRKLTRGn_Pos           (8)                                                /*!< PWM_T::SWBRK: BRKLTRGn Position           */
N#define PWM_SWBRK_BRKLTRGn_Msk           (0x7ul << PWM_SWBRK_BRKLTRGn_Pos)                  /*!< PWM_T::SWBRK: BRKLTRGn Mask               */
N
N#define PWM_SWBRK_BRKLTRG0_Pos           (8)                                                /*!< PWM_T::SWBRK: BRKLTRG0 Position           */
N#define PWM_SWBRK_BRKLTRG0_Msk           (0x1ul << PWM_SWBRK_BRKLTRG0_Pos)                  /*!< PWM_T::SWBRK: BRKLTRG0 Mask               */
N
N#define PWM_SWBRK_BRKLTRG2_Pos           (9)                                                /*!< PWM_T::SWBRK: BRKLTRG2 Position           */
N#define PWM_SWBRK_BRKLTRG2_Msk           (0x1ul << PWM_SWBRK_BRKLTRG2_Pos)                  /*!< PWM_T::SWBRK: BRKLTRG2 Mask               */
N
N#define PWM_SWBRK_BRKLTRG4_Pos           (10)                                               /*!< PWM_T::SWBRK: BRKLTRG4 Position           */
N#define PWM_SWBRK_BRKLTRG4_Msk           (0x1ul << PWM_SWBRK_BRKLTRG4_Pos)                  /*!< PWM_T::SWBRK: BRKLTRG4 Mask               */
N
N#define PWM_INTEN0_ZIENn_Pos             (0)                                                /*!< PWM_T::INTEN0: ZIENn Position             */
N#define PWM_INTEN0_ZIENn_Msk             (0x15ul << PWM_INTEN0_ZIENn_Pos)                   /*!< PWM_T::INTEN0: ZIENn Mask                 */
N
N#define PWM_INTEN0_ZIEN0_Pos             (0)                                                /*!< PWM_T::INTEN0: ZIEN0 Position             */
N#define PWM_INTEN0_ZIEN0_Msk             (0x1ul << PWM_INTEN0_ZIEN0_Pos)                    /*!< PWM_T::INTEN0: ZIEN0 Mask                 */
N
N#define PWM_INTEN0_ZIEN2_Pos             (2)                                                /*!< PWM_T::INTEN0: ZIEN2 Position             */
N#define PWM_INTEN0_ZIEN2_Msk             (0x1ul << PWM_INTEN0_ZIEN2_Pos)                    /*!< PWM_T::INTEN0: ZIEN2 Mask                 */
N
N#define PWM_INTEN0_ZIEN4_Pos             (4)                                                /*!< PWM_T::INTEN0: ZIEN4 Position             */
N#define PWM_INTEN0_ZIEN4_Msk             (0x1ul << PWM_INTEN0_ZIEN4_Pos)                    /*!< PWM_T::INTEN0: ZIEN4 Mask                 */
N
N#define PWM_INTEN0_PIENn_Pos             (8)                                                /*!< PWM_T::INTEN0: PIENn Position             */
N#define PWM_INTEN0_PIENn_Msk             (0x15ul << PWM_INTEN0_PIENn_Pos)                   /*!< PWM_T::INTEN0: PIENn Mask                 */
N
N#define PWM_INTEN0_PIEN0_Pos             (8)                                                /*!< PWM_T::INTEN0: PIEN0 Position             */
N#define PWM_INTEN0_PIEN0_Msk             (0x1ul << PWM_INTEN0_PIEN0_Pos)                    /*!< PWM_T::INTEN0: PIEN0 Mask                 */
N
N#define PWM_INTEN0_PIEN2_Pos             (10)                                               /*!< PWM_T::INTEN0: PIEN2 Position             */
N#define PWM_INTEN0_PIEN2_Msk             (0x1ul << PWM_INTEN0_PIEN2_Pos)                    /*!< PWM_T::INTEN0: PIEN2 Mask                 */
N
N#define PWM_INTEN0_PIEN4_Pos             (12)                                               /*!< PWM_T::INTEN0: PIEN4 Position             */
N#define PWM_INTEN0_PIEN4_Msk             (0x1ul << PWM_INTEN0_PIEN4_Pos)                    /*!< PWM_T::INTEN0: PIEN4 Mask                 */
N
N#define PWM_INTEN0_CMPUIENn_Pos          (16)                                               /*!< PWM_T::INTEN0: CMPUIENn Position          */
N#define PWM_INTEN0_CMPUIENn_Msk          (0x3ful << PWM_INTEN0_CMPUIENn_Pos)                /*!< PWM_T::INTEN0: CMPUIENn Mask              */
N
N#define PWM_INTEN0_CMPUIEN0_Pos          (16)                                               /*!< PWM_T::INTEN0: CMPUIEN0 Position          */
N#define PWM_INTEN0_CMPUIEN0_Msk          (0x1ul << PWM_INTEN0_CMPUIEN0_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN0 Mask              */
N
N#define PWM_INTEN0_CMPUIEN1_Pos          (17)                                               /*!< PWM_T::INTEN0: CMPUIEN1 Position          */
N#define PWM_INTEN0_CMPUIEN1_Msk          (0x1ul << PWM_INTEN0_CMPUIEN1_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN1 Mask              */
N
N#define PWM_INTEN0_CMPUIEN2_Pos          (18)                                               /*!< PWM_T::INTEN0: CMPUIEN2 Position          */
N#define PWM_INTEN0_CMPUIEN2_Msk          (0x1ul << PWM_INTEN0_CMPUIEN2_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN2 Mask              */
N
N#define PWM_INTEN0_CMPUIEN3_Pos          (19)                                               /*!< PWM_T::INTEN0: CMPUIEN3 Position          */
N#define PWM_INTEN0_CMPUIEN3_Msk          (0x1ul << PWM_INTEN0_CMPUIEN3_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN3 Mask              */
N
N#define PWM_INTEN0_CMPUIEN4_Pos          (20)                                               /*!< PWM_T::INTEN0: CMPUIEN4 Position          */
N#define PWM_INTEN0_CMPUIEN4_Msk          (0x1ul << PWM_INTEN0_CMPUIEN4_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN4 Mask              */
N
N#define PWM_INTEN0_CMPUIEN5_Pos          (21)                                               /*!< PWM_T::INTEN0: CMPUIEN5 Position          */
N#define PWM_INTEN0_CMPUIEN5_Msk          (0x1ul << PWM_INTEN0_CMPUIEN5_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN5 Mask              */
N
N#define PWM_INTEN0_IFAIEN4_5_Pos         (23)                                               /*!< PWM_T::INTEN0: IFAIEN4_5 Position         */
N#define PWM_INTEN0_IFAIEN4_5_Msk         (0x1ul << PWM_INTEN0_IFAIEN4_5_Pos)                /*!< PWM_T::INTEN0: IFAIEN4_5 Mask             */
N
N#define PWM_INTEN0_CMPDIENn_Pos          (24)                                               /*!< PWM_T::INTEN0: CMPDIENn Position          */
N#define PWM_INTEN0_CMPDIENn_Msk          (0x3ful << PWM_INTEN0_CMPDIENn_Pos)                /*!< PWM_T::INTEN0: CMPDIENn Mask              */
N
N#define PWM_INTEN0_CMPDIEN0_Pos          (24)                                               /*!< PWM_T::INTEN0: CMPDIEN0 Position          */
N#define PWM_INTEN0_CMPDIEN0_Msk          (0x1ul << PWM_INTEN0_CMPDIEN0_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN0 Mask              */
N
N#define PWM_INTEN0_CMPDIEN1_Pos          (25)                                               /*!< PWM_T::INTEN0: CMPDIEN1 Position          */
N#define PWM_INTEN0_CMPDIEN1_Msk          (0x1ul << PWM_INTEN0_CMPDIEN1_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN1 Mask              */
N
N#define PWM_INTEN0_CMPDIEN2_Pos          (26)                                               /*!< PWM_T::INTEN0: CMPDIEN2 Position          */
N#define PWM_INTEN0_CMPDIEN2_Msk          (0x1ul << PWM_INTEN0_CMPDIEN2_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN2 Mask              */
N
N#define PWM_INTEN0_CMPDIEN3_Pos          (27)                                               /*!< PWM_T::INTEN0: CMPDIEN3 Position          */
N#define PWM_INTEN0_CMPDIEN3_Msk          (0x1ul << PWM_INTEN0_CMPDIEN3_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN3 Mask              */
N
N#define PWM_INTEN0_CMPDIEN4_Pos          (28)                                               /*!< PWM_T::INTEN0: CMPDIEN4 Position          */
N#define PWM_INTEN0_CMPDIEN4_Msk          (0x1ul << PWM_INTEN0_CMPDIEN4_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN4 Mask              */
N
N#define PWM_INTEN0_CMPDIEN5_Pos          (29)                                               /*!< PWM_T::INTEN0: CMPDIEN5 Position          */
N#define PWM_INTEN0_CMPDIEN5_Msk          (0x1ul << PWM_INTEN0_CMPDIEN5_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN5 Mask              */
N
N#define PWM_INTEN1_BRKEIEN0_1_Pos        (0)                                                /*!< PWM_T::INTEN1: BRKEIEN0_1 Position        */
N#define PWM_INTEN1_BRKEIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKEIEN0_1_Pos)               /*!< PWM_T::INTEN1: BRKEIEN0_1 Mask            */
N
N#define PWM_INTEN1_BRKEIEN2_3_Pos        (1)                                                /*!< PWM_T::INTEN1: BRKEIEN2_3 Position        */
N#define PWM_INTEN1_BRKEIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKEIEN2_3_Pos)               /*!< PWM_T::INTEN1: BRKEIEN2_3 Mask            */
N
N#define PWM_INTEN1_BRKEIEN4_5_Pos        (2)                                                /*!< PWM_T::INTEN1: BRKEIEN4_5 Position        */
N#define PWM_INTEN1_BRKEIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKEIEN4_5_Pos)               /*!< PWM_T::INTEN1: BRKEIEN4_5 Mask            */
N
N#define PWM_INTEN1_BRKLIEN0_1_Pos        (8)                                                /*!< PWM_T::INTEN1: BRKLIEN0_1 Position        */
N#define PWM_INTEN1_BRKLIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKLIEN0_1_Pos)               /*!< PWM_T::INTEN1: BRKLIEN0_1 Mask            */
N
N#define PWM_INTEN1_BRKLIEN2_3_Pos        (9)                                                /*!< PWM_T::INTEN1: BRKLIEN2_3 Position        */
N#define PWM_INTEN1_BRKLIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKLIEN2_3_Pos)               /*!< PWM_T::INTEN1: BRKLIEN2_3 Mask            */
N
N#define PWM_INTEN1_BRKLIEN4_5_Pos        (10)                                               /*!< PWM_T::INTEN1: BRKLIEN4_5 Position        */
N#define PWM_INTEN1_BRKLIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKLIEN4_5_Pos)               /*!< PWM_T::INTEN1: BRKLIEN4_5 Mask            */
N
N#define PWM_INTSTS0_ZIFn_Pos             (0)                                                /*!< PWM_T::INTSTS0: ZIFn Position             */
N#define PWM_INTSTS0_ZIFn_Msk             (0x15ul << PWM_INTSTS0_ZIFn_Pos)                   /*!< PWM_T::INTSTS0: ZIFn Mask                 */
N
N#define PWM_INTSTS0_ZIF0_Pos             (0)                                                /*!< PWM_T::INTSTS0: ZIF0 Position             */
N#define PWM_INTSTS0_ZIF0_Msk             (0x1ul << PWM_INTSTS0_ZIF0_Pos)                    /*!< PWM_T::INTSTS0: ZIF0 Mask                 */
N
N#define PWM_INTSTS0_ZIF2_Pos             (2)                                                /*!< PWM_T::INTSTS0: ZIF2 Position             */
N#define PWM_INTSTS0_ZIF2_Msk             (0x1ul << PWM_INTSTS0_ZIF2_Pos)                    /*!< PWM_T::INTSTS0: ZIF2 Mask                 */
N
N#define PWM_INTSTS0_ZIF4_Pos             (4)                                                /*!< PWM_T::INTSTS0: ZIF4 Position             */
N#define PWM_INTSTS0_ZIF4_Msk             (0x1ul << PWM_INTSTS0_ZIF4_Pos)                    /*!< PWM_T::INTSTS0: ZIF4 Mask                 */
N
N#define PWM_INTSTS0_PIFn_Pos             (8)                                                /*!< PWM_T::INTSTS0: PIFn Position             */
N#define PWM_INTSTS0_PIFn_Msk             (0x15ul << PWM_INTSTS0_PIFn_Pos)                   /*!< PWM_T::INTSTS0: PIFn Mask                 */
N
N#define PWM_INTSTS0_PIF0_Pos             (8)                                                /*!< PWM_T::INTSTS0: PIF0 Position             */
N#define PWM_INTSTS0_PIF0_Msk             (0x1ul << PWM_INTSTS0_PIF0_Pos)                    /*!< PWM_T::INTSTS0: PIF0 Mask                 */
N
N#define PWM_INTSTS0_PIF2_Pos             (10)                                               /*!< PWM_T::INTSTS0: PIF2 Position             */
N#define PWM_INTSTS0_PIF2_Msk             (0x1ul << PWM_INTSTS0_PIF2_Pos)                    /*!< PWM_T::INTSTS0: PIF2 Mask                 */
N
N#define PWM_INTSTS0_PIF4_Pos             (12)                                               /*!< PWM_T::INTSTS0: PIF4 Position             */
N#define PWM_INTSTS0_PIF4_Msk             (0x1ul << PWM_INTSTS0_PIF4_Pos)                    /*!< PWM_T::INTSTS0: ZIF4 Mask                 */
N
N#define PWM_INTSTS0_CMPUIFn_Pos          (16)                                               /*!< PWM_T::INTSTS0: CMPUIFn Position          */
N#define PWM_INTSTS0_CMPUIFn_Msk          (0x3ful << PWM_INTSTS0_CMPUIFn_Pos)                /*!< PWM_T::INTSTS0: CMPUIFn Mask              */
N
N#define PWM_INTSTS0_CMPUIF0_Pos          (16)                                               /*!< PWM_T::INTSTS0: CMPUIF0 Position          */
N#define PWM_INTSTS0_CMPUIF0_Msk          (0x1ul << PWM_INTSTS0_CMPUIF0_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF0 Mask              */
N
N#define PWM_INTSTS0_CMPUIF1_Pos          (17)                                               /*!< PWM_T::INTSTS0: CMPUIF1 Position          */
N#define PWM_INTSTS0_CMPUIF1_Msk          (0x1ul << PWM_INTSTS0_CMPUIF1_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF1 Mask              */
N
N#define PWM_INTSTS0_CMPUIF2_Pos          (18)                                               /*!< PWM_T::INTSTS0: CMPUIF2 Position          */
N#define PWM_INTSTS0_CMPUIF2_Msk          (0x1ul << PWM_INTSTS0_CMPUIF2_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF2 Mask              */
N
N#define PWM_INTSTS0_CMPUIF3_Pos          (19)                                               /*!< PWM_T::INTSTS0: CMPUIF3 Position          */
N#define PWM_INTSTS0_CMPUIF3_Msk          (0x1ul << PWM_INTSTS0_CMPUIF3_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF3 Mask              */
N
N#define PWM_INTSTS0_CMPUIF4_Pos          (20)                                               /*!< PWM_T::INTSTS0: CMPUIF4 Position          */
N#define PWM_INTSTS0_CMPUIF4_Msk          (0x1ul << PWM_INTSTS0_CMPUIF4_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF4 Mask              */
N
N#define PWM_INTSTS0_CMPUIF5_Pos          (21)                                               /*!< PWM_T::INTSTS0: CMPUIF5 Position          */
N#define PWM_INTSTS0_CMPUIF5_Msk          (0x1ul << PWM_INTSTS0_CMPUIF5_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF5 Mask              */
N
N#define PWM_INTSTS0_IFAIF4_5_Pos         (23)                                               /*!< PWM_T::INTSTS0: IFAIF4_5 Position         */
N#define PWM_INTSTS0_IFAIF4_5_Msk         (0x1ul << PWM_INTSTS0_IFAIF4_5_Pos)                /*!< PWM_T::INTSTS0: IFAIF4_5 Mask             */
N
N#define PWM_INTSTS0_CMPDIFn_Pos          (24)                                               /*!< PWM_T::INTSTS0: CMPDIFn Position          */
N#define PWM_INTSTS0_CMPDIFn_Msk          (0x3ful << PWM_INTSTS0_CMPDIFn_Pos)                /*!< PWM_T::INTSTS0: CMPDIFn Mask              */
N
N#define PWM_INTSTS0_CMPDIF0_Pos          (24)                                               /*!< PWM_T::INTSTS0: CMPDIF0 Position          */
N#define PWM_INTSTS0_CMPDIF0_Msk          (0x1ul << PWM_INTSTS0_CMPDIF0_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF0 Mask              */
N
N#define PWM_INTSTS0_CMPDIF1_Pos          (25)                                               /*!< PWM_T::INTSTS0: CMPDIF1 Position          */
N#define PWM_INTSTS0_CMPDIF1_Msk          (0x1ul << PWM_INTSTS0_CMPDIF1_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF1 Mask              */
N
N#define PWM_INTSTS0_CMPDIF2_Pos          (26)                                               /*!< PWM_T::INTSTS0: CMPDIF2 Position          */
N#define PWM_INTSTS0_CMPDIF2_Msk          (0x1ul << PWM_INTSTS0_CMPDIF2_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF2 Mask              */
N
N#define PWM_INTSTS0_CMPDIF3_Pos          (27)                                               /*!< PWM_T::INTSTS0: CMPDIF3 Position          */
N#define PWM_INTSTS0_CMPDIF3_Msk          (0x1ul << PWM_INTSTS0_CMPDIF3_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF3 Mask              */
N
N#define PWM_INTSTS0_CMPDIF4_Pos          (28)                                               /*!< PWM_T::INTSTS0: CMPDIF4 Position          */
N#define PWM_INTSTS0_CMPDIF4_Msk          (0x1ul << PWM_INTSTS0_CMPDIF4_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF4 Mask              */
N
N#define PWM_INTSTS0_CMPDIF5_Pos          (29)                                               /*!< PWM_T::INTSTS0: CMPDIF5 Position          */
N#define PWM_INTSTS0_CMPDIF5_Msk          (0x1ul << PWM_INTSTS0_CMPDIF5_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF5 Mask              */
N
N#define PWM_INTSTS1_BRKEIFn_Pos          (0)                                                /*!< PWM_T::INTSTS1: BRKEIFn Position          */
N#define PWM_INTSTS1_BRKEIFn_Msk          (0x3ful << PWM_INTSTS1_BRKEIFn_Pos)                /*!< PWM_T::INTSTS1: BRKEIFn Mask              */
N
N#define PWM_INTSTS1_BRKEIF0_Pos          (0)                                                /*!< PWM_T::INTSTS1: BRKEIF0 Position          */
N#define PWM_INTSTS1_BRKEIF0_Msk          (0x1ul << PWM_INTSTS1_BRKEIF0_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF0 Mask              */
N
N#define PWM_INTSTS1_BRKEIF1_Pos          (1)                                                /*!< PWM_T::INTSTS1: BRKEIF1 Position          */
N#define PWM_INTSTS1_BRKEIF1_Msk          (0x1ul << PWM_INTSTS1_BRKEIF1_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF1 Mask              */
N
N#define PWM_INTSTS1_BRKEIF2_Pos          (2)                                                /*!< PWM_T::INTSTS1: BRKEIF2 Position          */
N#define PWM_INTSTS1_BRKEIF2_Msk          (0x1ul << PWM_INTSTS1_BRKEIF2_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF2 Mask              */
N
N#define PWM_INTSTS1_BRKEIF3_Pos          (3)                                                /*!< PWM_T::INTSTS1: BRKEIF3 Position          */
N#define PWM_INTSTS1_BRKEIF3_Msk          (0x1ul << PWM_INTSTS1_BRKEIF3_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF3 Mask              */
N
N#define PWM_INTSTS1_BRKEIF4_Pos          (4)                                                /*!< PWM_T::INTSTS1: BRKEIF4 Position          */
N#define PWM_INTSTS1_BRKEIF4_Msk          (0x1ul << PWM_INTSTS1_BRKEIF4_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF4 Mask              */
N
N#define PWM_INTSTS1_BRKEIF5_Pos          (5)                                                /*!< PWM_T::INTSTS1: BRKEIF5 Position          */
N#define PWM_INTSTS1_BRKEIF5_Msk          (0x1ul << PWM_INTSTS1_BRKEIF5_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF5 Mask              */
N
N#define PWM_INTSTS1_BRKLIFn_Pos          (8)                                                /*!< PWM_T::INTSTS1: BRKLIFn Position          */
N#define PWM_INTSTS1_BRKLIFn_Msk          (0x3ful << PWM_INTSTS1_BRKLIFn_Pos)                /*!< PWM_T::INTSTS1: BRKLIFn Mask              */
N
N#define PWM_INTSTS1_BRKLIF0_Pos          (8)                                                /*!< PWM_T::INTSTS1: BRKLIF0 Position          */
N#define PWM_INTSTS1_BRKLIF0_Msk          (0x1ul << PWM_INTSTS1_BRKLIF0_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF0 Mask              */
N
N#define PWM_INTSTS1_BRKLIF1_Pos          (9)                                                /*!< PWM_T::INTSTS1: BRKLIF1 Position          */
N#define PWM_INTSTS1_BRKLIF1_Msk          (0x1ul << PWM_INTSTS1_BRKLIF1_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF1 Mask              */
N
N#define PWM_INTSTS1_BRKLIF2_Pos          (10)                                               /*!< PWM_T::INTSTS1: BRKLIF2 Position          */
N#define PWM_INTSTS1_BRKLIF2_Msk          (0x1ul << PWM_INTSTS1_BRKLIF2_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF2 Mask              */
N
N#define PWM_INTSTS1_BRKLIF3_Pos          (11)                                               /*!< PWM_T::INTSTS1: BRKLIF3 Position          */
N#define PWM_INTSTS1_BRKLIF3_Msk          (0x1ul << PWM_INTSTS1_BRKLIF3_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF3 Mask              */
N
N#define PWM_INTSTS1_BRKLIF4_Pos          (12)                                               /*!< PWM_T::INTSTS1: BRKLIF4 Position          */
N#define PWM_INTSTS1_BRKLIF4_Msk          (0x1ul << PWM_INTSTS1_BRKLIF4_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF4 Mask              */
N
N#define PWM_INTSTS1_BRKLIF5_Pos          (13)                                               /*!< PWM_T::INTSTS1: BRKLIF5 Position          */
N#define PWM_INTSTS1_BRKLIF5_Msk          (0x1ul << PWM_INTSTS1_BRKLIF5_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF5 Mask              */
N
N#define PWM_INTSTS1_BRKESTS0_Pos         (16)                                               /*!< PWM_T::INTSTS1: BRKESTS0 Position         */
N#define PWM_INTSTS1_BRKESTS0_Msk         (0x1ul << PWM_INTSTS1_BRKESTS0_Pos)                /*!< PWM_T::INTSTS1: BRKESTS0 Mask             */
N
N#define PWM_INTSTS1_BRKESTS1_Pos         (17)                                               /*!< PWM_T::INTSTS1: BRKESTS1 Position         */
N#define PWM_INTSTS1_BRKESTS1_Msk         (0x1ul << PWM_INTSTS1_BRKESTS1_Pos)                /*!< PWM_T::INTSTS1: BRKESTS1 Mask             */
N
N#define PWM_INTSTS1_BRKESTS2_Pos         (18)                                               /*!< PWM_T::INTSTS1: BRKESTS2 Position         */
N#define PWM_INTSTS1_BRKESTS2_Msk         (0x1ul << PWM_INTSTS1_BRKESTS2_Pos)                /*!< PWM_T::INTSTS1: BRKESTS2 Mask             */
N
N#define PWM_INTSTS1_BRKESTS3_Pos         (19)                                               /*!< PWM_T::INTSTS1: BRKESTS3 Position         */
N#define PWM_INTSTS1_BRKESTS3_Msk         (0x1ul << PWM_INTSTS1_BRKESTS3_Pos)                /*!< PWM_T::INTSTS1: BRKESTS3 Mask             */
N
N#define PWM_INTSTS1_BRKESTS4_Pos         (20)                                               /*!< PWM_T::INTSTS1: BRKESTS4 Position         */
N#define PWM_INTSTS1_BRKESTS4_Msk         (0x1ul << PWM_INTSTS1_BRKESTS4_Pos)                /*!< PWM_T::INTSTS1: BRKESTS4 Mask             */
N
N#define PWM_INTSTS1_BRKESTS5_Pos         (21)                                               /*!< PWM_T::INTSTS1: BRKESTS5 Position         */
N#define PWM_INTSTS1_BRKESTS5_Msk         (0x1ul << PWM_INTSTS1_BRKESTS5_Pos)                /*!< PWM_T::INTSTS1: BRKESTS5 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS0_Pos         (24)                                               /*!< PWM_T::INTSTS1: BRKLSTS0 Position         */
N#define PWM_INTSTS1_BRKLSTS0_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS0_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS0 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS1_Pos         (25)                                               /*!< PWM_T::INTSTS1: BRKLSTS1 Position         */
N#define PWM_INTSTS1_BRKLSTS1_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS1_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS1 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS2_Pos         (26)                                               /*!< PWM_T::INTSTS1: BRKLSTS2 Position         */
N#define PWM_INTSTS1_BRKLSTS2_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS2_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS2 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS3_Pos         (27)                                               /*!< PWM_T::INTSTS1: BRKLSTS3 Position         */
N#define PWM_INTSTS1_BRKLSTS3_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS3_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS3 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS4_Pos         (28)                                               /*!< PWM_T::INTSTS1: BRKLSTS4 Position         */
N#define PWM_INTSTS1_BRKLSTS4_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS4_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS4 Mask             */
N
N#define PWM_INTSTS1_BRKLSTS5_Pos         (29)                                               /*!< PWM_T::INTSTS1: BRKLSTS5 Position         */
N#define PWM_INTSTS1_BRKLSTS5_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS5_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS5 Mask             */
N
N#define PWM_ADCTS0_TRGSEL0_Pos           (0)                                                /*!< PWM_T::ADCTS0: TRGSEL0 Position           */
N#define PWM_ADCTS0_TRGSEL0_Msk           (0xful << PWM_ADCTS0_TRGSEL0_Pos)                  /*!< PWM_T::ADCTS0: TRGSEL0 Mask               */
N
N#define PWM_ADCTS0_TRGEN0_Pos            (7)                                                /*!< PWM_T::ADCTS0: TRGEN0 Position            */
N#define PWM_ADCTS0_TRGEN0_Msk            (0x1ul << PWM_ADCTS0_TRGEN0_Pos)                   /*!< PWM_T::ADCTS0: TRGEN0 Mask                */
N
N#define PWM_ADCTS0_TRGSEL1_Pos           (8)                                                /*!< PWM_T::ADCTS0: TRGSEL1 Position           */
N#define PWM_ADCTS0_TRGSEL1_Msk           (0xful << PWM_ADCTS0_TRGSEL1_Pos)                  /*!< PWM_T::ADCTS0: TRGSEL1 Mask               */
N
N#define PWM_ADCTS0_TRGEN1_Pos            (15)                                               /*!< PWM_T::ADCTS0: TRGEN1 Position            */
N#define PWM_ADCTS0_TRGEN1_Msk            (0x1ul << PWM_ADCTS0_TRGEN1_Pos)                   /*!< PWM_T::ADCTS0: TRGEN1 Mask                */
N
N#define PWM_ADCTS0_TRGSEL2_Pos           (16)                                               /*!< PWM_T::ADCTS0: TRGSEL2 Position           */
N#define PWM_ADCTS0_TRGSEL2_Msk           (0xful << PWM_ADCTS0_TRGSEL2_Pos)                  /*!< PWM_T::ADCTS0: TRGSEL2 Mask               */
N
N#define PWM_ADCTS0_TRGEN2_Pos            (23)                                               /*!< PWM_T::ADCTS0: TRGEN2 Position            */
N#define PWM_ADCTS0_TRGEN2_Msk            (0x1ul << PWM_ADCTS0_TRGEN2_Pos)                   /*!< PWM_T::ADCTS0: TRGEN2 Mask                */
N
N#define PWM_ADCTS0_TRGSEL3_Pos           (24)                                               /*!< PWM_T::ADCTS0: TRGSEL3 Position           */
N#define PWM_ADCTS0_TRGSEL3_Msk           (0xful << PWM_ADCTS0_TRGSEL3_Pos)                  /*!< PWM_T::ADCTS0: TRGSEL3 Mask               */
N
N#define PWM_ADCTS0_TRGEN3_Pos            (31)                                               /*!< PWM_T::ADCTS0: TRGEN3 Position            */
N#define PWM_ADCTS0_TRGEN3_Msk            (0x1ul << PWM_ADCTS0_TRGEN3_Pos)                   /*!< PWM_T::ADCTS0: TRGEN3 Mask                */
N
N#define PWM_ADCTS1_TRGSEL4_Pos           (0)                                                /*!< PWM_T::ADCTS1: TRGSEL4 Position           */
N#define PWM_ADCTS1_TRGSEL4_Msk           (0xful << PWM_ADCTS1_TRGSEL4_Pos)                  /*!< PWM_T::ADCTS1: TRGSEL4 Mask               */
N
N#define PWM_ADCTS1_TRGEN4_Pos            (7)                                                /*!< PWM_T::ADCTS1: TRGEN4 Position            */
N#define PWM_ADCTS1_TRGEN4_Msk            (0x1ul << PWM_ADCTS1_TRGEN4_Pos)                   /*!< PWM_T::ADCTS1: TRGEN4 Mask                */
N
N#define PWM_ADCTS1_TRGSEL5_Pos           (8)                                                /*!< PWM_T::ADCTS1: TRGSEL5 Position           */
N#define PWM_ADCTS1_TRGSEL5_Msk           (0xful << PWM_ADCTS1_TRGSEL5_Pos)                  /*!< PWM_T::ADCTS1: TRGSEL5 Mask               */
N
N#define PWM_ADCTS1_TRGEN5_Pos            (15)                                               /*!< PWM_T::ADCTS1: TRGEN5 Position            */
N#define PWM_ADCTS1_TRGEN5_Msk            (0x1ul << PWM_ADCTS1_TRGEN5_Pos)                   /*!< PWM_T::ADCTS1: TRGEN5 Mask                */
N
N#define PWM_SSCTL_SSENn_Pos              (0)                                                /*!< PWM_T::SSCTL: SSENn Position              */
N#define PWM_SSCTL_SSENn_Msk              (0x15ul << PWM_SSCTL_SSENn_Pos)                    /*!< PWM_T::SSCTL: SSENn Mask                  */
N
N#define PWM_SSCTL_SSEN0_Pos              (0)                                                /*!< PWM_T::SSCTL: SSEN0 Position              */
N#define PWM_SSCTL_SSEN0_Msk              (0x1ul << PWM_SSCTL_SSEN0_Pos)                     /*!< PWM_T::SSCTL: SSEN0 Mask                  */
N
N#define PWM_SSCTL_SSEN2_Pos              (2)                                                /*!< PWM_T::SSCTL: SSEN2 Position              */
N#define PWM_SSCTL_SSEN2_Msk              (0x1ul << PWM_SSCTL_SSEN2_Pos)                     /*!< PWM_T::SSCTL: SSEN2 Mask                  */
N
N#define PWM_SSCTL_SSEN4_Pos              (4)                                                /*!< PWM_T::SSCTL: SSEN4 Position              */
N#define PWM_SSCTL_SSEN4_Msk              (0x1ul << PWM_SSCTL_SSEN4_Pos)                     /*!< PWM_T::SSCTL: SSEN4 Mask                  */
N
N#define PWM_SSCTL_SSRC_Pos               (8)                                                /*!< PWM_T::SSCTL: SSRC Position               */
N#define PWM_SSCTL_SSRC_Msk               (0x3ul << PWM_SSCTL_SSRC_Pos)                      /*!< PWM_T::SSCTL: SSRC Mask                   */
N
N#define PWM_SSTRG_CNTSEN_Pos             (0)                                                /*!< PWM_T::SSTRG: CNTSEN Position             */
N#define PWM_SSTRG_CNTSEN_Msk             (0x1ul << PWM_SSTRG_CNTSEN_Pos)                    /*!< PWM_T::SSTRG: CNTSEN Mask                 */
N
N#define PWM_STATUS_CNTMAXFn_Pos          (0)                                                /*!< PWM_T::STATUS: CNTMAXFn Position          */
N#define PWM_STATUS_CNTMAXFn_Msk          (0x15ul << PWM_STATUS_CNTMAXFn_Pos)                /*!< PWM_T::STATUS: CNTMAXFn Mask              */
N
N#define PWM_STATUS_CNTMAXF0_Pos          (0)                                                /*!< PWM_T::STATUS: CNTMAXF0 Position          */
N#define PWM_STATUS_CNTMAXF0_Msk          (0x1ul << PWM_STATUS_CNTMAXF0_Pos)                 /*!< PWM_T::STATUS: CNTMAXF0 Mask              */
N
N#define PWM_STATUS_CNTMAXF2_Pos          (2)                                                /*!< PWM_T::STATUS: CNTMAXF2 Position          */
N#define PWM_STATUS_CNTMAXF2_Msk          (0x1ul << PWM_STATUS_CNTMAXF2_Pos)                 /*!< PWM_T::STATUS: CNTMAXF2 Mask              */
N
N#define PWM_STATUS_CNTMAXF4_Pos          (4)                                                /*!< PWM_T::STATUS: CNTMAXF4 Position          */
N#define PWM_STATUS_CNTMAXF4_Msk          (0x1ul << PWM_STATUS_CNTMAXF4_Pos)                 /*!< PWM_T::STATUS: CNTMAXF4 Mask              */
N
N#define PWM_STATUS_ADCTRGFn_Pos          (16)                                               /*!< PWM_T::STATUS: ADCTRGFn Position          */
N#define PWM_STATUS_ADCTRGFn_Msk          (0x3ful << PWM_STATUS_ADCTRGFn_Pos)                /*!< PWM_T::STATUS: ADCTRGFn Mask              */
N
N#define PWM_STATUS_ADCTRGF0_Pos          (16)                                               /*!< PWM_T::STATUS: ADCTRGF0 Position          */
N#define PWM_STATUS_ADCTRGF0_Msk          (0x1ul << PWM_STATUS_ADCTRGF0_Pos)                 /*!< PWM_T::STATUS: ADCTRGF0 Mask              */
N
N#define PWM_STATUS_ADCTRGF1_Pos          (17)                                               /*!< PWM_T::STATUS: ADCTRGF1 Position          */
N#define PWM_STATUS_ADCTRGF1_Msk          (0x1ul << PWM_STATUS_ADCTRGF1_Pos)                 /*!< PWM_T::STATUS: ADCTRGF1 Mask              */
N
N#define PWM_STATUS_ADCTRGF2_Pos          (18)                                               /*!< PWM_T::STATUS: ADCTRGF2 Position          */
N#define PWM_STATUS_ADCTRGF2_Msk          (0x1ul << PWM_STATUS_ADCTRGF2_Pos)                 /*!< PWM_T::STATUS: ADCTRGF2 Mask              */
N
N#define PWM_STATUS_ADCTRGF3_Pos          (19)                                               /*!< PWM_T::STATUS: ADCTRGF3 Position          */
N#define PWM_STATUS_ADCTRGF3_Msk          (0x1ul << PWM_STATUS_ADCTRGF3_Pos)                 /*!< PWM_T::STATUS: ADCTRGF3 Mask              */
N
N#define PWM_STATUS_ADCTRGF4_Pos          (20)                                               /*!< PWM_T::STATUS: ADCTRGF4 Position          */
N#define PWM_STATUS_ADCTRGF4_Msk          (0x1ul << PWM_STATUS_ADCTRGF4_Pos)                 /*!< PWM_T::STATUS: ADCTRGF4 Mask              */
N
N#define PWM_STATUS_ADCTRGF5_Pos          (21)                                               /*!< PWM_T::STATUS: ADCTRGF5 Position          */
N#define PWM_STATUS_ADCTRGF5_Msk          (0x1ul << PWM_STATUS_ADCTRGF5_Pos)                 /*!< PWM_T::STATUS: ADCTRGF5 Mask              */
N
N#define PWM_CAPINEN_CAPINENn_Pos         (0)                                                /*!< PWM_T::CAPINEN: CAPINENn Position         */
N#define PWM_CAPINEN_CAPINENn_Msk         (0x3ful << PWM_CAPINEN_CAPINENn_Pos)               /*!< PWM_T::CAPINEN: CAPINENn Mask             */
N
N#define PWM_CAPINEN_CAPINEN0_Pos         (0)                                                /*!< PWM_T::CAPINEN: CAPINEN0 Position         */
N#define PWM_CAPINEN_CAPINEN0_Msk         (0x1ul << PWM_CAPINEN_CAPINEN0_Pos)                /*!< PWM_T::CAPINEN: CAPINEN0 Mask             */
N
N#define PWM_CAPINEN_CAPINEN1_Pos         (1)                                                /*!< PWM_T::CAPINEN: CAPINEN1 Position         */
N#define PWM_CAPINEN_CAPINEN1_Msk         (0x1ul << PWM_CAPINEN_CAPINEN1_Pos)                /*!< PWM_T::CAPINEN: CAPINEN1 Mask             */
N
N#define PWM_CAPINEN_CAPINEN2_Pos         (2)                                                /*!< PWM_T::CAPINEN: CAPINEN2 Position         */
N#define PWM_CAPINEN_CAPINEN2_Msk         (0x1ul << PWM_CAPINEN_CAPINEN2_Pos)                /*!< PWM_T::CAPINEN: CAPINEN2 Mask             */
N
N#define PWM_CAPINEN_CAPINEN3_Pos         (3)                                                /*!< PWM_T::CAPINEN: CAPINEN3 Position         */
N#define PWM_CAPINEN_CAPINEN3_Msk         (0x1ul << PWM_CAPINEN_CAPINEN3_Pos)                /*!< PWM_T::CAPINEN: CAPINEN3 Mask             */
N
N#define PWM_CAPINEN_CAPINEN4_Pos         (4)                                                /*!< PWM_T::CAPINEN: CAPINEN4 Position         */
N#define PWM_CAPINEN_CAPINEN4_Msk         (0x1ul << PWM_CAPINEN_CAPINEN4_Pos)                /*!< PWM_T::CAPINEN: CAPINEN4 Mask             */
N
N#define PWM_CAPINEN_CAPINEN5_Pos         (5)                                                /*!< PWM_T::CAPINEN: CAPINEN5 Position         */
N#define PWM_CAPINEN_CAPINEN5_Msk         (0x1ul << PWM_CAPINEN_CAPINEN5_Pos)                /*!< PWM_T::CAPINEN: CAPINEN5 Mask             */
N
N#define PWM_CAPCTL_CAPENn_Pos            (0)                                                /*!< PWM_T::CAPCTL: CAPENn Position            */
N#define PWM_CAPCTL_CAPENn_Msk            (0x3ful << PWM_CAPCTL_CAPENn_Pos)                  /*!< PWM_T::CAPCTL: CAPENn Mask                */
N
N#define PWM_CAPCTL_CAPEN0_Pos            (0)                                                /*!< PWM_T::CAPCTL: CAPEN0 Position            */
N#define PWM_CAPCTL_CAPEN0_Msk            (0x1ul << PWM_CAPCTL_CAPEN0_Pos)                   /*!< PWM_T::CAPCTL: CAPEN0 Mask                */
N
N#define PWM_CAPCTL_CAPEN1_Pos            (1)                                                /*!< PWM_T::CAPCTL: CAPEN1 Position            */
N#define PWM_CAPCTL_CAPEN1_Msk            (0x1ul << PWM_CAPCTL_CAPEN1_Pos)                   /*!< PWM_T::CAPCTL: CAPEN1 Mask                */
N
N#define PWM_CAPCTL_CAPEN2_Pos            (2)                                                /*!< PWM_T::CAPCTL: CAPEN2 Position            */
N#define PWM_CAPCTL_CAPEN2_Msk            (0x1ul << PWM_CAPCTL_CAPEN2_Pos)                   /*!< PWM_T::CAPCTL: CAPEN2 Mask                */
N
N#define PWM_CAPCTL_CAPEN3_Pos            (3)                                                /*!< PWM_T::CAPCTL: CAPEN3 Position            */
N#define PWM_CAPCTL_CAPEN3_Msk            (0x1ul << PWM_CAPCTL_CAPEN3_Pos)                   /*!< PWM_T::CAPCTL: CAPEN3 Mask                */
N
N#define PWM_CAPCTL_CAPEN4_Pos            (4)                                                /*!< PWM_T::CAPCTL: CAPEN4 Position            */
N#define PWM_CAPCTL_CAPEN4_Msk            (0x1ul << PWM_CAPCTL_CAPEN4_Pos)                   /*!< PWM_T::CAPCTL: CAPEN4 Mask                */
N
N#define PWM_CAPCTL_CAPEN5_Pos            (5)                                                /*!< PWM_T::CAPCTL: CAPEN5 Position            */
N#define PWM_CAPCTL_CAPEN5_Msk            (0x1ul << PWM_CAPCTL_CAPEN5_Pos)                   /*!< PWM_T::CAPCTL: CAPEN5 Mask                */
N
N#define PWM_CAPCTL_CAPINVn_Pos           (8)                                                /*!< PWM_T::CAPCTL: CAPINVn Position           */
N#define PWM_CAPCTL_CAPINVn_Msk           (0x3ful << PWM_CAPCTL_CAPINVn_Pos)                 /*!< PWM_T::CAPCTL: CAPINVn Mask               */
N
N#define PWM_CAPCTL_CAPINV0_Pos           (8)                                                /*!< PWM_T::CAPCTL: CAPINV0 Position           */
N#define PWM_CAPCTL_CAPINV0_Msk           (0x1ul << PWM_CAPCTL_CAPINV0_Pos)                  /*!< PWM_T::CAPCTL: CAPINV0 Mask               */
N
N#define PWM_CAPCTL_CAPINV1_Pos           (9)                                                /*!< PWM_T::CAPCTL: CAPINV1 Position           */
N#define PWM_CAPCTL_CAPINV1_Msk           (0x1ul << PWM_CAPCTL_CAPINV1_Pos)                  /*!< PWM_T::CAPCTL: CAPINV1 Mask               */
N
N#define PWM_CAPCTL_CAPINV2_Pos           (10)                                               /*!< PWM_T::CAPCTL: CAPINV2 Position           */
N#define PWM_CAPCTL_CAPINV2_Msk           (0x1ul << PWM_CAPCTL_CAPINV2_Pos)                  /*!< PWM_T::CAPCTL: CAPINV2 Mask               */
N
N#define PWM_CAPCTL_CAPINV3_Pos           (11)                                               /*!< PWM_T::CAPCTL: CAPINV3 Position           */
N#define PWM_CAPCTL_CAPINV3_Msk           (0x1ul << PWM_CAPCTL_CAPINV3_Pos)                  /*!< PWM_T::CAPCTL: CAPINV3 Mask               */
N
N#define PWM_CAPCTL_CAPINV4_Pos           (12)                                               /*!< PWM_T::CAPCTL: CAPINV4 Position           */
N#define PWM_CAPCTL_CAPINV4_Msk           (0x1ul << PWM_CAPCTL_CAPINV4_Pos)                  /*!< PWM_T::CAPCTL: CAPINV4 Mask               */
N
N#define PWM_CAPCTL_CAPINV5_Pos           (13)                                               /*!< PWM_T::CAPCTL: CAPINV5 Position           */
N#define PWM_CAPCTL_CAPINV5_Msk           (0x1ul << PWM_CAPCTL_CAPINV5_Pos)                  /*!< PWM_T::CAPCTL: CAPINV5 Mask               */
N
N#define PWM_CAPCTL_RCRLDENn_Pos          (16)                                               /*!< PWM_T::CAPCTL: RCRLDENn Position          */
N#define PWM_CAPCTL_RCRLDENn_Msk          (0x3ful << PWM_CAPCTL_RCRLDENn_Pos)                /*!< PWM_T::CAPCTL: RCRLDENn Mask              */
N
N#define PWM_CAPCTL_RCRLDEN0_Pos          (16)                                               /*!< PWM_T::CAPCTL: RCRLDEN0 Position          */
N#define PWM_CAPCTL_RCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN0_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN0 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN1_Pos          (17)                                               /*!< PWM_T::CAPCTL: RCRLDEN1 Position          */
N#define PWM_CAPCTL_RCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN1_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN1 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN2_Pos          (18)                                               /*!< PWM_T::CAPCTL: RCRLDEN2 Position          */
N#define PWM_CAPCTL_RCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN2_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN2 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN3_Pos          (19)                                               /*!< PWM_T::CAPCTL: RCRLDEN3 Position          */
N#define PWM_CAPCTL_RCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN3_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN3 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN4_Pos          (20)                                               /*!< PWM_T::CAPCTL: RCRLDEN4 Position          */
N#define PWM_CAPCTL_RCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN4_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN4 Mask              */
N
N#define PWM_CAPCTL_RCRLDEN5_Pos          (21)                                               /*!< PWM_T::CAPCTL: RCRLDEN5 Position          */
N#define PWM_CAPCTL_RCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN5_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN5 Mask              */
N
N#define PWM_CAPCTL_FCRLDENn_Pos          (24)                                               /*!< PWM_T::CAPCTL: FCRLDENn Position          */
N#define PWM_CAPCTL_FCRLDENn_Msk          (0x3ful << PWM_CAPCTL_FCRLDENn_Pos)                /*!< PWM_T::CAPCTL: FCRLDENn Mask              */
N
N#define PWM_CAPCTL_FCRLDEN0_Pos          (24)                                               /*!< PWM_T::CAPCTL: FCRLDEN0 Position          */
N#define PWM_CAPCTL_FCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN0_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN0 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN1_Pos          (25)                                               /*!< PWM_T::CAPCTL: FCRLDEN1 Position          */
N#define PWM_CAPCTL_FCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN1_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN1 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN2_Pos          (26)                                               /*!< PWM_T::CAPCTL: FCRLDEN2 Position          */
N#define PWM_CAPCTL_FCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN2_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN2 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN3_Pos          (27)                                               /*!< PWM_T::CAPCTL: FCRLDEN3 Position          */
N#define PWM_CAPCTL_FCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN3_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN3 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN4_Pos          (28)                                               /*!< PWM_T::CAPCTL: FCRLDEN4 Position          */
N#define PWM_CAPCTL_FCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN4_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN4 Mask              */
N
N#define PWM_CAPCTL_FCRLDEN5_Pos          (29)                                               /*!< PWM_T::CAPCTL: FCRLDEN5 Position          */
N#define PWM_CAPCTL_FCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN5_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN5 Mask              */
N
N#define PWM_CAPSTS_CRLIFOVn_Pos          (0)                                                /*!< PWM_T::CAPSTS: CRLIFOVn Position          */
N#define PWM_CAPSTS_CRLIFOVn_Msk          (0x3ful << PWM_CAPSTS_CRLIFOVn_Pos)                /*!< PWM_T::CAPSTS: CRLIFOVn Mask              */
N
N#define PWM_CAPSTS_CRLIFOV0_Pos          (0)                                                /*!< PWM_T::CAPSTS: CRLIFOV0 Position          */
N#define PWM_CAPSTS_CRLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV0_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV0 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV1_Pos          (1)                                                /*!< PWM_T::CAPSTS: CRLIFOV1 Position          */
N#define PWM_CAPSTS_CRLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV1_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV1 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV2_Pos          (2)                                                /*!< PWM_T::CAPSTS: CRLIFOV2 Position          */
N#define PWM_CAPSTS_CRLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV2_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV2 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV3_Pos          (3)                                                /*!< PWM_T::CAPSTS: CRLIFOV3 Position          */
N#define PWM_CAPSTS_CRLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV3_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV3 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV4_Pos          (4)                                                /*!< PWM_T::CAPSTS: CRLIFOV4 Position          */
N#define PWM_CAPSTS_CRLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV4_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV4 Mask              */
N
N#define PWM_CAPSTS_CRLIFOV5_Pos          (5)                                                /*!< PWM_T::CAPSTS: CRLIFOV5 Position          */
N#define PWM_CAPSTS_CRLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV5_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV5 Mask              */
N
N#define PWM_CAPSTS_CFLIFOVn_Pos          (8)                                                /*!< PWM_T::CAPSTS: CFLIFOVn Position          */
N#define PWM_CAPSTS_CFLIFOVn_Msk          (0x3ful << PWM_CAPSTS_CFLIFOVn_Pos)                /*!< PWM_T::CAPSTS: CFLIFOVn Mask              */
N
N#define PWM_CAPSTS_CFLIFOV0_Pos          (8)                                                /*!< PWM_T::CAPSTS: CFLIFOV0 Position          */
N#define PWM_CAPSTS_CFLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV0_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV0 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV1_Pos          (9)                                                /*!< PWM_T::CAPSTS: CFLIFOV1 Position          */
N#define PWM_CAPSTS_CFLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV1_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV1 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV2_Pos          (10)                                               /*!< PWM_T::CAPSTS: CFLIFOV2 Position          */
N#define PWM_CAPSTS_CFLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV2_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV2 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV3_Pos          (11)                                               /*!< PWM_T::CAPSTS: CFLIFOV3 Position          */
N#define PWM_CAPSTS_CFLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV3_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV3 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV4_Pos          (12)                                               /*!< PWM_T::CAPSTS: CFLIFOV4 Position          */
N#define PWM_CAPSTS_CFLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV4_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV4 Mask              */
N
N#define PWM_CAPSTS_CFLIFOV5_Pos          (13)                                               /*!< PWM_T::CAPSTS: CFLIFOV5 Position          */
N#define PWM_CAPSTS_CFLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV5_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV5 Mask              */
N
N#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT0: RCAPDAT Position         */
N#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT0: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT0: FCAPDAT Position         */
N#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT0: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT1: RCAPDAT Position         */
N#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT1: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT1: FCAPDAT Position         */
N#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT1: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT2_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT2: RCAPDAT Position         */
N#define PWM_RCAPDAT2_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT2_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT2: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT2_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT2: FCAPDAT Position         */
N#define PWM_FCAPDAT2_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT2_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT2: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT3_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT3: RCAPDAT Position         */
N#define PWM_RCAPDAT3_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT3_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT3: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT3_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT3: FCAPDAT Position         */
N#define PWM_FCAPDAT3_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT3_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT3: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT4_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT4: RCAPDAT Position         */
N#define PWM_RCAPDAT4_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT4_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT4: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT4_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT4: FCAPDAT Position         */
N#define PWM_FCAPDAT4_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT4_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT4: FCAPDAT Mask             */
N
N#define PWM_RCAPDAT5_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT5: RCAPDAT Position         */
N#define PWM_RCAPDAT5_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT5_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT5: RCAPDAT Mask             */
N
N#define PWM_FCAPDAT5_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT5: FCAPDAT Position         */
N#define PWM_FCAPDAT5_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT5_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT5: FCAPDAT Mask             */
N
N#define PWM_CAPIEN_CAPRIENn_Pos          (0)                                                /*!< PWM_T::CAPIEN: CAPRIENn Position          */
N#define PWM_CAPIEN_CAPRIENn_Msk          (0x3ful << PWM_CAPIEN_CAPRIENn_Pos)                /*!< PWM_T::CAPIEN: CAPRIENn Mask              */
N
N#define PWM_CAPIEN_CAPRIEN0_Pos          (0)                                                /*!< PWM_T::CAPIEN: CAPRIEN0 Position          */
N#define PWM_CAPIEN_CAPRIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN0_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN0 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN1_Pos          (1)                                                /*!< PWM_T::CAPIEN: CAPRIEN1 Position          */
N#define PWM_CAPIEN_CAPRIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN1_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN1 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN2_Pos          (2)                                                /*!< PWM_T::CAPIEN: CAPRIEN2 Position          */
N#define PWM_CAPIEN_CAPRIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN2_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN2 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN3_Pos          (3)                                                /*!< PWM_T::CAPIEN: CAPRIEN3 Position          */
N#define PWM_CAPIEN_CAPRIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN3_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN3 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN4_Pos          (4)                                                /*!< PWM_T::CAPIEN: CAPRIEN4 Position          */
N#define PWM_CAPIEN_CAPRIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN4_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN4 Mask              */
N
N#define PWM_CAPIEN_CAPRIEN5_Pos          (5)                                                /*!< PWM_T::CAPIEN: CAPRIEN5 Position          */
N#define PWM_CAPIEN_CAPRIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN5_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN5 Mask              */
N
N#define PWM_CAPIEN_CAPFIENn_Pos          (8)                                                /*!< PWM_T::CAPIEN: CAPFIENn Position          */
N#define PWM_CAPIEN_CAPFIENn_Msk          (0x3ful << PWM_CAPIEN_CAPFIENn_Pos)                /*!< PWM_T::CAPIEN: CAPFIENn Mask              */
N
N#define PWM_CAPIEN_CAPFIEN0_Pos          (8)                                                /*!< PWM_T::CAPIEN: CAPFIEN0 Position          */
N#define PWM_CAPIEN_CAPFIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN0_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN0 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN1_Pos          (9)                                                /*!< PWM_T::CAPIEN: CAPFIEN1 Position          */
N#define PWM_CAPIEN_CAPFIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN1_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN1 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN2_Pos          (10)                                               /*!< PWM_T::CAPIEN: CAPFIEN2 Position          */
N#define PWM_CAPIEN_CAPFIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN2_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN2 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN3_Pos          (11)                                               /*!< PWM_T::CAPIEN: CAPFIEN3 Position          */
N#define PWM_CAPIEN_CAPFIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN3_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN3 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN4_Pos          (12)                                               /*!< PWM_T::CAPIEN: CAPFIEN4 Position          */
N#define PWM_CAPIEN_CAPFIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN4_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN4 Mask              */
N
N#define PWM_CAPIEN_CAPFIEN5_Pos          (13)                                               /*!< PWM_T::CAPIEN: CAPFIEN5 Position          */
N#define PWM_CAPIEN_CAPFIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN5_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN5 Mask              */
N
N#define PWM_CAPIF_CRLIFn_Pos             (0)                                                /*!< PWM_T::CAPIF: CRLIFn Position             */
N#define PWM_CAPIF_CRLIFn_Msk             (0x3ful << PWM_CAPIF_CRLIFn_Pos)                   /*!< PWM_T::CAPIF: CRLIFn Mask                 */
N
N#define PWM_CAPIF_CRLIF0_Pos             (0)                                                /*!< PWM_T::CAPIF: CRLIF0 Position             */
N#define PWM_CAPIF_CRLIF0_Msk             (0x1ul << PWM_CAPIF_CRLIF0_Pos)                    /*!< PWM_T::CAPIF: CRLIF0 Mask                 */
N
N#define PWM_CAPIF_CRLIF1_Pos             (1)                                                /*!< PWM_T::CAPIF: CRLIF1 Position             */
N#define PWM_CAPIF_CRLIF1_Msk             (0x1ul << PWM_CAPIF_CRLIF1_Pos)                    /*!< PWM_T::CAPIF: CRLIF1 Mask                 */
N
N#define PWM_CAPIF_CRLIF2_Pos             (2)                                                /*!< PWM_T::CAPIF: CRLIF2 Position             */
N#define PWM_CAPIF_CRLIF2_Msk             (0x1ul << PWM_CAPIF_CRLIF2_Pos)                    /*!< PWM_T::CAPIF: CRLIF2 Mask                 */
N
N#define PWM_CAPIF_CRLIF3_Pos             (3)                                                /*!< PWM_T::CAPIF: CRLIF3 Position             */
N#define PWM_CAPIF_CRLIF3_Msk             (0x1ul << PWM_CAPIF_CRLIF3_Pos)                    /*!< PWM_T::CAPIF: CRLIF3 Mask                 */
N
N#define PWM_CAPIF_CRLIF4_Pos             (4)                                                /*!< PWM_T::CAPIF: CRLIF4 Position             */
N#define PWM_CAPIF_CRLIF4_Msk             (0x1ul << PWM_CAPIF_CRLIF4_Pos)                    /*!< PWM_T::CAPIF: CRLIF4 Mask                 */
N
N#define PWM_CAPIF_CRLIF5_Pos             (5)                                                /*!< PWM_T::CAPIF: CRLIF5 Position             */
N#define PWM_CAPIF_CRLIF5_Msk             (0x1ul << PWM_CAPIF_CRLIF5_Pos)                    /*!< PWM_T::CAPIF: CRLIF5 Mask                 */
N
N#define PWM_CAPIF_CFLIFn_Pos             (8)                                                /*!< PWM_T::CAPIF: CFLIFn Position             */
N#define PWM_CAPIF_CFLIFn_Msk             (0x3ful << PWM_CAPIF_CFLIFn_Pos)                   /*!< PWM_T::CAPIF: CFLIFn Mask                 */
N
N#define PWM_CAPIF_CFLIF0_Pos             (8)                                                /*!< PWM_T::CAPIF: CFLIF0 Position             */
N#define PWM_CAPIF_CFLIF0_Msk             (0x1ul << PWM_CAPIF_CFLIF0_Pos)                    /*!< PWM_T::CAPIF: CFLIF0 Mask                 */
N
N#define PWM_CAPIF_CFLIF1_Pos             (9)                                                /*!< PWM_T::CAPIF: CFLIF1 Position             */
N#define PWM_CAPIF_CFLIF1_Msk             (0x1ul << PWM_CAPIF_CFLIF1_Pos)                    /*!< PWM_T::CAPIF: CFLIF1 Mask                 */
N
N#define PWM_CAPIF_CFLIF2_Pos             (10)                                               /*!< PWM_T::CAPIF: CFLIF2 Position             */
N#define PWM_CAPIF_CFLIF2_Msk             (0x1ul << PWM_CAPIF_CFLIF2_Pos)                    /*!< PWM_T::CAPIF: CFLIF2 Mask                 */
N
N#define PWM_CAPIF_CFLIF3_Pos             (11)                                               /*!< PWM_T::CAPIF: CFLIF3 Position             */
N#define PWM_CAPIF_CFLIF3_Msk             (0x1ul << PWM_CAPIF_CFLIF3_Pos)                    /*!< PWM_T::CAPIF: CFLIF3 Mask                 */
N
N#define PWM_CAPIF_CFLIF4_Pos             (12)                                               /*!< PWM_T::CAPIF: CFLIF4 Position             */
N#define PWM_CAPIF_CFLIF4_Msk             (0x1ul << PWM_CAPIF_CFLIF4_Pos)                    /*!< PWM_T::CAPIF: CFLIF4 Mask                 */
N
N#define PWM_CAPIF_CFLIF5_Pos             (13)                                               /*!< PWM_T::CAPIF: CFLIF5 Position             */
N#define PWM_CAPIF_CFLIF5_Msk             (0x1ul << PWM_CAPIF_CFLIF5_Pos)                    /*!< PWM_T::CAPIF: CFLIF5 Mask                 */
N
N#define PWM_PBUF_PBUF_Pos                (0)                                                /*!< PWM_T::PBUF: PBUF Position                */
N#define PWM_PBUF_PBUF_Msk                (0xfffful << PWM_PBUF_PBUF_Pos)                    /*!< PWM_T::PBUF: PBUF Mask                    */
N
N#define PWM_CMPBUF_CMPBUF_Pos            (0)                                                /*!< PWM_T::CMPBUF: CMPBUF Position            */
N#define PWM_CMPBUF_CMPBUF_Msk            (0xfffful << PWM_CMPBUF_CMPBUF_Pos)                /*!< PWM_T::CMPBUF: CMPBUF Mask                */
N
N/*@}*/ /* end of group PWM_CONST */
N/*@}*/ /* end of group PWM */
N
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller (SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
Ntypedef struct
N{
N    /**
N     * SPI_CNTRL
N     * ===================================================================================================
N     * Offset: 0x00  Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GO_BUSY   |SPI Transfer Control Bit And Busy Status
N     * |        |          |0 = Data transfer stopped.
N     * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode,
N     * |        |          |    writing 1 to this bit indicates that the slave is ready to communicate with a master.
N     * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.
N     * |        |          |As the transfer is finished, this bit will be cleared automatically.
N     * |        |          |Software can read this bit to check if the SPI is in busy status.
N     * |        |          |In FIFO mode, this bit will be controlled by hardware.
N     * |        |          |Software should not modify this bit.
N     * |        |          |In Slave mode, this bit always returns 1 when this register is read by software.
N     * |        |          |In Master mode, this bit reflects the busy or idle status of SPI.
N     * |        |          |Note:
N     * |        |          |1. When FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.
N     * |        |          |2. When FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data, this bit
N     * |        |          |   will be cleared after the PDMA finishes the data transfer.
N     * |[1]     |RX_NEG    |Receive On Negative Edge
N     * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
N     * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
N     * |[2]     |TX_NEG    |Transmit On Negative Edge
N     * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
N     * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
N     * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
N     * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
N     * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
N     * |        |          |TX_BIT_LEN = 0x08 ... 8 bits.
N     * |        |          |TX_BIT_LEN = 0x09 ... 9 bits.
N     * |        |          |......
N     * |        |          |TX_BIT_LEN = 0x1F ... 31 bits.
N     * |        |          |TX_BIT_LEN = 0x00 ... 32 bits.
N     * |[10]    |LSB       |Send LSB First
N     * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first.
N     * |        |          |1 = The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the first bit received from
N     * |        |          |    the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
N     * |[11]    |CLKP      |Clock Polarity
N     * |        |          |0 = SPI bus clock is idle low.
N     * |        |          |1 = SPI bus clock is idle high.
N     * |[15:12] |SP_CYCLE  |Suspend Interval (Master Only)
N     * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.
N     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word
N     * |        |          |and the first clock edge of the following transaction word.
N     * |        |          |The default value is 0x3.
N     * |        |          |The period of the suspend interval is obtained according to the following equation.
N     * |        |          |(SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle
N     * |        |          |Example:
N     * |        |          |SP_CYCLE = 0x0 ... 0.5 SPI bus clock cycle.
N     * |        |          |SP_CYCLE = 0x1 ... 1.5 SPI bus clock cycle.
N     * |        |          |......
N     * |        |          |SP_CYCLE = 0xE ... 14.5 SPI bus clock cycle.
N     * |        |          |SP_CYCLE = 0xF ... 15.5 SPI bus clock cycle.
N     * |        |          |If the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend
N     * |        |          |interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.
N     * |[16]    |IF        |Unit Transfer Interrupt Flag
N     * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N     * |        |          |1 = SPI controller has finished one unit transfer.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[17]    |IE        |Unit Transfer Interrupt Enable
N     * |        |          |0 = SPI unit transfer interrupt Disabled.
N     * |        |          |1 = SPI unit transfer interrupt Enabled.
N     * |[18]    |SLAVE     |Slave Mode Enable
N     * |        |          |0 = Master mode.
N     * |        |          |1 = Slave mode.
N     * |[19]    |REORDER   |Byte Reorder Function Enable
N     * |        |          |0 = Byte Reorder function Disabled.
N     * |        |          |1 = Byte Reorder function Enabled.
N     * |        |          |A byte suspend interval will be inserted among each byte.
N     * |        |          |The period of the byte suspend interval depends on the setting of SP_CYCLE.
N     * |        |          |Note:
N     * |        |          |1. Byte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
N     * |        |          |2. In Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the
N     * |        |          |   byte suspend interval.
N     * |        |          |3. The Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.
N     * |[21]    |FIFO      |FIFO Mode Enable
N     * |        |          |0 = FIFO mode Disabled.
N     * |        |          |1 = FIFO mode Enabled.
N     * |        |          |Note:
N     * |        |          |1. Before enabling FIFO mode, the other related settings should be set in advance.
N     * |        |          |2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data
N     * |        |          |   to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle.
N     * |        |          |   If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.
N     * |        |          |3. After clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.
N     * |[23]    |VARCLK_EN |Variable Clock Enable (Master Only)
N     * |        |          |0 = SPI clock output frequency is fixed and decided only by the value of DIVIDER.
N     * |        |          |1 = SPI clock output frequency is variable.
N     * |        |          |The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
N     * |        |          |Note: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).
N     * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |It is a mutual mirror bit of SPI_STATUS[24].
N     * |        |          |0 = Receive FIFO buffer is not empty.
N     * |        |          |1 = Receive FIFO buffer is empty.
N     * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only)
N     * |        |          |It is a mutual mirror bit of SPI_STATUS[25].
N     * |        |          |0 = Receive FIFO buffer is not full.
N     * |        |          |1 = Receive FIFO buffer is full.
N     * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |It is a mutual mirror bit of SPI_STATUS[26].
N     * |        |          |0 = Transmit FIFO buffer is not empty.
N     * |        |          |1 = Transmit FIFO buffer is empty.
N     * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
N     * |        |          |It is a mutual mirror bit of SPI_STATUS[27].
N     * |        |          |0 = Transmit FIFO buffer is not full.
N     * |        |          |1 = Transmit FIFO buffer is full.
N     */
N    __IO uint32_t CNTRL;
X    volatile uint32_t CNTRL;
N
N    /**
N     * SPI_DIVIDER
N     * ===================================================================================================
N     * Offset: 0x04  Clock Divider Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |DIVIDER   |Clock Divider 1 Register
N     * |        |          |The value in this field is the frequency divider for generating the SPI peripheral clock and the SPI bus clock of SPI master.
N     * |        |          |The frequency is obtained according to the following equation.
N     * |        |          |If the bit of BCn, SPI_CNTRL2[31], is set to 0,
N     * |        |          |   SPI peripheral clock frequency = SPI peripheral clock source frequency / (DIVIDER + 1) / 2
N     * |        |          |else if BCn is set to 1,
N     * |        |          |   SPI peripheral clock frequency = SPI peripheral clock source frequency / (DIVIDER + 1)
N     * |        |          |The SPI peripheral clock source is defined in the CLKSEL1 register.
N     * |[23:16] |DIVIDER2  |Clock Divider 2 Register (Master Only)
N     * |        |          |The value in this field is the 2nd frequency divider for generating the second clock of the variable clock function.
N     * |        |          |The frequency is obtained according to the following equation:
N     * |        |          |   f_clk2 = SPI peripheral clock frequency / (DIVIDER2 + 1) / 2
N     * |        |          |If the VARCLK_EN bit is cleared to 0, this setting is unmeaning.
N     */
N    __IO uint32_t DIVIDER;
X    volatile uint32_t DIVIDER;
N
N    /**
N     * SPI_SSR
N     * ===================================================================================================
N     * Offset: 0x08  Slave Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |SSR       |Slave Select Control Bits (Master Only)
N     * |        |          |If AUTOSS bit is cleared, writing 1 to any bit of this field sets the SPI0_SS
N     * |        |          |line to an active state and writing 0 sets the line back to inactive state.
N     * |        |          |If the AUTOSS bit is set, writing 0 to any bit location of this field will keep the
N     * |        |          |SPI0_SS line at inactive state; writing 1 to this field will select
N     * |        |          |SPI0_SS line to be automatically driven to active state for the duration of the
N     * |        |          |transmit/receive, and will be driven to inactive state for the rest of the time.
N     * |        |          |The active state of SPI0_SS is specified in SS_LVL.
N     * |[2]     |SS_LVL    |Slave Select Active Level
N     * |        |          |This bit defines the active status of slave select signal (SPI0_SS).
N     * |        |          |0 = The slave select signal SPI0_SS is active on low-level/falling-edge.
N     * |        |          |1 = The slave select signal SPI0_SS is active on high-level/rising-edge.
N     * |[3]     |AUTOSS    |Automatic Slave Select Function Enable (Master Only)
N     * |        |          |0 = If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing
N     * |        |          |    SPI_SSR[0].
N     * |        |          |1 = If this bit is set, SPI0_SS signals will be generated automatically.
N     * |        |          |    It means that slave select signal, which is set in SPI_SSR[0], will be asserted by the
N     * |        |          |    SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished.
N     * |[4]     |SS_LTRIG  |Slave Select Level Trigger Enable (Slave Only)
N     * |        |          |0 = Slave select signal is edge-trigger.
N     * |        |          |    This is the default value.
N     * |        |          |    The SS_LVL bit decides the signal is active after a falling-edge or rising-edge.
N     * |        |          |1 = Slave select signal is level-trigger.
N     * |        |          |    The SS_LVL bit decides the signal is active low or active high.
N     * |[5]     |LTRIG_FLAG|Level Trigger Accomplish Flag
N     * |        |          |In Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.
N     * |        |          |0 = Transferred bit length of one transaction does not meet the specified requirement.
N     * |        |          |1 = Transferred bit length meets the specified requirement which defined in TX_BIT_LEN.
N     * |        |          |Note: This bit is READ only.
N     * |        |          |As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period.
N     * |        |          |In FIFO mode, this bit has no meaning.
N     */
N    __IO uint32_t SSR;
X    volatile uint32_t SSR;
N
N    __I  uint32_t RESERVE0;
X    volatile const  uint32_t RESERVE0;
N
N    /**
N     * SPI_RX
N     * ===================================================================================================
N     * Offset: 0x10  Data Receive Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |RX        |Data Receive Register
N     * |        |          |The data receive register holds the datum received from SPI data input pin.
N     * |        |          |If FIFO mode is disabled, the last received data can be accessed through software by reading this register.
N     * |        |          |If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive
N     * |        |          |FIFO buffer can be accessed through software by reading this register. This is a read-only register.
N     */
N    __I  uint32_t RX;
X    volatile const  uint32_t RX;
N
N    __I  uint32_t RESERVE1;
X    volatile const  uint32_t RESERVE1;
N    __I  uint32_t RESERVE2;
X    volatile const  uint32_t RESERVE2;
N    __I  uint32_t RESERVE3;
X    volatile const  uint32_t RESERVE3;
N
N    /**
N     * SPI_TX
N     * ===================================================================================================
N     * Offset: 0x20  Data Transmit Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |TX        |Data Transmit Register
N     * |        |          |The data transmit registers hold the data to be transmitted in the next transfer.
N     * |        |          |The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.
N     * |        |          |For example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer.
N     * |        |          |If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.
N     * |        |          |Note 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI
N     * |        |          |        controller attempts to transmit data to a master, the transmit data register should be updated
N     * |        |          |        by software before setting the GO_BUSY bit to 1.
N     * |        |          |Note 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles after user writes to this register.
N     */
N    __O  uint32_t TX;
X    volatile  uint32_t TX;
N
N    __I  uint32_t RESERVE4;
X    volatile const  uint32_t RESERVE4;
N    __I  uint32_t RESERVE5;
X    volatile const  uint32_t RESERVE5;
N    __I  uint32_t RESERVE6;
X    volatile const  uint32_t RESERVE6;
N    __I  uint32_t RESERVE7;
X    volatile const  uint32_t RESERVE7;
N
N    /**
N     * SPI_VARCLK
N     * ===================================================================================================
N     * Offset: 0x34  Variable Clock Pattern Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |VARCLK    |Variable Clock Pattern
N     * |        |          |This register defines the clock pattern of the SPI transfer.
N     * |        |          |If the variable clock function is disabled, this setting is unmeaning.
N     */
N    __IO uint32_t VARCLK;
X    volatile uint32_t VARCLK;
N
N    __I  uint32_t RESERVE8;
X    volatile const  uint32_t RESERVE8;
N
N    /**
N     * SPI_CNTRL2
N     * ===================================================================================================
N     * Offset: 0x3C  Control and Status Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |NOSLVSEL  |Slave 3-Wire Mode Enable
N     * |        |          |This is used to ignore the slave select signal in Slave mode.
N     * |        |          |The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.
N     * |        |          |0 = 4-wire bi-direction interface.
N     * |        |          |1 = 3-wire bi-direction interface.
N     * |        |          |Note: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.
N     * |[9]     |SLV_ABORT |Slave 3-Wire Mode Abort Control
N     * |        |          |In normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.
N     * |        |          |If the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in
N     * |        |          |Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event.
N     * |        |          |Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.
N     * |[10]    |SSTA_INTEN|Slave 3-Wire Mode Start Interrupt Enable
N     * |        |          |Used to enable interrupt when the transfer has started in Slave 3-wire mode.
N     * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the transfer start,
N     * |        |          |the user can set the SLV_ABORT bit to force the transfer done.
N     * |        |          |0 = Transaction start interrupt Disabled.
N     * |        |          |1 = Transaction start interrupt Enabled.
N     * |        |          |It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared.
N     * |[11]    |SLV_START_INTSTS|Slave 3-Wire Mode Start Interrupt Status
N     * |        |          |This bit indicates if a transaction has started in Slave 3-wire mode.
N     * |        |          |It is a mutual mirror bit of SPI_STATUS[11].
N     * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
N     * |        |          |1 = A transaction has started in Slave 3-wire mode.
N     * |        |          |It will be cleared automatically when a transaction is done or by writing 1 to this bit.
N     * |[12]    |DUAL_IO_DIR|Dual I/O Mode Direction Control
N     * |        |          |0 = Dual Input mode.
N     * |        |          |1 = Dual Output mode.
N     * |[13]    |DUAL_IO_EN|Dual I/O Mode Enable
N     * |        |          |0 = Dual I/O mode Disabled.
N     * |        |          |1 = Dual I/O mode Enabled.
N     * |[16]    |SS_INT_OPT|Slave Select Inactive Interrupt Option
N     * |        |          |This setting is only available if the SPI controller is configured as level trigger slave device.
N     * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
N     * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
N     * |[31]    |BCn       |SPI Peripheral Clock Backward Compatible Option
N     * |        |          |0 = Backward compatible clock configuration.
N     * |        |          |1 = Clock configuration is not backward compatible.
N     * |        |          |Refer to the description of SPI_DIVIDER register for details.
N     */
N    __IO uint32_t CNTRL2;
X    volatile uint32_t CNTRL2;
N
N    /**
N     * SPI_FIFO_CTL
N     * ===================================================================================================
N     * Offset: 0x40  SPI FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_CLR    |Clear Receive FIFO Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear receive FIFO buffer.
N     * |        |          |The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1.
N     * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
N     * |[1]     |TX_CLR    |Clear Transmit FIFO Buffer
N     * |        |          |0 = No effect.
N     * |        |          |1 = Clear transmit FIFO buffer.
N     * |        |          |The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1.
N     * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
N     * |[2]     |RX_INTEN  |Receive Threshold Interrupt Enable
N     * |        |          |0 = RX threshold interrupt Disabled.
N     * |        |          |1 = RX threshold interrupt Enabled.
N     * |[3]     |TX_INTEN  |Transmit Threshold Interrupt Enable
N     * |        |          |0 = TX threshold interrupt Disabled.
N     * |        |          |1 = TX threshold interrupt Enabled.
N     * |[6]     |RXOV_INTEN|Receive FIFO Overrun Interrupt Enable
N     * |        |          |0 = Receive FIFO overrun interrupt Disabled.
N     * |        |          |1 = Receive FIFO overrun interrupt Enabled.
N     * |[21]    |TIMEOUT_INTEN|Receive FIFO Time-Out Interrupt Enable
N     * |        |          |0 = Time-out interrupt Disabled.
N     * |        |          |1 = Time-out interrupt Enabled.
N     * |[26:24] |RX_THRESHOLD|Receive FIFO Threshold
N     * |        |          |If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting,
N     * |        |          |the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
N     * |[30:28] |TX_THRESHOLD|Transmit FIFO Threshold
N     * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD
N     * |        |          |setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
N     */
N    __IO uint32_t FIFO_CTL;
X    volatile uint32_t FIFO_CTL;
N
N    /**
N     * SPI_STATUS
N     * ===================================================================================================
N     * Offset: 0x44  SPI Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_INTSTS |Receive FIFO Threshold Interrupt Status (Read Only)
N     * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD.
N     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD.
N     * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
N     * |[2]     |RX_OVERRUN|Receive FIFO Overrun Status
N     * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[4]     |TX_INTSTS |Transmit FIFO Threshold Interrupt Status (Read Only)
N     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD.
N     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD.
N     * |        |          |Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
N     * |[11]    |SLV_START_INTSTS|Slave Start Interrupt Status
N     * |        |          |It is used to dedicate if a transaction has started in Slave 3-wire mode.
N     * |        |          |It is a mutual mirror bit of SPI_CNTRL2[11].
N     * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
N     * |        |          |1 = A transaction has started in Slave 3-wire mode.
N     * |        |          |It will be cleared as a transaction is done or by writing 1 to this bit.
N     * |[15:12] |RX_FIFO_COUNT|Receive FIFO Data Count (Read Only)
N     * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
N     * |[16]    |IF        |SPI Unit Transfer Interrupt Flag
N     * |        |          |It is a mutual mirror bit of SPI_CNTRL[16].
N     * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N     * |        |          |1 = SPI controller has finished one unit transfer.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[20]    |TIMEOUT   |Time-Out Interrupt Flag
N     * |        |          |0 = No receive FIFO time-out event.
N     * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock
N     * |        |          |period in Master mode or over 576 SPI peripheral clock period in Slave mode.
N     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
N     * |        |          |Note: This bit will be cleared by writing 1 to itself.
N     * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |It is a mutual mirror bit of SPI_CNTRL[24].
N     * |        |          |0 = Receive FIFO buffer is not empty.
N     * |        |          |1 = Receive FIFO buffer is empty.
N     * |[25]    |RX_FULL   |Receive FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |It is a mutual mirror bit of SPI_CNTRL[25].
N     * |        |          |0 = Receive FIFO buffer is not empty.
N     * |        |          |1 = Receive FIFO buffer is empty.
N     * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
N     * |        |          |It is a mutual mirror bit of SPI_CNTRL[26].
N     * |        |          |0 = Transmit FIFO buffer is not empty.
N     * |        |          |1 = Transmit FIFO buffer is empty.
N     * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
N     * |        |          |It is a mutual mirror bit of SPI_CNTRL[27].
N     * |        |          |0 = Transmit FIFO buffer is not full.
N     * |        |          |1 = Transmit FIFO buffer is full.
N     * |[31:28] |TX_FIFO_COUNT|Transmit FIFO Data Count (Read Only)
N     * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
N     */
N    __IO uint32_t STATUS;
X    volatile uint32_t STATUS;
N} SPI_T;
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N
N/* SPI_CNTRL Bit Field Definitions */
N#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI_T::CNTRL: TX_FULL Position */
N#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI_T::CNTRL: TX_FULL Mask     */
N
N#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI_T::CNTRL: TX_EMPTY Position */
N#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI_T::CNTRL: TX_EMPTY Mask     */
N
N#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI_T::CNTRL: RX_FULL Position */
N#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI_T::CNTRL: RX_FULL Mask     */
N
N#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI_T::CNTRL: RX_EMPTY Position */
N#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI_T::CNTRL: RX_EMPTY Mask     */
N
N#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI_T::CNTRL: VARCLK_EN Position */
N#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI_T::CNTRL: VARCLK_EN Mask     */
N
N#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI_T::CNTRL: FIFO Position */
N#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI_T::CNTRL: FIFO Mask     */
N
N#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI_T::CNTRL: REORDER Position */
N#define SPI_CNTRL_REORDER_Msk      (1ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI_T::CNTRL: REORDER Mask     */
N
N#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI_T::CNTRL: SLAVE Position */
N#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI_T::CNTRL: SLAVE Mask     */
N
N#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI_T::CNTRL: IE Position */
N#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI_T::CNTRL: IE Mask     */
N
N#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI_T::CNTRL: IF Position */
N#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI_T::CNTRL: IF Mask     */
N
N#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI_T::CNTRL: SP_CYCLE Position */
N#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI_T::CNTRL: SP_CYCLE Mask     */
N
N#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI_T::CNTRL: CLKP Position */
N#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI_T::CNTRL: CLKP Mask     */
N
N#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI_T::CNTRL: LSB Position */
N#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI_T::CNTRL: LSB Mask     */
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI_T::CNTRL: TX_BIT_LEN Position */
N#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI_T::CNTRL: TX_BIT_LEN Mask     */
N
N#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI_T::CNTRL: TX_NEG Position */
N#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI_T::CNTRL: TX_NEG Mask     */
N
N#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI_T::CNTRL: RX_NEG Position */
N#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI_T::CNTRL: RX_NEG Mask     */
N
N#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI_T::CNTRL: GO_BUSY Position */
N#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI_T::CNTRL: GO_BUSY Mask     */
N
N/* SPI_DIVIDER Bit Field Definitions */
N#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI_T::DIVIDER: DIVIDER2 Position */
N#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI_T::DIVIDER: DIVIDER2 Mask */
N
N#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI_T::DIVIDER: DIVIDER Position */
N#define SPI_DIVIDER_DIVIDER_Msk    (0xFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI_T::DIVIDER: DIVIDER Mask */
N
N/* SPI_SSR Bit Field Definitions */
N#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI_T::SSR: LTRIG_FLAG Position */
N#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI_T::SSR: LTRIG_FLAG Mask */
N
N#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI_T::SSR: SS_LTRIG Position */
N#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI_T::SSR: SS_LTRIG Mask */
N
N#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI_T::SSR: AUTOSS Position */
N#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI_T::SSR: AUTOSS Mask */
N
N#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI_T::SSR: SS_LVL Position */
N#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI_T::SSR: SS_LVL Mask */
N
N#define SPI_SSR_SSR_Pos            0                                 /*!< SPI_T::SSR: SSR Position */
N#define SPI_SSR_SSR_Msk            (1ul << SPI_SSR_SSR_Pos)          /*!< SPI_T::SSR: SSR Mask */
N
N/* SPI_CNTRL2 Bit Field Definitions */
N#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI_T::CNTRL2: BCn Position */
N#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI_T::CNTRL2: BCn Mask */
N
N#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI_T::CNTRL2: SS_INT_OPT Position */
N#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI_T::CNTRL2: SS_INT_OPT Mask */
N
N#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI_T::CNTRL2: DUAL_IO_EN Position */
N#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI_T::CNTRL2: DUAL_IO_EN Mask */
N
N#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI_T::CNTRL2: DUAL_IO_DIR Position */
N#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI_T::CNTRL2: DUAL_IO_DIR Mask */
N
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::CNTRL2: SLV_START_INTSTS Position */
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI_T::CNTRL2: SLV_START_INTSTS Mask */
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI_T::CNTRL2: SSTA_INTEN Position */
N#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI_T::CNTRL2: SSTA_INTEN Mask */
N
N#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI_T::CNTRL2: SLV_ABORT Position */
N#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI_T::CNTRL2: SLV_ABORT Mask */
N
N#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI_T::CNTRL2: NOSLVSEL Position */
N#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI_T::CNTRL2: NOSLVSEL Mask */
N
N/* SPI_FIFO_CTL Bit Field Definitions */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Position */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Position */
N#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Position */
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Mask */
N
N#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI_T::FIFO_CTL: RXOV_INTEN Position */
N#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI_T::FIFO_CTL: RXOV_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI_T::FIFO_CTL: TX_INTEN Position */
N#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: TX_INTEN Mask */
N
N#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI_T::FIFO_CTL: RX_INTEN Position */
N#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: RX_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI_T::FIFO_CTL: TX_CLR Position */
N#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI_T::FIFO_CTL: TX_CLR Mask */
N
N#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI_T::FIFO_CTL: RX_CLR Position */
N#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI_T::FIFO_CTL: RX_CLR Mask */
N
N/* SPI_STATUS Bit Field Definitions */
N#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI_T::STATUS: TX_FIFO_COUNT Position */
N#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: TX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI_T::STATUS: TX_FULL Position */
N#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI_T::STATUS: TX_FULL Mask */
N
N#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI_T::STATUS: TX_EMPTY Position */
N#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI_T::STATUS: TX_EMPTY Mask */
N
N#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI_T::STATUS: RX_FULL Position */
N#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI_T::STATUS: RX_FULL Mask */
N
N#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI_T::STATUS: RX_EMPTY Position */
N#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI_T::STATUS: RX_EMPTY Mask */
N
N#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI_T::STATUS: TIMEOUT Position */
N#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI_T::STATUS: TIMEOUT Mask */
N
N#define SPI_STATUS_IF_Pos   16                                                       /*!< SPI_T::STATUS: IF Position */
N#define SPI_STATUS_IF_Msk   (1ul << SPI_STATUS_IF_Pos)                               /*!< SPI_T::STATUS: IF Mask     */
N
N#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI_T::STATUS: RX_FIFO_COUNT Position */
N#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: RX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::STATUS: SLV_START_INTSTS Position */
N#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI_T::STATUS: SLV_START_INTSTS Mask */
N
N#define SPI_STATUS_TX_INTSTS_Pos   4                                                 /*!< SPI_T::STATUS: TX_INTSTS Position */
N#define SPI_STATUS_TX_INTSTS_Msk   (1ul << SPI_STATUS_TX_INTSTS_Pos)                 /*!< SPI_T::STATUS: TX_INTSTS Mask */
N
N#define SPI_STATUS_RX_OVERRUN_Pos   2                                                /*!< SPI_T::STATUS: RX_OVERRUN Position */
N#define SPI_STATUS_RX_OVERRUN_Msk   (1ul << SPI_STATUS_RX_OVERRUN_Pos)               /*!< SPI_T::STATUS: RX_OVERRUN Mask */
N
N#define SPI_STATUS_RX_INTSTS_Pos   0                                                 /*!< SPI_T::STATUS: RX_INTSTS Position */
N#define SPI_STATUS_RX_INTSTS_Msk   (1ul << SPI_STATUS_RX_INTSTS_Pos)                 /*!< SPI_T::STATUS: RX_INTSTS Mask */
N/*@}*/ /* end of group SPI_CONST */
N/*@}*/ /* end of group SPI */
N
N
N
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller (SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
Ntypedef struct
N{
N
N    /**
N     * PDID
N     * ===================================================================================================
N     * Offset: 0x00  Part Device Identification Number Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |PDID      |Part Device Identification Number
N     * |        |          |This register reflects device part number code.
N     * |        |          |Software can read this register to identify which device is used.
N     */
N    __I uint32_t PDID;
X    volatile const uint32_t PDID;
N
N    /**
N     * RSTSRC
N     * ===================================================================================================
N     * Offset: 0x04  System Reset Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RSTS_POR  |Power-on Reset Flag
N     * |        |          |The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) controller or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.
N     * |        |          |0 = No reset from POR or CHIP_RST (IPRSTC1[0]).
N     * |        |          |1 = Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the system.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[1]     |RSTS_RESET|Reset Pin Reset Flag
N     * |        |          |The RSTS_RESET flag is set by the "Reset Signal" from the /RESET pin to indicate the previous reset source.
N     * |        |          |0 = No reset from /RESET pin.
N     * |        |          |1 = The Pin /RESET had issued the reset signal to reset the system.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[2]     |RSTS_WDT  |Watchdog Reset Flag
N     * |        |          |The RSTS_WDT flag is set by The "Reset Signal" from the Watchdog Timer to indicate the previous reset source
N     * |        |          |0 = No reset from watchdog timer.
N     * |        |          |1 = The watchdog timer had issued the reset signal to reset the system.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[3]     |RSTS_LVR  |Low Voltage Reset Flag
N     * |        |          |The RSTS_LVR flag Is Set By The "Reset Signal" From The Low-Voltage-Reset Controller To Indicate The Previous Reset Source
N     * |        |          |0 = No reset from LVR.
N     * |        |          |1 = The LVR controller had issued the reset signal to reset the system.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[4]     |RSTS_BOD  |Brown-out Detector Reset Flag
N     * |        |          |The RSTS_BOD flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the previous reset source.
N     * |        |          |0 = No reset from BOD.
N     * |        |          |1 = The BOD had issued the reset signal to reset the system.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[5]     |RSTS_SYS  |SYS Reset Flag
N     * |        |          |The RSTS_SYS flag is set by the "Reset Signal" from the Cortex-M0 kernel to indicate the previous reset source.
N     * |        |          |0 = No reset from Cortex-M0.
N     * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 kernel.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[7]     |RSTS_CPU  |CPU Reset Flag
N     * |        |          |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and flash. Memory Controller (FMC)
N     * |        |          |0 = No reset from CPU.
N     * |        |          |1 = Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     */
N    __IO uint32_t RSTSRC;
X    volatile uint32_t RSTSRC;
N
N    /**
N     * IPRSTC1
N     * ===================================================================================================
N     * Offset: 0x08  IP Reset Control Register 1
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |CHIP_RST  |CHIP One-Shot Reset (Write Protect)
N     * |        |          |Setting this bit will reset the whole chip, including CPU kernel and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
N     * |        |          |The CHIP_RST is the same as the POR reset, all the chip controllers are reset and the chip setting from flash are also reload.
N     * |        |          |0 = CHIP normal operation.
N     * |        |          |1 = CHIP one-shot reset.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[1]     |CPU_RST   |CPU Kernel One-Shot Reset (Write Protect)
N     * |        |          |Setting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit will automatically return 0 after the two clock cycles
N     * |        |          |0 = CPU normal operation.
N     * |        |          |1 = CPU one-shot reset.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     */
N    __IO uint32_t IPRSTC1;
X    volatile uint32_t IPRSTC1;
N
N    /**
N     * IPRSTC2
N     * ===================================================================================================
N     * Offset: 0x0C  IP Reset Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |GPIO_RST  |GPIO Controller Reset
N     * |        |          |0 = GPIO controller normal operation.
N     * |        |          |1 = GPIO controller reset.
N     * |[2]     |TMR0_RST  |Timer0 Controller Reset
N     * |        |          |0 = Timer0 controller normal operation.
N     * |        |          |1 = Timer0 controller reset.
N     * |[3]     |TMR1_RST  |Timer1 Controller Reset
N     * |        |          |0 = Timer1 controller normal operation.
N     * |        |          |1 = Timer1 controller reset.
N     * |[4]     |TMR2_RST  |Timer2 Controller Reset
N     * |        |          |0 = Timer2 controller normal operation.
N     * |        |          |1 = Timer2 controller reset.
N     * |[5]     |TMR3_RST  |Timer3 Controller Reset
N     * |        |          |0 = Timer3 controller normal operation.
N     * |        |          |1 = Timer3 controller reset.
N     * |[8]     |I2C0_RST  |I2C0 Controller Reset
N     * |        |          |0 = I2C0 controller normal operation.
N     * |        |          |1 = I2C0 controller reset.
N     * |[9]     |I2C1_RST  |I2C1 Controller Reset
N     * |        |          |0 = I2C1 controller normal operation.
N     * |        |          |1 = I2C1 controller reset.
N     * |[12]    |SPI0_RST  |SPI0 Controller Reset
N     * |        |          |0 = SPI0 controller normal operation.
N     * |        |          |1 = SPI0 controller reset.
N     * |[16]    |UART0_RST |UART0 Controller Reset
N     * |        |          |0 = UART0 controller normal operation.
N     * |        |          |1 = UART0 controller reset.
N     * |[17]    |UART1_RST |UART1 Controller Reset
N     * |        |          |0 = UART1 controller normal operation.
N     * |        |          |1 = UART1 controller reset.
N     * |[18]    |UART2_RST |UART2 Controller Reset
N     * |        |          |0 = UART2 controller normal operation.
N     * |        |          |1 = UART2 controller reset.
N     * |[24]    |CAN0_RST  |CAN0 Controller Reset
N     * |        |          |0 = CAN0 controller normal operation.
N     * |        |          |1 = CAN0 controller reset.     
N     * |[28]    |ADC_RST   |ADC Controller Reset
N     * |        |          |0 = ADC controller normal operation.
N     * |        |          |1 = ADC controller reset.
N     */
N    __IO uint32_t IPRSTC2;
X    volatile uint32_t IPRSTC2;
N
N    /**
N     * IPRSTC3
N     * ===================================================================================================
N     * Offset: 0x10  Peripheral Reset Control Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[8]     |UART3_RST |UART3 Controller Reset
N     * |        |          |0 = UART3 controller normal operation.
N     * |        |          |1 = UART3 controller reset.
N     * |[9]     |UART4_RST |UART4 Controller Reset
N     * |        |          |0 = UART4 controller normal operation.
N     * |        |          |1 = UART4 controller reset.
N     * |[10]    |UART5_RST |UART5 Controller Reset
N     * |        |          |0 = UART5 controller normal operation.
N     * |        |          |1 = UART5 controller reset.
N     * |[16]    |PWM0_RST  |PWM0 Controller Reset
N     * |        |          |0 = PWM0 controller normal operation.
N     * |        |          |1 = PWM0 controller reset.
N     * |[17]    |PWM1_RST  |PWM1 Controller Reset
N     * |        |          |0 = PWM1 controller normal operation.
N     * |        |          |1 = PWM1 controller reset.
N     * |[18]    |BPWM0_RST |BPWM0 Controller Reset
N     * |        |          |0 = BPWM0 controller normal operation.
N     * |        |          |1 = BPWM0 controller reset.
N     * |[19]    |BPWM1_RST |BPWM1 Controller Reset
N     * |        |          |0 = BPWM1 controller normal operation.
N     * |        |          |1 = BPWM1 controller reset.
N     */
N    __IO uint32_t IPRSTC3;
X    volatile uint32_t IPRSTC3;
N
N    uint32_t RESERVE0;
N
N    /**
N     * BODCR
N     * ===================================================================================================
N     * Offset: 0x18  Brown-out Detector Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |BOD_EN    |Brown-Out Detector Enable Bit (Write Protect)
N     * |        |          |The default value is set by flash memory controller user configuration register CBODEN (CONFIG0[23]) bit.
N     * |        |          |0 = Brown-out Detector function Disabled.
N     * |        |          |1 = Brown-out Detector function Enabled.
N     * |        |          |Note: This bit is the protected bit.
N     * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[2:1]   |BOD_VL    |Brown-Out Detector Threshold Voltage Selection (Write Protect)
N     * |        |          |The default value is set by flash memory controller user configuration register CBOV (CONFIG0[22:21]) bit.
N     * |        |          |00 = Brown-out voltage is 2.2V.
N     * |        |          |01 = Brown-out voltage is 2.7V.
N     * |        |          |10 = Brown-out voltage is 3.7V.
N     * |        |          |11 = Brown-out voltage is 4.4V.
N     * |        |          |Note: This bit is the protected bit.
N     * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[3]     |BOD_RSTEN |Brown-Out Reset Enable Bit (Write Protect)
N     * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
N     * |        |          |1 = Brown-out "RESET" function Enabled.
N     * |        |          |While the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BOD_OUT high).
N     * |        |          |Note1: While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high.
N     * |        |          |BOD interrupt will keep till to the BOD_EN set to 0.
N     * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).
N     * |        |          |Note2: The default value is set by flash controller user configuration register CBORST (CONFIG0[20]) bit.
N     * |        |          |Note3: This bit is the protected bit.
N     * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[4]     |BOD_INTF  |Brown-Out Detector Interrupt Flag
N     * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting.
N     * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled.
N     * |        |          |Note: Write 1 to clear this bit to 0.
N     * |[5]     |BOD_LPM   |Brown-Out Detector Low Power Mode (Write Protect)
N     * |        |          |0 = BOD operated in Normal mode (default).
N     * |        |          |1 = BOD Low Power mode Enabled.
N     * |        |          |Note1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the current to about 1/10 but slow the BOD response.
N     * |        |          |Note2: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[6]     |BOD_OUT   |Brown-Out Detector Output Status
N     * |        |          |0 = Brown-out Detector output status is 0.
N     * |        |          |It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0.
N     * |        |          |1 = Brown-out Detector output status is 1.
N     * |        |          |It means the detected voltage is lower than BOD_VL setting.
N     * |        |          |If the BOD_EN is 0, BOD function disabled, this bit always responds to 0.
N     * |[7]     |LVR_EN    |Low Voltage Reset Enable Bit (Write Protect)
N     * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting.
N     * |        |          |LVR function is enabled by default.
N     * |        |          |0 = Low Voltage Reset function Disabled.
N     * |        |          |1 = Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[10:8]  |BODDGSEL  |Brown-Out Detector Output De-Glitch Time Select (Write Protect)
N     * |        |          |000 = BOD output is sampled by RC10K clock.
N     * |        |          |001 = 4 system clock (HCLK).
N     * |        |          |010 = 8 system clock (HCLK).
N     * |        |          |011 = 16 system clock (HCLK).
N     * |        |          |100 = 32 system clock (HCLK).
N     * |        |          |101 = 64 system clock (HCLK).
N     * |        |          |110 = 128 system clock (HCLK).
N     * |        |          |111 = 256 system clock (HCLK).
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     * |[14:12] |LVRDGSEL  |LVR Output De-Glitch Time Select (Write Protect)
N     * |        |          |000 = Without de-glitch function.
N     * |        |          |001 = 4 system clock (HCLK).
N     * |        |          |010 = 8 system clock (HCLK).
N     * |        |          |011 = 16 system clock (HCLK).
N     * |        |          |100 = 32 system clock (HCLK).
N     * |        |          |101 = 64 system clock (HCLK).
N     * |        |          |110 = 128 system clock (HCLK).
N     * |        |          |111 = 256 system clock (HCLK).
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     */
N    __IO uint32_t BODCR;
X    volatile uint32_t BODCR;
N
N    uint32_t RESERVE1[2];
N
N    /**
N     * PORCR
N     * ===================================================================================================
N     * Offset: 0x24  Power-on-Reset Controller Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |POR_DIS_CODE|Power-On-Reset Enable Control (Write Protect)
N     * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
N     * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
N     * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
N     * |        |          |/RESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function
N     * |        |          |Note: This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.
N     */
N    __IO uint32_t PORCR;
X    volatile uint32_t PORCR;
N
N    /**
N     * VREFCR
N     * ===================================================================================================
N     * Offset: 0x28  VREF Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |ADC_VREFSEL|ADC VREF Path Control (Write Protect)
N     * |        |          |0 = ADC VREF is from VREF pin.
N     * |        |          |1 = ADC VREF is from AVDD.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.
N     */
N    __IO uint32_t VREFCR;
X    volatile uint32_t VREFCR;
N
N    uint32_t RESERVE2[1];
N
N    /**
N     * GPA_MFP
N     * ===================================================================================================
N     * Offset: 0x30  GPIOA Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GPA_MFP0  |PA.0 Pin Function Selection
N     * |        |          |Bits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.
N     * |        |          |(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = ADC0 function is selected.
N     * |        |          |(0, 0, 1, 1) = I2C1_SCL function is selected.
N     * |        |          |(0, 1, 0, 1) = UART5_TXD function is selected.
N     * |        |          |(1, 0, 0, 1) = PWM0_CH4 function is selected.
N     * |[1]     |GPA_MFP1  |PA.1 Pin Function Selection
N     * |        |          |Bits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.
N     * |        |          |(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N     * |        |          |(0, 0, 1, 1) = I2C1_SDA function is selected.
N     * |        |          |(0, 1, 0, 1) = UART5_RXD function is selected.
N     * |        |          |(1, 0, 0, 1) = PWM0_CH5 function is selected.
N     * |[2]     |GPA_MFP2  |PA.2 Pin Function Selection
N     * |        |          |Bits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.
N     * |        |          |(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC2 function is selected.
N     * |        |          |(0, 1, 1) = UART3_TXD function is selected.
N     * |        |          |(1, 0, 1) = PWM1_CH0 function is selected.
N     * |[3]     |GPA_MFP3  |PA.3 Pin Function Selection
N     * |        |          |Bits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.
N     * |        |          |(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC3 function is selected.
N     * |        |          |(0, 1, 1) = UART3_RXD function is selected.
N     * |        |          |(1, 0, 1) = PWM1_CH1 function is selected.
N     * |[4]     |GPA_MFP4  |PA.4 Pin Function Selection
N     * |        |          |Bit GPA_MFP4 determines the PA.4 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = ADC4 function is selected.
N     * |[5]     |GPA_MFP5  |PA.5 Pin Function Selection
N     * |        |          |Bits PA5_UR3RXD (ALT_MFP4[4]) and GPA_MFP5 determine the PA.5 function.
N     * |        |          |(PA5_UR3RXD, GPA_MFP5) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC5 function is selected.
N     * |        |          |(1, 1) = UART3_RXD function is selected.
N     * |[6]     |GPA_MFP6  |PA.6 Pin Function Selection
N     * |        |          |Bits PA6_UR3TXD (ALT_MFP4[5]) and GPA_MFP6 determine the PA.6 function.
N     * |        |          |(PA6_UR3TXD, GPA_MFP6) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC6 function is selected.
N     * |        |          |(1, 1) = UART3_TXD function is selected.
N     * |[7]     |GPA_MFP7  |PA.7 Pin Function Selection
N     * |        |          |Bits PA7_VREF (ALT_MFP4[14]) and GPA_MFP7 determine the PA.7 function.
N     * |        |          |(PA7_VREF, GPA_MFP7) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC7 function is selected.
N     * |        |          |(1, 1) = Vref function is selected.
N     * |[8]     |GPA_MFP8  |PA.8 Pin Function Selection
N     * |        |          |Bits PA8_UR1RTS (ALT_MFP4[0]) and GPA_MFP8 determine the PA.8 function.
N     * |        |          |(PA8_UR1RTS, GPA_MFP8) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C0_SDA function is selected.
N     * |        |          |(1, 1) = UART1_nRTS function is selected.
N     * |[9]     |GPA_MFP9  |PA.9 Pin Function Selection
N     * |        |          |Bits PA9_UR1CTS (ALT_MFP4[1]) and GPA_MFP9 determine the PA.9 function.
N     * |        |          |(PA9_UR1CTS, GPA_MFP9) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C0_SCL function is selected.
N     * |        |          |(1, 1) = UART1_nCTS function is selected.
N     * |[10]    |GPA_MFP10 |PA.10 Pin Function Selection
N     * |        |          |Bits PA10_PWM12 (ALT_MFP3[8]) and GPA_MFP10 determine the PA.10 function.
N     * |        |          |(PA10_PWM12, GPA_MFP10) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C1_SDA function is selected.
N     * |        |          |(1, 1) = PWM1_CH2 function is selected.
N     * |[11]    |GPA_MFP11 |PA.11 Pin Function Selection
N     * |        |          |Bits PA11_PWM13 (ALT_MFP3[9]) and GPA_MFP11 determine the PA.11 function.
N     * |        |          |(PA11_PWM13, GPA_MFP11) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C1_SCL function is selected.
N     * |        |          |(1, 1) = PWM1_CH3 function is selected.
N     * |[12]    |GPA_MFP12 |PA.12 Pin Function Selection
N     * |        |          |Bits PA12_UR5RXD (ALT_MFP4[8]) and GPA_MFP12 determine the PA.12 function.
N     * |        |          |(PA12_UR5RXD, GPA_MFP12) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = PWM0_CH0 function is selected.
N     * |        |          |(1, 1) = UART5_RXD function is selected.
N     * |[13]    |GPA_MFP13 |PA.13 Pin Function Selection
N     * |        |          |Bits PA13_UR5TXD (ALT_MFP4[9]) and GPA_MFP13 determine the PA.13 function.
N     * |        |          |(PA13_UR5TXD, GPA_MFP13) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = PWM0_CH1 function is selected.
N     * |        |          |(1, 1) = UART5_TXD function is selected.
N     * |[14]    |GPA_MFP14 |PA.14 Pin Function Selection
N     * |        |          |Bit GPA_MFP14 determines the PA.14 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = PWM0_CH2 function is selected.
N     * |[15]    |GPA_MFP15 |PA.15 Pin Function Selection
N     * |        |          |Bit GPA_MFP15 determines the PA.15 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = PWM0_CH3 function is selected.
N     * |[31:16] |GPA_TYPEn |Trigger Function Selection
N     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger function Enabled.
N     */
N    __IO uint32_t GPA_MFP;
X    volatile uint32_t GPA_MFP;
N
N    /**
N     * GPB_MFP
N     * ===================================================================================================
N     * Offset: 0x34  GPIOB Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GPB_MFP0  |PB.0 Pin Function Selection
N     * |        |          |Bit GPB_MFP0 determines the PB.0 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = UART0_RXD function is selected.
N     * |[1]     |GPB_MFP1  |PB.1 Pin Function Selection
N     * |        |          |Bit GPB_MFP1 determines the PB.1 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = UART0_TXD function is selected.
N     * |[2]     |GPB_MFP2  |PB.2 Pin Function Selection
N     * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.
N     * |        |          |(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N     * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE1 function is selected.
N     * |        |          |(1, 0, 0, 1) = TM2 function is selected.
N     * |[3]     |GPB_MFP3  |PB.3 Pin Function Selection
N     * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.
N     * |        |          |(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
N     * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
N     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE0 function is selected.
N     * |        |          |(1, 0, 0, 1) = TM3 function is selected.
N     * |[4]     |GPB_MFP4  |PB.4 Pin Function Selection
N     * |        |          |Bit GPB_MFP4 determines the PB.4 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = UART1_RXD function is selected.
N     * |[5]     |GPB_MFP5  |PB 5 Pin Function Selection
N     * |        |          |Bit GPB_MFP5 determines the PB.5 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = UART1_TXD function is selected.
N     * |[6]     |GPB_MFP6  |PB.6 Pin Function Selection
N     * |        |          |Bit GPB_MFP6 determines the PB.6 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = UART1_nRTS function is selected.
N     * |[7]     |GPB_MFP7  |PB.7 Pin Function Selection
N     * |        |          |Bit GPB_MFP7 determines the PB.7 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = UART1_nCTS function is selected.
N     * |[8]     |GPB_MFP8  |PB.8 Pin Function Selection
N     * |        |          |Bits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.
N     * |        |          |(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = TM0 function is selected.
N     * |        |          |(0, 1, 1) = CLKO function is selected.
N     * |        |          |(1, 0, 1) = BPWM1_CH2 function is selected.
N     * |[9]     |GPB_MFP9  |PB.9 Pin Function Selection
N     * |        |          |Bit GPB_MFP9 determines the PB.9 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = TM1 function is selected.
N     * |[10]    |GPB_MFP10 |PB.10 Pin Function Selection
N     * |        |          |Bit GPB_MFP10 determines the PB.10 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = TM2 function is selected.
N     * |[11]    |GPB_MFP11 |PB.11 Pin Function Selection
N     * |        |          |Bits PB11_PWM04 (ALT_MFP3[24]) and GPB_MFP11 determine the PB.11 function.
N     * |        |          |(PB11_PWM04, GPB_MFP11) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = TM3 function is selected.
N     * |        |          |(1, 1) = PWM0_CH4 function is selected.
N     * |[12]    |GPB_MFP12 |PB.12 Pin Function Selection
N     * |        |          |Bits PB12_BPWM13 (ALT_MFP3[21]) and GPB_MFP12 determine the PB.12 function.
N     * |        |          |(PB12_BPWM13, GPB_MFP12) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = CLKO function is selected.
N     * |        |          |(1, 1) = BPWM1_CH3 function is selected.
N     * |[14]    |GPB_MFP14 |PB.14 Pin Function Selection
N     * |        |          |Bit GPB_MFP14 determines the PB.14 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = INT0 function is selected.
N     * |[15]    |GPB_MFP15 |PB.15 Pin Function Selection
N     * |        |          |Bits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.
N     * |        |          |(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = INT1 function is selected.
N     * |        |          |(0, 0, 1, 1) = TM0 function is selected.
N     * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
N     * |        |          |(1, 0, 1, 1) = BPWM1_CH5 function is selected.
N     * |[31:16] |GPB_TYPEn |Trigger Function Selection
N     * |        |          |0 = GPIOB[15:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = GPIOB[15:0] I/O input Schmitt Trigger function Enabled.
N     */
N    __IO uint32_t GPB_MFP;
X    volatile uint32_t GPB_MFP;
N
N    /**
N     * GPC_MFP
N     * ===================================================================================================
N     * Offset: 0x38  GPIOC Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GPC_MFP0  |PC.0 Pin Function Selection
N     * |        |          |Bits PC0_BPWM00 (ALT_MFP3[12]) and GPC_MFP0 determine the PC.0 function.
N     * |        |          |(PC0_BPWM00, GPC_MFP0) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_SS0 function is selected.
N     * |        |          |(1, 1) = BPWM0_CH0 function is selected.
N     * |[1]     |GPC_MFP1  |PC.1 Pin Function Selection
N     * |        |          |Bits PC1_BPWM01 (ALT_MFP3[13]) and GPC_MFP1 determine the PC.1 function.
N     * |        |          |(PC1_BPWM01, GPC_MFP1) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_CLK function is selected.
N     * |        |          |(1, 1) = BPWM0_CH1 function is selected.
N     * |[2]     |GPC_MFP2  |PC.2 Pin Function Selection
N     * |        |          |Bits PC2_BPWM02 (ALT_MFP3[14]) and GPC_MFP2 determine the PC.2 function.
N     * |        |          |(PC2_BPWM02, GPC_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_MISO0 function is selected.
N     * |        |          |(1, 1) = BPWM0_CH2 function is selected.
N     * |[3]     |GPC_MFP3  |PC.3 Pin Function Selection
N     * |        |          |Bits PC3_BPWM03 (ALT_MFP3[15]) and GPC_MFP3 determine the PC.3 function.
N     * |        |          |(PC3_BPWM03, GPC_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
N     * |        |          |(1, 1) = BPWM0_CH3 function is selected.
N     * |[6]     |GPC_MFP6  |PC.6 Pin Function Selection
N     * |        |          |Bits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.
N     * |        |          |(PC6_PWM0BK0, PC6_I2C0SDA, GPC_MFP6) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = UART4_TXD function is selected.
N     * |        |          |(0, 1, 1) = I2C0_SDA function is selected.
N     * |        |          |(1, 0, 1) = PWM0_BRAKE0 function is selected.
N     * |[7]     |GPC_MFP7  |PC.7 Pin Function Selection
N     * |        |          |Bits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.
N     * |        |          |(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = UART4_RXD function is selected.
N     * |        |          |(0, 1, 1) = I2C0_SCL function is selected.
N     * |        |          |(1, 0, 1) = PWM0_BRAKE1 function is selected.
N     * |[8]     |GPC_MFP8  |PC.8 Pin Function Selection
N     * |        |          |Bit GPC_MFP8 determines the PC.8 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = PWM0_BRAKE0 function is selected.
N     * |[9]     |GPC_MFP9  |PC.9 Pin Function Selection
N     * |        |          |Bit GPC_MFP9 determines the PC.9 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = PWM0_BRAKE1 function is selected.
N     * |[10]    |GPC_MFP10 |PC.10 Pin Function Selection
N     * |        |          |Bit GPC_MFP10 determines the PC.10 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = PWM1_BRAKE0 function is selected.
N     * |[11]    |GPC_MFP11 |PC.11 Pin Function Selection
N     * |        |          |Bit GPC_MFP11 determines the PC.11 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = PWM1_BRAKE1 function is selected.
N     * |[31:16] |GPC_TYPEn |Trigger Function Selection
N     * |        |          |0 = GPIOC[15:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = GPIOC[15:0] I/O input Schmitt Trigger function Enabled.
N     */
N    __IO uint32_t GPC_MFP;
X    volatile uint32_t GPC_MFP;
N
N    /**
N     * GPD_MFP
N     * ===================================================================================================
N     * Offset: 0x3C  GPIOD Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[6]     |GPD_MFP6  |PD.6 Pin Function Selection
N     * |        |          |Bits PD6_BPWM11 (ALT_MFP3[19]) and GPD_MFP6 determine the PD.6 function.
N     * |        |          |(PD6_BPWM11, GPD_MFP6) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = CAN0_RXD function is selected.
N     * |        |          |(1, 1) = BPWM1_CH1 function is selected.
N     * |[7]     |GPD_MFP7  |PD.7 Pin Function Selection
N     * |        |          |Bits PD7_BPWM10 (ALT_MFP3[18]) and GPD_MFP7 determine the PD.7 function.
N     * |        |          |(PD7_BPWM10, GPD_MFP7) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = CAN0_TXD function is selected.
N     * |        |          |(1, 1) = BPWM1_CH0 function is selected.
N     * |[14]    |GPD_MFP14 |PD.14 Pin Function Selection
N     * |        |          |Bits PD14_BPWM05 (ALT_MFP3[17]) and GPD_MFP14 determine the PD.14 function.
N     * |        |          |(PD14_BPWM05, GPD_MFP14) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = UART2_RXD function is selected.
N     * |        |          |(1, 1) = BPWM0_CH5 function is selected.
N     * |[15]    |GPD_MFP15 |PD.15 Pin Function Selection
N     * |        |          |Bits PD15_BPWM04 (ALT_MFP3[16]) and GPD_MFP15 determine the PD.15 function.
N     * |        |          |(PD15_BPWM04, GPD_MFP15) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = UART2_TXD function is selected.
N     * |        |          |(1, 1) = BPWM0_CH4 function is selected.
N     * |[31:16] |GPD_TYPEn |Trigger Function Selection
N     * |        |          |0 = GPIOD[15:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = GPIOD[15:0] I/O input Schmitt Trigger function Enabled.
N     */
N    __IO uint32_t GPD_MFP;
X    volatile uint32_t GPD_MFP;
N
N    /**
N     * GPE_MFP
N     * ===================================================================================================
N     * Offset: 0x40  GPIOE Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5]     |GPE_MFP5  |PE.5 Pin Function Selection
N     * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
N     * |        |          |(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = PWM0_CH5 function is selected.
N     * |        |          |(0, 1, 1) = TM1 function is selected.
N     * |        |          |(1, 0, 1) = TM1_EXT function is selected.
N     * |[21]    |GPE_TYPE5 |Trigger Function Selection
N     * |        |          |0 = GPIOE[5] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = GPIOE[5] I/O input Schmitt Trigger function Enabled.
N     */
N    __IO uint32_t GPE_MFP;
X    volatile uint32_t GPE_MFP;
N
N    /**
N     * GPF_MFP
N     * ===================================================================================================
N     * Offset: 0x44  GPIOF Multiple Function and Input Type Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |GPF_MFP0  |PF.0 Pin Function Selection
N     * |        |          |Bit GPF_MFP0 determine the PF.0 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = XT1_OUT function is selected.
N     * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).
N     * |[1]     |GPF_MFP1  |PF.1 Pin Function Selection
N     * |        |          |Bit GPF_MFP1 determine the PF.1 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = XT1_IN function is selected.
N     * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).
N     * |[4]     |GPF_MFP4  |PF.4 Pin Function Selection
N     * |        |          |Bits PF4_PWM14 (ALT_MFP3[10]) and GPF_MFP4 determine the PF.4 function.
N     * |        |          |(PF4_PWM14, GPF_MFP4) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C0_SDA function is selected.
N     * |        |          |(1, 1) = PWM1_CH4 function is selected.
N     * |[5]     |GPF_MFP5  |PF.5 Pin Function Selection
N     * |        |          |Bits PF5_PWM15 (ALT_MFP3[11]) and GPF_MFP5 determine the PF.5 function.
N     * |        |          |(PF5_PWM15, GPF_MFP5) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C0_SCL function is selected.
N     * |        |          |(1, 1) = PWM1_CH5 function is selected.
N     * |[6]     |GPF_MFP6  |PF.6 Pin Function Selection
N     * |        |          |Bit GPF_MFP6 determines the PF.6 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = ICE_CLK function is selected.
N     * |[7]     |GPF_MFP7  |PF.7 Pin Function Selection
N     * |        |          |Bit GPF_MFP7 determines the PF.7 function.
N     * |        |          |0 = GPIO function is selected.
N     * |        |          |1 = ICE_DAT function is selected.
N     * |[8]     |GPF_MFP8  |PF.8 Pin Function Selection
N     * |        |          |Bits PF8_BPWM14 (ALT_MFP3[22]) and GPF_MFP8 determine the PF.8 function.
N     * |        |          |(PF8_BPWM14, GPF_MFP8) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = CLKO function is selected.
N     * |        |          |(1, 0) = BPWM1_CH4 function is selected.
N     * |[24:16] |GPF_TYPEn |Trigger Function Selection
N     * |        |          |0 = GPIOF[8:0] I/O input Schmitt Trigger function Disabled.
N     * |        |          |1 = GPIOF[8:0] I/O input Schmitt Trigger function Enabled.
N     */
N    __IO uint32_t GPF_MFP;
X    volatile uint32_t GPF_MFP;
N
N    uint32_t RESERVE3[2];
N
N    /**
N     * ALT_MFP
N     * ===================================================================================================
N     * Offset: 0x50  Alternative Multiple Function Pin Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[24]    |PB15_T0EX |PB.15 Pin Alternative Function Selection
N     * |        |          |Bits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.
N     * |        |          |(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = INT1 function is selected.
N     * |        |          |(0, 0, 1, 1) = TM0 function is selected.
N     * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
N     * |        |          |(1, 0, 1, 1) = BPWM1_CH5 function is selected.
N     * |[25]    |PE5_T1EX  |PE.5 Pin Alternative Function Selection
N     * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
N     * |        |          |(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = PWM0_CH5 function is selected.
N     * |        |          |(0, 1, 1) = TM1 function is selected.
N     * |        |          |(1, 0, 1) = TM1_EXT function is selected.
N     * |[26]    |PB2_T2EX  |PB.2 Pin Alternative Function Selection
N     * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.
N     * |        |          |(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N     * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE1 function is selected.
N     * |        |          |(1, 0, 0, 1) = TM2 function is selected.
N     * |[27]    |PB3_T3EX  |PB.3 Pin Alternative Function Selection
N     * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.
N     * |        |          |(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
N     * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
N     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE0 function is selected.
N     * |        |          |(1, 0, 0, 1) = TM3 function is selected.
N     * |[29]    |PB8_CLKO  |PB.8 Pin Alternative Function Selection
N     * |        |          |Bits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.
N     * |        |          |(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = TM0 function is selected.
N     * |        |          |(0, 1, 1) = CLKO function is selected.
N     * |        |          |(1, 0, 1) = BPWM1_CH2 function is selected.
N     */
N    __IO uint32_t ALT_MFP;
X    volatile uint32_t ALT_MFP;
N
N    uint32_t RESERVE4[2];
N
N    /**
N     * ALT_MFP2
N     * ===================================================================================================
N     * Offset: 0x5C  Alternative Multiple Function Pin Control Register 2
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[2]     |PB15_TM0  |PB.15 Pin Alternative Function Selection
N     * |        |          |Bits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.
N     * |        |          |(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = INT1 function is selected.
N     * |        |          |(0, 0, 1, 1) = TM0 function is selected.
N     * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
N     * |        |          |(1, 0, 1, 1) = BPWM1_CH5 function is selected.
N     * |[3]     |PE5_TM1   |PE.5 Pin Alternative Function Selection
N     * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
N     * |        |          |(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = PWM0_CH5 function is selected.
N     * |        |          |(0, 1, 1) = TM1 function is selected.
N     * |        |          |(1, 0, 1) = TM1_EXT function is selected.
N     * |[4]     |PB2_TM2   |PB.2 Pin Alternative Function Selection
N     * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.
N     * |        |          |(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N     * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE1 function is selected.
N     * |        |          |(1, 0, 0, 1) = TM2 function is selected.
N     * |[5]     |PB3_TM3   |PB.3 Pin Alternative Function Selection
N     * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.
N     * |        |          |(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
N     * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
N     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE0 function is selected.
N     * |        |          |(1, 0, 0, 1) = TM3 function is selected.
N     */
N    __IO uint32_t ALT_MFP2;
X    volatile uint32_t ALT_MFP2;
N
N    /**
N     * ALT_MFP3
N     * ===================================================================================================
N     * Offset: 0x60  Alternative Multiple Function Pin Control Register 3
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4]     |PA0_PWM04 |PA.0 Pin Alternative Function Selection
N     * |        |          |Bits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.
N     * |        |          |(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = ADC0 function is selected.
N     * |        |          |(0, 0, 1, 1) = I2C1_SCL function is selected.
N     * |        |          |(0, 1, 0, 1) = UART5_TXD function is selected.
N     * |        |          |(1, 0, 0, 1) = PWM0_CH4 function is selected.
N     * |[5]     |PA1_PWM05 |PA.1 Pin Alternative Function Selection
N     * |        |          |Bits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.
N     * |        |          |(PA1_PWM05, PA1_UR5RXD , PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N     * |        |          |(0, 0, 1, 1) = I2C1_SDA function is selected.
N     * |        |          |(0, 1, 0, 1) = UART5_RXD function is selected.
N     * |        |          |(1, 0, 0, 1) = PWM0_CH5 function is selected.
N     * |[6]     |PA2_PWM10 |PA.2 Pin Alternative Function Selection
N     * |        |          |Bits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.
N     * |        |          |(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC2 function is selected.
N     * |        |          |(0, 1, 1) = UART3_TXD function is selected.
N     * |        |          |(1, 0, 1) = PWM1_CH0 function is selected.
N     * |[7]     |PA3_PWM11 |PA.3 Pin Alternative Function Selection
N     * |        |          |Bits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.
N     * |        |          |(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC3 function is selected.
N     * |        |          |(0, 1, 1) = UART3_RXD function is selected.
N     * |        |          |(1, 0, 1) = PWM1_CH1 function is selected.
N     * |[8]     |PA10_PWM12|PA.10 Pin Alternative Function Selection
N     * |        |          |Bits PA10_PWM12 (ALT_MFP3[8]) and GPA_MFP10 determine the PA.10 function.
N     * |        |          |(PA10_PWM12, GPA_MFP10) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C1_SDA function is selected.
N     * |        |          |(1, 1) = PWM1_CH2 function is selected.
N     * |[9]     |PA11_PWM13|PA.11 Pin Alternative Function Selection
N     * |        |          |Bits PA11_PWM13 (ALT_MFP3[9]) and GPA_MFP11 determine the PA.11 function.
N     * |        |          |(PA11_PWM13, GPA_MFP11) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C1_SCL function is selected.
N     * |        |          |(1, 1) = PWM1_CH3 function is selected.
N     * |[10]    |PF4_PWM14 |PF.4 Pin Alternative Function Selection
N     * |        |          |Bits PF4_PWM14 (ALT_MFP3[10]) and GPF_MFP4 determine the PF.4 function.
N     * |        |          |(PF4_PWM14, GPF_MFP4) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C0_SDA function is selected.
N     * |        |          |(1, 1) = PWM1_CH4 function is selected.
N     * |[11]    |PF5_PWM15 |PF.5 Pin Alternative Function Selection
N     * |        |          |Bits PF5_PWM15 (ALT_MFP3[11]) and GPF_MFP5 determine the PF.5 function.
N     * |        |          |(PF5_PWM15, GPF_MFP5) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C0_SCL function is selected.
N     * |        |          |(1, 1) = PWM1_CH5 function is selected.
N     * |[12]    |PC0_BPWM00|PC.0 Pin Alternative Function Selection
N     * |        |          |Bits PC0_BPWM00 (ALT_MFP3[12]) and GPC_MFP0 determine the PC.0 function.
N     * |        |          |(PC0_BPWM00, GPC_MFP0) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_SS0 function is selected.
N     * |        |          |(1, 1) = BPWM0_CH0 function is selected.
N     * |[13]    |PC1_BPWM01|PC.1 Pin Alternative Function Selection
N     * |        |          |Bits PC1_BPWM01 (ALT_MFP3[13]) and GPC_MFP1 determine the PC.1 function.
N     * |        |          |(PC1_BPWM01, GPC_MFP1) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_CLK function is selected.
N     * |        |          |(1, 1) = BPWM0_CH1 function is selected.
N     * |[14]    |PC2_BPWM02|PC.2 Pin Alternative Function Selection
N     * |        |          |Bits PC2_BPWM02 (ALT_MFP3[14]) and GPC_MFP2 determine the PC.2 function.
N     * |        |          |(PC2_BPWM02, GPC_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_MISO0 function is selected.
N     * |        |          |(1, 1) = BPWM0_CH2 function is selected.
N     * |[15]    |PC3_BPWM03|PC.3 Pin Alternative Function Selection
N     * |        |          |Bits PC3_BPWM03 (ALT_MFP3[15]) and GPC_MFP3 determine the PC.3 function.
N     * |        |          |(PC3_BPWM03, GPC_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
N     * |        |          |(1, 1) = BPWM0_CH3 function is selected.
N     * |[16]    |PD15_BPWM04|PD.15 Pin Alternative Function Selection
N     * |        |          |Bits PD15_BPWM04 (ALT_MFP3[16]) and GPD_MFP15 determine the PD.15 function.
N     * |        |          |(PD15_BPWM04, GPD_MFP15) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = UART2_TXD function is selected.
N     * |        |          |(1, 1) = BPWM0_CH4 function is selected.
N     * |[17]    |PD14_BPWM05|PD.14 Pin Alternative Function Selection
N     * |        |          |Bits PD14_BPWM05 (ALT_MFP3[17]) and GPD_MFP14 determine the PD.14 function.
N     * |        |          |(PD14_BPWM05, GPD_MFP14) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = UART2_RXD function is selected.
N     * |        |          |(1, 1) = BPWM0_CH5 function is selected.
N     * |[18]    |PD7_BPWM10|PD.7 Pin Alternative Function Selection
N     * |        |          |Bits PD7_BPWM10 (ALT_MFP3[18]) and GPD_MFP7 determine the PD.7 function.
N     * |        |          |(PD7_BPWM10, GPD_MFP7) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = CAN0_TXD function is selected.
N     * |        |          |(1, 1) = BPWM1_CH0 function is selected.
N     * |[19]    |PD6_BPWM11|PD.6 Pin Alternative Function Selection
N     * |        |          |Bits PD6_BPWM11 (ALT_MFP3[19]) and GPD_MFP6 determine the PD.6 function.
N     * |        |          |(PD6_BPWM11, GPD_MFP6) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = CAN0_RXD function is selected.
N     * |        |          |(1, 1) = BPWM1_CH1 function is selected.
N     * |[20]    |PB8_BPWM12|PB.8 Pin Alternative Function Selection
N     * |        |          |Bits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.
N     * |        |          |(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = TM0 function is selected.
N     * |        |          |(0, 1, 1) = CLKO function is selected.
N     * |        |          |(1, 0, 1) = BPWM1_CH2 function is selected.
N     * |[21]    |PB12_BPWM13|PB.12 Pin Alternative Function Selection
N     * |        |          |Bits PB12_BPWM13 (ALT_MFP3[21]) and GPB_MFP12 determine the PB.12 function.
N     * |        |          |(PB12_BPWM13, GPB_MFP12) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = CLKO function is selected.
N     * |        |          |(1, 1) = BPWM1_CH3 function is selected.
N     * |[22]    |PF8_BPWM14|PF.8 Pin Alternative Function Selection
N     * |        |          |Bits PF8_BPWM14 (ALT_MFP3[22]) and GPF_MFP8 determine the PF.8 function.
N     * |        |          |(PF8_BPWM14, GPF_MFP8) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = CLKO function is selected.
N     * |        |          |(1, 0) = BPWM1_CH4 function is selected.
N     * |[23]    |PB15_BPWM15|PB.15 Pin Alternative Function Selection
N     * |        |          |Bits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.
N     * |        |          |(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = INT1 function is selected.
N     * |        |          |(0, 0, 1, 1) = TM0 function is selected.
N     * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
N     * |        |          |(1, 0, 1, 1) = BPWM1_CH5 function is selected.
N     * |[24]    |PB11_PWM04|PB.11 Pin Alternative Function Selection
N     * |        |          |Bits PB11_PWM04 (ALT_MFP3[24]) and GPB_MFP11 determine the PB.11 function.
N     * |        |          |(PB11_PWM04, GPB_MFP11) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = TM3 function is selected.
N     * |        |          |(1, 1) = PWM0_CH4 function is selected.
N     * |[28]    |PC6_PWM0BK0|PC.6 Pin Alternative Function Selection
N     * |        |          |Bits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.
N     * |        |          |(PC6_PWM0BK0, PC6_I2C0SDA, GPB_MFP6) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = UART4_TXD function is selected.
N     * |        |          |(0, 1, 1) = I2C0_SDA function is selected.
N     * |        |          |(1, 0, 1) = PWM0_BRAKE0 function is selected.
N     * |[29]    |PC7_PWM0BK1|PC.7 Pin Alternative Function Selection
N     * |        |          |Bits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.
N     * |        |          |(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = UART4_RXD function is selected.
N     * |        |          |(0, 1, 1) = I2C0_SCL function is selected.
N     * |        |          |(1, 0, 1) = PWM0_BRAKE1 function is selected.
N     * |[30]    |PB3_PWM1BK0|PB.3 Pin Alternative Function Selection
N     * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.
N     * |        |          |(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
N     * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
N     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE0 function is selected.
N     * |        |          |(1, 0, 0, 1) = TM3 function is selected.
N     * |[31]    |PB2_PWM1BK1|PB.2 Pin Alternative Function Selection
N     * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.
N     * |        |          |(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N     * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE1 function is selected.
N     * |        |          |(1, 0, 0, 1) = TM2 function is selected.
N     */
N    __IO uint32_t ALT_MFP3;
X    volatile uint32_t ALT_MFP3;
N
N    /**
N     * ALT_MFP4
N     * ===================================================================================================
N     * Offset: 0x64  Alternative Multiple Function Pin Control Register 4
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |PA8_UR1RTS|PA.8 Pin Alternative Function Selection
N     * |        |          |Bits PA8_UR1RTS (ALT_MFP4[0]) and GPA_MFP8 determine the PA.8 function.
N     * |        |          |(PA8_UR1RTS, GPA_MFP8) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C0_SDA function is selected.
N     * |        |          |(1, 1) = UART1_nRTS function is selected.
N     * |[1]     |PA9_UR1CTS|PA.9 Pin Alternative Function Selection
N     * |        |          |Bits PA9_UR1CTS (ALT_MFP4[1]) and GPA_MFP9 determine the PA.9 function.
N     * |        |          |(PA9_UR1CTS, GPA_MFP9) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = I2C0_SCL function is selected.
N     * |        |          |(1, 1) = UART1_nCTS function is selected.
N     * |[2]     |PA3_UR3RXD|PA.3 Pin Alternative Function Selection
N     * |        |          |Bits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.
N     * |        |          |(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC3 function is selected.
N     * |        |          |(0, 1, 1) = UART3_RXD function is selected.
N     * |        |          |(1, 0, 1) = PWM1_CH1 function is selected.
N     * |[3]     |PA2_UR3TXD|PA.2 Pin Alternative Function Selection
N     * |        |          |Bits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.
N     * |        |          |(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = ADC2 function is selected.
N     * |        |          |(0, 1, 1) = UART3_TXD function is selected.
N     * |        |          |(1, 0, 1) = PWM1_CH0 function is selected.
N     * |[4]     |PA5_UR3RXD|PA.5 Pin Alternative Function Selection
N     * |        |          |Bits PA5_UR3RXD (ALT_MFP4[4]) and GPA_MFP5 determine the PA.5 function.
N     * |        |          |(PA5_UR3RXD, GPA_MFP5) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC5 function is selected.
N     * |        |          |(1, 1) = UART3_RXD function is selected.
N     * |[5]     |PA6_UR3TXD|PA.6 Pin Alternative Function Selection
N     * |        |          |Bits PA6_UR3TXD (ALT_MFP4[5]) and GPA_MFP6 determine the PA.6 function.
N     * |        |          |(PA6_UR3TXD, GPA_MFP6) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC6 function is selected.
N     * |        |          |(1, 1) = UART3_TXD function is selected.
N     * |[6]     |PA1_UR5RXD|PA.1 Pin Alternative Function Selection
N     * |        |          |Bits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.
N     * |        |          |(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N     * |        |          |(0, 0, 1, 1) = I2C1_SDA function is selected.
N     * |        |          |(0, 1, 0, 1) = UART5_RXD function is selected.
N     * |        |          |(1, 0, 0, 1) = PWM0_CH5 function is selected.
N     * |[7]     |PA0_UR5TXD|PA.0 Pin Alternative Function Selection
N     * |        |          |Bits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.
N     * |        |          |(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = ADC0 function is selected.
N     * |        |          |(0, 0, 1, 1) = I2C1_SCL function is selected.
N     * |        |          |(0, 1, 0, 1) = UART5_TXD function is selected.
N     * |        |          |(1, 0, 0, 1) = PWM0_CH4 function is selected.
N     * |[8]     |PA12_UR5RXD|PA.12 Pin Alternative Function Selection
N     * |        |          |Bits PA12_UR5RXD (ALT_MFP4[8]) and GPA_MFP12 determine the PA.12 function.
N     * |        |          |(PA12_UR5RXD, GPA_MFP12) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = PWM0_CH0 function is selected.
N     * |        |          |(1, 1) = UART5_RXD function is selected.
N     * |[9]     |PA13_UR5TXD|PA.13 Pin Alternative Function Selection
N     * |        |          |Bits PA13_UR5TXD (ALT_MFP4[9]) and GPA_MFP13 determine the PA.13 function.
N     * |        |          |(PA13_UR5TXD, GPA_MFP13) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = PWM0_CH1 function is selected.
N     * |        |          |(1, 1) = UART5_TXD function is selected.
N     * |[10]    |PC6_I2C0SDA|PC.6 Pin Alternative Function Selection
N     * |        |          |Bits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.
N     * |        |          |(PC6_PWM0BK0, PC6_I2C0SDA, GPC_MFP6) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = UART4_TXD function is selected.
N     * |        |          |(0, 1, 1) = I2C0_SDA function is selected.
N     * |        |          |(1, 0, 1) = PWM0_BRAKE0 function is selected.
N     * |[11]    |PC7_I2C0SCL|PC.7 Pin Alternative Function Selection
N     * |        |          |Bits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.
N     * |        |          |(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.
N     * |        |          |(0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 1) = UART4_RXD function is selected.
N     * |        |          |(0, 1, 1) = I2C0_SCL function is selected.
N     * |        |          |(1, 0, 1) = PWM0_BRAKE1 function is selected.
N     * |[12]    |PA0_I2C1SCL|PA.0 Pin Alternative Function Selection
N     * |        |          |Bits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.
N     * |        |          |(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = ADC0 function is selected.
N     * |        |          |(0, 0, 1, 1) = I2C1_SCL function is selected.
N     * |        |          |(0, 1, 0, 1) = UART5_TXD function is selected.
N     * |        |          |(1, 0, 0, 1) = PWM0_CH4 function is selected.
N     * |[13]    |PA1_I2C1SDA|PA.1 Pin Alternative Function Selection
N     * |        |          |Bits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.
N     * |        |          |(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.
N     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N     * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N     * |        |          |(0, 0, 1, 1) = I2C1_SDA function is selected.
N     * |        |          |(0, 1, 0, 1) = UART5_RXD function is selected.
N     * |        |          |(1, 0, 0, 1) = PWM0_CH5 function is selected.
N     * |[14]    |PA7_VREF  |PA.7 Pin Alternative Function Selection
N     * |        |          |Bits PA7_VREF (ALT_MFP4[14]) and GPA_MFP7 determine the PA.7 function.
N     * |        |          |(PA7_VREF, GPA_MFP7) value and function mapping is as following list.
N     * |        |          |(0, 0) = GPIO function is selected.
N     * |        |          |(0, 1) = ADC7 function is selected.
N     * |        |          |(1, 1) = VREF function is selected.
N     */
N    __IO uint32_t ALT_MFP4;
X    volatile uint32_t ALT_MFP4;
N
N    uint32_t RESERVE5[38];
N
N    /**
N     * REGWRPROT
N     * ===================================================================================================
N     * Offset: 0x100  Register Write Protection Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |REGPROTDIS|Register Write-Protection Disable Index (Read Only)
N     * |        |          |0 = Write-protection is enabled for writing protected registers. Any write to the protected register is ignored.
N     * |        |          |1 = Write-protection is disabled for writing protected registers.
N     * |        |          |The Protected registers are:
N     * |        |          |IPRSTC1: address 0x5000_0008
N     * |        |          |BODCR: address 0x5000_0018
N     * |        |          |PORCR: address 0x5000_0024
N     * |        |          |VREFCR: address 0x5000_0028
N     * |        |          |PWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear)
N     * |        |          |APBCLK bit[0]: address 0x5000_0208 (bit[0] is Watchdog Timer clock enable)
N     * |        |          |CLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source selection)
N     * |        |          |CLKSEL1 bit[1:0]: address 0x5000_0214 (for Watchdog Timer clock source selection)
N     * |        |          |NMISEL bit[8]: address 0x5000_0380 (for NMI_EN NMI interrupt enable)
N     * |        |          |ISPCON: address 0x5000_C000 (Flash ISP Control register)
N     * |        |          |ISPTRG: address 0x5000_C010 (ISP Trigger Control register)
N     * |        |          |FATCON: address 0x5000_C018
N     * |        |          |WTCR: address 0x4000_4000
N     * |        |          |WTCRALT: address 0x4000_4004
N     * |        |          |PWM_CTL0: address 0x4004_0000, 0x4014_0000
N     * |        |          |PWM_DTCTL0_1: address 0x4004_0070, 0x4014_0070
N     * |        |          |PWM_DTCTL2_3: address 0x4004_0074, 0x4014_0074
N     * |        |          |PWM_DTCTL4_5: address 0x4004_0078, 0x4014_0078
N     * |        |          |PWM_BRKCTL0_1: address 0x4004_00C8, 0x4014_00C8
N     * |        |          |PWM_BRKCTL2_3: address 0x4004_00CC, 0x4014_00CC
N     * |        |          |PWM_BRKCTL4_5: address 0x4004_00D0, 0x4014_00D0
N     * |        |          |PWM_SWBRK: address 0x4004_00DC, 0x4014_00DC
N     * |        |          |PWM_INTEN1: address 0x4004_00E4, 0x4014_00E4
N     * |        |          |PWM_INTSTS1: address 0x4004_00EC, 0x4014_00EC
N     * |        |          |BPWM_CTL0: address 0x4004_4000, 0x4014_4000
N     * |        |          |Note: The bits which are write-protected will be noted as" (Write Protect)" beside the description.
N     * |[7:0]   |REGWRPROT |Register Write-Protection Code (Write Only)
N     * |        |          |Some registers have write-protection function.
N     * |        |          |Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field.
N     * |        |          |After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection registers can be normal write.
N     */
N    __IO uint32_t REGWRPROT;
X    volatile uint32_t REGWRPROT;
N} GCR_T;
N
N/**
N    @addtogroup SYS_CONST SYS Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N/* GCR RSTSRC Bit Field Definitions */
N#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                   /*!< GCR_T::RSTSRC: RSTS_CPU Position */
N#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)    /*!< GCR_T::RSTSRC: RSTS_CPU Mask */
N
N#define SYS_RSTSRC_RSTS_SYS_Pos                 5                                   /*!< GCR_T::RSTSRC: RSTS_SYS Position */
N#define SYS_RSTSRC_RSTS_SYS_Msk                 (1ul << SYS_RSTSRC_RSTS_SYS_Pos)    /*!< GCR_T::RSTSRC: RSTS_SYS Mask */
N
N#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                   /*!< GCR_T::RSTSRC: RSTS_BOD Position */
N#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)    /*!< GCR_T::RSTSRC: RSTS_BOD Mask */
N
N#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                   /*!< GCR_T::RSTSRC: RSTS_LVR Position */
N#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)    /*!< GCR_T::RSTSRC: RSTS_LVR Mask */
N
N#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                   /*!< GCR_T::RSTSRC: RSTS_WDT Position */
N#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)    /*!< GCR_T::RSTSRC: RSTS_WDT Mask */
N
N#define SYS_RSTSRC_RSTS_RESET_Pos               1                                   /*!< GCR_T::RSTSRC: RSTS_RESET Position */
N#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)  /*!< GCR_T::RSTSRC: RSTS_RESET Mask */
N
N#define SYS_RSTSRC_RSTS_POR_Pos                 0                                   /*!< GCR_T::RSTSRC: RSTS_POR Position */
N#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)    /*!< GCR_T::RSTSRC: RSTS_POR Mask */
N
N/* GCR IPRSTC1 Bit Field Definitions */
N#define SYS_IPRSTC1_CPU_RST_Pos                 1                                   /*!< GCR_T::IPRSTC1: CPU_RST Position */
N#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)    /*!< GCR_T::IPRSTC1: CPU_RST Mask */
N
N#define SYS_IPRSTC1_CHIP_RST_Pos                0                                   /*!< GCR_T::IPRSTC1: CHIP_RST Position */
N#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)   /*!< GCR_T::IPRSTC1: CHIP_RST Mask */
N
N/* GCR IPRSTC2 Bit Field Definitions */
N#define SYS_IPRSTC2_ADC_RST_Pos                 28                                  /*!< GCR_T::IPRSTC2: ADC_RST Position */
N#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)    /*!< GCR_T::IPRSTC2: ADC_RST Mask */
N
N#define SYS_IPRSTC2_CAN0_RST_Pos                24                                  /*!< GCR_T IPRSTC2: CAN0_RST Position */
N#define SYS_IPRSTC2_CAN0_RST_Msk                (1ul << SYS_IPRSTC2_CAN0_RST_Pos)   /*!< GCR_T IPRSTC2: CAN0_RST Mask */
N
N#define SYS_IPRSTC2_UART2_RST_Pos               18                                  /*!< GCR_T::IPRSTC2: UART2_RST Position */
N#define SYS_IPRSTC2_UART2_RST_Msk               (1ul << SYS_IPRSTC2_UART2_RST_Pos)  /*!< GCR_T::IPRSTC2: UART2_RST Mask */
N
N#define SYS_IPRSTC2_UART1_RST_Pos               17                                  /*!< GCR_T::IPRSTC2: UART1_RST Position */
N#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)  /*!< GCR_T::IPRSTC2: UART1_RST Mask */
N
N#define SYS_IPRSTC2_UART0_RST_Pos               16                                  /*!< GCR_T::IPRSTC2: UART0_RST Position */
N#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)  /*!< GCR_T::IPRSTC2: UART0_RST Mask */
N
N#define SYS_IPRSTC2_SPI0_RST_Pos                12                                  /*!< GCR_T::IPRSTC2: SPI0_RST Position */
N#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI0_RST Mask */
N
N#define SYS_IPRSTC2_I2C1_RST_Pos                9                                   /*!< GCR_T::IPRSTC2: I2C1_RST Position */
N#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C1_RST Mask */
N
N#define SYS_IPRSTC2_I2C0_RST_Pos                8                                   /*!< GCR_T::IPRSTC2: I2C0_RST Position */
N#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C0_RST Mask */
N
N#define SYS_IPRSTC2_TMR3_RST_Pos                5                                   /*!< GCR_T::IPRSTC2: TMR3_RST Position */
N#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR3_RST Mask */
N
N#define SYS_IPRSTC2_TMR2_RST_Pos                4                                   /*!< GCR_T::IPRSTC2: TMR2_RST Position */
N#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR2_RST Mask */
N
N#define SYS_IPRSTC2_TMR1_RST_Pos                3                                   /*!< GCR_T::IPRSTC2: TMR1_RST Position */
N#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR1_RST Mask */
N
N#define SYS_IPRSTC2_TMR0_RST_Pos                2                                   /*!< GCR_T::IPRSTC2: TMR0_RST Position */
N#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR0_RST Mask */
N
N#define SYS_IPRSTC2_GPIO_RST_Pos                1                                   /*!< GCR_T::IPRSTC2: GPIO_RST Position */
N#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)   /*!< GCR_T::IPRSTC2: GPIO_RST Mask */
N
N/* GCR IPRSTC3 Bit Field Definitions */
N#define SYS_IPRSTC3_BPWM1_RST_Pos               19                                  /*!< GCR_T::IPRSTC3: BPWM1_RST Position */
N#define SYS_IPRSTC3_BPWM1_RST_Msk               (1ul << SYS_IPRSTC3_BPWM1_RST_Pos)  /*!< GCR_T::IPRSTC3: BPWM1_RST Mask */
N
N#define SYS_IPRSTC3_BPWM0_RST_Pos               18                                  /*!< GCR_T::IPRSTC3: BPWM0_RST Position */
N#define SYS_IPRSTC3_BPWM0_RST_Msk               (1ul << SYS_IPRSTC3_BPWM0_RST_Pos)  /*!< GCR_T::IPRSTC3: BPWM0_RST Mask */
N
N#define SYS_IPRSTC3_PWM1_RST_Pos                17                                  /*!< GCR_T::IPRSTC3: PWM1_RST Position */
N#define SYS_IPRSTC3_PWM1_RST_Msk                (1ul << SYS_IPRSTC3_PWM1_RST_Pos)   /*!< GCR_T::IPRSTC3: PWM1_RST Mask */
N
N#define SYS_IPRSTC3_PWM0_RST_Pos                16                                  /*!< GCR_T::IPRSTC3: PWM0_RST Position */
N#define SYS_IPRSTC3_PWM0_RST_Msk                (1ul << SYS_IPRSTC3_PWM0_RST_Pos)   /*!< GCR_T::IPRSTC3: PWM0_RST Mask */
N
N#define SYS_IPRSTC3_UART5_RST_Pos               10                                  /*!< GCR_T::IPRSTC3: UART5_RST Position */
N#define SYS_IPRSTC3_UART5_RST_Msk               (1ul << SYS_IPRSTC3_UART5_RST_Pos)  /*!< GCR_T::IPRSTC3: UART5_RST Mask */
N
N#define SYS_IPRSTC3_UART4_RST_Pos               9                                   /*!< GCR_T::IPRSTC3: UART4_RST Position */
N#define SYS_IPRSTC3_UART4_RST_Msk               (1ul << SYS_IPRSTC3_UART4_RST_Pos)  /*!< GCR_T::IPRSTC3: UART4_RST Mask */
N
N#define SYS_IPRSTC3_UART3_RST_Pos               8                                   /*!< GCR_T::IPRSTC3: UART3_RST Position */
N#define SYS_IPRSTC3_UART3_RST_Msk               (1ul << SYS_IPRSTC3_UART3_RST_Pos)  /*!< GCR_T::IPRSTC3: UART3_RST Mask */
N
N/* GCR BODCR Bit Field Definitions */
N#define SYS_BODCR_LVR_OUT_DG_SEL_Pos            12                                      /*!< GCR_T::BODCR: LVR_OUT_DG_SEL Position */
N#define SYS_BODCR_LVR_OUT_DG_SEL_Msk            (0x7ul << SYS_BODCR_LVR_OUT_DG_SEL_Pos) /*!< GCR_T::BODCR: LVR_OUT_DG_SEL Mask */
N
N#define SYS_BODCR_BOD_OUT_DG_SEL_Pos            8                                       /*!< GCR_T::BODCR: BOD_OUT_DG_SEL Position */
N#define SYS_BODCR_BOD_OUT_DG_SEL_Msk            (0x7ul << SYS_BODCR_BOD_OUT_DG_SEL_Pos) /*!< GCR_T::BODCR: BOD_OUT_DG_SEL Mask */
N
N#define SYS_BODCR_LVR_EN_Pos                    7                                   /*!< GCR_T::BODCR: LVR_EN Position */
N#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)       /*!< GCR_T::BODCR: LVR_EN Mask */
N
N#define SYS_BODCR_BOD_OUT_Pos                   6                                   /*!< GCR_T::BODCR: BOD_OUT Position */
N#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)      /*!< GCR_T::BODCR: BOD_OUT Mask */
N
N#define SYS_BODCR_BOD_LPM_Pos                   5                                   /*!< GCR_T::BODCR: BOD_LPM Position */
N#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)      /*!< GCR_T::BODCR: BOD_LPM Mask */
N
N#define SYS_BODCR_BOD_INTF_Pos                  4                                   /*!< GCR_T::BODCR: BOD_INTF Position */
N#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)     /*!< GCR_T::BODCR: BOD_INTF Mask */
N
N#define SYS_BODCR_BOD_RSTEN_Pos                 3                                   /*!< GCR_T::BODCR: BOD_RSTEN Position */
N#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)    /*!< GCR_T::BODCR: BOD_RSTEN Mask */
N
N#define SYS_BODCR_BOD_VL_Pos                    1                                   /*!< GCR_T::BODCR: BOD_VL Position */
N#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)       /*!< GCR_T::BODCR: BOD_VL Mask */
N
N#define SYS_BODCR_BOD_EN_Pos                    0                                   /*!< GCR_T::BODCR: BOD_EN Position */
N#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)       /*!< GCR_T::BODCR: BOD_EN Mask */
N
N/* GCR VREFCR Bit Field Definitions */
N#define SYS_VREFCR_ADC_VREFSEL_Pos              4                                       /*!< GCR_T::VREFCR: ADC_VREFSEL Position */
N#define SYS_VREFCR_ADC_VREFSEL_Msk              (1ul << SYS_VREFCR_ADC_VREFSEL_Pos)     /*!< GCR_T::VREFCR: ADC_VREFSEL Mask */
N
N/* GCR PORCR Bit Field Definitions */
N#define SYS_PORCR_POR_DIS_CODE_Pos              0                                           /*!< GCR_T::PORCR: POR_DIS_CODE Position */
N#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)    /*!< GCR_T::PORCR: POR_DIS_CODE Mask */
N
N/* GCR GPAMFP Bit Field Definitions */
N#define SYS_GPA_MFP_GPA_TYPE_Pos                 16                                         /*!< GCR_T::GPA_MFP: GPA_TYPE Position */
N#define SYS_GPA_MFP_GPA_TYPE_Msk                 (0xFFFFul << SYS_GPA_MFP_GPA_TYPE_Pos)     /*!< GCR_T::GPA_MFP: GPA_TYPE Mask */
N
N#define SYS_GPA_MFP_GPA_MFP_Pos                  0                                          /*!< GCR_T::GPA_MFP: GPA_MFP Position */
N#define SYS_GPA_MFP_GPA_MFP_Msk                  (0xFFFFul << SYS_GPA_MFP_GPA_MFP_Pos)      /*!< GCR_T::GPA_MFP: GPA_MFP Mask */
N
N/* GCR GPBMFP Bit Field Definitions */
N#define SYS_GPB_MFP_GPB_TYPE_Pos                 16                                         /*!< GCR_T::GPB_MFP: GPB_TYPE Position */
N#define SYS_GPB_MFP_GPB_TYPE_Msk                 (0xFFFFul << SYS_GPB_MFP_GPB_TYPE_Pos)     /*!< GCR_T::GPB_MFP: GPB_TYPE Mask */
N
N#define SYS_GPB_MFP_GPB_MFP_Pos                  0                                          /*!< GCR_T::GPB_MFP: GPB_MFP Position */
N#define SYS_GPB_MFP_GPB_MFP_Msk                  (0xFFFFul << SYS_GPB_MFP_GPB_MFP_Pos)      /*!< GCR_T::GPB_MFP: GPB_MFP Mask */
N
N/* GCR GPCMFP Bit Field Definitions */
N#define SYS_GPC_MFP_GPC_TYPE_Pos                 16                                         /*!< GCR_T::GPC_MFP: GPC_TYPE Position */
N#define SYS_GPC_MFP_GPC_TYPE_Msk                 (0xFFFFul << SYS_GPC_MFP_GPC_TYPE_Pos)     /*!< GCR_T::GPC_MFP: GPC_TYPE Mask */
N
N#define SYS_GPC_MFP_GPC_MFP_Pos                  0                                          /*!< GCR_T::GPC_MFP: GPC_MFP Position */
N#define SYS_GPC_MFP_GPC_MFP_Msk                  (0xFFFFul << SYS_GPC_MFP_GPC_MFP_Pos)      /*!< GCR_T::GPC_MFP: GPC_MFP Mask */
N
N/* GCR GPDMFP Bit Field Definitions */
N#define SYS_GPD_MFP_GPD_TYPE_Pos                 16                                         /*!< GCR_T::GPD_MFP: GPD_TYPE Position */
N#define SYS_GPD_MFP_GPD_TYPE_Msk                 (0xFFFFul << SYS_GPD_MFP_GPD_TYPE_Pos)     /*!< GCR_T::GPD_MFP: GPD_TYPE Mask */
N
N#define SYS_GPD_MFP_GPD_MFP_Pos                  0                                          /*!< GCR_T::GPD_MFP: GPD_MFP Position */
N#define SYS_GPD_MFP_GPD_MFP_Msk                  (0xFFFFul << SYS_GPD_MFP_GPD_MFP_Pos)      /*!< GCR_T::GPD_MFP: GPD_MFP Mask */
N
N/* GCR GPEMFP Bit Field Definitions */
N#define SYS_GPE_MFP_GPE_TYPE_Pos                 16                                         /*!< GCR_T::GPE_MFP: GPE_TYPE Position */
N#define SYS_GPE_MFP_GPE_TYPE_Msk                 (0xFFFFul << SYS_GPE_MFP_GPE_TYPE_Pos)     /*!< GCR_T::GPE_MFP: GPE_TYPE Mask */
N
N#define SYS_GPE_MFP_GPE_MFP5_Pos                 5                                          /*!< GCR_T::GPE_MFP: GPE_MFP5 Position */
N#define SYS_GPE_MFP_GPE_MFP5_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP5_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP5 Mask */
N
N/* GCR GPFMFP Bit Field Definitions */
N#define SYS_GPF_MFP_GPF_TYPE_Pos                 16                                         /*!< GCR_T::GPF_MFP: GPF_TYPE Position */
N#define SYS_GPF_MFP_GPF_TYPE_Msk                 (0x1Ful << SYS_GPF_MFP_GPF_TYPE_Pos)       /*!< GCR_T::GPF_MFP: GPF_TYPE Mask */
N
N#define SYS_GPF_MFP_GPF_MFP_Pos                  0                                          /*!< GCR_T::GPF_MFP: GPF_MFP Position */
N#define SYS_GPF_MFP_GPF_MFP_Msk                  (0x1Ful << SYS_GPF_MFP_GPF_MFP_Pos)        /*!< GCR_T::GPF_MFP: GPF_MFP Mask */
N
N/* GCR ALTMFP Bit Field Definitions */
N#define SYS_ALT_MFP_PB8_CLKO_Pos                29                                          /*!< GCR_T::ALT_MFP: PB8_CLKO Position */
N#define SYS_ALT_MFP_PB8_CLKO_Msk                (1ul << SYS_ALT_MFP_PB8_CLKO_Pos)           /*!< GCR_T::ALT_MFP: PB8_CLKO Mask */
N
N#define SYS_ALT_MFP_PB3_T3EX_Pos                 27                                         /*!< GCR_T::ALT_MFP: PB3_T3EX Position */
N#define SYS_ALT_MFP_PB3_T3EX_Msk                 (1ul << SYS_ALT_MFP_PB3_T3EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
N
N#define SYS_ALT_MFP_PB2_T2EX_Pos                 26                                         /*!< GCR_T::ALT_MFP: PB2_T2EX Position */
N#define SYS_ALT_MFP_PB2_T2EX_Msk                 (1ul << SYS_ALT_MFP_PB2_T2EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
N
N#define SYS_ALT_MFP_PE5_T1EX_Pos                 25                                         /*!< GCR_T::ALT_MFP: PE5_T1EX Position */
N#define SYS_ALT_MFP_PE5_T1EX_Msk                 (1ul << SYS_ALT_MFP_PE5_T1EX_Pos)          /*!< GCR_T::ALT_MFP: PE5_T1EX Mask */
N
N#define SYS_ALT_MFP_PB15_T0EX_Pos                24                                         /*!< GCR_T::ALT_MFP: PB15_T0EX Position */
N#define SYS_ALT_MFP_PB15_T0EX_Msk                (1ul << SYS_ALT_MFP_PB15_T0EX_Pos)         /*!< GCR_T::ALT_MFP: PB15_T0EX Mask */
N
N/* GCR ALTMFP2 Bit Field Definitions */
N#define SYS_ALT_MFP2_PB3_TM3_Pos                5                                           /*!< GCR_T::ALT_MFP2: PB3_TM3 Position */
N#define SYS_ALT_MFP2_PB3_TM3_Msk                (1ul << SYS_ALT_MFP2_PB3_TM3_Pos)           /*!< GCR_T::ALT_MFP2: PB3_TM3 Mask */
N
N#define SYS_ALT_MFP2_PB2_TM2_Pos                4                                           /*!< GCR_T::ALT_MFP2: PB2_TM2 Position */
N#define SYS_ALT_MFP2_PB2_TM2_Msk                (1ul << SYS_ALT_MFP2_PB2_TM2_Pos)           /*!< GCR_T::ALT_MFP2: PB2_TM2 Mask */
N
N#define SYS_ALT_MFP2_PE5_TM1_Pos                3                                           /*!< GCR_T::ALT_MFP2: PE5_TM1 Position */
N#define SYS_ALT_MFP2_PE5_TM1_Msk                (1ul << SYS_ALT_MFP2_PE5_TM1_Pos)           /*!< GCR_T::ALT_MFP2: PE5_TM1 Mask */
N
N#define SYS_ALT_MFP2_PB15_TM0_Pos               2                                           /*!< GCR_T::ALT_MFP2: PB15_TM0 Position */
N#define SYS_ALT_MFP2_PB15_TM0_Msk               (1ul << SYS_ALT_MFP2_PB15_TM0_Pos)          /*!< GCR_T::ALT_MFP2: PB15_TM0 Mask */
N
N/* GCR ALTMFP3 Bit Field Definitions */
N#define SYS_ALT_MFP3_PB2_PWM1BK1_Pos            31                                          /*!< GCR_T::ALT_MFP3: PB2_PWM1BK1 Position */
N#define SYS_ALT_MFP3_PB2_PWM1BK1_Msk            (1ul << SYS_ALT_MFP3_PB2_PWM1BK1_Pos)       /*!< GCR_T::ALT_MFP3: PB2_PWM1BK1 Mask */
N
N#define SYS_ALT_MFP3_PB3_PWM1BK0_Pos            30                                          /*!< GCR_T::ALT_MFP3: PB3_PWM1BK0 Position */
N#define SYS_ALT_MFP3_PB3_PWM1BK0_Msk            (1ul << SYS_ALT_MFP3_PB3_PWM1BK0_Pos)       /*!< GCR_T::ALT_MFP3: PB3_PWM1BK0 Mask */
N
N#define SYS_ALT_MFP3_PC7_PWM0BK1_Pos            29                                          /*!< GCR_T::ALT_MFP3: PC7_PWM0BK1 Position */
N#define SYS_ALT_MFP3_PC7_PWM0BK1_Msk            (1ul << SYS_ALT_MFP3_PC7_PWM0BK1_Pos)       /*!< GCR_T::ALT_MFP3: PC7_PWM0BK1 Mask */
N
N#define SYS_ALT_MFP3_PC6_PWM0BK0_Pos            28                                          /*!< GCR_T::ALT_MFP3: PC6_PWM0BK0 Position */
N#define SYS_ALT_MFP3_PC6_PWM0BK0_Msk            (1ul << SYS_ALT_MFP3_PC6_PWM0BK0_Pos)       /*!< GCR_T::ALT_MFP3: PC6_PWM0BK0 Mask */
N
N#define SYS_ALT_MFP3_PB11_PWM04_Pos             24                                          /*!< GCR_T::ALT_MFP3: PB11_PWM04 Position */
N#define SYS_ALT_MFP3_PB11_PWM04_Msk             (1ul << SYS_ALT_MFP3_PB11_PWM04_Pos)        /*!< GCR_T::ALT_MFP3: PB11_PWM04 Mask */
N
N#define SYS_ALT_MFP3_PB15_BPWM15_Pos            23                                          /*!< GCR_T::ALT_MFP3: PFB15_BPWM15 Position */
N#define SYS_ALT_MFP3_PB15_BPWM15_Msk            (1ul << SYS_ALT_MFP3_PB15_BPWM15_Pos)       /*!< GCR_T::ALT_MFP3: PB15_BPWM15 Mask */
N
N#define SYS_ALT_MFP3_PF8_BPWM14_Pos             22                                          /*!< GCR_T::ALT_MFP3: PF8_BPWM14 Position */
N#define SYS_ALT_MFP3_PF8_BPWM14_Msk             (1ul << SYS_ALT_MFP3_PF8_BPWM14_Pos)        /*!< GCR_T::ALT_MFP3: PF8_BPWM14 Mask */
N
N#define SYS_ALT_MFP3_PB12_BPWM13_Pos            21                                          /*!< GCR_T::ALT_MFP3: PB12_BPWM13 Position */
N#define SYS_ALT_MFP3_PB12_BPWM13_Msk            (1ul << SYS_ALT_MFP3_PB12_BPWM13_Pos)       /*!< GCR_T::ALT_MFP3: PB12_BPWM13 Mask */
N
N#define SYS_ALT_MFP3_PB8_BPWM12_Pos             20                                          /*!< GCR_T::ALT_MFP3: PB8_BPWM12 Position */
N#define SYS_ALT_MFP3_PB8_BPWM12_Msk             (1ul << SYS_ALT_MFP3_PB8_BPWM12_Pos)        /*!< GCR_T::ALT_MFP3: PB8_BPWM12 Mask */
N
N#define SYS_ALT_MFP3_PD6_BPWM11_Pos             19                                          /*!< GCR_T::ALT_MFP3: PD6_BPWM11 Position */
N#define SYS_ALT_MFP3_PD6_BPWM11_Msk             (1ul << SYS_ALT_MFP3_PD6_BPWM11_Pos)        /*!< GCR_T::ALT_MFP3: PD6_BPWM11 Mask */
N
N#define SYS_ALT_MFP3_PD7_BPWM10_Pos             18                                          /*!< GCR_T::ALT_MFP3: PD7_BPWM10 Position */
N#define SYS_ALT_MFP3_PD7_BPWM10_Msk             (1ul << SYS_ALT_MFP3_PD7_BPWM10_Pos)        /*!< GCR_T::ALT_MFP3: PD7_BPWM10 Mask */
N
N#define SYS_ALT_MFP3_PD14_BPWM05_Pos            17                                          /*!< GCR_T::ALT_MFP3: PD14_BPWM05 Position */
N#define SYS_ALT_MFP3_PD14_BPWM05_Msk            (1ul << SYS_ALT_MFP3_PD14_BPWM05_Pos)       /*!< GCR_T::ALT_MFP3: PD14_BPWM05 Mask */
N
N#define SYS_ALT_MFP3_PD15_BPWM04_Pos            16                                          /*!< GCR_T::ALT_MFP3: PD15_BPWM04 Position */
N#define SYS_ALT_MFP3_PD15_BPWM04_Msk            (1ul << SYS_ALT_MFP3_PD15_BPWM04_Pos)       /*!< GCR_T::ALT_MFP3: PD15_BPWM04 Mask */
N
N#define SYS_ALT_MFP3_PC3_BPWM03_Pos             15                                          /*!< GCR_T::ALT_MFP3: PC3_BPWM03 Position */
N#define SYS_ALT_MFP3_PC3_BPWM03_Msk             (1ul << SYS_ALT_MFP3_PC3_BPWM03_Pos)        /*!< GCR_T::ALT_MFP3: PC3_BPWM03 Mask */
N
N#define SYS_ALT_MFP3_PC2_BPWM02_Pos             14                                          /*!< GCR_T::ALT_MFP3: PC2_BPWM02 Position */
N#define SYS_ALT_MFP3_PC2_BPWM02_Msk             (1ul << SYS_ALT_MFP3_PC2_BPWM02_Pos)        /*!< GCR_T::ALT_MFP3: PC2_BPWM02 Mask */
N
N#define SYS_ALT_MFP3_PC1_BPWM01_Pos             13                                          /*!< GCR_T::ALT_MFP3: PC1_BPWM01 Position */
N#define SYS_ALT_MFP3_PC1_BPWM01_Msk             (1ul << SYS_ALT_MFP3_PC1_BPWM01_Pos)        /*!< GCR_T::ALT_MFP3: PC1_BPWM01 Mask */
N
N#define SYS_ALT_MFP3_PC0_BPWM00_Pos             12                                          /*!< GCR_T::ALT_MFP3: PC0_BPWM00 Position */
N#define SYS_ALT_MFP3_PC0_BPWM00_Msk             (1ul << SYS_ALT_MFP3_PC0_BPWM00_Pos)        /*!< GCR_T::ALT_MFP3: PC0_BPWM00 Mask */
N
N#define SYS_ALT_MFP3_PF5_PWM15_Pos              11                                          /*!< GCR_T::ALT_MFP3: PF5_PWM15 Position */
N#define SYS_ALT_MFP3_PF5_PWM15_Msk              (1ul << SYS_ALT_MFP3_PF5_PWM15_Pos)         /*!< GCR_T::ALT_MFP3: PF5_PWM15 Mask */
N
N#define SYS_ALT_MFP3_PF4_PWM14_Pos              10                                          /*!< GCR_T::ALT_MFP3: PF5_PWM14 Position */
N#define SYS_ALT_MFP3_PF4_PWM14_Msk              (1ul << SYS_ALT_MFP3_PF4_PWM14_Pos)         /*!< GCR_T::ALT_MFP3: PF5_PWM14 Mask */
N
N#define SYS_ALT_MFP3_PA11_PWM13_Pos             9                                           /*!< GCR_T::ALT_MFP3: PA11_PWM13 Position */
N#define SYS_ALT_MFP3_PA11_PWM13_Msk             (1ul << SYS_ALT_MFP3_PA11_PWM13_Pos)        /*!< GCR_T::ALT_MFP3: PA11_PWM13 Mask */
N
N#define SYS_ALT_MFP3_PA10_PWM12_Pos             8                                           /*!< GCR_T::ALT_MFP3: PA10_PWM12 Position */
N#define SYS_ALT_MFP3_PA10_PWM12_Msk             (1ul << SYS_ALT_MFP3_PA10_PWM12_Pos)        /*!< GCR_T::ALT_MFP3: PA10_PWM12 Mask */
N
N#define SYS_ALT_MFP3_PA3_PWM11_Pos              7                                           /*!< GCR_T::ALT_MFP3: PA3_PWM11 Position */
N#define SYS_ALT_MFP3_PA3_PWM11_Msk              (1ul << SYS_ALT_MFP3_PA3_PWM11_Pos)         /*!< GCR_T::ALT_MFP3: PA3_PWM11 Mask */
N
N#define SYS_ALT_MFP3_PA2_PWM10_Pos              6                                           /*!< GCR_T::ALT_MFP3: PA2_PWM10 Position */
N#define SYS_ALT_MFP3_PA2_PWM10_Msk              (1ul << SYS_ALT_MFP3_PA2_PWM10_Pos)         /*!< GCR_T::ALT_MFP3: PA2_PWM10 Mask */
N
N#define SYS_ALT_MFP3_PA1_PWM05_Pos              5                                           /*!< GCR_T::ALT_MFP3: PA1_PWM05 Position */
N#define SYS_ALT_MFP3_PA1_PWM05_Msk              (1ul << SYS_ALT_MFP3_PA1_PWM05_Pos)         /*!< GCR_T::ALT_MFP3: PA1_PWM05 Mask */
N
N#define SYS_ALT_MFP3_PA0_PWM04_Pos              4                                           /*!< GCR_T::ALT_MFP3: PA0_PWM04 Position */
N#define SYS_ALT_MFP3_PA0_PWM04_Msk              (1ul << SYS_ALT_MFP3_PA0_PWM04_Pos)         /*!< GCR_T::ALT_MFP3: PA0_PWM04 Mask */
N
N/* GCR ALTMFP4 Bit Field Definitions */
N#define SYS_ALT_MFP4_PA7_VREF_Pos               14                                          /*!< GCR_T::ALT_MFP4: PA7_VREF Position */
N#define SYS_ALT_MFP4_PA7_VREF_Msk               (1ul << SYS_ALT_MFP4_PA7_VREF_Pos)          /*!< GCR_T::ALT_MFP4: PA7_VREF Mask */
N
N#define SYS_ALT_MFP4_PA1_I2C1SDA_Pos            13                                          /*!< GCR_T::ALT_MFP4: PA1_I2C1SDA Position */
N#define SYS_ALT_MFP4_PA1_I2C1SDA_Msk            (1ul << SYS_ALT_MFP4_PA1_I2C1SDA_Pos)       /*!< GCR_T::ALT_MFP4: PA1_I2C1SDA Mask */
N
N#define SYS_ALT_MFP4_PA0_I2C1SCL_Pos            12                                          /*!< GCR_T::ALT_MFP4: PA0_I2C1SCL Position */
N#define SYS_ALT_MFP4_PA0_I2C1SCL_Msk            (1ul << SYS_ALT_MFP4_PA0_I2C1SCL_Pos)       /*!< GCR_T::ALT_MFP4: PA0_I2C1SCL Mask */
N
N#define SYS_ALT_MFP4_PC7_I2C0SCL_Pos            11                                          /*!< GCR_T::ALT_MFP4: PC7_I2C0SCL Position */
N#define SYS_ALT_MFP4_PC7_I2C0SCL_Msk            (1ul << SYS_ALT_MFP4_PC7_I2C0SCL_Pos)       /*!< GCR_T::ALT_MFP4: PC7_I2C0SCL Mask */
N
N#define SYS_ALT_MFP4_PC6_I2C0SDA_Pos            10                                          /*!< GCR_T::ALT_MFP4: PC6_I2C0SDA Position */
N#define SYS_ALT_MFP4_PC6_I2C0SDA_Msk            (1ul << SYS_ALT_MFP4_PC6_I2C0SDA_Pos)       /*!< GCR_T::ALT_MFP4: PC6_I2C0SDA Mask */
N
N#define SYS_ALT_MFP4_PA13_UR5TXD_Pos            9                                           /*!< GCR_T::ALT_MFP4: PA13_UR5TXD Position */
N#define SYS_ALT_MFP4_PA13_UR5TXD_Msk            (1ul << SYS_ALT_MFP4_PA13_UR5TXD_Pos)       /*!< GCR_T::ALT_MFP4: PA13_UR5TXD Mask */
N
N#define SYS_ALT_MFP4_PA12_UR5RXD_Pos            8                                           /*!< GCR_T::ALT_MFP4: PA12_UR5RXD Position */
N#define SYS_ALT_MFP4_PA12_UR5RXD_Msk            (1ul << SYS_ALT_MFP4_PA12_UR5RXD_Pos)       /*!< GCR_T::ALT_MFP4: PA12_UR5RXD Mask */
N
N#define SYS_ALT_MFP4_PA0_UR5TXD_Pos             7                                           /*!< GCR_T::ALT_MFP4: PA0_UR5TXD Position */
N#define SYS_ALT_MFP4_PA0_UR5TXD_Msk             (1ul << SYS_ALT_MFP4_PA0_UR5TXD_Pos)        /*!< GCR_T::ALT_MFP4: PA0_UR5TXD Mask */
N
N#define SYS_ALT_MFP4_PA1_UR5RXD_Pos             6                                           /*!< GCR_T::ALT_MFP4: PA1_UR5RXD Position */
N#define SYS_ALT_MFP4_PA1_UR5RXD_Msk             (1ul << SYS_ALT_MFP4_PA1_UR5RXD_Pos)        /*!< GCR_T::ALT_MFP4: PA1_UR5RXD Mask */
N
N#define SYS_ALT_MFP4_PA6_UR3TXD_Pos             5                                           /*!< GCR_T::ALT_MFP4: PA6_UR3TXD Position */
N#define SYS_ALT_MFP4_PA6_UR3TXD_Msk             (1ul << SYS_ALT_MFP4_PA6_UR3TXD_Pos)        /*!< GCR_T::ALT_MFP4: PA6_UR3TXD Mask */
N
N#define SYS_ALT_MFP4_PA5_UR3RXD_Pos             4                                           /*!< GCR_T::ALT_MFP4: PA5_UR3RXD Position */
N#define SYS_ALT_MFP4_PA5_UR3RXD_Msk             (1ul << SYS_ALT_MFP4_PA5_UR3RXD_Pos)        /*!< GCR_T::ALT_MFP4: PA5_UR3RXD Mask */
N
N#define SYS_ALT_MFP4_PA2_UR3TXD_Pos             3                                           /*!< GCR_T::ALT_MFP4: PA2_UR3TXD Position */
N#define SYS_ALT_MFP4_PA2_UR3TXD_Msk             (1ul << SYS_ALT_MFP4_PA2_UR3TXD_Pos)        /*!< GCR_T::ALT_MFP4: PA2_UR3TXD Mask */
N
N#define SYS_ALT_MFP4_PA3_UR3RXD_Pos             2                                           /*!< GCR_T::ALT_MFP4: PA3_UR3RXD Position */
N#define SYS_ALT_MFP4_PA3_UR3RXD_Msk             (1ul << SYS_ALT_MFP4_PA3_UR3RXD_Pos)        /*!< GCR_T::ALT_MFP4: PA3_UR3RXD Mask */
N
N#define SYS_ALT_MFP4_PA9_UR1CTS_Pos             1                                           /*!< GCR_T::ALT_MFP4: PA9_UR1CTS Position */
N#define SYS_ALT_MFP4_PA9_UR1CTS_Msk             (1ul << SYS_ALT_MFP4_PA9_UR1CTS_Pos)        /*!< GCR_T::ALT_MFP4: PA9_UR1CTS Mask */
N
N#define SYS_ALT_MFP4_PA8_UR1RTS_Pos             0                                           /*!< GCR_T::ALT_MFP4: PA8_UR1RTS Position */
N#define SYS_ALT_MFP4_PA8_UR1RTS_Msk             (1ul << SYS_ALT_MFP4_PA8_UR1RTS_Pos)        /*!< GCR_T::ALT_MFP4: PA8_UR1RTS Mask */
N
N/* GCR REGWRPROT Bit Field Definitions */
N#define SYS_REGWRPROT_REGWRPROT_Pos             0                                           /*!< GCR_T::REGWRPROT: REGWRPROT Position */
N#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos)     /*!< GCR_T::REGWRPROT: REGWRPROT Mask */
N
N#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                           /*!< GCR_T::REGWRPROT: REGPROTDIS Position */
N#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)       /*!< GCR_T::REGWRPROT: REGPROTDIS Mask */
N
N/*@}*/ /* end of group SYS_CONST */
N
Ntypedef struct
N{
N    /**
N     * IRQSRC
N     * ===================================================================================================
N     * Offset: 0x00~0x7C  IRQ0~IRQ31 Interrupt Source Identity
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |INTSRC    |Interrupt Source
N     * |        |          |Define the interrupt sources for interrupt event.
N     */
N    __I uint32_t IRQSRC[32];
X    volatile const uint32_t IRQSRC[32];
N
N    /**
N     * NMISEL
N     * ===================================================================================================
N     * Offset: 0x80  NMI Source Interrupt Select Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[4:0]   |NMISEL    |NMI Interrupt Source Selection
N     * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMISEL.
N     * |[8]     |NMIEN     |NMI Interrupt Enable Bit (Write Protect)
N     * |        |          |0 = NMI interrupt Disabled.
N     * |        |          |1 = NMI interrupt Enabled.
N     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
N     */
N    __IO uint32_t NMISEL;
X    volatile uint32_t NMISEL;
N
N    /**
N     * MCUIRQ
N     * ===================================================================================================
N     * Offset: 0x84  MCU Interrupt Request Source Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |MCUIRQ    |MCU IRQ Source Register
N     * |        |          |The MCUIRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0.
N     * |        |          |There are two modes to generate interrupt to Cortex-M0, the normal mode and test mode.
N     * |        |          |The MCUIRQ collects all interrupts from each peripheral and synchronizes them and interrupts the Cortex-M0.
N     * |        |          |When the MCU_IRQ[n] is 0: Set MCU_IRQ[n] 1 will generate an interrupt to Cortex-M0 NVIC[n].
N     * |        |          |When the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_IRQ[n] 1 will clear the interrupt and setting MCUIRQ[n] 0: has no effect.
N     */
N    __IO uint32_t MCUIRQ;
X    volatile uint32_t MCUIRQ;
N
N    /**
N     * MCUIRQCR
N     * ===================================================================================================
N     * Offset: 0x88  MCU Interrupt Request Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |FASTIRQ   |Fast IRQ Latency Enable Bit
N     * |        |          |0 = MCU IRQ latency is fixed at 13 clock cycles of HCLK, MCU will enter IRQ handler after this fixed latency when interrupt happened.
N     * |        |          |1 = MCU IRQ latency will not fixed, MCU will enter IRQ handler as soon as possible when interrupt happened.
N     */
N    __IO uint32_t MCUIRQCR;
X    volatile uint32_t MCUIRQCR;
N
N} GCR_INT_T;
N
N/**
N    @addtogroup INT_CONST System Interrupt Bit Field Definition
N    Constant Definitions for SYS Interrupt Controller
N@{ */
N
N/* INT IRQSRC Bit Field Definitions */
N#define INT_IRQSRC_INTSRC_Pos                   0                                   /*!< GCR_INT_T::IRQSRC: INTSRC Position */
N#define INT_IRQSRC_INTSRC_Msk                   (0xFul << INT_IRQSRC_INTSRC_Pos)    /*!< GCR_INT_T::IRQSRC: INTSRC Mask */
N
N/* INT NMISEL Bit Field Definitions */
N#define INT_NMISEL_NMIEN_Pos                    8                                   /*!< GCR_INT_T::NMISEL: NMIEN Position */
N#define INT_NMISEL_NMIEN_Msk                    (1ul << INT_NMISEL_NMIEN_Pos)       /*!< GCR_INT_T::NMISEL: NMIEN Mask */
N
N#define INT_NMISEL_NMISEL_Pos                   0                                   /*!< GCR_INT_T::NMISEL: NMISEL Position */
N#define INT_NMISEL_NMISEL_Msk                   (0x1Ful << INT_NMISEL_NMISEL_Pos)   /*!< GCR_INT_T::NMISEL: NMISEL Mask */
N
N/* INT MCUIRQ Bit Field Definitions */
N#define INT_MCUIRQ_MCUIRQ_Pos                   0                                       /*!< GCR_INT_T::MCUIRQ: MCUIRQ Position */
N#define INT_MCUIRQ_MCUIRQ_Msk                   (0xFFFFFFFFul << INT_MCUIRQ_MCUIRQ_Pos) /*!< GCR_INT_T::MCUIRQ: MCUIRQ Mask */
N
N/* INT MCUIRQCR Bit Field Definitions */
N#define INT_MCUIRQCR_FASTIRQ_Pos                0                                   /*!< GCR_INT_T::MCUIRQCR: FASTIRQ Position */
N#define INT_MCUIRQCR_FASTIRQ_Msk                (1ul << INT_MCUIRQCR_FASTIRQ_Pos)   /*!< GCR_INT_T::MCUIRQCR: FASTIRQ Mask */
N/*@}*/ /* end of group INT_CONST */
N/*@}*/ /* end of group SYS */
N
N
N
N
N/*----------------------------- Timer Controller (TIMER) -----------------------------*/
N/** @addtogroup TIMER Timer Controller (TIMER)
N  Memory Mapped Structure for Timer Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * TCSR
N     * ===================================================================================================
N     * Offset: 0x00  Timer Control and Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |PRESCALE  |Prescale Counter
N     * |        |          |Timer input clock source is divided by (PRESCALE+1) before it is fed to the Timer up counter.
N     * |        |          |If this field is 0 (PRESCALE = 0), then there is no scaling.
N     * |[16]    |TDR_EN    |Data Load Enable Control
N     * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.
N     * |        |          |0 = Timer Data Register update Disabled.
N     * |        |          |1 = Timer Data Register update Enabled while Timer counter is active.
N     * |[18]    |TRG_SRC_SEL    |Trigger Source Select Bit
N     * |        |               |This bit is used to select trigger source is form timer time-out interrupt signal or capture interrupt signal.
N     * |        |               |0 = Timer time-out interrupt signal is used to trigger PWM.
N     * |        |               |1 = Capture interrupt signal is used to trigger PWM.
N     * |[19]    |TRG_PWM_EN     |Trigger PWM Enable Bit
N     * |        |               |If this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered PWM.
N     * |        |               |0 = Timer interrupt trigger PWM Disabled.
N     * |        |               |1 = Timer interrupt trigger PWM Enabled.
N     * |[23]    |WAKE_EN   |Wake Up Function Enable Control
N     * |        |          |0 = Wake-up trigger event Disabled.
N     * |        |          |1 = Wake-up trigger event Enabled.
N     * |[24]    |CTB       |Counter Mode Enable Control
N     * |        |          |This bit is for external counting pin function enabled.
N     * |        |          |When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source.
N     * |        |          |0 = External counter mode Disabled.
N     * |        |          |1 = External counter mode Enabled.
N     * |[25]    |CACT      |Timer Active Status (Read Only)
N     * |        |          |This bit indicates the 24-bit up counter status.
N     * |        |          |0 = 24-bit up counter is not active.
N     * |        |          |1 = 24-bit up counter is active.
N     * |[26]    |CRST      |Timer Reset
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1.
N     * |[28:27] |MODE      |Timer Operating Mode
N     * |        |          |00 = The Timer controller is operated in One-shot mode.
N     * |        |          |01 = The Timer controller is operated in Periodic mode.
N     * |        |          |10 = The Timer controller is operated in Toggle-output mode.
N     * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
N     * |[29]    |IE        |Interrupt Enable Control
N     * |        |          |0 = Timer Interrupt function Disabled.
N     * |        |          |1 = Timer Interrupt function Enabled.
N     * |        |          |If this bit is enabled, when the timer interrupt flag (TISR[0] TIF) is set to 1, the timer interrupt signal is generated and inform to CPU.
N     * |[30]    |CEN       |Timer Enable Control
N     * |        |          |0 = Stops/Suspends counting.
N     * |        |          |1 = Starts counting.
N     * |        |          |Note1: In stop status, and then set CEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
N     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TCSR [28:27] = 00) when the timer interrupt flag (TISR[0] TIF) is generated.
N     * |[31]    |DBGACK_TMR|ICE Debug Mode Acknowledge Disable (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgment effects TIMER counting.
N     * |        |          |TIMER counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgment Disabled.
N     * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
N     */
N    __IO uint32_t  TCSR;
X    volatile uint32_t  TCSR;
N
N    /**
N     * TCMPR
N     * ===================================================================================================
N     * Offset: 0x04  Timer Compare Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TCMP      |Timer Compared Value
N     * |        |          |TCMP is a 24-bit compared value register.
N     * |        |          |When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.
N     * |        |          |Time-out period = (Period of Timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP).
N     * |        |          |Note1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.
N     * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into TCMP field.
N     * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest TCMP value to be the timer compared value if user writes a new value into TCMP field.
N     */
N    __IO uint32_t  TCMPR;
X    volatile uint32_t  TCMPR;
N
N    /**
N     * TISR
N     * ===================================================================================================
N     * Offset: 0x08  Timer Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TIF       |Timer Interrupt Flag
N     * |        |          |This bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.
N     * |        |          |0 = No effect.
N     * |        |          |1 = TDR value matches the TCMP value.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[1]     |TWF       |Timer Wake-Up Flag
N     * |        |          |This bit indicates the interrupt wake-up flag status of Timer.
N     * |        |          |0 = Timer does not cause CPU wake-up.
N     * |        |          |1 = CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     */
N    __IO uint32_t  TISR;
X    volatile uint32_t  TISR;
N
N    /**
N     * TDR
N     * ===================================================================================================
N     * Offset: 0x0C  Timer Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TDR       |Timer Data Register
N     * |        |          |If TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up counter value.
N     */
N    __I  uint32_t  TDR;
X    volatile const  uint32_t  TDR;
N
N    /**
N     * TCAP
N     * ===================================================================================================
N     * Offset: 0x10  Timer Capture Data Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[23:0]  |TCAP      |Timer Capture Data Register
N     * |        |          |When TEXIF flag is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.
N     */
N    __I  uint32_t  TCAP;
X    volatile const  uint32_t  TCAP;
N
N    /**
N     * TEXCON
N     * ===================================================================================================
N     * Offset: 0x14  Timer External Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TX_PHASE  |Timer External Count Pin Phase Detect Selection
N     * |        |          |This bit indicates the detection phase of TMx pin.
N     * |        |          |0 = A falling edge of TMx pin will be counted.
N     * |        |          |1 = A rising edge of TMx pin will be counted.
N     * |[2:1]   |TEX_EDGE  |Timer External Capture Pin Edge Detect Selection
N     * |        |          |00 = A 1 to 0 transition on TMx_EXT pin will be detected.
N     * |        |          |01 = A 0 to 1 transition on TMx_EXT pin will be detected.
N     * |        |          |10 = Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected.
N     * |        |          |11 = Reserved.
N     * |[3]     |TEXEN     |Timer External Pin Function Enable
N     * |        |          |This bit enables the RSTCAPSEL function on the TxEX pin.
N     * |        |          |0 = RSTCAPSEL function of TxEX pin will be ignored.
N     * |        |          |1 = RSTCAPSEL function of TxEX pin is active.
N     * |[4]     |RSTCAPSEL |Timer External Reset Counter / Timer External Capture Mode Selection
N     * |        |          |0 = Transition on TMx_EXT pin is using to save the TDR value into TCAP value if TEXIF flag is set to 1.
N     * |        |          |1 = Transition on TMx_EXT pin is using to reset the 24-bit up counter.
N     * |[5]     |TEXIEN    |Timer External Capture Interrupt Enable Control
N     * |        |          |0 = TMx_EXT pin detection Interrupt Disabled.
N     * |        |          |1 = TMx_EXT pin detection Interrupt Enabled.
N     * |        |          |If TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.
N     * |[6]     |TEXDB     |Timer External Capture Input Pin De-Bounce Enable Control
N     * |        |          |0 = TMx_EXT pin de-bounce Disabled.
N     * |        |          |1 = TMx_EXT pin de-bounce Enabled.
N     * |        |          |If this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.
N     * |[7]     |TCDB      |Timer External Counter Input Pin De-Bounce Enable Control
N     * |        |          |0 = TMx pin de-bounce Disabled.
N     * |        |          |1 = TMx pin de-bounce Enabled.
N     * |        |          |If this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.
N     */
N    __IO uint32_t  TEXCON;
X    volatile uint32_t  TEXCON;
N
N    /**
N     * TEXISR
N     * ===================================================================================================
N     * Offset: 0x18  Timer External Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |TEXIF     |Timer External Capture Interrupt Flag
N     * |        |          |This bit indicates the external capture interrupt flag status.
N     * |        |          |When TEXEN enabled, TMx_EXT pin selected as external capture function, and a transition on TMx_EXT pin matched the TEX_EDGE setting, this flag will set to 1 by hardware.
N     * |        |          |0 = TMx_EXT pin interrupt did not occur.
N     * |        |          |1 = TMx_EXT pin interrupt occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     */
N    __IO uint32_t  TEXISR;
X    volatile uint32_t  TEXISR;
N} TIMER_T;
N
N
N/** @addtogroup TIMER_CONST TIMER Bit Field Definition
N    Constant Definitions for TIMER Controller
N  @{
N */
N
N/* TIMER TCSR Bit Field Definitions */
N#define TIMER_TCSR_DBGACK_TMR_Pos   31                                          /*!< TIMER_T::TCSR: DBGACK_TMR Position */
N#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER_T::TCSR: DBGACK_TMR Mask */
N
N#define TIMER_TCSR_CEN_Pos          30                                          /*!< TIMER_T::TCSR: CEN Position */
N#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)                 /*!< TIMER_T::TCSR: CEN Mask */
N
N#define TIMER_TCSR_IE_Pos           29                                          /*!< TIMER_T::TCSR: IE Position */
N#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)                  /*!< TIMER_T::TCSR: IE Mask */
N
N#define TIMER_TCSR_MODE_Pos         27                                          /*!< TIMER_T::TCSR: MODE Position */
N#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)              /*!< TIMER_T::TCSR: MODE Mask */
N
N#define TIMER_TCSR_CRST_Pos         26                                          /*!< TIMER_T::TCSR: CRST Position */
N#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)                /*!< TIMER_T::TCSR: CRST Mask */
N
N#define TIMER_TCSR_CACT_Pos         25                                          /*!< TIMER_T::TCSR: CACT Position */
N#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)                /*!< TIMER_T::TCSR: CACT Mask */
N
N#define TIMER_TCSR_CTB_Pos          24                                          /*!< TIMER_T::TCSR: CTB Position */
N#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)                 /*!< TIMER_T::TCSR: CTB Mask */
N
N#define TIMER_TCSR_WAKE_EN_Pos      23                                          /*!< TIMER_T::TCSR: WAKE_EN Position */
N#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)             /*!< TIMER_T::TCSR: WAKE_EN Mask */
N
N#define TIMER_TCSR_TRG_PWM_EN_Pos   19                                          /*!< TIMER_T::TCSR: TRG_PWM_EN Position */
N#define TIMER_TCSR_TRG_PWM_EN_Msk   (1ul << TIMER_TCSR_TRG_PWM_EN_Pos)          /*!< TIMER_T::TCSR: TRG_PWM_EN Mask */
N
N#define TIMER_TCSR_TRG_SRC_SEL_Pos  18                                          /*!< TIMER_T::TCSR: TRG_SRC_SEL Position */
N#define TIMER_TCSR_TRG_SRC_SEL_Msk  (1ul << TIMER_TCSR_TRG_SRC_SEL_Pos)         /*!< TIMER_T::TCSR: TRG_SRC_SEL Mask */
N
N#define TIMER_TCSR_TDR_EN_Pos       16                                          /*!< TIMER_T::TCSR: TDR_EN Position */
N#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)              /*!< TIMER_T::TCSR: TDR_EN Mask */
N
N#define TIMER_TCSR_PRESCALE_Pos     0                                           /*!< TIMER_T::TCSR: PRESCALE Position */
N#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)         /*!< TIMER_T::TCSR: PRESCALE Mask */
N
N/* TIMER TCMPR Bit Field Definitions */
N#define TIMER_TCMP_TCMP_Pos         0                                           /*!< TIMER_T::TCMPR: TCMP Position */
N#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)         /*!< TIMER_T::TCMPR: TCMP Mask */
N
N/* TIMER TISR Bit Field Definitions */
N#define TIMER_TISR_TWF_Pos          1                                           /*!< TIMER_T::TISR: TWF Position */
N#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)                 /*!< TIMER_T::TISR: TWF Mask */
N
N#define TIMER_TISR_TIF_Pos          0                                           /*!< TIMER_T::TISR: TIF Position */
N#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)                 /*!< TIMER_T::TISR: TIF Mask */
N
N/* TIMER TDR Bit Field Definitions */
N#define TIMER_TDR_TDR_Pos           0                                           /*!< TIMER_T::TDR: TDR Position */
N#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)           /*!< TIMER_T::TDR: TDR Mask */
N
N/* TIMER TCAP Bit Field Definitions */
N#define TIMER_TCAP_TCAP_Pos         0                                           /*!< TIMER_T::TCAP: TCAP Position */
N#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER_T::TCAP: TCAP Mask */
N
N/* TIMER TEXCON Bit Field Definitions */
N#define TIMER_TEXCON_TCDB_Pos       7                                           /*!< TIMER_T::TEXCON: TCDB Position */
N#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)              /*!< TIMER_T::TEXCON: TCDB Mask */
N
N#define TIMER_TEXCON_TEXDB_Pos      6                                           /*!< TIMER_T::TEXCON: TEXDB Position */
N#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)             /*!< TIMER_T::TEXCON: TEXDB Mask */
N
N#define TIMER_TEXCON_TEXIEN_Pos     5                                           /*!< TIMER_T::TEXCON: TEXIEN Position */
N#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)            /*!< TIMER_T::TEXCON: TEXIEN Mask */
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos  4                                           /*!< TIMER_T::TEXCON: RSTCAPSEL Position */
N#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)         /*!< TIMER_T::TEXCON: RSTCAPSEL Mask */
N
N#define TIMER_TEXCON_TEXEN_Pos      3                                           /*!< TIMER_T::TEXCON: TEXEN Position */
N#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)             /*!< TIMER_T::TEXCON: TEXEN Mask */
N
N#define TIMER_TEXCON_TEX_EDGE_Pos   1                                           /*!< TIMER_T::TEXCON: TEX_EDGE Position */
N#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)        /*!< TIMER_T::TEXCON: TEX_EDGE Mask */
N
N#define TIMER_TEXCON_TX_PHASE_Pos   0                                           /*!< TIMER_T::TEXCON: TX_PHASE Position */
N#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)          /*!< TIMER_T::TEXCON: TX_PHASE Mask */
N
N/* TIMER TEXISR Bit Field Definitions */
N#define TIMER_TEXISR_TEXIF_Pos      0                                           /*!< TIMER_T::TEXISR: TEXIF Position */
N#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)             /*!< TIMER_T::TEXISR: TEXIF Mask */
N/*@}*/ /* end of group TIMER_CONST */
N/*@}*/ /* end of group TIMER */
N
N
N
N
N
N/*------------------------- UART Interface Controller ------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller (UART)
N    Memory Mapped Structure for UART Controller
N@{ */
Ntypedef struct
N{
N
N    union
N    {
N        __IO uint32_t DATA;
X        volatile uint32_t DATA;
N
N        /**
N         * THR
N         * ===================================================================================================
N         * Offset: 0x00 Transmit Holding DATA
N         * ---------------------------------------------------------------------------------------------------
N         * |Bits    |Field     |Descriptions
N         * | :----: | :----:   | :---- |
N         * |[7:0]   |THR       |Transmit Holding Register
N         * |        |          |By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB first).
N         */
N        __IO uint32_t THR;
X        volatile uint32_t THR;
N
N        /**
N         * UA_RBR
N         * ===================================================================================================
N         * Offset: 0x00  UART Receive Buffer Register
N         * ---------------------------------------------------------------------------------------------------
N         * |Bits    |Field     |Descriptions
N         * | :----: | :----:   | :---- |
N         * |[7:0]   |RBR       |Receive Buffer Register (Read Only)
N         * |        |          |By reading this register, the UART will return the 8-bit data received from RX pin (LSB first).
N         */
N        __IO uint32_t RBR;
X        volatile uint32_t RBR;
N    };
N
N    /**
N     * UA_IER
N     * ===================================================================================================
N     * Offset: 0x04  UART Interrupt Enable Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable Control
N     * |        |          |0 = RDA_INT Masked off.
N     * |        |          |1 = RDA_INT Enabled.
N     * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable Control
N     * |        |          |0 = THRE_INT Masked off.
N     * |        |          |1 = THRE_INT Enabled.
N     * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable Control
N     * |        |          |0 = RLS_INT Masked off.
N     * |        |          |1 = RLS_INT Enabled
N     * |[3]     |MODEM_IEN |Modem Status Interrupt Enable Control (Available In UART0/UART1 Channel)
N     * |        |          |0 = MODEM_INT Masked off.
N     * |        |          |1 = MODEM_INT Enabled.
N     * |[4]     |TOUT_IEN  |RX Time-Out Interrupt Enable Control
N     * |        |          |0 = TOUT_INT Masked off.
N     * |        |          |1 = TOUT_INT Enabled.
N     * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable Control
N     * |        |          |0 = BUF_ERR_INT Masked off.
N     * |        |          |1 = BUF_ERR_INT Enabled.
N     * |[6]     |WKCTSIEN  |nCTS Wake-Up Interrupt Enable Bit (Available In UART0/UART1 Channel)
N     * |        |          |0 = nCTS wake-up system function Disabled.
N     * |        |          |1 = Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode.
N     * |[8]     |LIN_IEN   |LIN Bus Interrupt Enable
N     * |        |          |0 = Lin bus interrupt Disabled.
N     * |        |          |1 = Lin bus interrupt Enabled.
N     * |        |          |Note: This field is used for LIN function mode.
N     * |[10]    |WKDATIEN  |Incoming Data Wake-Up Interrupt Enable Bit
N     * |        |          |0 = Incoming data wake-up system function Disabled.
N     * |        |          |1 = Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode.
N     * |        |          |Note: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable.
N     * |[11]    |TIME_OUT_EN|Time-Out Counter Enable
N     * |        |          |0 = Time-out counter Disabled.
N     * |        |          |1 = Time-out counter Enabled.
N     * |[12]    |AUTO_RTS_EN|RTS Auto Flow Control Enable (Available In UART0/UART1 Channel)
N     * |        |          |0 = RTS auto flow control Disabled.
N     * |        |          |1 = RTS auto flow control Enabled.
N     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.
N     * |[13]    |AUTO_CTS_EN|CTS Auto Flow Control Enable (Available In UART0/UART1 Channel)
N     * |        |          |0 = CTS auto flow control Disabled.
N     * |        |          |1 = CTS auto flow control Enabled.
N     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
N     * |[18]    |ABRIEN    |Auto-Baud Rate Interrupt Enable Bit
N     * |        |          |0 = Auto-baud rate interrupt Disabled.
N     * |        |          |1 = Auto-baud rate interrupt Enabled.
N     */
N    __IO uint32_t IER;
X    volatile uint32_t IER;
N
N    /**
N     * UA_FCR
N     * ===================================================================================================
N     * Offset: 0x08  UART FIFO Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RFR       |RX Field Software Reset
N     * |        |          |When RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the RX internal state machine and pointers.
N     * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N     * |[2]     |TFR       |TX Field Software Reset
N     * |        |          |When TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the TX internal state machine and pointers.
N     * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N     * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
N     * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if RDA_IEN(UA_IER[0]) enabled, and an interrupt will be generated).
N     * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
N     * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
N     * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
N     * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
N     * |        |          |Other = Reserved.
N     * |[8]     |RX_DIS    |Receiver Disable Register
N     * |        |          |The receiver is disabled or not (set 1 to disable receiver).
N     * |        |          |0 = Receiver Enabled.
N     * |        |          |1 = Receiver Disabled.
N     * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode.
N     * |        |          |It should be programmed before RS485_NMM(UA_ALT_CSR[8]) is programmed.
N     * |[19:16] |RTS_TRI_LEV|RTS Trigger Level For Auto-Flow Control Use (Available In UART0/UART1 Channel)
N     * |        |          |0000 = RTS Trigger Level is 1 byte.
N     * |        |          |0001 = RTS Trigger Level is 4 bytes.
N     * |        |          |0010 = RTS Trigger Level is 8 bytes.
N     * |        |          |0011 = RTS Trigger Level is 14 bytes.
N     * |        |          |Other = Reserved.
N     * |        |          |Note: This field is used for RTS auto-flow control.
N     */
N    __IO uint32_t FCR;
X    volatile uint32_t FCR;
N
N    /**
N     * UA_LCR
N     * ===================================================================================================
N     * Offset: 0x0C  UART Line Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WLS       |Word Length Selection
N     * |        |          |00 = Word length is 5-bit.
N     * |        |          |01 = Word length is 6-bit.
N     * |        |          |10 = Word length is 7-bit
N     * |        |          |11 = Word length is 8-bit
N     * |[2]     |NSB       |Number Of "STOP Bit"
N     * |        |          |0 = One " STOP bit" is generated in the transmitted data.
N     * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
N     * |        |          |When select 6-,7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
N     * |[3]     |PBE       |Parity Bit Enable
N     * |        |          |0 = No parity bit.
N     * |        |          |1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
N     * |[4]     |EPE       |Even Parity Enable
N     * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
N     * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
N     * |        |          |This bit has effect only when PBE (UA_LCR[3]) is set.
N     * |[5]     |SPE       |Stick Parity Enable
N     * |        |          |0 = Stick parity Disabled.
N     * |        |          |1 = If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
N     * |        |          |If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1.
N     * |[6]     |BCB       |Break Control Bit
N     * |        |          |When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
N     * |        |          |This bit acts only on TX and has no effect on the transmitter logic.
N     */
N    __IO uint32_t LCR;
X    volatile uint32_t LCR;
N
N    /**
N     * UA_MCR
N     * ===================================================================================================
N     * Offset: 0x10  UART Modem Control Register (Available In UART0/UART1 Channel)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |RTS       |RTS (Request-To-Send) Signal Control
N     * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.
N     * |        |          |0 = RTS signal is active.
N     * |        |          |1 = RTS signal is inactive.
N     * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.
N     * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
N     * |[9]     |LEV_RTS   |RTS Pin Active Level 
N     * |        |          |This bit defines the active level state of RTS pin output.
N     * |        |          |0 = RTS pin output is high level active.
N     * |        |          |1 = RTS pin output is low level active.
N     * |[13]    |RTS_ST    |RTS Pin State (Read Only)
N     * |        |          |This bit mirror from RTS pin output of voltage logic status.
N     * |        |          |0 = RTS pin output is low level voltage logic state.
N     * |        |          |1 = RTS pin output is high level voltage logic state.
N     */
N    __IO uint32_t MCR;
X    volatile uint32_t MCR;
N
N    /**
N     * UA_MSR
N     * ===================================================================================================
N     * Offset: 0x14  UART Modem Status Register (Available In UART0/UART1 Channel)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |DCTSF     |Detect CTS State Change Flag (Read Only)
N     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.
N     * |        |          |0 = CTS input has not change state.
N     * |        |          |1 = CTS input has change state.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[4]     |CTS_ST    |CTS Pin Status (Read Only) 
N     * |        |          |This bit mirror from CTS pin input of voltage logic status.
N     * |        |          |0 = CTS pin input is low level voltage logic state.
N     * |        |          |1 = CTS pin input is high level voltage logic state.
N     * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected
N     * |[8]     |LEV_CTS   |CTS Pin Active Level
N     * |        |          |This bit defines the active level state of CTS pin input.
N     * |        |          |0 = CTS pin input is high level active.
N     * |        |          |1 = CTS pin input is low level active.
N     */
N    __IO uint32_t MSR;
X    volatile uint32_t MSR;
N
N    /**
N     * UA_FSR
N     * ===================================================================================================
N     * Offset: 0x18  UART FIFO Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RX_OVER_IF|RX Overflow Error IF (Read Only)
N     * |        |          |This bit is set when RX FIFO overflow.
N     * |        |          |If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 16 bytes of UART0/UART1/UART2, this bit will be set.
N     * |        |          |0 = RX FIFO is not overflow.
N     * |        |          |1 = RX FIFO is overflow.
N     * |        |          |If the number of bytes of received data is greater than 1 byte, 1 byte of UART3/UART4/UART5, this bit will be set.
N     * |        |          |0 = RX Buffer is not overflow.
N     * |        |          |1 = RX Buffer is overflow.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[1]     |ABRDIF    |Auto-Baud Rate Detect Interrupt (Read Only)
N     * |        |          |0 = Auto-baud rate detect function is not finished.
N     * |        |          |1 = Auto-baud rate detect function is finished.
N     * |        |          |This bit is set to logic "1" when auto-baud rate detect function is finished.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[2]     |ABRDTOIF  |Auto-Baud Rate Time-Out Interrupt (Read Only)
N     * |        |          |0 = Auto-baud rate counter is underflow.
N     * |        |          |1 = Auto-baud rate counter is overflow.
N     * |        |          |Note1: This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.
N     * |        |          |Note2: This bit is read only, but can be cleared by writing "1" to it.
N     * |[3]     |RS485_ADD_DETF|RS-485 Address Byte Detection Flag (Read Only) (Available In UART0/UART1 Channel)
N     * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 ='1').
N     * |        |          |1 = Receiver detects a data that is an address bit (bit 9 ='1').
N     * |        |          |Note1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.
N     * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
N     * |[4]     |PEF       |Parity Error Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
N     * |        |          |0 = No parity error is generated.
N     * |        |          |1 = Parity error is generated.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[5]     |FEF       |Framing Error Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.
N     * |        |          |0 = No framing error is generated.
N     * |        |          |1 = Framing error is generated.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[6]     |BIF       |Break Interrupt Flag (Read Only)
N     * |        |          |This bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
N     * |        |          |0 = No Break interrupt is generated.
N     * |        |          |1 = Break interrupt is generated.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[13:8]  |RX_POINTER|RX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the RX FIFO Buffer Pointer.
N     * |        |          |When UART receives one byte from external device, then RX_POINTER increases one. '
N     * |        |          |When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.
N     * |        |          |The Maximum value shown in RX_POINTER is 15 (UART0/UART1/UART2).
N     * |        |          |When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0.
N     * |        |          |As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15 (UART0/UART1/UART2).
N     * |        |          |When RX Buffer is equal to 1, if one byte data is received, the RX_FULL bit is set to 1 and RX_POINTER will show 1.
N     * |        |          |Once the RX Buffer is read, the RX_POINTER is 0.
N     * |[14]    |RX_EMPTY  |Receiver FIFO Empty (Read Only)
N     * |        |          |This bit initiate RX FIFO empty or not. (UART0/UART1/UART2)
N     * |        |          |0 = RX FIFO is not empty.
N     * |        |          |1 = RX FIFO is empty.
N     * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.
N     * |        |          |This bit initiate RX Buffer empty or not. (UART3/UART4/UART5)
N     * |        |          |0 = RX Buffer is not empty.
N     * |        |          |1 = RX Buffer is empty.
N     * |        |          |Note: When the last byte of RX Buffer has been read by CPU, hardware sets this bit high.
N     * |        |          |It will be cleared when UART receives any new data.
N     * |[15]    |RX_FULL   |Receiver FIFO Full (Read Only)
N     * |        |          |This bit initiates RX FIFO is full or not (UART0/UART1/UART2).
N     * |        |          |0 = RX FIFO is not full.
N     * |        |          |1 = RX FIFO is full.
N     * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16 (UART0/UART1/UART2), otherwise is cleared by hardware.
N     * |        |          |This bit initiates RX Buffer is full or not (UART3/UART4/UART5).
N     * |        |          |0 = RX buffer is not full.
N     * |        |          |1 = RX buffer is full.
N     * |        |          |Note: This bit is set when the number of usage in RX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.
N     * |[21:16] |TX_POINTER|TX FIFO Pointer (Read Only)
N     * |        |          |This field indicates the TX FIFO Buffer Pointer.
N     * |        |          |When CPU writes one byte into UA_THR, then TX_POINTER increases one.
N     * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.
N     * |        |          |The Maximum value shown in TX_POINTER is 15 (UART0/UART1/UART2).
N     * |        |          |When the using level of TX FIFO Buffer is equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0.
N     * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15 (UART0/UART1/UART2).
N     * |        |          |TX_POINTER is 0 (UART3/UART4/UART5).
N     * |        |          |When TX Buffer is equal to 1, if one byte data is received, the TX_FULL bit is set to 1 and TX_POINTER will show 1.
N     * |        |          |Once the TX Buffer is read, the TX_POINTER is 0.
N     * |[22]    |TX_EMPTY  |Transmitter FIFO Empty (Read Only)
N     * |        |          |This bit indicates TX FIFO empty or not. (UART0/UART1/UART2)
N     * |        |          |0 = TX FIFO is not empty.
N     * |        |          |1 = TX FIFO is empty.
N     * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
N     * |        |          |It will be cleared when writing data into THR (TX FIFO not empty).
N     * |        |          |This bit indicates TX Buffer filled or not. (UART3/UART4/UART5)
N     * |        |          |0 = TX Buffer is not empty.
N     * |        |          |1 = TX Buffer is empty.
N     * |        |          |Note: When the last byte of TX Buffer has been transferred to Transmitter Shift Register, hardware sets this bit high.
N     * |        |          |It will be cleared when writing data into THR (TX FIFO not empty).
N     * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
N     * |        |          |This bit indicates TX FIFO is full or not. (UART0/UART1/UART2)
N     * |        |          |0 = TX FIFO is not full.
N     * |        |          |1 = TX FIFO is full.
N     * |        |          |This bit is set when the number of usage in TX FIFO is equal to 16 (UART0/UART1/UART2), otherwise is cleared by hardware.
N     * |        |          |This bit indicates TX Buffer is full or not.(UART3/UART4/UART5)
N     * |        |          |0 = TX Buffer is not full.
N     * |        |          |1 = TX Buffer is full.
N     * |        |          |This bit is set when the number of usage in TX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.
N     * |[24]    |TX_OVER_IF|TX Overflow Error Interrupt Flag (Read Only)
N     * |        |          |If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. (UART0/UART1/UART2)
N     * |        |          |0 = TX FIFO is not overflow.
N     * |        |          |1 = TX FIFO is overflow.
N     * |        |          |If TX Buffer is filled, an additional write to UA_THR will cause this bit to logic 1. (UART3/UART4/UART5)
N     * |        |          |0 = TX Buffer is not overflow.
N     * |        |          |1 = TX Buffer is overflow.
N     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
N     * |[28]    |TE_FLAG   |Transmitter Empty Flag (Read Only)
N     * |        |          |This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART0/UART1/UART2)
N     * |        |          |0 = TX FIFO is not empty.
N     * |        |          |1 = TX FIFO is empty.
N     * |        |          |This bit is set by hardware when TX Buffer (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART3/UART4/UART5)
N     * |        |          |0 = TX Buffer is not empty.
N     * |        |          |1 = TX Buffer is empty.
N     * |        |          |Note: This bit is cleared automatically when TX FIFO/TX Buffer is not empty or the last byte transmission has not completed.
N      */
N    __IO uint32_t FSR;
X    volatile uint32_t FSR;
N
N    /**
N     * UA_ISR
N     * ===================================================================================================
N     * Offset: 0x1C  UART Interrupt Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only)
N     * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set.
N     * |        |          |If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
N     * |        |          |0 = No RDA interrupt flag is generated.
N     * |        |          |1 = RDA interrupt flag is generated.
N     * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).
N     * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
N     * |        |          |If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.
N     * |        |          |0 = No THRE interrupt flag is generated.
N     * |        |          |1 = THRE interrupt flag is generated.
N     * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).
N     * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set).
N     * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
N     * |        |          |0 = No RLS interrupt flag is generated.
N     * |        |          |1 = RLS interrupt flag is generated.
N     * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = '1') bit.
N     * |        |          |At the same time, the bit of UA_FSR[RS485_ADD_DETF] is also set.
N     * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.
N     * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.
N     * |[3]     |MODEM_IF  |MODEM Interrupt Flag (Read Only) (Available In UART0/UART1 Channel)
N     * |        |          |This bit is set when the CTS pin has state change (DCTSF (UA_MSR[0]) = 1).
N     * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
N     * |        |          |0 = No Modem interrupt flag is generated.
N     * |        |          |1 = Modem interrupt flag is generated.
N     * |        |          |Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).
N     * |[4]     |TOUT_IF   |Time-Out Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
N     * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
N     * |        |          |0 = No Time-out interrupt flag is generated.
N     * |        |          |1 = Time-out interrupt flag is generated.
N     * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it
N     * |[5]     |BUF_ERR_IF|Buffer Error Interrupt Flag (Read Only)
N     * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set).
N     * |        |          |When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct.
N     * |        |          |If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.
N     * |        |          |0 = No buffer error interrupt flag is generated.
N     * |        |          |1 = Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.
N     * |        |          |1 = Buffer error interrupt flag is generated.
N     * |        |          |Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared
N     * |[6]     |WKIF      |UART Wake-up Interrupt Flag (Read Only)
N     * |        |          |This bit is set when DATWKIF (UA_ISR[17]) or CTSWKIF(UA_ISR[16]) is set to 1.
N     * |        |          |0 = No DATWKIF and CTSWKIF are generated.
N     * |        |          |1 = DATWKIF or CTSWKIF.
N     * |        |          |Note: This bit is read only.
N     * |        |          |This bit is cleared if both of DATWKIF (UA_ISR[17]) and CTSWKIF(UA_ISR[16]) are cleared to 0 by writing 1 to DATWKIF (UA_ISR[17]) and CTSWKIF (UA_ISR[17]).
N     * |[7]     |LIN_IF    |LIN Bus Flag (Read Only)
N     * |        |          |This bit is set when LIN slave header detect (LINS_HDET_F (UA_LIN_SR[0] =1)), LIN break detect (LIN_BKDET_F(UA_LIN_SR[9]=1)), bit error detect (BIT_ERR_F(UA_LIN_SR[9]=1), LIN slave ID parity error (LINS_IDPERR_F(UA_LIN_SR[2] = 1) or LIN slave header error detect (LINS_HERR_F (UA_LIN_SR[1])).
N     * |        |          |If LIN_ IEN (UA_IER [8]) is enabled the LIN interrupt will be generated.
N     * |        |          |0 = None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated.
N     * |        |          |1 = At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated.
N     * |        |          |Note: This bit is read only.
N     * |        |          |This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are cleared.
N     * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.
N     * |        |          |0 = No RDA interrupt is generated.
N     * |        |          |1 = RDA interrupt is generated.
N     * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.
N     * |        |          |0 = No THRE interrupt is generated.
N     * |        |          |1 = THRE interrupt is generated.
N     * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.
N     * |        |          |0 = No RLS interrupt is generated.
N     * |        |          |1 = RLS interrupt is generated
N     * |[11]    |MODEM_INT |MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)
N     * |        |          |This bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1
N     * |        |          |0 = No Modem interrupt is generated.
N     * |        |          |1 = Modem interrupt is generated.
N     * |[12]    |TOUT_INT  |Time-Out Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.
N     * |        |          |0 = No Tout interrupt is generated.
N     * |        |          |1 = Tout interrupt is generated.
N     * |[13]    |BUF_ERR_INT|Buffer Error Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.
N     * |        |          |0 = No buffer error interrupt is generated.
N     * |        |          |1 = Buffer error interrupt is generated.
N     * |[15]    |LIN_INT   |LIN Bus Interrupt Indicator (Read Only)
N     * |        |          |This bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.
N     * |        |          |0 = No LIN Bus interrupt is generated.
N     * |        |          |1 = The LIN Bus interrupt is generated.
N     * |[16]    |CTSWKIF   |nCTS Wake-Up Interrupt Flag (Read Only) (Available In UART0/UART1 Channel)
N     * |        |          |0 = Chip stays in power-down state.
N     * |        |          |1 = Chip wake-up from power-down state by nCTS wake-up.
N     * |        |          |Note1: If WKCTSIEN (UA_IER[6])is enabled, the wake-up interrupt is generated.
N     * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
N     * |[17]    |DATWKIF   |Data Wake-Up Interrupt Flag (Read Only)
N     * |        |          |This bit is set if chip wake-up from power-down state by data wake-up.
N     * |        |          |0 = Chip stays in power-down state.
N     * |        |          |1 = Chip wake-up from power-down state by data wake-up.
N     * |        |          |Note1: If WKDATIEN (UA_IER[10]) is enabled, the wake-up interrupt is generated.
N     * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
N     */
N    __IO uint32_t ISR;
X    volatile uint32_t ISR;
N
N    /**
N     * UA_TOR
N     * ===================================================================================================
N     * Offset: 0x20  UART Time-out Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |TOIC      |Time-Out Interrupt Comparator
N     * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
N     * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UA_TOR[7:0])), a receiver time-out interrupt (INT_TOUT) is generated if TOUT_IEN (UA_IER [4]) enabled.
N     * |        |          |A new incoming data word or RX FIFO empty will clear TOUT_INT(UA_IER[9]).
N     * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC (UA_TOR[7:0]) value should be set between 40 and 255.
N     * |        |          |So, for example, if TOIC (UA_TOR[7:0]) is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
N     * |[15:8]  |DLY       |TX Delay Time Value
N     * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit.
N     */
N    __IO uint32_t TOR;
X    volatile uint32_t TOR;
N
N    /**
N     * UA_BAUD
N     * ===================================================================================================
N     * Offset: 0x24  UART Baud Rate Divisor Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[15:0]  |BRD       |Baud Rate Divider
N     * |        |          |The field indicates the baud rate divider
N     * |[27:24] |DIVIDER_X |Divider X
N     * |        |          |The baud rate divider M = X+1.
N     * |[28]    |DIV_X_ONE |Divider X Equal To 1
N     * |        |          |0 = Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must >= 8).
N     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD [15:0] must >= 3).  
N     * |[29]    |DIV_X_EN  |Divider X Enable
N     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is
N     * |        |          |Baud Rate = Clock / [M * (BRD + 2)]; The default value of M is 16.
N     * |        |          |0 = Divider X Disabled (the equation of M = 16).
N     * |        |          |1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
N     * |        |          |Note: In IrDA mode, this bit must disable.
N     */
N    __IO uint32_t BAUD;
X    volatile uint32_t BAUD;
N
N    /**
N     * UA_IRCR
N     * ===================================================================================================
N     * Offset: 0x28  UART IrDA Control Register 
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1]     |TX_SELECT |TX_SELECT
N     * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled.
N     * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
N     * |[5]     |INV_TX    |IrDA inverse Transmitting Output Signal Control
N     * |        |          |0 = None inverse transmitting signal.
N     * |        |          |1 = Inverse transmitting output signal.
N     * |[6]     |INV_RX    |IrDA inverse Receive Input Signal Control
N     * |        |          |0 = None inverse receiving input signal.
N     * |        |          |1 = Inverse receiving input signal.
N     */
N    __IO uint32_t IRCR;
X    volatile uint32_t IRCR;
N
N    /**
N     * UA_ALT_CSR
N     * ===================================================================================================
N     * Offset: 0x2C  UART Alternate Control/Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[3:0]   |LIN_BKFL  |UART LIN Break Field Length (Available In UART0/UART1/UART2)
N     * |        |          |This field indicates a 4-bit LIN TX break field count.
N     * |        |          |Note1: This break field length is UA_LIN_BKFL + 1
N     * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
N     * |[6]     |LIN_RX_EN |LIN RX Enable (Available In UART0/UART1/UART2)
N     * |        |          |0 = LIN RX mode Disabled.
N     * |        |          |1 = LIN RX mode Enabled.
N     * |[7]     |LIN_TX_EN |LIN TX Break Mode Enable (Available In UART0/UART1/UART2)
N     * |        |          |0 = LIN TX Break mode Disabled.
N     * |        |          |1 = LIN TX Break mode Enabled.
N     * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
N     * |[8]     |RS485_NMM |RS-485 Normal Multi-Drop Operation Mode (NMM) (Available In UART0/UART1)
N     * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
N     * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
N     * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
N     * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD) (Available In UART0/UART1)
N     * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
N     * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
N     * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
N     * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD) (Available In UART0/UART1)
N     * |        |          |0 = RS-485 Auto Direction Operation mode (AUO) Disabled.
N     * |        |          |1 = RS-485 Auto Direction Operation mode (AUO) Enabled.
N     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
N     * |[15]    |RS485_ADD_EN|RS-485 Address Detection Enable (Available In UART0/UART1)
N     * |        |          |This bit is used to enable RS-485 Address Detection mode.
N     * |        |          |0 = Address detection mode Disabled.
N     * |        |          |1 = Address detection mode Enabled.
N     * |        |          |Note: This bit is used for RS-485 any operation mode.
N     * |[17]    |ABRIF     |Auto-Baud Rate Interrupt Flag (Read Only)
N     * |        |          |This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UA_IEN [18]) is set then the auto-baud rate interrupt will be generated.
N     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to ABRDTOIF (UA_FSR[2]) and ABRDIF(UA_FSR[1])
N     * |[18]    |ABRDEN    |Auto-Baud Rate Detect Enable Bit
N     * |        |          |0 = Auto-baud rate detect function Disabled.
N     * |        |          |1 = Auto-baud rate detect function Enabled.
N     * |        |          |This bit is cleared automatically after auto-baud detection is finished.
N     * |[20:19] |ABRDBITS  |Auto-Baud Rate Detect Bit Length
N     * |        |          |00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
N     * |        |          |01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
N     * |        |          |10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
N     * |        |          |11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
N     * |        |          |Note : The calculation of bit number includes the START bit.
N     * |[31:24] |ADDR_MATCH|Address Match Value Register (Available In UART0/UART1)
N     * |        |          |This field contains the RS-485 address match values.
N     * |        |          |Note: This field is used for RS-485 auto address detection mode.
N     */
N    __IO uint32_t ALT_CSR;
X    volatile uint32_t ALT_CSR;
N
N    /**
N     * UA_FUN_SEL
N     * ===================================================================================================
N     * Offset: 0x30  UART Function Select Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |FUN_SEL   |Function Select Enable
N     * |        |          |00 = UART function Enabled.
N     * |        |          |01 = LIN function Enabled. (Available In UART0/UART1/UART2)
N     * |        |          |10 = IrDA function Enabled.
N     * |        |          |11 = RS-485 function Enabled. (Available In UART0/UART1)
N     */
N    __IO uint32_t FUN_SEL;
X    volatile uint32_t FUN_SEL;
N
N    /**
N     * UA_LIN_CTL
N     * ===================================================================================================
N     * Offset: 0x34  UART LIN Control Register (Available In UART0/UART1/UART2)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LINS_EN   |LIN Slave Mode Enable Control
N     * |        |          |0 = LIN slave mode Disabled.
N     * |        |          |1 = LIN slave mode Enabled.
N     * |[1]     |LINS_HDET_EN|LIN Slave Header Detection Enable Control
N     * |        |          |0 = LIN slave header detection Disabled.
N     * |        |          |1 = LIN slave header detection Enabled.
N     * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N     * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), LINS_HDET_F (UA_LIN_SR [0]) flag will be asserted.
N     * |        |          |If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
N     * |[2]     |LINS_ARS_EN|LIN Slave Automatic Resynchronization Mode Enable Control
N     * |        |          |0 = LIN automatic resynchronization Disabled.
N     * |        |          |1 = LIN automatic resynchronization Enabled.
N     * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N     * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).
N     * |        |          |(Slave mode with automatic resynchronization).
N     * |[3]     |LINS_DUM_EN|LIN Slave Divider Update Method Enable Control
N     * |        |          |0 = UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time).
N     * |        |          |1 = UA_BAUD is updated at the next received character. User must set the bit before checksum reception.
N     * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N     * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
N     * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
N     * |        |          |(Slave mode with automatic resynchronization).
N     * |[4]     |LIN_MUTE_EN|LIN Mute Mode Enable Control
N     * |        |          |0 = LIN mute mode Disabled.
N     * |        |          |1 = LIN mute mode Enabled.
N     * |        |          |Note: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).
N     * |[8]     |LIN_SHD   |LIN TX Send Header Enable Control
N     * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).
N     * |        |          |0 = Send LIN TX header Disabled.
N     * |        |          |1 = Send LIN TX header Enabled.
N     * |        |          |Note1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).
N     * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.
N     * |[9]     |LIN_IDPEN |LIN ID Parity Enable Control
N     * |        |          |0 = LIN frame ID parity Disabled.
N     * |        |          |1 = LIN frame ID parity Enabled.
N     * |        |          |Note1: This bit can be used for LIN master to sending header field (LIN_SHD (UA_LIN_CTL[8])) = 1 and LIN_HEAD_SEL (UA_LIN_CTL[23:22]) = 10) or be used for enable LIN slave received frame ID parity checked.
N     * |        |          |Note2: This bit is only use when the operation header transmitter is in LIN_HEAD_SEL (UA_LIN_CTL[23:22]) = 10
N     * |[10]    |LIN_BKDET_EN|LIN Break Detection Enable Control
N     * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter character, the LIN_BKDET_F (UA_LIN_SR[8]) flag is set in UA_LIN_SR register at the end of break field.
N     * |        |          |If the LIN_IEN (UA_IER [8])=1, an interrupt will be generated.
N     * |        |          |0 = LIN break detection Disabled.
N     * |        |          |1 = LIN break detection Enabled.
N     * |[11]    |LIN_RX_DIS|LIN Receiver Disable Control
N     * |        |          |If the receiver is enabled (LIN_RX_DIS (UA_LIN_CTL[11] ) = 0), all received byte data will be accepted and stored in the RX-FIFO, and if the receiver is disabled (LIN_RX_DIS (UA_LIN_CTL[11] = 1), all received byte data will be ignore.
N     * |        |          |0 = LIN receiver Enabled.
N     * |        |          |1 = LIN receiver Disabled.
N     * |        |          |Note: This bit is only valid when operating in LIN function mode (FUN_SEL (UA_FUN_SEL[1:0]) = 01)
N     * |[12]    |BIT_ERR_EN|Bit Error Detect Enable Control
N     * |        |          |0 = Bit error detection function Disabled.
N     * |        |          |1 = Bit error detection Enabled.
N     * |        |          |Note: In LIN function mode, when occur bit error, the BIT_ERR_F (UA_LIN_SR[9]) flag will be asserted.
N     * |        |          |If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
N     * |[19:16] |LIN_BKFL  |LIN Break Field Length
N     * |        |          |This field indicates a 4-bit LIN TX break field count.
N     * |        |          |Note1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].
N     * |        |          |Note2: This break field length is LIN_BKFL + 1.
N     * |        |          |Note3:
N     * |        |          |According to LIN spec, the reset value is 12 (break field length = 13).
N     * |[21:20] |LIN_BS_LEN|LIN Break/Sync Delimiter Length
N     * |        |          |00 = The LIN break/sync delimiter length is 1 bit time.
N     * |        |          |10 = The LIN break/sync delimiter length is 2 bit time.
N     * |        |          |10 = The LIN break/sync delimiter length is 3 bit time.
N     * |        |          |11 = The LIN break/sync delimiter length is 4 bit time.
N     * |        |          |Note: This bit used for LIN master to sending header field.
N     * |[23:22] |LIN_HEAD_SEL|LIN Header Select
N     * |        |          |00 = The LIN header includes "break field".
N     * |        |          |01 = The LIN header includes "break field" and "sync field".
N     * |        |          |10 = The LIN header includes "break field", "sync field" and "frame ID field".
N     * |        |          |11 = Reserved.
N     * |        |          |Note: This bit is used to master mode for LIN to send header field (LIN_SHD (UA_LIN_CTL [8]) = 1) or used to slave to indicates exit from mute mode condition (LIN_MUTE_EN (UA_LIN_CTL[4] = 1).
N     * |[31:24] |LIN_PID   |LIN PID Register
N     * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be generated by software or hardware depends on LIN_IDPEN (UA_LIN_CTL[9]) = 1.
N     * |        |          |If the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.
N     * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
N     * |        |          |Note2: This field can be used for LIN master mode or slave mode.
N     */
N    __IO uint32_t LIN_CTL;
X    volatile uint32_t LIN_CTL;
N
N    /**
N     * UA_LIN_SR
N     * ===================================================================================================
N     * Offset: 0x38  UART LIN Status Register (Available In UART0/UART1/UART2)
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |LINS_HDET_F|LIN Slave Header Detection Flag (Read Only)
N     * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.
N     * |        |          |0 = LIN header not detected.
N     * |        |          |1 = LIN header detected (break + sync + frame ID).
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0]) = 1) and enable LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
N     * |        |          |Note3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ("break + sync + frame ID"), the LINS_HEDT_F will be set whether the frame ID correct or not.
N     * |[1]     |LINS_HERR_F|LIN Slave Header Error Flag (Read Only)
N     * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it.
N     * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".
N     * |        |          |0 = LIN header error not detected.
N     * |        |          |1 = LIN header error detected.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (LINS_EN (UA_LIN_CTL [0]) = 1) and enables LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
N     * |[2]     |LINS_IDPERR_F|LIN Slave ID Parity Error Flag (Read Only)
N     * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
N     * |        |          |0 = No active.
N     * |        |          |1 = Receipted frame ID parity is not correct.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N     * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0])= 1) and enable LIN frame ID parity check function LIN_IDPEN (UA_LIN_CTL [9]).
N     * |[3]     |LINS_SYNC_F|LIN Slave Sync Field
N     * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode.
N     * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.
N     * |        |          |0 = The current character is not at LIN sync state.
N     * |        |          |1 = The current character is at LIN sync state.
N     * |        |          |Note1: This bit is only valid when in LIN Slave mode (LINS_EN(UA_LIN_CTL[0]) = 1).
N     * |        |          |Note2: This bit is read only, but it can be cleared by writing 1 to it.
N     * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.
N     * |[8]     |LIN_BKDET_F|LIN Break Detection Flag (Read Only)
N     * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.
N     * |        |          |0 = LIN break not detected.
N     * |        |          |1 = LIN break detected.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (LIN_BKDET_EN (UA_LIN_CTL[10]) =1).
N     * |[9]     |BIT_ERR_F |Bit Error Detect Status Flag (Read Only)
N     * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.
N     * |        |          |When occur bit error, if the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
N     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N     * |        |          |Note2: This bit is only valid when enable bit error detection function (BIT_ERR_EN (UA_LIN_CTL [12]) = 1).
N     */
N    __IO uint32_t LIN_SR;
X    volatile uint32_t LIN_SR;
N} UART_T;
N
N
N/** @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N  @{
N */
N
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos            0                                       /*!< UART_T::THR: THR Position  */
N#define UART_THR_THR_Msk            (0xFul << UART_THR_THR_Pos)             /*!< UART_T::THR: THR Mask      */
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos            0                                       /*!< UART_T::RBR: RBR Position */
N#define UART_RBR_RBR_Msk            (0xFul << UART_RBR_RBR_Pos)             /*!< UART_T::RBR: RBR Mask      */
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_AERIEN_Pos         18                                      /*!< UART_T::IER: AERIEN Position           */
N#define UART_IER_AERIEN_Msk         (1ul << UART_IER_AERIEN_Pos)            /*!< UART_T::IER: AERIEN Mask                */
N
N#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART_T::IER: AUTO_CTS_EN Position      */
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART_T::IER: AUTO_CTS_EN Mask           */
N
N#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART_T::IER: AUTO_RTS_EN Position      */
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART_T::IER: AUTO_RTS_EN Mask           */
N
N#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART_T::IER: TIME_OUT_EN Position      */
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART_T::IER: TIME_OUT_EN Mask           */
N
N#define UART_IER_WKDATIEN_Pos       10                                      /*!< UART_T::IER: WKDATIEN Position         */
N#define UART_IER_WKDATIEN_Msk       (1ul << UART_IER_WKDATIEN_Pos)          /*!< UART_T::IER: WKDATIEN Mask              */
N
N#define UART_IER_LIN_IEN_Pos        8                                       /*!< UART_T::IER: LIN_IEN Position          */
N#define UART_IER_LIN_IEN_Msk        (1ul << UART_IER_LIN_IEN_Pos)           /*!< UART_T::IER: LIN_IEN Mask               */
N
N#define UART_IER_WKCTSIEN_Pos       6                                       /*!< UART_T::IER: WKCTSIEN Position         */
N#define UART_IER_WKCTSIEN_Msk       (1ul << UART_IER_WKCTSIEN_Pos)          /*!< UART_T::IER: WKCTSIEN Mask              */
N
N#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART_T::IER: BUF_ERR_IEN Position      */
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART_T::IER: BUF_ERR_IEN Mask           */
N
N#define UART_IER_TOUT_IEN_Pos        4                                      /*!< UART_T::IER: TOUT_IEN Position          */
N#define UART_IER_TOUT_IEN_Msk        (1ul << UART_IER_TOUT_IEN_Pos)         /*!< UART_T::IER: TOUT_IEN Mask               */
N
N#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART_T::IER: MODEM_IEN Position        */
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART_T::IER: MODEM_IEN Mask             */
N
N#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART_T::IER: RLS_IEN Position          */
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART_T::IER: RLS_IEN Mask               */
N
N#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART_T::IER: THRE_IEN Position         */
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART_T::IER: THRE_IEN Mask              */
N
N#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART_T::IER: RDA_IEN Position           */
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART_T::IER: RDA_IEN Mask               */
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART_T::FCR: RTS_TRI_LEV Position       */
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART_T::FCR: RTS_TRI_LEV Mask           */
N
N#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART_T::FCR: RX_DIS Position            */
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART_T::FCR: RX_DIS Mask                */
N
N#define UART_FCR_RFITL_Pos          4                                       /*!< UART_T::FCR: RFITL Position             */
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART_T::FCR: RFITL Mask                 */
N
N#define UART_FCR_TFR_Pos            2                                       /*!< UART_T::FCR: TFR Position               */
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART_T::FCR: TFR Mask                   */
N
N#define UART_FCR_RFR_Pos            1                                       /*!< UART_T::FCR: RFR Position               */
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART_T::FCR: RFR Mask                   */
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6                                       /*!< UART_T::LCR: BCB Position               */
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART_T::LCR: BCB Mask                   */
N
N#define UART_LCR_SPE_Pos            5                                       /*!< UART_T::LCR: SPE Position               */
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART_T::LCR: SPE Mask                   */
N
N#define UART_LCR_EPE_Pos            4                                       /*!< UART_T::LCR: EPE Position               */
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART_T::LCR: EPE Mask                   */
N
N#define UART_LCR_PBE_Pos            3                                       /*!< UART_T::LCR: PBE Position               */
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART_T::LCR: PBE Mask                   */
N
N#define UART_LCR_NSB_Pos            2                                       /*!< UART_T::LCR: NSB Position               */
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART_T::LCR: NSB Mask                   */
N
N#define UART_LCR_WLS_Pos            0                                       /*!< UART_T::LCR: WLS Position               */
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART_T::LCR: WLS Mask                   */
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART_T::MCR: RTS_ST Position            */
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART_T::MCR: RTS_ST Mask                */
N
N#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART_T::MCR: LEV_RTS Position           */
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART_T::MCR: LEV_RTS Mask               */
N
N#define UART_MCR_RTS_Pos            1                                       /*!< UART_T::MCR: RTS Position               */
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART_T::MCR: RTS Mask                   */
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART_T::MSR: LEV_CTS Position           */
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART_T::MSR: LEV_CTS Mask               */
N
N#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART_T::MSR: CTS_ST Position            */
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART_T::MSR: CTS_ST Mask                */
N
N#define UART_MSR_DCTSF_Pos          0                                       /*!< UART_T::MSR: DCTST Position             */
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART_T::MSR: DCTST Mask                 */
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART_T::FSR: TE_FLAG Position           */
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART_T::FSR: TE_FLAG Mask               */
N
N#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART_T::FSR: TX_OVER_IF Position        */
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART_T::FSR: TX_OVER_IF Mask            */
N
N#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART_T::FSR: TX_FULL Position           */
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART_T::FSR: TX_FULL Mask               */
N
N#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART_T::FSR: TX_EMPTY Position          */
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART_T::FSR: TX_EMPTY Mask              */
N
N#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART_T::FSR: TX_POINTER Position        */
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART_T::FSR: TX_POINTER Mask            */
N
N#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART_T::FSR: RX_FULL Position           */
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART_T::FSR: RX_FULL Mask               */
N
N#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART_T::FSR: RX_EMPTY Position          */
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART_T::FSR: RX_EMPTY Mask              */
N
N#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART_T::FSR: RX_POINTERS Position       */
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART_T::FSR: RX_POINTER Mask            */
N
N#define UART_FSR_BIF_Pos            6                                       /*!< UART_T::FSR: BIF Position               */
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART_T::FSR: BIF Mask                   */
N
N#define UART_FSR_FEF_Pos            5                                       /*!< UART_T::FSR: FEF Position               */
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART_T::FSR: FEF Mask                   */
N
N#define UART_FSR_PEF_Pos            4                                       /*!< UART_T::FSR: PEF Position               */
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART_T::FSR: PEF Mask                   */
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART_T::FSR: RS485_ADD_DETF Position    */
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART_T::FSR: RS485_ADD_DETF Mask        */
N
N#define UART_FSR_ABRDTOIF_Pos       2                                       /*!< UART_T::FSR: ABRDTOIF Position          */
N#define UART_FSR_ABRDTOIF_Msk       (1ul << UART_FSR_ABRDTOIF_Pos)          /*!< UART_T::FSR: ABRDTOIF Mask              */
N
N#define UART_FSR_ABRDIF_Pos         1                                       /*!< UART_T::FSR: ABRDIF Position            */
N#define UART_FSR_ABRDIF_Msk         (1ul << UART_FSR_ABRDIF_Pos)            /*!< UART_T::FSR: ABRDIF Mask                */
N
N#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART_T::FSR: RX_OVER_IF Position        */
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART_T::FSR: RX_OVER_IF Mask            */
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_DATWKIF_Pos        17                                      /*!< UART_T::ISR: DATWKIF Position           */
N#define UART_ISR_DATWKIF_Msk        (1ul << UART_ISR_DATWKIF_Pos)           /*!< UART_T::ISR: DATWKIF Mask               */
N
N#define UART_ISR_CTSWKIF_Pos        16                                      /*!< UART_T::ISR: CTSWKIF Position           */
N#define UART_ISR_CTSWKIF_Msk        (1ul << UART_ISR_CTSWKIF_Pos)           /*!< UART_T::ISR: CTSWKIF Mask               */
N
N#define UART_ISR_LIN_INT_Pos        15                                      /*!< UART_T::ISR: LIN_INT Position           */
N#define UART_ISR_LIN_INT_Msk        (1ul << UART_ISR_LIN_INT_Pos)           /*!< UART_T::ISR: LIN_INT Mask               */
N
N#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART_T::ISR: BUF_ERR_INT Position       */
N#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART_T::ISR: BUF_ERR_INT Mask           */
N
N#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART_T::ISR: TOUT_INT Position          */
N#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART_T::ISR: TOUT_INT Mask              */
N
N#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART_T::ISR: MODEM_INT Position         */
N#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART_T::ISR: MODEM_INT Mask             */
N
N#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART_T::ISR: RLS_INT Position           */
N#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART_T::ISR: RLS_INT Mask               */
N
N#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART_T::ISR: THRE_INT Position          */
N#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART_T::ISR: THRE_INT Mask              */
N
N#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART_T::ISR: RDA_INT Position           */
N#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART_T::ISR: RDA_INT Mask               */
N
N#define UART_ISR_LIN_IF_Pos         7                                       /*!< UART_T::ISR: LIN RX_IF Position         */
N#define UART_ISR_LIN_IF_Msk         (1ul << UART_ISR_LIN_IF_Pos)            /*!< UART_T::ISR: LIN RX_IF Mask             */
N
N#define UART_ISR_WKIF_Pos           6                                       /*!< UART_T::ISR: WKIF Position        */
N#define UART_ISR_WKIF_Msk           (1ul << UART_ISR_WKIF_Pos)              /*!< UART_T::ISR: WKIF Mask            */
N
N#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART_T::ISR: BUF_ERR_IF Position        */
N#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART_T::ISR: BUF_ERR_IF Mask            */
N
N#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART_T::ISR: TOUT_IF Position           */
N#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART_T::ISR: TOUT_IF Mask               */
N
N#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART_T::ISR: MODEM_IF Position          */
N#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART_T::ISR: MODEM_IF Mask              */
N
N#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART_T::ISR: RLS_IF Position            */
N#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART_T::ISR: RLS_IF Mask                */
N
N#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART_T::ISR: THRE_IF Position           */
N#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART_T::ISR: THRE_IF Mask               */
N
N#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART_T::ISR: RDA_IF Position            */
N#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART_T::ISR: RDA_IF Mask                */
N
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos           8                                        /*!< UART_T::TOR: DLY Position               */
N#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART_T::TOR: DLY Mask                   */
N
N#define UART_TOR_TOIC_Pos          0                                        /*!< UART_T::TOR: TOIC Position              */
N#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART BARD: DIV_X_EN Position         */
N#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART BARD: DIV_X_EN Mask             */
N
N#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART BARD: DIV_X_ONE Position        */
N#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART BARD: DIV_X_ONE Mask            */
N
N#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART BARD: DIVIDER_X Position        */
N#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART BARD: DIVIDER_X Mask            */
N
N#define UART_BAUD_BRD_Pos         0                                         /*!< UART BARD: BRD Position              */
N#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART BARD: BRD Mask                  */
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART_T::IRCR: INV_RX Position           */
N#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART_T::IRCR: INV_RX Mask               */
N
N#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART_T::IRCR: INV_TX Position           */
N#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART_T::IRCR: INV_TX Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART_T::IRCR: TX_SELECT Position        */
N#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART_T::IRCR: TX_SELECT Mask            */
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART_T::ALT_CSR: ADDR_MATCH Position    */
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART_T::ALT_CSR: ADDR_MATCH Mask        */
N
N#define UART_ALT_CSR_ABRDBITS_Pos       19                                       /*!< UART_T::ALT_CSR: ABRDBITS Position      */
N#define UART_ALT_CSR_ABRDBITS_Msk       (0x3ul << UART_ALT_CSR_ABRDBITS_Pos)     /*!< UART_T::ALT_CSR: ABRDBITS Mask          */
N
N#define UART_ALT_CSR_ABRDEN_Pos         18                                       /*!< UART_T::ALT_CSR: ABRDEN Position        */
N#define UART_ALT_CSR_ABRDEN_Msk         (1ul << UART_ALT_CSR_ABRDEN_Pos)         /*!< UART_T::ALT_CSR: ABRDEN Mask            */
N
N#define UART_ALT_CSR_ABRIF_Pos          17                                       /*!< UART_T::ALT_CSR: ABRIF Position         */
N#define UART_ALT_CSR_ABRIF_Msk          (1ul << UART_ALT_CSR_ABRIF_Pos)          /*!< UART_T::ALT_CSR: ABRIF Mask             */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART_T::ALT_CSR: RS485_ADD_EN Position  */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART_T::ALT_CSR: RS485_ADD_EN Mask      */
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART_T::ALT_CSR: RS485_AUD Position     */
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART_T::ALT_CSR: RS485_AUD Mask         */
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART_T::ALT_CSR: RS485_AAD Position     */
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART_T::ALT_CSR: RS485_AAD Mask         */
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART_T::ALT_CSR: RS485_NMM Position     */
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART_T::ALT_CSR: RS485_NMM Mask         */
N
N#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Position     */
N#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Mask         */
N
N#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART_T::ALT_CSR: LIN RX Enable Position     */
N#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN RX Enable Mask         */
N
N#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART_T::ALT_CSR: UART LIN Break Field Length Position     */
N#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART_T::ALT_CSR: UART LIN Break Field Length Mask         */
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART_T::FUN_SEL: FUN_SEL Position       */
N#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART_T::FUN_SEL: FUN_SEL Mask           */
N
N/* UART LIN_CTL Bit Field Definitions */
N#define UART_LIN_CTL_LIN_PID_Pos        24                                        /*!< UART_T::LIN_CTL: LIN_PID Position       */
N#define UART_LIN_CTL_LIN_PID_Msk        (0xFFul << UART_LIN_CTL_LIN_PID_Pos)      /*!< UART_T::LIN_CTL: LIN_PID Mask           */
N
N#define UART_LIN_CTL_LIN_HEAD_SEL_Pos   22                                        /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Position       */
N#define UART_LIN_CTL_LIN_HEAD_SEL_Msk   (0x3ul << UART_LIN_CTL_LIN_HEAD_SEL_Pos)  /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Mask           */
N
N#define UART_LIN_CTL_LIN_BS_LEN_Pos     20                                        /*!< UART_T::LIN_CTL: LIN_BS_LEN Position       */
N#define UART_LIN_CTL_LIN_BS_LEN_Msk     (0x3ul << UART_LIN_CTL_LIN_BS_LEN_Pos)    /*!< UART_T::LIN_CTL: LIN_BS_LEN Mask           */
N
N#define UART_LIN_CTL_LIN_BKFL_Pos       16                                        /*!< UART_T::LIN_CTL: LIN_BKFL Position       */
N#define UART_LIN_CTL_LIN_BKFL_Msk       (0xFul << UART_LIN_CTL_LIN_BKFL_Pos)      /*!< UART_T::LIN_CTL: LIN_BKFL Mask           */
N
N#define UART_LIN_CTL_BIT_ERR_EN_Pos     12                                        /*!< UART_T::LIN_CTL: BIT_ERR_EN Position       */
N#define UART_LIN_CTL_BIT_ERR_EN_Msk     (1ul << UART_LIN_CTL_BIT_ERR_EN_Pos)      /*!< UART_T::LIN_CTL: BIT_ERR_EN Mask           */
N
N#define UART_LIN_CTL_LIN_RX_DIS_Pos     11                                        /*!< UART_T::LIN_CTL: LIN_RX_DIS Position       */
N#define UART_LIN_CTL_LIN_RX_DIS_Msk     (1ul << UART_LIN_CTL_LIN_RX_DIS_Pos)      /*!< UART_T::LIN_CTL: LIN_RX_DIS Mask           */
N
N#define UART_LIN_CTL_LIN_BKDET_EN_Pos   10                                        /*!< UART_T::LIN_CTL: LIN_BKDET_EN Position       */
N#define UART_LIN_CTL_LIN_BKDET_EN_Msk   (1ul << UART_LIN_CTL_LIN_BKDET_EN_Pos)    /*!< UART_T::LIN_CTL: LIN_BKDET_EN Mask           */
N
N#define UART_LIN_CTL_LIN_IDPEN_Pos      9                                         /*!< UART_T::LIN_CTL: LIN_IDPEN Position       */
N#define UART_LIN_CTL_LIN_IDPEN_Msk      (1ul << UART_LIN_CTL_LIN_IDPEN_Pos)       /*!< UART_T::LIN_CTL: LIN_IDPEN Mask           */
N
N#define UART_LIN_CTL_LIN_SHD_Pos        8                                         /*!< UART_T::LIN_CTL: LIN_SHD Position       */
N#define UART_LIN_CTL_LIN_SHD_Msk        (1ul << UART_LIN_CTL_LIN_SHD_Pos)         /*!< UART_T::LIN_CTL: LIN_SHD Mask           */
N
N#define UART_LIN_CTL_LIN_MUTE_EN_Pos    4                                          /*!< UART_T::LIN_CTL: LIN_MUTE_EN Position       */
N#define UART_LIN_CTL_LIN_MUTE_EN_Msk    (1ul << UART_LIN_CTL_LIN_MUTE_EN_Pos)      /*!< UART_T::LIN_CTL: LIN_MUTE_EN Mask           */
N
N#define UART_LIN_CTL_LINS_DUM_EN_Pos    3                                          /*!< UART_T::LIN_CTL: LINS_DUM_EN Position       */
N#define UART_LIN_CTL_LINS_DUM_EN_Msk    (1ul << UART_LIN_CTL_LINS_DUM_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_DUM_EN Mask           */
N
N#define UART_LIN_CTL_LINS_ARS_EN_Pos    2                                          /*!< UART_T::LIN_CTL: LINS_ARS_EN Position       */
N#define UART_LIN_CTL_LINS_ARS_EN_Msk    (1ul << UART_LIN_CTL_LINS_ARS_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_ARS_EN Mask           */
N
N#define UART_LIN_CTL_LINS_HDET_EN_Pos   1                                          /*!< UART_T::LIN_CTL: LINS_HDET_EN Position       */
N#define UART_LIN_CTL_LINS_HDET_EN_Msk   (1ul << UART_LIN_CTL_LINS_HDET_EN_Pos)     /*!< UART_T::LIN_CTL: LINS_HDET_EN Mask           */
N
N#define UART_LIN_CTL_LINS_EN_Pos        0                                          /*!< UART_T::LIN_CTL: LINS_EN Position       */
N#define UART_LIN_CTL_LINS_EN_Msk        (1ul << UART_LIN_CTL_LINS_EN_Pos)          /*!< UART_T::LIN_CTL: LINS_EN Mask           */
N
N/* UART LIN_SR Bit Field Definitions */
N#define UART_LIN_SR_BIT_ERR_F_Pos       9                                           /*!< UART_T::LIN_SR: BIT_ERR_F Position         */
N#define UART_LIN_SR_BIT_ERR_F_Msk       (1ul << UART_LIN_SR_BIT_ERR_F_Pos)          /*!< UART_T::LIN_SR: BIT_ERR_F Mask             */
N
N#define UART_LIN_SR_LINS_BKDET_F_Pos    8                                           /*!< UART_T::LIN_SR: LINS_BKDET_F Position      */
N#define UART_LIN_SR_LINS_BKDET_F_Msk    (1ul << UART_LIN_SR_LINS_BKDET_F_Pos)       /*!< UART_T::LIN_SR: LINS_BKDET_F Mask          */
N
N#define UART_LIN_SR_LINS_SYNC_F_Pos     3                                           /*!< UART_T::LIN_SR: LINS_SYNC_F Position       */
N#define UART_LIN_SR_LINS_SYNC_F_Msk     (1ul << UART_LIN_SR_LINS_SYNC_F_Pos)        /*!< UART_T::LIN_SR: LINS_SYNC_F Mask           */
N
N#define UART_LIN_SR_LINS_IDPERR_F_Pos   2                                           /*!< UART_T::LIN_SR: LINS_IDPERR_F Position     */
N#define UART_LIN_SR_LINS_IDPERR_F_Msk   (1ul << UART_LIN_SR_LINS_IDPERR_F_Pos)      /*!< UART_T::LIN_SR: LINS_IDPERR_F Mask         */
N
N#define UART_LIN_SR_LINS_HERR_F_Pos     1                                           /*!< UART_T::LIN_SR: LINS_HERR_F Position       */
N#define UART_LIN_SR_LINS_HERR_F_Msk     (1ul << UART_LIN_SR_LINS_HERR_F_Pos)        /*!< UART_T::LIN_SR: LINS_HERR_F Mask           */
N
N#define UART_LIN_SR_LINS_HDET_F_Pos     0                                           /*!< UART_T::LIN_SR: LINS_HDET_F Position       */
N#define UART_LIN_SR_LINS_HDET_F_Msk     (1ul << UART_LIN_SR_LINS_HDET_F_Pos)        /*!< UART_T::LIN_SR: LINS_HDET_F Mask           */
N
N/*@}*/ /* end of group UART_CONST */
N/*@}*/ /* end of group UART */
N
N
N
N/*----------------------------- Watchdog Timer (WDT) -----------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller (WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
Ntypedef struct
N{
N    /**
N     * WTCR
N     * ===================================================================================================
N     * Offset: 0x00  Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WTR       |Reset Watchdog Timer Up Counter (Write Protect)
N     * |        |          |0 = No effect.
N     * |        |          |1 = Reset the internal 18-bit WDT up counter value.
N     * |        |          |Note: This bit will be automatically cleared by hardware.
N     * |[1]     |WTRE      |Watchdog Timer Reset Enable (Write Protect)
N     * |        |          |Setting this bit will enable the WDT time-out reset function if the WDT up counter value has not been cleared after the specific WDT reset delay period expires.
N     * |        |          |0 = WDT time-out reset function Disabled.
N     * |        |          |1 = WDT time-out reset function Enabled.
N     * |[2]     |WTRF      |Watchdog Timer Time-out Reset Flag
N     * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
N     * |        |          |0 = WDT time-out reset did not occur.
N     * |        |          |1 = WDT time-out reset occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[3]     |WTIF      |Watchdog Timer Time-out Interrupt Flag
N     * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval.
N     * |        |          |0 = WDT time-out interrupt did not occur.
N     * |        |          |1 = WDT time-out interrupt occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[4]     |WTWKE     |Watchdog Timer Time-out Wake-Up Function Control
N     * |        |          |(Write Protect)
N     * |        |          |If this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.
N     * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
N     * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
N     * |        |          |Note: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz oscillator.
N     * |[5]     |WTWKF     |Watchdog Timer Time-out Wake-Up Flag
N     * |        |          |This bit indicates the interrupt wake-up flag status of WDT.
N     * |        |          |0 = WDT does not cause chip wake-up.
N     * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[6]     |WTIE      |Watchdog Timer Time-out Interrupt Enable Control (Write Protect)
N     * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
N     * |        |          |0 = WDT time-out interrupt Disabled.
N     * |        |          |1 = WDT time-out interrupt Enabled.
N     * |[7]     |WTE       |Watchdog Timer Enable Control (Write Protect)
N     * |        |          |0 = WDT Disabled. (This action will reset the internal up counter value.)
N     * |        |          |1 = WDT Enabled.
N     * |        |          |Note: If CWDTEN (CONFIG0[31] Watchdog Enable) bit is set to 0, this bit is forced as 1 and
N     * |        |          | user cannot change this bit to 0.
N     * |[10:8]  |WTIS      |Watchdog Timer Time-out Interval Selection (Write Protect)
N     * |        |          |These three bits select the time-out interval period for the WDT.
N     * |        |          |000 = 2^4 *WDT_CLK.
N     * |        |          |001 = 2^6 * WDT_CLK.
N     * |        |          |010 = 2^8 * WDT_CLK.
N     * |        |          |011 = 2^10 * WDT_CLK.
N     * |        |          |100 = 2^12 * WDT_CLK.
N     * |        |          |101 = 2^14 * WDT_CLK.
N     * |        |          |110 = 2^16 * WDT_CLK.
N     * |        |          |111 = 2^18 * WDT_CLK.
N     * |[31]    |DBGACK_WDT|ICE Debug Mode Acknowledge Disable Control (Write Protect)
N     * |        |          |0 = ICE debug mode acknowledgment effects WDT counting.
N     * |        |          |WDT up counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgment Disabled.
N     * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
N     */
N    __IO uint32_t  WTCR;
X    volatile uint32_t  WTCR;
N
N    /**
N     * WTCRALT
N     * ===================================================================================================
N     * Offset: 0x04  Watchdog Timer Alternative Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[1:0]   |WTRDSEL   |Watchdog Timer Reset Delay Selection (Write Protect)
N     * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter to prevent WDT time-out reset happened.
N     * |        |          |User can select a suitable value of WDT Reset Delay Period for different WDT time-out period.
N     * |        |          |These bits are protected bit.
N     * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection.
N     * |        |          |Reference the register REGWRPROT at address GCR_BASE+0x100.
N     * |        |          |00 = Watchdog Timer Reset Delay Period is 1026 * WDT_CLK.
N     * |        |          |01 = Watchdog Timer Reset Delay Period is 130 * WDT_CLK.
N     * |        |          |10 = Watchdog Timer Reset Delay Period is 18 * WDT_CLK.
N     * |        |          |11 = Watchdog Timer Reset Delay Period is 3 * WDT_CLK.
N     * |        |          |Note: This register will be reset to 0 if WDT time-out reset happened.
N     */
N    __IO uint32_t  WTCRALT;
X    volatile uint32_t  WTCRALT;
N} WDT_T;
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N
N/* WDT WTCR Bit Field Definitions */
N#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT_T::WTCR: DBGACK_WDT Position */
N#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT_T::WTCR: DBGACK_WDT Mask */
N
N#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT_T::WTCR: WTIS Position */
N#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT_T::WTCR: WTIS Mask */
N
N#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT_T::WTCR: WTE Position */
N#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT_T::WTCR: WTE Mask */
N
N#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT_T::WTCR: WTIE Position */
N#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT_T::WTCR: WTIE Mask */
N
N#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT_T::WTCR: WTWKF Position */
N#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT_T::WTCR: WTWKF Mask */
N
N#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT_T::WTCR: WTWKE Position */
N#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT_T::WTCR: WTWKE Mask */
N
N#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT_T::WTCR: WTIF Position */
N#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT_T::WTCR: WTIF Mask */
N
N#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT_T::WTCR: WTRF Position */
N#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT_T::WTCR: WTRF Mask */
N
N#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT_T::WTCR: WTRE Position */
N#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT_T::WTCR: WTRE Mask */
N
N#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT_T::WTCR: WTR Position */
N#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT_T::WTCR: WTR Mask */
N
N/* WDT WTCRALT Bit Field Definitions */
N#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT_T::WTCRALT: WTRDSEL Position */
N#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT_T::WTCRALT: WTRDSEL Mask */
N/*@}*/ /* end of group WDT_CONST */
N/*@}*/ /* end of group WDT */
N
N
N/*----------------------------- Window Watchdog Timer (WWDT) -----------------------------*/
N/** @addtogroup WWDT Window Watchdog Timer (WWDT)
N    Memory Mapped Structure for WWDT Controller
N  @{
N */
Ntypedef struct
N{
N    /**
N     * WWDTRLD
N     * ===================================================================================================
N     * Offset: 0x00  Window Watchdog Timer Reload Counter Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[31:0]  |WWDTRLD   |WWDT Reload Counter Register
N     * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
N     * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT
N     * |        |          | counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT
N     * |        |          | counter value is larger than WINCMP, WWDT reset signal will generate immediately.
N     */
N    __IO uint32_t  WWDTRLD;
X    volatile uint32_t  WWDTRLD;
N
N    /**
N     * WWDTCR
N     * ===================================================================================================
N     * Offset: 0x04  Window Watchdog Timer Control Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WWDTEN    |WWDT Enable Control
N     * |        |          |0 = WWDT counter is stopped.
N     * |        |          |1 = WWDT counter is starting counting.
N     * |[1]     |WWDTIE    |WWDT Interrupt Enable Control
N     * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.
N     * |        |          |0 = WWDT counter compare match interrupt Disabled.
N     * |        |          |1 = WWDT counter compare match interrupt Enabled.
N     * |[11:8]  |PERIODSEL |WWDT Counter Prescale Period Selection
N     * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT.
N     * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT.
N     * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT.
N     * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT.
N     * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT.
N     * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT.
N     * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT.
N     * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT.
N     * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT.
N     * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT.
N     * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT.
N     * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT.
N     * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT.
N     * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT.
N     * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT.
N     * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT.
N     * |[21:16] |WINCMP    |WWDT Window Compare Register
N     * |        |          |Set this register to adjust the valid reload window.
N     * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP.
N     * |        |          |If user writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.
N     * |[31]    |DBGACK_WWDT|ICE Debug Mode Acknowledge Disable Control
N     * |        |          |0 = ICE debug mode acknowledgment effects WWDT counting.
N     * |        |          |WWDT down counter will be held while CPU is held by ICE.
N     * |        |          |1 = ICE debug mode acknowledgment Disabled.
N     * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
N     */
N    __IO uint32_t  WWDTCR;
X    volatile uint32_t  WWDTCR;
N
N    /**
N     * WWDTSR
N     * ===================================================================================================
N     * Offset: 0x08  Window Watchdog Timer Status Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
N     * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches WINCMP value.
N     * |        |          |0 = No effect.
N     * |        |          |1 = WWDT counter value matches WINCMP value.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     * |[1]     |WWDTRF    |WWDT Time-out Reset Flag
N     * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
N     * |        |          |0 = WWDT time-out reset did not occur.
N     * |        |          |1 = WWDT time-out reset occurred.
N     * |        |          |Note: This bit is cleared by writing 1 to it.
N     */
N    __IO uint32_t  WWDTSR;
X    volatile uint32_t  WWDTSR;
N
N    /**
N     * WWDTCVR
N     * ===================================================================================================
N     * Offset: 0x0C  Window Watchdog Timer Counter Value Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[5:0]   |WWDTCVAL  |WWDT Counter Value
N     * |        |          |WWDTCVAL will be updated continuously to monitor 6-bit down counter value.
N     */
N    __I  uint32_t  WWDTCVR;
X    volatile const  uint32_t  WWDTCVR;
N} WWDT_T;
N
N/** @addtogroup WWDT_CONST Bit Field Definition
N  @{
N */
N
N
N/* WWDT WWDTRLD Bit Field Definitions */
N#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT_T::WWDTRLD: WWDTRLD Position */
N#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT_T::WWDTRLD: WWDTRLD Mask */
N
N/* WWDT WWDTCR Bit Field Definitions */
N#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT_T::WWDTCR: DBGACK_WWDT Position */
N#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT_T::WWDTCR: DBGACK_WWDT Mask */
N
N#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT_T::WWDTCR: WINCMP Position */
N#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT_T::WWDTCR: WINCMP Mask */
N
N#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT_T::WWDTCR: PERIODSEL Position */
N#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT_T::WWDTCR: PERIODSEL Mask */
N
N#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT_T::WWDTCR: WWDTIE Position */
N#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT_T::WWDTCR: WWDTIE Mask */
N
N#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT_T::WWDTCR: WWDTEN Position */
N#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT_T::WWDTCR: WWDTEN Mask */
N
N/* WWDT WWDTSR Bit Field Definitions */
N#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT_T::WWDTSR: WWDTRF Position */
N#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT_T::WWDTSR: WWDTRF Mask */
N
N#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT_T::WWDTSR: WWDTIF Position */
N#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT_T::WWDTSR: WWDTIF Mask */
N
N/* WWDT WWDTCVR Bit Field Definitions */
N#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT_T::WWDTCVR: WWDTCVAL Position */
N#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT_T::WWDTCVR: WWDTCVAL Mask */
N/*@}*/ /* end of group WWDT_CONST */
N/*@}*/ /* end of group WWDT */
N
N
N
N
N
N/*@}*/ /* end of group REGISTER */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup PERIPHERAL_MEM_MAP Peripheral Memory Map
N  Memory Mapped Structure for Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N#define APB2_BASE           ((     uint32_t)0x40100000)
N
N/* Peripheral memory map */
N#define GPIO_BASE           (AHB_BASE        + 0x4000)                  /*!< GPIO Base Address                                   */
N#define PA_BASE             (GPIO_BASE               )                  /*!< GPIO PORTA Base Address                             */
N#define PB_BASE             (GPIO_BASE       + 0x0040)                  /*!< GPIO PORTB Base Address                             */
N#define PC_BASE             (GPIO_BASE       + 0x0080)                  /*!< GPIO PORTC Base Address                             */
N#define PD_BASE             (GPIO_BASE       + 0x00C0)                  /*!< GPIO PORTD Base Address                             */
N#define PE_BASE             (GPIO_BASE       + 0x0100)                  /*!< GPIO PORTE Base Address                             */
N#define PF_BASE             (GPIO_BASE       + 0x0140)                  /*!< GPIO PORTF Base Address                             */
N#define GPIO_DBNCECON_BASE  (GPIO_BASE       + 0x0180)                  /*!< GPIO De-bounce Cycle Control Base Address           */
N#define GPIO_PIN_DATA_BASE  (GPIO_BASE       + 0x0200)                  /*!< GPIO Pin Data Input/Output Control Base Address     */
N
N
N#define UART0_BASE           (APB1_BASE      + 0x50000)                 /*!< UART0 Base Address                              */
N#define UART1_BASE           (APB2_BASE      + 0x50000)                 /*!< UART1 Base Address                              */
N#define UART2_BASE           (APB2_BASE      + 0x54000)                 /*!< UART2 Base Address                              */
N#define UART3_BASE           (APB1_BASE      + 0x54000)                 /*!< UART3 Base Address                              */
N#define UART4_BASE           (APB1_BASE      + 0x58000)                 /*!< UART4 Base Address                              */
N#define UART5_BASE           (APB2_BASE      + 0x58000)                 /*!< UART5 Base Address                              */
N
N
N#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
N#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
N#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
N#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
N
N#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watchdog Timer Base Address                      */
N
N#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watchdog Timer Base Address               */
N
N#define SPI0_BASE            (APB1_BASE      + 0x30000)                 /*!< SPI0 Base Address                                */
N
N#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
N#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
N
N#define ADC_BASE             (APB1_BASE      + 0xE0000)                 /*!< ADC Base Address                                 */
N
N#define CLK_BASE             (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
N
N#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
N
N#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
N
N#define FMC_BASE             (AHB_BASE       + 0x0C000)
N
N#define CAN0_BASE            (APB2_BASE      + 0x80000)                 /*!< CAN0 Base Address                                */
N#define CAN1_BASE            (APB2_BASE      + 0x84000)                 /*!< CAN1 Base Address                                */
N
N#define PWM0_BASE            (APB1_BASE      + 0x40000)                 /*!< PWM0 Base Address                                */
N#define PWM1_BASE            (APB2_BASE      + 0x40000)                 /*!< PWM1 Base Address                                */
N
N#define BPWM0_BASE           (APB1_BASE      + 0x44000)                 /*!< BPWM0 Base Address                                */
N#define BPWM1_BASE           (APB2_BASE      + 0x44000)                 /*!< BPWM1 Base Address                                */
N
N/*@}*/ /* end of group PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                         Peripheral Definitions                             */
N/******************************************************************************/
N
N/** @addtogroup PERIPHERAL Peripheral Definitions
N  The Definitions of Peripheral
N  @{
N */
N#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
N#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
N#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
N#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
N#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
N#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
N#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */
N
N
N#define UART0               ((UART_T *) UART0_BASE)                     /*!< UART0 Configuration Struct                       */
N#define UART1               ((UART_T *) UART1_BASE)                     /*!< UART1 Configuration Struct                       */
N#define UART2               ((UART_T *) UART2_BASE)                     /*!< UART2 Configuration Struct                       */
N#define UART3               ((UART_T *) UART3_BASE)                     /*!< UART3 Configuration Struct                       */
N#define UART4               ((UART_T *) UART4_BASE)                     /*!< UART4 Configuration Struct                       */
N#define UART5               ((UART_T *) UART5_BASE)                     /*!< UART5 Configuration Struct                       */
N
N#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< Timer0 Configuration Struct                      */
N#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< Timer1 Configuration Struct                      */
N#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< Timer2 Configuration Struct                      */
N#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< Timer3 Configuration Struct                      */
N
N#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watchdog Timer Configuration Struct              */
N
N#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watchdog Timer Configuration Struct       */
N
N#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
N
N#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
N#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
N
N#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
N
N#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
N
N#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
N
N#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
N
N#define FMC                 ((FMC_T *) FMC_BASE)
N
N#define CAN                 ((CAN_T *) CAN0_BASE)
N#define CAN0                ((CAN_T *) CAN0_BASE)                       /*!< CAN0 Configuration Struct                        */
N#define CAN1                ((CAN_T *) CAN1_BASE)                       /*!< CAN1 Configuration Struct                        */
N
N#define PWM0                ((PWM_T *) PWM0_BASE)                       /*!< PWM0 Configuration Struct                        */
N#define PWM1                ((PWM_T *) PWM1_BASE)                       /*!< PWM1 Configuration Struct                        */
N
N#define BPWM0               ((BPWM_T *) BPWM0_BASE)                     /*!< BPWM0 Configuration Struct                       */
N#define BPWM1               ((BPWM_T *) BPWM1_BASE)                     /*!< BPWM1 Configuration Struct                       */
N
N
N/*@}*/ /* end of group PERIPHERAL */
N
N//=============================================================================
N/** @addtogroup IO_ROUTINE I/O routines
N  The Declaration of I/O routines
N  @{
N */
N
N#define UNLOCKREG(x)        do{*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x88;}while(*((__IO uint32_t *)(GCR_BASE + 0x100))==0)
N#define LOCKREG(x)          *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x00
N
N#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
N#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
N
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = (value)
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = (value)
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = (value)
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = (value)
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = (value)
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = (value)
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N/*@}*/ /* end of group IO_ROUTINE */
N
N
N
N
N/** @addtogroup legacy_Constants Legacy Constants
N  Legacy Constants
N  @{
N*/
N
N
N#define E_SUCCESS   0
N#ifndef NULL
N#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE     1
N#define DISABLE    0
N
N/* Define one bit mask */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N/*@}*/ /* end of group legacy_Constants */
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "SYS.h"
L 1 "..\..\..\Library\StdDriver\inc\SYS.h" 1
N/**************************************************************************//**
N * @file     sys.h
N * @version  V3.00
N * $Revision: 33 $
N * $Date: 15/06/10 10:55a $
N * @brief    NUC131 Series SYS Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup NUC131_SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_RST    ((0x4<<24) | SYS_IPRSTC2_GPIO_RST_Pos  ) /*!< GPIO reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST    ((0x4<<24) | SYS_IPRSTC2_TMR0_RST_Pos  ) /*!< TMR0 reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST    ((0x4<<24) | SYS_IPRSTC2_TMR1_RST_Pos  ) /*!< TMR1 reset is one of the SYS_ResetModule parameter */
N#define TMR2_RST    ((0x4<<24) | SYS_IPRSTC2_TMR2_RST_Pos  ) /*!< TMR2 reset is one of the SYS_ResetModule parameter */
N#define TMR3_RST    ((0x4<<24) | SYS_IPRSTC2_TMR3_RST_Pos  ) /*!< TMR3 reset is one of the SYS_ResetModule parameter */
N#define I2C0_RST    ((0x4<<24) | SYS_IPRSTC2_I2C0_RST_Pos  ) /*!< I2C0 reset is one of the SYS_ResetModule parameter */
N#define I2C1_RST    ((0x4<<24) | SYS_IPRSTC2_I2C1_RST_Pos  ) /*!< I2C1 reset is one of the SYS_ResetModule parameter */
N#define SPI0_RST    ((0x4<<24) | SYS_IPRSTC2_SPI0_RST_Pos  ) /*!< SPI0 reset is one of the SYS_ResetModule parameter */
N#define UART0_RST   ((0x4<<24) | SYS_IPRSTC2_UART0_RST_Pos ) /*!< UART0 reset is one of the SYS_ResetModule parameter */
N#define UART1_RST   ((0x4<<24) | SYS_IPRSTC2_UART1_RST_Pos ) /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define UART2_RST   ((0x4<<24) | SYS_IPRSTC2_UART2_RST_Pos ) /*!< UART2 reset is one of the SYS_ResetModule parameter */
N#define CAN0_RST    ((0x4<<24) | SYS_IPRSTC2_CAN0_RST_Pos  ) /*!< CAN0 reset is one of the SYS_ResetModule parameter */
N#define ADC_RST     ((0x4<<24) | SYS_IPRSTC2_ADC_RST_Pos   ) /*!< ADC reset is one of the SYS_ResetModule parameter */
N#define UART3_RST   ((0x8<<24) | SYS_IPRSTC3_UART3_RST_Pos ) /*!< UART3 reset is one of the SYS_ResetModule parameter */
N#define UART4_RST   ((0x8<<24) | SYS_IPRSTC3_UART4_RST_Pos ) /*!< UART4 reset is one of the SYS_ResetModule parameter */
N#define UART5_RST   ((0x8<<24) | SYS_IPRSTC3_UART5_RST_Pos ) /*!< UART5 reset is one of the SYS_ResetModule parameter */
N#define PWM0_RST    ((0x8<<24) | SYS_IPRSTC3_PWM0_RST_Pos )  /*!< PWM0 reset is one of the SYS_ResetModule parameter */
N#define PWM1_RST    ((0x8<<24) | SYS_IPRSTC3_PWM1_RST_Pos )  /*!< PWM1 reset is one of the SYS_ResetModule parameter */
N#define BPWM0_RST   ((0x8<<24) | SYS_IPRSTC3_BPWM0_RST_Pos ) /*!< BPWM0 reset is one of the SYS_ResetModule parameter */
N#define BPWM1_RST   ((0x8<<24) | SYS_IPRSTC3_BPWM1_RST_Pos ) /*!< BPWM1 reset is one of the SYS_ResetModule parameter */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCR_BOD_RST_EN            (1UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Reset Enable */
N#define SYS_BODCR_BOD_INTERRUPT_EN      (0UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Interrupt Enable */
N#define SYS_BODCR_BOD_VL_4_4V           (3UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 4.4V */
N#define SYS_BODCR_BOD_VL_3_7V           (2UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCR_BOD_VL_2_7V           (1UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCR_BOD_VL_2_2V           (0UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* How to use below #define?
NExample: If user want to set PA.0 as ADC0 and PA.1 as ADC1 in initial function,
N         user can issue following command to achieve it.
N
N         SYS->GPA_MFP  = SYS_GPA_MFP_PA0_ADC0  | SYS_GPA_MFP_PA1_ADC1;
N         SYS->ALT_MFP3 = SYS_ALT_MFP3_PA0_ADC0 | SYS_ALT_MFP3_PA1_ADC1;
N         SYS->ALT_MFP4 = SYS_ALT_MFP4_PA0_ADC0 | SYS_ALT_MFP4_PA1_ADC1;
N*/
N
N//PA.0
N#define SYS_GPA_MFP_PA0_GPIO        0x00000000UL        /*!< GPA_MFP PA.0 setting for GPIO */
N#define SYS_ALT_MFP_PA0_GPIO        NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.0 */
N#define SYS_ALT_MFP2_PA0_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.0 */
N#define SYS_ALT_MFP3_PA0_GPIO       0x00000000UL        /*!< ALT_MFP3 PA.0 setting for GPIO */
N#define SYS_ALT_MFP4_PA0_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.0 setting for GPIO */
N
N#define SYS_GPA_MFP_PA0_ADC0        (1UL<<0)            /*!< GPA_MFP PA.0 setting for ADC0 */
N#define SYS_ALT_MFP_PA0_ADC0        NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_ADC0       NULL                /*!< No ALT_MFP1 setting for PA.0 */
N#define SYS_ALT_MFP2_PA0_ADC0       NULL                /*!< No ALT_MFP2 setting for PA.0 */
N#define SYS_ALT_MFP3_PA0_ADC0       0x00000000UL        /*!< ALT_MFP3 PA.0 setting for ADC0 */
N#define SYS_ALT_MFP4_PA0_ADC0       0x00000000UL        /*!< ALT_MFP4 PA.0 setting for ADC0 */
N
N#define SYS_GPA_MFP_PA0_I2C1_SCL    (1UL<<0)            /*!< GPA_MFP PA.0 setting for I2C1_SCL */
N#define SYS_ALT_MFP_PA0_I2C1_SCL    NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_I2C1_SCL   NULL                /*!< No ALT_MFP1 setting for PA.0 */
N#define SYS_ALT_MFP2_PA0_I2C1_SCL   NULL                /*!< No ALT_MFP2 setting for PA.0 */
N#define SYS_ALT_MFP3_PA0_I2C1_SCL   0x00000000UL        /*!< ALT_MFP3 PA.0 setting for I2C1_SCL */
N#define SYS_ALT_MFP4_PA0_I2C1_SCL   (1UL<<12)           /*!< ALT_MFP4 PA.0 setting for I2C1_SCL */
N
N#define SYS_GPA_MFP_PA0_UART5_TXD   (1UL<<0)            /*!< GPA_MFP PA.0 setting for UART5_TXD */
N#define SYS_ALT_MFP_PA0_UART5_TXD   NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_UART5_TXD  NULL                /*!< No ALT_MFP1 setting for PA.0 */
N#define SYS_ALT_MFP2_PA0_UART5_TXD  NULL                /*!< No ALT_MFP2 setting for PA.0 */
N#define SYS_ALT_MFP3_PA0_UART5_TXD  0x00000000UL        /*!< ALT_MFP3 PA.0 setting for UART5_TXD */
N#define SYS_ALT_MFP4_PA0_UART5_TXD  (1UL<<7)            /*!< ALT_MFP4 PA.0 setting for UART5_TXD */
N
N#define SYS_GPA_MFP_PA0_PWM0_CH4    (1UL<<0)            /*!< GPA_MFP PA.0 setting for PWM0_CH4 */
N#define SYS_ALT_MFP_PA0_PWM0_CH4    NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_PWM0_CH4   NULL                /*!< No ALT_MFP1 setting for PA.0 */
N#define SYS_ALT_MFP2_PA0_PWM0_CH4   NULL                /*!< No ALT_MFP2 setting for PA.0 */
N#define SYS_ALT_MFP3_PA0_PWM0_CH4   (1UL<<4)            /*!< ALT_MFP3 PA.0 setting for PWM0_CH4 */
N#define SYS_ALT_MFP4_PA0_PWM0_CH4   0x00000000UL        /*!< ALT_MFP4 PA.0 setting for PWM0_CH4 */
N
N#define SYS_GPA_MFP_PA0_Msk         (1UL<<0)            /*!< GPA_MFP PA.0 mask */
N#define SYS_ALT_MFP_PA0_Msk         NULL                /*!< No ALT_MFP PA.0 mask */
N#define SYS_ALT_MFP1_PA0_Msk        NULL                /*!< No ALT_MFP1 PA.0 mask */
N#define SYS_ALT_MFP2_PA0_Msk        NULL                /*!< No ALT_MFP2 PA.0 mask */
N#define SYS_ALT_MFP3_PA0_Msk        (1UL<<4)            /*!< ALT_MFP3 PA.0 mask */
N#define SYS_ALT_MFP4_PA0_Msk        ((1UL<<12)|(1UL<<7))/*!< ALT_MFP4 PA.0 mask */
N
N//PA.1
N#define SYS_GPA_MFP_PA1_GPIO        0x00000000UL        /*!< GPA_MFP PA.1 setting for GPIO */
N#define SYS_ALT_MFP_PA1_GPIO        NULL                /*!< No ALT_MFP setting for PA.1 */
N#define SYS_ALT_MFP1_PA1_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.1 */
N#define SYS_ALT_MFP2_PA1_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.1 */
N#define SYS_ALT_MFP3_PA1_GPIO       0x00000000UL        /*!< ALT_MFP3 PA.1 setting for GPIO */
N#define SYS_ALT_MFP4_PA1_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.1 setting for GPIO */
N
N#define SYS_GPA_MFP_PA1_ADC1        (1UL<<1)            /*!< GPA_MFP PA.1 setting for ADC1 */
N#define SYS_ALT_MFP_PA1_ADC1        NULL                /*!< No ALT_MFP setting for PA.1 */
N#define SYS_ALT_MFP1_PA1_ADC1       NULL                /*!< No ALT_MFP1 setting for PA.1 */
N#define SYS_ALT_MFP2_PA1_ADC1       NULL                /*!< No ALT_MFP2 setting for PA.1 */
N#define SYS_ALT_MFP3_PA1_ADC1       0x00000000UL        /*!< ALT_MFP3 PA.1 setting for ADC1 */
N#define SYS_ALT_MFP4_PA1_ADC1       0x00000000UL        /*!< ALT_MFP4 PA.1 setting for ADC1 */
N
N#define SYS_GPA_MFP_PA1_I2C1_SDA    (1UL<<1)            /*!< GPA_MFP PA.1 setting for I2C1_SDA */
N#define SYS_ALT_MFP_PA1_I2C1_SDA    NULL                /*!< No ALT_MFP setting for PA.1 */
N#define SYS_ALT_MFP1_PA1_I2C1_SDA   NULL                /*!< No ALT_MFP1 setting for PA.1 */
N#define SYS_ALT_MFP2_PA1_I2C1_SDA   NULL                /*!< No ALT_MFP2 setting for PA.1 */
N#define SYS_ALT_MFP3_PA1_I2C1_SDA   0x00000000UL        /*!< ALT_MFP3 PA.1 setting for I2C1_SDA */
N#define SYS_ALT_MFP4_PA1_I2C1_SDA   (1UL<<13)           /*!< ALT_MFP4 PA.1 setting for I2C1_SDA */
N
N#define SYS_GPA_MFP_PA1_UART5_RXD   (1UL<<1)            /*!< GPA_MFP PA.1 setting for UART5_RXD */
N#define SYS_ALT_MFP_PA1_UART5_RXD   NULL                /*!< No ALT_MFP setting for PA.1 */
N#define SYS_ALT_MFP1_PA1_UART5_RXD  NULL                /*!< No ALT_MFP1 setting for PA.1 */
N#define SYS_ALT_MFP2_PA1_UART5_RXD  NULL                /*!< No ALT_MFP2 setting for PA.1 */
N#define SYS_ALT_MFP3_PA1_UART5_RXD  0x00000000UL        /*!< ALT_MFP3 PA.1 setting for UART5_RXD */
N#define SYS_ALT_MFP4_PA1_UART5_RXD  (1UL<<6)            /*!< ALT_MFP4 PA.1 setting for UART5_RXD */
N
N#define SYS_GPA_MFP_PA1_PWM0_CH5    (1UL<<1)            /*!< GPA_MFP PA.1 setting for PWM0_CH5 */
N#define SYS_ALT_MFP_PA1_PWM0_CH5    NULL                /*!< No ALT_MFP setting for PA.1 */
N#define SYS_ALT_MFP1_PA1_PWM0_CH5   NULL                /*!< No ALT_MFP1 setting for PA.1 */
N#define SYS_ALT_MFP2_PA1_PWM0_CH5   NULL                /*!< No ALT_MFP2 setting for PA.1 */
N#define SYS_ALT_MFP3_PA1_PWM0_CH5   (1UL<<5)            /*!< ALT_MFP3 PA.1 setting for PWM0_CH5 */
N#define SYS_ALT_MFP4_PA1_PWM0_CH5   0x00000000UL        /*!< ALT_MFP4 PA.1 setting for PWM0_CH5 */
N
N#define SYS_GPA_MFP_PA1_Msk         (1UL<<1)            /*!< GPA_MFP PA.1 mask */
N#define SYS_ALT_MFP_PA1_Msk         NULL                /*!< No ALT_MFP PA.1 mask */
N#define SYS_ALT_MFP1_PA1_Msk        NULL                /*!< No ALT_MFP1 PA.1 mask */
N#define SYS_ALT_MFP2_PA1_Msk        NULL                /*!< No ALT_MFP2 PA.1 mask */
N#define SYS_ALT_MFP3_PA1_Msk        (1UL<<5)            /*!< ALT_MFP3 PA.1 mask */
N#define SYS_ALT_MFP4_PA1_Msk        ((1UL<<13)|(1UL<<6))/*!< ALT_MFP4 PA.1 mask */
N
N//PA.2
N#define SYS_GPA_MFP_PA2_GPIO        0x00000000UL        /*!< GPA_MFP PA.2 setting for GPIO */
N#define SYS_ALT_MFP_PA2_GPIO        NULL                /*!< No ALT_MFP setting for PA.2 */
N#define SYS_ALT_MFP1_PA2_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.2 */
N#define SYS_ALT_MFP2_PA2_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.2 */
N#define SYS_ALT_MFP3_PA2_GPIO       0x00000000UL        /*!< ALT_MFP3 PA.2 setting for GPIO */
N#define SYS_ALT_MFP4_PA2_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.2 setting for GPIO */
N
N#define SYS_GPA_MFP_PA2_ADC2        (1UL<<2)            /*!< GPA_MFP PA.2 setting for ADC2 */
N#define SYS_ALT_MFP_PA2_ADC2        NULL                /*!< No ALT_MFP setting for PA.2 */
N#define SYS_ALT_MFP1_PA2_ADC2       NULL                /*!< No ALT_MFP1 setting for PA.2 */
N#define SYS_ALT_MFP2_PA2_ADC2       NULL                /*!< No ALT_MFP2 setting for PA.2 */
N#define SYS_ALT_MFP3_PA2_ADC2       0x00000000UL        /*!< ALT_MFP3 PA.2 setting for ADC2 */
N#define SYS_ALT_MFP4_PA2_ADC2       0x00000000UL        /*!< ALT_MFP4 PA.2 setting for ADC2 */
N
N#define SYS_GPA_MFP_PA2_UART3_TXD   (1UL<<2)            /*!< GPA_MFP PA.2 setting for UART3_TXD */
N#define SYS_ALT_MFP_PA2_UART3_TXD   NULL                /*!< No ALT_MFP setting for PA.2 */
N#define SYS_ALT_MFP1_PA2_UART3_TXD  NULL                /*!< No ALT_MFP1 setting for PA.2 */
N#define SYS_ALT_MFP2_PA2_UART3_TXD  NULL                /*!< No ALT_MFP2 setting for PA.2 */
N#define SYS_ALT_MFP3_PA2_UART3_TXD  0x00000000UL        /*!< ALT_MFP3 PA.2 setting for UART3_TXD */
N#define SYS_ALT_MFP4_PA2_UART3_TXD  (1UL<<3)            /*!< ALT_MFP4 PA.2 setting for UART3_TXD */
N
N#define SYS_GPA_MFP_PA2_PWM1_CH0    (1UL<<2)            /*!< GPA_MFP PA.2 setting for PWM1_CH0 */
N#define SYS_ALT_MFP_PA2_PWM1_CH0    NULL                /*!< No ALT_MFP setting for PA.2 */
N#define SYS_ALT_MFP1_PA2_PWM1_CH0   NULL                /*!< No ALT_MFP1 setting for PA.2 */
N#define SYS_ALT_MFP2_PA2_PWM1_CH0   NULL                /*!< No ALT_MFP2 setting for PA.2 */
N#define SYS_ALT_MFP3_PA2_PWM1_CH0   (1UL<<6)            /*!< ALT_MFP3 PA.2 setting for PWM1_CH0 */
N#define SYS_ALT_MFP4_PA2_PWM1_CH0   0x00000000UL        /*!< ALT_MFP4 PA.2 setting for PWM1_CH0 */
N
N#define SYS_GPA_MFP_PA2_Msk         (1UL<<2)            /*!< GPA_MFP PA.2 mask */
N#define SYS_ALT_MFP_PA2_Msk         NULL                /*!< No ALT_MFP PA.2 mask */
N#define SYS_ALT_MFP1_PA2_Msk        NULL                /*!< No ALT_MFP1 PA.2 mask */
N#define SYS_ALT_MFP2_PA2_Msk        NULL                /*!< No ALT_MFP2 PA.2 mask */
N#define SYS_ALT_MFP3_PA2_Msk        (1UL<<6)            /*!< ALT_MFP3 PA.2 mask */
N#define SYS_ALT_MFP4_PA2_Msk        (1UL<<3)            /*!< ALT_MFP4 PA.2 mask */
N
N//PA.3
N#define SYS_GPA_MFP_PA3_GPIO        0x00000000UL        /*!< GPA_MFP PA.3 setting for GPIO */
N#define SYS_ALT_MFP_PA3_GPIO        NULL                /*!< No ALT_MFP setting for PA.3 */
N#define SYS_ALT_MFP1_PA3_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.3 */
N#define SYS_ALT_MFP2_PA3_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.3 */
N#define SYS_ALT_MFP3_PA3_GPIO       0x00000000UL        /*!< ALT_MFP3 PA.3 setting for GPIO */
N#define SYS_ALT_MFP4_PA3_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.3 setting for GPIO */
N
N#define SYS_GPA_MFP_PA3_ADC3        (1UL<<3)            /*!< GPA_MFP PA.3 setting for ADC3 */
N#define SYS_ALT_MFP_PA3_ADC3        NULL                /*!< No ALT_MFP setting for PA.3 */
N#define SYS_ALT_MFP1_PA3_ADC3       NULL                /*!< No ALT_MFP1 setting for PA.3 */
N#define SYS_ALT_MFP2_PA3_ADC3       NULL                /*!< No ALT_MFP2 setting for PA.3 */
N#define SYS_ALT_MFP3_PA3_ADC3       0x00000000UL        /*!< ALT_MFP3 PA.3 setting for ADC3 */
N#define SYS_ALT_MFP4_PA3_ADC3       0x00000000UL        /*!< ALT_MFP4 PA.3 setting for ADC3 */
N
N#define SYS_GPA_MFP_PA3_UART3_RXD   (1UL<<3)            /*!< GPA_MFP PA.3 setting for UART3_RXD */
N#define SYS_ALT_MFP_PA3_UART3_RXD   NULL                /*!< No ALT_MFP setting for PA.3 */
N#define SYS_ALT_MFP1_PA3_UART3_RXD  NULL                /*!< No ALT_MFP1 setting for PA.3 */
N#define SYS_ALT_MFP2_PA3_UART3_RXD  NULL                /*!< No ALT_MFP2 setting for PA.3 */
N#define SYS_ALT_MFP3_PA3_UART3_RXD  0x00000000UL        /*!< ALT_MFP3 PA.3 setting for UART3_RXD */
N#define SYS_ALT_MFP4_PA3_UART3_RXD  (1UL<<2)            /*!< ALT_MFP4 PA.3 setting for UART3_RXD */
N
N#define SYS_GPA_MFP_PA3_PWM1_CH1    (1UL<<3)            /*!< GPA_MFP PA.3 setting for PWM1_CH1 */
N#define SYS_ALT_MFP_PA3_PWM1_CH1    NULL                /*!< No ALT_MFP setting for PA.3 */
N#define SYS_ALT_MFP1_PA3_PWM1_CH1   NULL                /*!< No ALT_MFP1 setting for PA.3 */
N#define SYS_ALT_MFP2_PA3_PWM1_CH1   NULL                /*!< No ALT_MFP2 setting for PA.3 */
N#define SYS_ALT_MFP3_PA3_PWM1_CH1   (1UL<<7)            /*!< ALT_MFP3 PA.3 setting for PWM1_CH1 */
N#define SYS_ALT_MFP4_PA3_PWM1_CH1   0x00000000UL        /*!< ALT_MFP4 PA.3 setting for PWM1_CH1 */
N
N#define SYS_GPA_MFP_PA3_Msk         (1UL<<3)            /*!< GPA_MFP PA.3 mask */
N#define SYS_ALT_MFP_PA3_Msk         NULL                /*!< No ALT_MFP PA.3 mask */
N#define SYS_ALT_MFP1_PA3_Msk        NULL                /*!< No ALT_MFP1 PA.3 mask */
N#define SYS_ALT_MFP2_PA3_Msk        NULL                /*!< No ALT_MFP2 PA.3 mask */
N#define SYS_ALT_MFP3_PA3_Msk        (1UL<<7)            /*!< ALT_MFP3 PA.3 mask */
N#define SYS_ALT_MFP4_PA3_Msk        (1UL<<2)            /*!< ALT_MFP4 PA.3 mask */
N
N//PA.4
N#define SYS_GPA_MFP_PA4_GPIO        0x00000000UL        /*!< GPA_MFP PA.4 setting for GPIO */
N#define SYS_ALT_MFP_PA4_GPIO        NULL                /*!< No ALT_MFP setting for PA.4 */
N#define SYS_ALT_MFP1_PA4_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.4 */
N#define SYS_ALT_MFP2_PA4_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.4 */
N#define SYS_ALT_MFP3_PA4_GPIO       NULL                /*!< No ALT_MFP3 setting for PA.4 */
N#define SYS_ALT_MFP4_PA4_GPIO       NULL                /*!< No ALT_MFP4 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_ADC4        (1UL<<4)            /*!< GPA_MFP PA.4 setting for ADC4 */
N#define SYS_ALT_MFP_PA4_ADC4        NULL                /*!< No ALT_MFP setting for PA.4 */
N#define SYS_ALT_MFP1_PA4_ADC4       NULL                /*!< No ALT_MFP1 setting for PA.4 */
N#define SYS_ALT_MFP2_PA4_ADC4       NULL                /*!< No ALT_MFP2 setting for PA.4 */
N#define SYS_ALT_MFP3_PA4_ADC4       NULL                /*!< No ALT_MFP3 setting for PA.4 */
N#define SYS_ALT_MFP4_PA4_ADC4       NULL                /*!< No ALT_MFP4 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_Msk         (1UL<<4)            /*!< GPA_MFP PA.4 mask */
N#define SYS_ALT_MFP_PA4_Msk         NULL                /*!< No ALT_MFP PA.4 mask */
N#define SYS_ALT_MFP1_PA4_Msk        NULL                /*!< No ALT_MFP1 PA.4 mask */
N#define SYS_ALT_MFP2_PA4_Msk        NULL                /*!< No ALT_MFP2 PA.4 mask */
N#define SYS_ALT_MFP3_PA4_Msk        NULL                /*!< No ALT_MFP3 PA.4 mask */
N#define SYS_ALT_MFP4_PA4_Msk        NULL                /*!< No ALT_MFP4 PA.4 mask */
N
N//PA.5
N#define SYS_GPA_MFP_PA5_GPIO        0x00000000UL        /*!< GPA_MFP PA.5 setting for GPIO */
N#define SYS_ALT_MFP_PA5_GPIO        NULL                /*!< No ALT_MFP setting for PA.5 */
N#define SYS_ALT_MFP1_PA5_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.5 */
N#define SYS_ALT_MFP2_PA5_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.5 */
N#define SYS_ALT_MFP3_PA5_GPIO       NULL                /*!< No ALT_MFP3 setting for PA.5 */
N#define SYS_ALT_MFP4_PA5_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.5 setting for GPIO */
N
N#define SYS_GPA_MFP_PA5_ADC5        (1UL<<5)            /*!< GPA_MFP PA.5 setting for ADC5 */
N#define SYS_ALT_MFP_PA5_ADC5        NULL                /*!< No ALT_MFP setting for PA.5 */
N#define SYS_ALT_MFP1_PA5_ADC5       NULL                /*!< No ALT_MFP1 setting for PA.5 */
N#define SYS_ALT_MFP2_PA5_ADC5       NULL                /*!< No ALT_MFP2 setting for PA.5 */
N#define SYS_ALT_MFP3_PA5_ADC5       NULL                /*!< No ALT_MFP3 setting for PA.5 */
N#define SYS_ALT_MFP4_PA5_ADC5       0x00000000UL        /*!< ALT_MFP4 PA.5 setting for ADC5 */
N
N#define SYS_GPA_MFP_PA5_UART3_RXD   (1UL<<5)            /*!< GPA_MFP PA.5 setting for UART3_RXD */
N#define SYS_ALT_MFP_PA5_UART3_RXD   NULL                /*!< No ALT_MFP setting for PA.5 */
N#define SYS_ALT_MFP1_PA5_UART3_RXD  NULL                /*!< No ALT_MFP1 setting for PA.5 */
N#define SYS_ALT_MFP2_PA5_UART3_RXD  NULL                /*!< No ALT_MFP2 setting for PA.5 */
N#define SYS_ALT_MFP3_PA5_UART3_RXD  NULL                /*!< No ALT_MFP3 setting for PA.5 */
N#define SYS_ALT_MFP4_PA5_UART3_RXD  (1UL<<4)            /*!< ALT_MFP4 PA.5 setting for UART3_RXD */
N
N#define SYS_GPA_MFP_PA5_Msk         (1UL<<5)            /*!< GPA_MFP PA.5 mask */
N#define SYS_ALT_MFP_PA5_Msk         NULL                /*!< No ALT_MFP PA.5 mask */
N#define SYS_ALT_MFP1_PA5_Msk        NULL                /*!< No ALT_MFP1 PA.5 mask */
N#define SYS_ALT_MFP2_PA5_Msk        NULL                /*!< No ALT_MFP2 PA.5 mask */
N#define SYS_ALT_MFP3_PA5_Msk        NULL                /*!< No ALT_MFP3 PA.5 mask */
N#define SYS_ALT_MFP4_PA5_Msk        (1UL<<4)            /*!< ALT_MFP4 PA.5 mask */
N
N//PA.6
N#define SYS_GPA_MFP_PA6_GPIO        0x00000000UL        /*!< GPA_MFP PA.6 setting for GPIO */
N#define SYS_ALT_MFP_PA6_GPIO        NULL                /*!< No ALT_MFP setting for PA.6 */
N#define SYS_ALT_MFP1_PA6_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.6 */
N#define SYS_ALT_MFP2_PA6_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.6 */
N#define SYS_ALT_MFP3_PA6_GPIO       NULL                /*!< No ALT_MFP3 setting for PA.6 */
N#define SYS_ALT_MFP4_PA6_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.6 setting for GPIO */
N
N#define SYS_GPA_MFP_PA6_ADC6        (1UL<<6)            /*!< GPA_MFP PA.6 setting for ADC6 */
N#define SYS_ALT_MFP_PA6_ADC6        NULL                /*!< No ALT_MFP setting for PA.6 */
N#define SYS_ALT_MFP1_PA6_ADC6       NULL                /*!< No ALT_MFP1 setting for PA.6 */
N#define SYS_ALT_MFP2_PA6_ADC6       NULL                /*!< No ALT_MFP2 setting for PA.6 */
N#define SYS_ALT_MFP3_PA6_ADC6       NULL                /*!< No ALT_MFP3 setting for PA.6 */
N#define SYS_ALT_MFP4_PA6_ADC6       0x00000000UL        /*!< ALT_MFP4 PA.6 setting for ADC6 */
N
N#define SYS_GPA_MFP_PA6_UART3_TXD   (1UL<<6)            /*!< GPA_MFP PA.6 setting for UART3_TXD */
N#define SYS_ALT_MFP_PA6_UART3_TXD   NULL                /*!< No ALT_MFP setting for PA.6 */
N#define SYS_ALT_MFP1_PA6_UART3_TXD  NULL                /*!< No ALT_MFP1 setting for PA.6 */
N#define SYS_ALT_MFP2_PA6_UART3_TXD  NULL                /*!< No ALT_MFP2 setting for PA.6 */
N#define SYS_ALT_MFP3_PA6_UART3_TXD  NULL                /*!< No ALT_MFP3 setting for PA.6 */
N#define SYS_ALT_MFP4_PA6_UART3_TXD  (1UL<<5)            /*!< ALT_MFP4 PA.6 setting for UART3_TXD */
N
N#define SYS_GPA_MFP_PA6_Msk         (1UL<<6)            /*!< GPA_MFP PA.6 mask */
N#define SYS_ALT_MFP_PA6_Msk         NULL                /*!< No ALT_MFP PA.6 mask */
N#define SYS_ALT_MFP1_PA6_Msk        NULL                /*!< No ALT_MFP1 PA.6 mask */
N#define SYS_ALT_MFP2_PA6_Msk        NULL                /*!< No ALT_MFP2 PA.6 mask */
N#define SYS_ALT_MFP3_PA6_Msk        NULL                /*!< No ALT_MFP3 PA.6 mask */
N#define SYS_ALT_MFP4_PA6_Msk        (1UL<<5)            /*!< ALT_MFP4 PA.6 mask */
N
N//PA.7
N#define SYS_GPA_MFP_PA7_GPIO        0x00000000UL        /*!< GPA_MFP PA.7 setting for GPIO */
N#define SYS_ALT_MFP_PA7_GPIO        NULL                /*!< No ALT_MFP setting for PA.7 */
N#define SYS_ALT_MFP1_PA7_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.7 */
N#define SYS_ALT_MFP2_PA7_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.7 */
N#define SYS_ALT_MFP3_PA7_GPIO       NULL                /*!< No ALT_MFP3 setting for PA.7 */
N#define SYS_ALT_MFP4_PA7_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.7 setting for GPIO */
N
N#define SYS_GPA_MFP_PA7_ADC7        (1UL<<7)            /*!< GPA_MFP PA.7 setting for ADC7 */
N#define SYS_ALT_MFP_PA7_ADC7        NULL                /*!< No ALT_MFP setting for PA.7 */
N#define SYS_ALT_MFP1_PA7_ADC7       NULL                /*!< No ALT_MFP1 setting for PA.7 */
N#define SYS_ALT_MFP2_PA7_ADC7       NULL                /*!< No ALT_MFP2 setting for PA.7 */
N#define SYS_ALT_MFP3_PA7_ADC7       NULL                /*!< No ALT_MFP3 setting for PA.7 */
N#define SYS_ALT_MFP4_PA7_ADC7       0x00000000UL        /*!< ALT_MFP4 PA.7 setting for ADC7 */
N
N#define SYS_GPA_MFP_PA7_Vref        (1UL<<7)            /*!< GPA_MFP PA.7 setting for Vref */
N#define SYS_ALT_MFP_PA7_Vref        NULL                /*!< No ALT_MFP setting for PA.7 */
N#define SYS_ALT_MFP1_PA7_Vref       NULL                /*!< No ALT_MFP1 setting for PA.7 */
N#define SYS_ALT_MFP2_PA7_Vref       NULL                /*!< No ALT_MFP2 setting for PA.7 */
N#define SYS_ALT_MFP3_PA7_Vref       NULL                /*!< No ALT_MFP3 setting for PA.7 */
N#define SYS_ALT_MFP4_PA7_Vref       (1UL<<14)           /*!< ALT_MFP4 PA.7 setting for Vref */
N
N#define SYS_GPA_MFP_PA7_Msk         (1UL<<7)            /*!< GPA_MFP PA.7 mask */
N#define SYS_ALT_MFP_PA7_Msk         NULL                /*!< No ALT_MFP PA.7 mask */
N#define SYS_ALT_MFP1_PA7_Msk        NULL                /*!< No ALT_MFP1 PA.7 mask */
N#define SYS_ALT_MFP2_PA7_Msk        NULL                /*!< No ALT_MFP2 PA.7 mask */
N#define SYS_ALT_MFP3_PA7_Msk        NULL                /*!< No ALT_MFP3 PA.7 mask */
N#define SYS_ALT_MFP4_PA7_Msk        (1UL<<14)            /*!< ALT_MFP4 PA.7 mask */
N
N//PA.8
N#define SYS_GPA_MFP_PA8_GPIO        0x00000000UL        /*!< GPA_MFP PA.8 setting for GPIO */
N#define SYS_ALT_MFP_PA8_GPIO        NULL                /*!< No ALT_MFP setting for PA.8 */
N#define SYS_ALT_MFP1_PA8_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.8 */
N#define SYS_ALT_MFP2_PA8_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.8 */
N#define SYS_ALT_MFP3_PA8_GPIO       NULL                /*!< No ALT_MFP3 setting for PA.8 */
N#define SYS_ALT_MFP4_PA8_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.8 setting for GPIO */
N
N#define SYS_GPA_MFP_PA8_I2C0_SDA     (1UL<<8)           /*!< GPA_MFP PA.8 setting for I2C0_SDA */
N#define SYS_ALT_MFP_PA8_I2C0_SDA    NULL                /*!< No ALT_MFP setting for PA.8 */
N#define SYS_ALT_MFP1_PA8_I2C0_SDA   NULL                /*!< No ALT_MFP1 setting for PA.8 */
N#define SYS_ALT_MFP2_PA8_I2C0_SDA   NULL                /*!< No ALT_MFP2 setting for PA.8 */
N#define SYS_ALT_MFP3_PA8_I2C0_SDA   NULL                /*!< No ALT_MFP3 setting for PA.8 */
N#define SYS_ALT_MFP4_PA8_I2C0_SDA   0x00000000UL        /*!< ALT_MFP4 PA.8 setting for I2C0_SDA */
N
N#define SYS_GPA_MFP_PA8_UART1_nRTS   (1UL<<8)           /*!< GPA_MFP PA.8 setting for UART1_nRTS */
N#define SYS_ALT_MFP_PA8_UART1_nRTS   NULL               /*!< No ALT_MFP setting for PA.8 */
N#define SYS_ALT_MFP1_PA8_UART1_nRTS  NULL               /*!< No ALT_MFP1 setting for PA.8 */
N#define SYS_ALT_MFP2_PA8_UART1_nRTS  NULL               /*!< No ALT_MFP2 setting for PA.8 */
N#define SYS_ALT_MFP3_PA8_UART1_nRTS  NULL               /*!< No ALT_MFP3 setting for PA.8 */
N#define SYS_ALT_MFP4_PA8_UART1_nRTS  (1UL<<0)           /*!< ALT_MFP4 PA.8 setting for UART1_nRTS */
N
N#define SYS_GPA_MFP_PA8_Msk         (1UL<<8)            /*!< GPA_MFP PA.8 mask */
N#define SYS_ALT_MFP_PA8_Msk         NULL                /*!< No ALT_MFP PA.8 mask */
N#define SYS_ALT_MFP1_PA8_Msk        NULL                /*!< No ALT_MFP1 PA.8 mask */
N#define SYS_ALT_MFP2_PA8_Msk        NULL                /*!< No ALT_MFP2 PA.8 mask */
N#define SYS_ALT_MFP3_PA8_Msk        NULL                /*!< No ALT_MFP3 PA.8 mask */
N#define SYS_ALT_MFP4_PA8_Msk        (1UL<<0)            /*!< ALT_MFP4 PA.8 mask */
N
N//PA.9
N#define SYS_GPA_MFP_PA9_GPIO        0x00000000UL        /*!< GPA_MFP PA.9 setting for GPIO */
N#define SYS_ALT_MFP_PA9_GPIO        NULL                /*!< No ALT_MFP setting for PA.9 */
N#define SYS_ALT_MFP1_PA9_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.9 */
N#define SYS_ALT_MFP2_PA9_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.9 */
N#define SYS_ALT_MFP3_PA9_GPIO       NULL                /*!< No ALT_MFP3 setting for PA.9 */
N#define SYS_ALT_MFP4_PA9_GPIO       0x00000000UL        /*!< ALT_MFP4 PA.9 setting for GPIO */
N
N#define SYS_GPA_MFP_PA9_I2C0_SCL    (1UL<<9)            /*!< GPA_MFP PA.9 setting for I2C0_SCL */
N#define SYS_ALT_MFP_PA9_I2C0_SCL    NULL                /*!< No ALT_MFP setting for PA.9 */
N#define SYS_ALT_MFP1_PA9_I2C0_SCL   NULL                /*!< No ALT_MFP1 setting for PA.9 */
N#define SYS_ALT_MFP2_PA9_I2C0_SCL   NULL                /*!< No ALT_MFP2 setting for PA.9 */
N#define SYS_ALT_MFP3_PA9_I2C0_SCL   NULL                /*!< No ALT_MFP3 setting for PA.9 */
N#define SYS_ALT_MFP4_PA9_I2C0_SCL   0x00000000UL        /*!< ALT_MFP4 PA.9 setting for I2C0_SCL */
N
N#define SYS_GPA_MFP_PA9_UART1_nCTS   (1UL<<9)           /*!< GPA_MFP PA.9 setting for UART1_nCTS */
N#define SYS_ALT_MFP_PA9_UART1_nCTS   NULL               /*!< No ALT_MFP setting for PA.9 */
N#define SYS_ALT_MFP1_PA9_UART1_nCTS  NULL               /*!< No ALT_MFP1 setting for PA.9 */
N#define SYS_ALT_MFP2_PA9_UART1_nCTS  NULL               /*!< No ALT_MFP2 setting for PA.9 */
N#define SYS_ALT_MFP3_PA9_UART1_nCTS  NULL               /*!< No ALT_MFP3 setting for PA.9 */
N#define SYS_ALT_MFP4_PA9_UART1_nCTS  (1UL<<1)           /*!< ALT_MFP4 PA.9 setting for UART1_nCTS */
N
N#define SYS_GPA_MFP_PA9_Msk          (1UL<<9)           /*!< GPA_MFP PA.9 mask */
N#define SYS_ALT_MFP_PA9_Msk          NULL               /*!< No ALT_MFP PA.9 mask */
N#define SYS_ALT_MFP1_PA9_Msk         NULL               /*!< No ALT_MFP1 PA.9 mask */
N#define SYS_ALT_MFP2_PA9_Msk         NULL               /*!< No ALT_MFP2 PA.9 mask */
N#define SYS_ALT_MFP3_PA9_Msk         NULL               /*!< No ALT_MFP3 PA.9 mask */
N#define SYS_ALT_MFP4_PA9_Msk         (1UL<<1)           /*!< ALT_MFP4 PA.9 mask */
N
N//PA.10
N#define SYS_GPA_MFP_PA10_GPIO        0x00000000UL       /*!< GPA_MFP PA.10 setting for GPIO */
N#define SYS_ALT_MFP_PA10_GPIO        NULL               /*!< No ALT_MFP setting for PA.10 */
N#define SYS_ALT_MFP1_PA10_GPIO       NULL               /*!< No ALT_MFP1 setting for PA.10 */
N#define SYS_ALT_MFP2_PA10_GPIO       NULL               /*!< No ALT_MFP2 setting for PA.10 */
N#define SYS_ALT_MFP3_PA10_GPIO       0x00000000UL       /*!< ALT_MFP3 PA.10 setting for GPIO */
N#define SYS_ALT_MFP4_PA10_GPIO       NULL               /*!< No ALT_MFP4 setting for PA.10 */
N
N#define SYS_GPA_MFP_PA10_I2C1_SDA    (1UL<<10)          /*!< GPA_MFP PA.10 setting for I2C1_SDA */
N#define SYS_ALT_MFP_PA10_I2C1_SDA    NULL               /*!< No ALT_MFP setting for PA.10 */
N#define SYS_ALT_MFP1_PA10_I2C1_SDA   NULL               /*!< No ALT_MFP1 setting for PA.10 */
N#define SYS_ALT_MFP2_PA10_I2C1_SDA   NULL               /*!< No ALT_MFP2 setting for PA.10 */
N#define SYS_ALT_MFP3_PA10_I2C1_SDA   0x00000000UL       /*!< ALT_MFP3 PA.10 setting for I2C1_SDA */
N#define SYS_ALT_MFP4_PA10_I2C1_SDA   NULL               /*!< No ALT_MFP4 setting for PA.10 */
N
N#define SYS_GPA_MFP_PA10_PWM1_CH2    (1UL<<10)          /*!< GPA_MFP PA.10 setting for PWM1_CH2 */
N#define SYS_ALT_MFP_PA10_PWM1_CH2    NULL               /*!< No ALT_MFP setting for PA.10 */
N#define SYS_ALT_MFP1_PA10_PWM1_CH2   NULL               /*!< No ALT_MFP1 setting for PA.10 */
N#define SYS_ALT_MFP2_PA10_PWM1_CH2   NULL               /*!< No ALT_MFP2 setting for PA.10 */
N#define SYS_ALT_MFP3_PA10_PWM1_CH2   (1UL<<8)           /*!< ALT_MFP3 PA.10 setting for PWM1_CH2 */
N#define SYS_ALT_MFP4_PA10_PWM1_CH2   NULL               /*!< No ALT_MFP4 setting for PA.10 */
N
N#define SYS_GPA_MFP_PA10_Msk         (1UL<<10)          /*!< GPA_MFP PA.10 mask */
N#define SYS_ALT_MFP_PA10_Msk         NULL               /*!< No ALT_MFP PA.10 mask */
N#define SYS_ALT_MFP1_PA10_Msk        NULL               /*!< No ALT_MFP1 PA.10 mask */
N#define SYS_ALT_MFP2_PA10_Msk        NULL               /*!< No ALT_MFP2 PA.10 mask */
N#define SYS_ALT_MFP3_PA10_Msk        (1UL<<8)           /*!< ALT_MFP3 PA.10 mask */
N#define SYS_ALT_MFP4_PA10_Msk        NULL               /*!< No ALT_MFP4 PA.10 mask */
N
N//PA.11
N#define SYS_GPA_MFP_PA11_GPIO        0x00000000UL       /*!< GPA_MFP PA.11 setting for GPIO */
N#define SYS_ALT_MFP_PA11_GPIO        NULL               /*!< No ALT_MFP setting for PA.11 */
N#define SYS_ALT_MFP1_PA11_GPIO       NULL               /*!< No ALT_MFP1 setting for PA.11 */
N#define SYS_ALT_MFP2_PA11_GPIO       NULL               /*!< No ALT_MFP2 setting for PA.11 */
N#define SYS_ALT_MFP3_PA11_GPIO       0x00000000UL       /*!< ALT_MFP3 PA.11 setting for GPIO */
N#define SYS_ALT_MFP4_PA11_GPIO       NULL               /*!< No ALT_MFP4 setting for PA.11 */
N
N#define SYS_GPA_MFP_PA11_I2C1_SCL    (1UL<<11)          /*!< GPA_MFP PA.11 setting for I2C1_SCL */
N#define SYS_ALT_MFP_PA11_I2C1_SCL    NULL               /*!< No ALT_MFP setting for PA.11 */
N#define SYS_ALT_MFP1_PA11_I2C1_SCL   NULL               /*!< No ALT_MFP1 setting for PA.11 */
N#define SYS_ALT_MFP2_PA11_I2C1_SCL   NULL               /*!< No ALT_MFP2 setting for PA.11 */
N#define SYS_ALT_MFP3_PA11_I2C1_SCL   0x00000000UL       /*!< ALT_MFP3 PA.11 setting for I2C1_SCL */
N#define SYS_ALT_MFP4_PA11_I2C1_SCL   NULL               /*!< No ALT_MFP4 setting for PA.11 */
N
N#define SYS_GPA_MFP_PA11_PWM1_CH3    (1UL<<11)          /*!< GPA_MFP PA.11 setting for PWM1_CH3 */
N#define SYS_ALT_MFP_PA11_PWM1_CH3    NULL               /*!< No ALT_MFP setting for PA.11 */
N#define SYS_ALT_MFP1_PA11_PWM1_CH3   NULL               /*!< No ALT_MFP1 setting for PA.11 */
N#define SYS_ALT_MFP2_PA11_PWM1_CH3   NULL               /*!< No ALT_MFP2 setting for PA.11 */
N#define SYS_ALT_MFP3_PA11_PWM1_CH3   (1UL<<9)           /*!< ALT_MFP3 PA.11 setting for PWM1_CH3 */
N#define SYS_ALT_MFP4_PA11_PWM1_CH3   NULL               /*!< No ALT_MFP4 setting for PA.11 */
N
N#define SYS_GPA_MFP_PA11_Msk         (1UL<<11)          /*!< GPA_MFP PA.11 mask */
N#define SYS_ALT_MFP_PA11_Msk         NULL               /*!< No ALT_MFP PA.11 mask */
N#define SYS_ALT_MFP1_PA11_Msk        NULL               /*!< No ALT_MFP1 PA.11 mask */
N#define SYS_ALT_MFP2_PA11_Msk        NULL               /*!< No ALT_MFP2 PA.11 mask */
N#define SYS_ALT_MFP3_PA11_Msk        (1UL<<9)           /*!< ALT_MFP3 PA.11 mask */
N#define SYS_ALT_MFP4_PA11_Msk        NULL               /*!< No ALT_MFP4 PA.11 mask */
N
N//PA.12
N#define SYS_GPA_MFP_PA12_GPIO        0x00000000UL       /*!< GPA_MFP PA.12 setting for GPIO */
N#define SYS_ALT_MFP_PA12_GPIO        NULL               /*!< No ALT_MFP setting for PA.12 */
N#define SYS_ALT_MFP1_PA12_GPIO       NULL               /*!< No ALT_MFP1 setting for PA.12 */
N#define SYS_ALT_MFP2_PA12_GPIO       NULL               /*!< No ALT_MFP2 setting for PA.12 */
N#define SYS_ALT_MFP3_PA12_GPIO       NULL               /*!< No ALT_MFP3 setting for PA.12 */
N#define SYS_ALT_MFP4_PA12_GPIO       0x00000000UL       /*!< ALT_MFP4 PA.12 setting for for GPIO */
N
N#define SYS_GPA_MFP_PA12_PWM0_CH0    (1UL<<12)          /*!< GPA_MFP PA.12 setting for PWM0_CH0 */
N#define SYS_ALT_MFP_PA12_PWM0_CH0    NULL               /*!< No ALT_MFP setting for PA.12 */
N#define SYS_ALT_MFP1_PA12_PWM0_CH0   NULL               /*!< No ALT_MFP1 setting for PA.12 */
N#define SYS_ALT_MFP2_PA12_PWM0_CH0   NULL               /*!< No ALT_MFP2 setting for PA.12 */
N#define SYS_ALT_MFP3_PA12_PWM0_CH0   NULL               /*!< No ALT_MFP3 setting for PA.12 */
N#define SYS_ALT_MFP4_PA12_PWM0_CH0   0x00000000UL       /*!< ALT_MFP4 PA.12 setting for PWM0_CH0 */
N
N#define SYS_GPA_MFP_PA12_UART5_RXD   (1UL<<12)          /*!< GPA_MFP PA.12 setting for UART5_RXD */
N#define SYS_ALT_MFP_PA12_UART5_RXD   NULL               /*!< No ALT_MFP setting for PA.12 */
N#define SYS_ALT_MFP1_PA12_UART5_RXD  NULL               /*!< No ALT_MFP1 setting for PA.12 */
N#define SYS_ALT_MFP2_PA12_UART5_RXD  NULL               /*!< No ALT_MFP2 setting for PA.12 */
N#define SYS_ALT_MFP3_PA12_UART5_RXD  NULL               /*!< No ALT_MFP3 setting for PA.12 */
N#define SYS_ALT_MFP4_PA12_UART5_RXD  (1UL<<8)           /*!< ALT_MFP4 PA.12 setting for  UART5_RXD */
N
N#define SYS_GPA_MFP_PA12_Msk         (1UL<<12)          /*!< GPA_MFP PA.12 mask */
N#define SYS_ALT_MFP_PA12_Msk         NULL               /*!< No ALT_MFP PA.12 mask */
N#define SYS_ALT_MFP1_PA12_Msk        NULL               /*!< No ALT_MFP1 PA.12 mask */
N#define SYS_ALT_MFP2_PA12_Msk        NULL               /*!< No ALT_MFP2 PA.12 mask */
N#define SYS_ALT_MFP3_PA12_Msk        NULL               /*!< No ALT_MFP3 PA.12 mask */
N#define SYS_ALT_MFP4_PA12_Msk        (1UL<<8)           /*!< ALT_MFP4 PA.12 mask */
N
N//PA.13
N#define SYS_GPA_MFP_PA13_GPIO        0x00000000UL       /*!< GPA_MFP PA.13 setting for GPIO */
N#define SYS_ALT_MFP_PA13_GPIO        NULL               /*!< No ALT_MFP setting for PA.13 */
N#define SYS_ALT_MFP1_PA13_GPIO       NULL               /*!< No ALT_MFP1 setting for PA.13 */
N#define SYS_ALT_MFP2_PA13_GPIO       NULL               /*!< No ALT_MFP2 setting for PA.13 */
N#define SYS_ALT_MFP3_PA13_GPIO       NULL               /*!< No ALT_MFP3 setting for PA.13 */
N#define SYS_ALT_MFP4_PA13_GPIO       0x00000000UL       /*!< ALT_MFP4 PA.13 setting for for GPIO */
N
N#define SYS_GPA_MFP_PA13_PWM0_CH1    (1UL<<13)          /*!< GPA_MFP PA.13 setting for PWM0_CH1 */
N#define SYS_ALT_MFP_PA13_PWM0_CH1    NULL               /*!< No ALT_MFP setting for PA.13 */
N#define SYS_ALT_MFP1_PA13_PWM0_CH1   NULL               /*!< No ALT_MFP1 setting for PA.13 */
N#define SYS_ALT_MFP2_PA13_PWM0_CH1   NULL               /*!< No ALT_MFP2 setting for PA.13 */
N#define SYS_ALT_MFP3_PA13_PWM0_CH1   NULL               /*!< No ALT_MFP3 setting for PA.13 */
N#define SYS_ALT_MFP4_PA13_PWM0_CH1   0x00000000UL       /*!< ALT_MFP4 PA.13 setting for PWM0_CH1 */
N
N#define SYS_GPA_MFP_PA13_UART5_TXD   (1UL<<13)          /*!< GPA_MFP PA.13 setting for UART5_TXD */
N#define SYS_ALT_MFP_PA13_UART5_TXD   NULL               /*!< No ALT_MFP setting for PA.13 */
N#define SYS_ALT_MFP1_PA13_UART5_TXD  NULL               /*!< No ALT_MFP1 setting for PA.13 */
N#define SYS_ALT_MFP2_PA13_UART5_TXD  NULL               /*!< No ALT_MFP2 setting for PA.13 */
N#define SYS_ALT_MFP3_PA13_UART5_TXD  NULL               /*!< No ALT_MFP3 setting for PA.13 */
N#define SYS_ALT_MFP4_PA13_UART5_TXD  (1UL<<9)           /*!< ALT_MFP4 PA.13 setting for UART5_TXD */
N
N#define SYS_GPA_MFP_PA13_Msk         (1UL<<13)          /*!< GPA_MFP PA.13 mask */
N#define SYS_ALT_MFP_PA13_Msk         NULL               /*!< No ALT_MFP PA.13 mask */
N#define SYS_ALT_MFP1_PA13_Msk        NULL               /*!< No ALT_MFP1 PA.13 mask */
N#define SYS_ALT_MFP2_PA13_Msk        NULL               /*!< No ALT_MFP2 PA.13 mask */
N#define SYS_ALT_MFP3_PA13_Msk        NULL               /*!< No ALT_MFP3 PA.13 mask */
N#define SYS_ALT_MFP4_PA13_Msk        (1UL<<9)           /*!< ALT_MFP4 PA.13 mask */
N
N//PA.14
N#define SYS_GPA_MFP_PA14_GPIO        0x00000000UL       /*!< GPA_MFP PA.14 setting for GPIO */
N#define SYS_ALT_MFP_PA14_GPIO        NULL               /*!< No ALT_MFP setting for PA.14 */
N#define SYS_ALT_MFP1_PA14_GPIO       NULL               /*!< No ALT_MFP1 setting for PA.14 */
N#define SYS_ALT_MFP2_PA14_GPIO       NULL               /*!< No ALT_MFP2 setting for PA.14 */
N#define SYS_ALT_MFP3_PA14_GPIO       NULL               /*!< No ALT_MFP3 setting for PA.14 */
N#define SYS_ALT_MFP4_PA14_GPIO       NULL               /*!< No ALT_MFP4 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_PWM0_CH2    (1UL<<14)          /*!< GPA_MFP PA.14 setting for PWM0_CH2 */
N#define SYS_ALT_MFP_PA14_PWM0_CH2    NULL               /*!< No ALT_MFP setting for PA.14 */
N#define SYS_ALT_MFP1_PA14_PWM0_CH2   NULL               /*!< No ALT_MFP1 setting for PA.14 */
N#define SYS_ALT_MFP2_PA14_PWM0_CH2   NULL               /*!< No ALT_MFP2 setting for PA.14 */
N#define SYS_ALT_MFP3_PA14_PWM0_CH2   NULL               /*!< No ALT_MFP3 setting for PA.14 */
N#define SYS_ALT_MFP4_PA14_PWM0_CH2   NULL               /*!< No ALT_MFP4 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_Msk         (1UL<<14)          /*!< GPA_MFP PA.14 mask */
N#define SYS_ALT_MFP_PA14_Msk         NULL               /*!< No ALT_MFP PA.14 mask */
N#define SYS_ALT_MFP1_PA14_Msk        NULL               /*!< No ALT_MFP1 PA.14 mask */
N#define SYS_ALT_MFP2_PA14_Msk        NULL               /*!< No ALT_MFP2 PA.14 mask */
N#define SYS_ALT_MFP3_PA14_Msk        NULL               /*!< No ALT_MFP3 PA.14 mask */
N#define SYS_ALT_MFP4_PA14_Msk        NULL               /*!< No ALT_MFP4 PA.14 mask */
N
N//PA.15
N#define SYS_GPA_MFP_PA15_GPIO        0x00000000UL       /*!< GPA_MFP PA.15 setting for GPIO */
N#define SYS_ALT_MFP_PA15_GPIO        NULL               /*!< No ALT_MFP setting for PA.15 */
N#define SYS_ALT_MFP1_PA15_GPIO       NULL               /*!< No ALT_MFP1 setting for PA.15 */
N#define SYS_ALT_MFP2_PA15_GPIO       NULL               /*!< No ALT_MFP2 setting for PA.15 */
N#define SYS_ALT_MFP3_PA15_GPIO       NULL               /*!< No ALT_MFP3 setting for PA.15 */
N#define SYS_ALT_MFP4_PA15_GPIO       NULL               /*!< No ALT_MFP4 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_PWM0_CH3    (1UL<<15)          /*!< GPA_MFP PA.15 setting for PWM0_CH3 */
N#define SYS_ALT_MFP_PA15_PWM0_CH3    NULL               /*!< No ALT_MFP setting for PA.15 */
N#define SYS_ALT_MFP1_PA15_PWM0_CH3   NULL               /*!< No ALT_MFP1 setting for PA.15 */
N#define SYS_ALT_MFP2_PA15_PWM0_CH3   NULL               /*!< No ALT_MFP2 setting for PA.15 */
N#define SYS_ALT_MFP3_PA15_PWM0_CH3   NULL               /*!< No ALT_MFP3 setting for PA.15 */
N#define SYS_ALT_MFP4_PA15_PWM0_CH3   NULL               /*!< No ALT_MFP4 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_Msk         (1UL<<15)          /*!< GPA_MFP PA.14 mask */
N#define SYS_ALT_MFP_PA15_Msk         NULL               /*!< No ALT_MFP PA.14 mask */
N#define SYS_ALT_MFP1_PA15_Msk        NULL               /*!< No ALT_MFP1 PA.14 mask */
N#define SYS_ALT_MFP2_PA15_Msk        NULL               /*!< No ALT_MFP2 PA.14 mask */
N#define SYS_ALT_MFP3_PA15_Msk        NULL               /*!< No ALT_MFP3 PA.14 mask */
N#define SYS_ALT_MFP4_PA15_Msk        NULL               /*!< No ALT_MFP4 PA.14 mask */
N
N//PB.0
N#define SYS_GPB_MFP_PB0_GPIO         0x00000000UL       /*!< GPB_MFP PB.0 setting for GPIO */
N#define SYS_ALT_MFP_PB0_GPIO         NULL               /*!< No ALT_MFP setting for PB.0 */
N#define SYS_ALT_MFP1_PB0_GPIO        NULL               /*!< No ALT_MFP1 setting for PB.0 */
N#define SYS_ALT_MFP2_PB0_GPIO        NULL               /*!< No ALT_MFP2 setting for PB.0 */
N#define SYS_ALT_MFP3_PB0_GPIO        NULL               /*!< No ALT_MFP3 setting for PB.0 */
N#define SYS_ALT_MFP4_PB0_GPIO        NULL               /*!< No ALT_MFP4 setting for PB.0 */
N
N#define SYS_GPB_MFP_PB0_UART0_RXD    (1UL<<0)           /*!< GPB_MFP PB.0 setting for UART0_RXD */
N#define SYS_ALT_MFP_PB0_UART0_RXD    NULL               /*!< No ALT_MFP setting for PB.0 */
N#define SYS_ALT_MFP1_PB0_UART0_RXD   NULL               /*!< No ALT_MFP1 setting for PB.0 */
N#define SYS_ALT_MFP2_PB0_UART0_RXD   NULL               /*!< No ALT_MFP2 setting for PB.0 */
N#define SYS_ALT_MFP3_PB0_UART0_RXD   NULL               /*!< No ALT_MFP3 setting for PB.0 */
N#define SYS_ALT_MFP4_PB0_UART0_RXD   NULL               /*!< No ALT_MFP4 setting for PB.0 */
N
N#define SYS_GPB_MFP_PB0_Msk          (1UL<<0)           /*!< GPB_MFP PB.0 mask */
N#define SYS_ALT_MFP_PB0_Msk          NULL               /*!< No ALT_MFP PB.0 mask */
N#define SYS_ALT_MFP1_PB0_Msk         NULL               /*!< No ALT_MFP1 PB.0 mask */
N#define SYS_ALT_MFP2_PB0_Msk         NULL               /*!< No ALT_MFP2 PB.0 mask */
N#define SYS_ALT_MFP3_PB0_Msk         NULL               /*!< No ALT_MFP3 PB.0 mask */
N#define SYS_ALT_MFP4_PB0_Msk         NULL               /*!< No ALT_MFP4 PB.0 mask */
N
N//PB.1
N#define SYS_GPB_MFP_PB1_GPIO         0x00000000UL       /*!< GPB_MFP PB.1 setting for GPIO */
N#define SYS_ALT_MFP_PB1_GPIO         NULL               /*!< No ALT_MFP setting for PB.1 */
N#define SYS_ALT_MFP1_PB1_GPIO        NULL               /*!< No ALT_MFP1 setting for PB.1 */
N#define SYS_ALT_MFP2_PB1_GPIO        NULL               /*!< No ALT_MFP2 setting for PB.1 */
N#define SYS_ALT_MFP3_PB1_GPIO        NULL               /*!< No ALT_MFP3 setting for PB.1 */
N#define SYS_ALT_MFP4_PB1_GPIO        NULL               /*!< No ALT_MFP4 setting for PB.1 */
N
N#define SYS_GPB_MFP_PB1_UART0_TXD    (1UL<<1)           /*!< GPB_MFP PB.1 setting for UART0_TXD */
N#define SYS_ALT_MFP_PB1_UART0_TXD    NULL               /*!< No ALT_MFP setting for PB.1 */
N#define SYS_ALT_MFP1_PB1_UART0_TXD   NULL               /*!< No ALT_MFP1 setting for PB.1 */
N#define SYS_ALT_MFP2_PB1_UART0_TXD   NULL               /*!< No ALT_MFP2 setting for PB.1 */
N#define SYS_ALT_MFP3_PB1_UART0_TXD   NULL               /*!< No ALT_MFP3 setting for PB.1 */
N#define SYS_ALT_MFP4_PB1_UART0_TXD   NULL               /*!< No ALT_MFP4 setting for PB.1 */
N
N#define SYS_GPB_MFP_PB1_Msk          (1UL<<1)           /*!< GPB_MFP PB.1 mask */
N#define SYS_ALT_MFP_PB1_Msk          NULL               /*!< No ALT_MFP PB.1 mask */
N#define SYS_ALT_MFP1_PB1_Msk         NULL               /*!< No ALT_MFP1 PB.1 mask */
N#define SYS_ALT_MFP2_PB1_Msk         NULL               /*!< No ALT_MFP2 PB.1 mask */
N#define SYS_ALT_MFP3_PB1_Msk         NULL               /*!< No ALT_MFP3 PB.1 mask */
N#define SYS_ALT_MFP4_PB1_Msk         NULL               /*!< No ALT_MFP4 PB.1 mask */
N
N//PB.2
N#define SYS_GPB_MFP_PB2_GPIO         0x00000000UL       /*!< GPB_MFP PB.2 setting for GPIO */
N#define SYS_ALT_MFP_PB2_GPIO         0x00000000UL       /*!< ALT_MFP PB.2 setting for GPIO */
N#define SYS_ALT_MFP1_PB2_GPIO        NULL               /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_GPIO        0x00000000UL       /*!< ALT_MFP2 PB.2 setting for GPIO */
N#define SYS_ALT_MFP3_PB2_GPIO        0x00000000UL       /*!< ALT_MFP3 PB.2 setting for GPIO */
N#define SYS_ALT_MFP4_PB2_GPIO        NULL               /*!< No ALT_MFP4 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_UART0_nRTS   (1UL<<2)           /*!< GPB_MFP PB.2 setting for UART0_nRTS */
N#define SYS_ALT_MFP_PB2_UART0_nRTS   0x00000000UL       /*!< ALT_MFP PB.2 setting for UART0_nRTS */
N#define SYS_ALT_MFP1_PB2_UART0_nRTS  NULL               /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_UART0_nRTS  0x00000000UL       /*!< ALT_MFP2 PB.2 setting for UART0_nRTS */
N#define SYS_ALT_MFP3_PB2_UART0_nRTS  0x00000000UL       /*!< ALT_MFP3 PB.2 setting for UART0_nRTS */
N#define SYS_ALT_MFP4_PB2_UART0_nRTS  NULL               /*!< No ALT_MFP4 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_TM2_EXT      (1UL<<2)           /*!< GPB_MFP PB.2 setting for TM2_EXT */
N#define SYS_ALT_MFP_PB2_TM2_EXT      (1UL<<26)          /*!< ALT_MFP PB.2 setting for TM2_EXT */
N#define SYS_ALT_MFP1_PB2_TM2_EXT     NULL               /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_TM2_EXT     0x00000000UL       /*!< ALT_MFP2 PB.2 setting for TM2_EXT */
N#define SYS_ALT_MFP3_PB2_TM2_EXT     0x00000000UL       /*!< ALT_MFP3 PB.2 setting for TM2_EXT */
N#define SYS_ALT_MFP4_PB2_TM2_EXT     NULL               /*!< No ALT_MFP4 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_PWM1_BRAKE1   (1UL<<2)          /*!< GPB_MFP PB.2 setting for PWM1_BRAKE1 */
N#define SYS_ALT_MFP_PB2_PWM1_BRAKE1   0x00000000UL      /*!< ALT_MFP PB.2 setting for PWM1_BRAKE1 */
N#define SYS_ALT_MFP1_PB2_PWM1_BRAKE1  NULL              /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_PWM1_BRAKE1  0x00000000UL      /*!< ALT_MFP2 PB.2 setting for PWM1_BRAKE1 */
N#define SYS_ALT_MFP3_PB2_PWM1_BRAKE1  (1UL<<31)         /*!< ALT_MFP3 PB.2 setting for PWM1_BRAKE1 */
N#define SYS_ALT_MFP4_PB2_PWM1_BRAKE1  NULL              /*!< No ALT_MFP4 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_TM2          (1UL<<2)           /*!< GPB_MFP PB.2 setting for TM2 */
N#define SYS_ALT_MFP_PB2_TM2          0x00000000UL       /*!< ALT_MFP PB.2 setting for TM2 */
N#define SYS_ALT_MFP1_PB2_TM2         NULL               /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_TM2         (1UL<<4)           /*!< ALT_MFP2 PB.2 setting for TM2 */
N#define SYS_ALT_MFP3_PB2_TM2         0x00000000UL       /*!< ALT_MFP3 PB.2 setting for TM2 */
N#define SYS_ALT_MFP4_PB2_TM2         NULL               /*!< No ALT_MFP4 setting for PB.2 */
N
N#define SYS_GPB_MFP_PB2_Msk          (1UL<<2)           /*!< GPB_MFP PB.2 mask */
N#define SYS_ALT_MFP_PB2_Msk          (1UL<<26)          /*!< ALT_MFP PB.2 mask */
N#define SYS_ALT_MFP1_PB2_Msk         NULL               /*!< No ALT_MFP1 PB.2 mask */
N#define SYS_ALT_MFP2_PB2_Msk         (1UL<<4)           /*!< ALT_MFP2 PB.2 mask */
N#define SYS_ALT_MFP3_PB2_Msk         (1UL<<31)          /*!< ALT_MFP3 PB.2 mask */
N#define SYS_ALT_MFP4_PB2_Msk         NULL               /*!< No ALT_MFP4 PB.2 mask */
N
N//PB.3
N#define SYS_GPB_MFP_PB3_GPIO         0x00000000UL       /*!< GPB_MFP PB.3 setting for GPIO */
N#define SYS_ALT_MFP_PB3_GPIO         0x00000000UL       /*!< ALT_MFP PB.3 setting for GPIO */
N#define SYS_ALT_MFP1_PB3_GPIO        NULL               /*!< No ALT_MFP1 setting for PB.3 */
N#define SYS_ALT_MFP2_PB3_GPIO        0x00000000UL       /*!< ALT_MFP2 PB.3 setting for GPIO */
N#define SYS_ALT_MFP3_PB3_GPIO        0x00000000UL       /*!< ALT_MFP3 PB.3 setting for GPIO */
N#define SYS_ALT_MFP4_PB3_GPIO        NULL               /*!< No ALT_MFP4 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_UART0_nCTS   (1UL<<3)           /*!< GPB_MFP PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP_PB3_UART0_nCTS   0x00000000UL       /*!< ALT_MFP PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP1_PB3_UART0_nCTS  NULL               /*!< No ALT_MFP1 setting for PB.3 */
N#define SYS_ALT_MFP2_PB3_UART0_nCTS  0x00000000UL       /*!< ALT_MFP2 PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP3_PB3_UART0_nCTS  0x00000000UL       /*!< ALT_MFP3 PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP4_PB3_UART0_nCTS  NULL               /*!< No ALT_MFP4 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_TM3_EXT      (1UL<<3)           /*!< GPB_MFP PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP_PB3_TM3_EXT      (1UL<<27)          /*!< ALT_MFP PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP1_PB3_TM3_EXT     NULL               /*!< No ALT_MFP1 setting for PB.3 */
N#define SYS_ALT_MFP2_PB3_TM3_EXT     0x00000000UL       /*!< ALT_MFP2 PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP3_PB3_TM3_EXT     0x00000000UL       /*!< ALT_MFP3 PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP4_PB3_TM3_EXT     NULL               /*!< No ALT_MFP4 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_PWM1_BRAKE0     (1UL<<3)        /*!< GPB_MFP PB.3 setting for PWM1_BRAKE0 */
N#define SYS_ALT_MFP_PB3_PWM1_BRAKE0     0x00000000UL    /*!< ALT_MFP PB.3 setting for PWM1_BRAKE0 */
N#define SYS_ALT_MFP1_PB3_PWM1_BRAKE0    NULL            /*!< No ALT_MFP1 setting for PB.3 */
N#define SYS_ALT_MFP2_PB3_PWM1_BRAKE0    0x00000000UL    /*!< ALT_MFP2 PB.3 setting for PWM1_BRAKE0 */
N#define SYS_ALT_MFP3_PB3_PWM1_BRAKE0    (1UL<<30)       /*!< ALT_MFP3 PB.3 setting for PWM1_BRAKE0 */
N#define SYS_ALT_MFP4_PB3_PWM1_BRAKE0    NULL            /*!< No ALT_MFP4 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_TM3         (1UL<<3)            /*!< GPB_MFP PB.3 setting for TM3 */
N#define SYS_ALT_MFP_PB3_TM3         0000000UL           /*!< ALT_MFP PB.3 setting for TM3 */
N#define SYS_ALT_MFP1_PB3_TM3        NULL                /*!< No ALT_MFP1 setting for PB.3 */
N#define SYS_ALT_MFP2_PB3_TM3        (1UL<<5)            /*!< ALT_MFP2 PB.3 setting for TM3 */
N#define SYS_ALT_MFP3_PB3_TM3        0x00000000UL        /*!< ALT_MFP3 PB.3 setting for TM3 */
N#define SYS_ALT_MFP4_PB3_TM3        NULL                /*!< No ALT_MFP4 setting for PB.3 */
N
N#define SYS_GPB_MFP_PB3_Msk         (1UL<<3)            /*!< GPB_MFP PB.3 mask */
N#define SYS_ALT_MFP_PB3_Msk         (1UL<<27)           /*!< ALT_MFP PB.3 mask */
N#define SYS_ALT_MFP1_PB3_Msk        NULL                /*!< No ALT_MFP1 PB.3 mask */
N#define SYS_ALT_MFP2_PB3_Msk        (1UL<<5)            /*!< ALT_MFP2 PB.3 mask */
N#define SYS_ALT_MFP3_PB3_Msk        (1UL<<30)           /*!< ALT_MFP3 PB.3 mask */
N#define SYS_ALT_MFP4_PB3_Msk        NULL                /*!< No ALT_MFP4 PB.3 mask */
N
N//PB.4
N#define SYS_GPB_MFP_PB4_GPIO        0x00000000UL        /*!< GPB_MFP PB.4 setting for GPIO */
N#define SYS_ALT_MFP_PB4_GPIO        NULL                /*!< No ALT_MFP setting for PB.4 */
N#define SYS_ALT_MFP1_PB4_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.4 */
N#define SYS_ALT_MFP2_PB4_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.4 */
N#define SYS_ALT_MFP3_PB4_GPIO       NULL                /*!< No ALT_MFP3 setting for PB.4 */
N#define SYS_ALT_MFP4_PB4_GPIO       NULL                /*!< No ALT_MFP4 setting for PB.4 */
N
N#define SYS_GPB_MFP_PB4_UART1_RXD   (1UL<<4)            /*!< GPB_MFP PB.4 setting for UART1_RXD */
N#define SYS_ALT_MFP_PB4_UART1_RXD   NULL                /*!< No ALT_MFP setting for PB.4 */
N#define SYS_ALT_MFP1_PB4_UART1_RXD  NULL                /*!< No ALT_MFP1 setting for PB.4 */
N#define SYS_ALT_MFP2_PB4_UART1_RXD  NULL                /*!< No ALT_MFP2 setting for PB.4 */
N#define SYS_ALT_MFP3_PB4_UART1_RXD  NULL                /*!< No ALT_MFP3 setting for PB.4 */
N#define SYS_ALT_MFP4_PB4_UART1_RXD  NULL                /*!< No ALT_MFP4 setting for PB.4 */
N
N#define SYS_GPB_MFP_PB4_Msk         (1UL<<4)            /*!< GPB_MFP PB.4 mask */
N#define SYS_ALT_MFP_PB4_Msk         NULL                /*!< No ALT_MFP PB.4 mask */
N#define SYS_ALT_MFP1_PB4_Msk        NULL                /*!< No ALT_MFP1 PB.4 mask */
N#define SYS_ALT_MFP2_PB4_Msk        NULL                /*!< No ALT_MFP2 PB.4 mask */
N#define SYS_ALT_MFP3_PB4_Msk        NULL                /*!< No ALT_MFP3 PB.4 mask */
N#define SYS_ALT_MFP4_PB4_Msk        NULL                /*!< No ALT_MFP4 PB.4 mask */
N
N//PB.5
N#define SYS_GPB_MFP_PB5_GPIO        0x00000000UL        /*!< GPB_MFP PB.5 setting for GPIO */
N#define SYS_ALT_MFP_PB5_GPIO        NULL                /*!< No ALT_MFP setting for PB.5 */
N#define SYS_ALT_MFP1_PB5_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.5 */
N#define SYS_ALT_MFP2_PB5_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.5 */
N#define SYS_ALT_MFP3_PB5_GPIO       NULL                /*!< No ALT_MFP3 setting for PB.5 */
N#define SYS_ALT_MFP4_PB5_GPIO       NULL                /*!< No ALT_MFP4 setting for PB.5 */
N
N#define SYS_GPB_MFP_PB5_UART1_TXD   (1UL<<5)            /*!< GPB_MFP PB.5 setting for UART1_TXD */
N#define SYS_ALT_MFP_PB5_UART1_TXD   NULL                /*!< No ALT_MFP setting for PB.5 */
N#define SYS_ALT_MFP1_PB5_UART1_TXD  NULL                /*!< No ALT_MFP1 setting for PB.5 */
N#define SYS_ALT_MFP2_PB5_UART1_TXD  NULL                /*!< No ALT_MFP2 setting for PB.5 */
N#define SYS_ALT_MFP3_PB5_UART1_TXD  NULL                /*!< No ALT_MFP3 setting for PB.5 */
N#define SYS_ALT_MFP4_PB5_UART1_TXD  NULL                /*!< No ALT_MFP4 setting for PB.5 */
N
N#define SYS_GPB_MFP_PB5_Msk         (1UL<<5)            /*!< GPB_MFP PB.5 mask */
N#define SYS_ALT_MFP_PB5_Msk         NULL                /*!< No ALT_MFP PB.5 mask */
N#define SYS_ALT_MFP1_PB5_Msk        NULL                /*!< No ALT_MFP1 PB.5 mask */
N#define SYS_ALT_MFP2_PB5_Msk        NULL                /*!< No ALT_MFP2 PB.5 mask */
N#define SYS_ALT_MFP3_PB5_Msk        NULL                /*!< No ALT_MFP3 PB.5 mask */
N#define SYS_ALT_MFP4_PB5_Msk        NULL                /*!< No ALT_MFP4 PB.5 mask */
N
N//PB.6
N#define SYS_GPB_MFP_PB6_GPIO        0x00000000UL        /*!< GPB_MFP PB.6 setting for GPIO */
N#define SYS_ALT_MFP_PB6_GPIO        NULL                /*!< No ALT_MFP setting for PB.6 */
N#define SYS_ALT_MFP1_PB6_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.6 */
N#define SYS_ALT_MFP2_PB6_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.6 */
N#define SYS_ALT_MFP3_PB6_GPIO       NULL                /*!< No ALT_MFP3 setting for PB.6 */
N#define SYS_ALT_MFP4_PB6_GPIO       NULL                /*!< No ALT_MFP4 setting for PB.6 */
N
N#define SYS_GPB_MFP_PB6_UART1_nRTS      (1UL<<6)        /*!< GPB_MFP PB.6 setting for UART1_nRTS */
N#define SYS_ALT_MFP_PB6_UART1_nRTS      NULL            /*!< No ALT_MFP setting for PB.6 */
N#define SYS_ALT_MFP1_PB6_UART1_nRTS     NULL            /*!< No ALT_MFP1 setting for PB.6 */
N#define SYS_ALT_MFP2_PB6_UART1_nRTS     NULL            /*!< No ALT_MFP2 setting for PB.6 */
N#define SYS_ALT_MFP3_PB6_UART1_nRTS     NULL            /*!< No ALT_MFP3 setting for PB.6 */
N#define SYS_ALT_MFP4_PB6_UART1_nRTS     NULL            /*!< No ALT_MFP4 setting for PB.6 */
N
N#define SYS_GPB_MFP_PB6_Msk         (1UL<<6)            /*!< GPB_MFP PB.6 mask */
N#define SYS_ALT_MFP_PB6_Msk         NULL                /*!< No ALT_MFP PB.6 mask */
N#define SYS_ALT_MFP1_PB6_Msk        NULL                /*!< No ALT_MFP1 PB.6 mask */
N#define SYS_ALT_MFP2_PB6_Msk        NULL                /*!< No ALT_MFP2 PB.6 mask */
N#define SYS_ALT_MFP3_PB6_Msk        NULL                /*!< No ALT_MFP3 PB.6 mask */
N#define SYS_ALT_MFP4_PB6_Msk        NULL                /*!< No ALT_MFP4 PB.6 mask */
N
N//PB.7
N#define SYS_GPB_MFP_PB7_GPIO        0x00000000UL        /*!< GPB_MFP PB.7 setting for GPIO */
N#define SYS_ALT_MFP_PB7_GPIO        NULL                /*!< No ALT_MFP setting for PB.7 */
N#define SYS_ALT_MFP1_PB7_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.7 */
N#define SYS_ALT_MFP2_PB7_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.7 */
N#define SYS_ALT_MFP3_PB7_GPIO       NULL                /*!< No ALT_MFP3 setting for PB.7 */
N#define SYS_ALT_MFP4_PB7_GPIO       NULL                /*!< No ALT_MFP4 setting for PB.7 */
N
N#define SYS_GPB_MFP_PB7_UART1_nCTS      (1UL<<7)        /*!< GPB_MFP PB.7 setting for UART1_nCTS */
N#define SYS_ALT_MFP_PB7_UART1_nCTS      NULL            /*!< No ALT_MFP setting for PB.7 */
N#define SYS_ALT_MFP1_PB7_UART1_nCTS     NULL            /*!< No ALT_MFP1 setting for PB.7 */
N#define SYS_ALT_MFP2_PB7_UART1_nCTS     NULL            /*!< No ALT_MFP2 setting for PB.7 */
N#define SYS_ALT_MFP3_PB7_UART1_nCTS     NULL            /*!< No ALT_MFP3 setting for PB.7 */
N#define SYS_ALT_MFP4_PB7_UART1_nCTS     NULL            /*!< No ALT_MFP4 setting for PB.7 */
N
N#define SYS_GPB_MFP_PB7_Msk         (1UL<<7)            /*!< GPB_MFP PB.7 mask */
N#define SYS_ALT_MFP_PB7_Msk         NULL                /*!< No ALT_MFP PB.7 mask */
N#define SYS_ALT_MFP1_PB7_Msk        NULL                /*!< No ALT_MFP1 PB.7 mask */
N#define SYS_ALT_MFP2_PB7_Msk        NULL                /*!< No ALT_MFP2 PB.7 mask */
N#define SYS_ALT_MFP3_PB7_Msk        NULL                /*!< No ALT_MFP3 PB.7 mask */
N#define SYS_ALT_MFP4_PB7_Msk        NULL                /*!< No ALT_MFP4 PB.7 mask */
N
N//PB.8
N#define SYS_GPB_MFP_PB8_GPIO        0x00000000UL        /*!< GPB_MFP PB.8 setting for GPIO */
N#define SYS_ALT_MFP_PB8_GPIO        0x00000000UL        /*!< ALT_MFP PB.8 setting for GPIO */
N#define SYS_ALT_MFP1_PB8_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.8 */
N#define SYS_ALT_MFP2_PB8_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.8 */
N#define SYS_ALT_MFP3_PB8_GPIO       0x00000000UL        /*!< ALT_MFP3 PB.8 setting for GPIO */
N#define SYS_ALT_MFP4_PB8_GPIO       NULL                /*!< No ALT_MFP4 setting for PB.8 */
N
N#define SYS_GPB_MFP_PB8_TM0         (1UL<<8)            /*!< GPB_MFP PB.8 setting for TM0 */
N#define SYS_ALT_MFP_PB8_TM0         0x00000000UL        /*!< ALT_MFP PB.8 setting for TM0 */
N#define SYS_ALT_MFP1_PB8_TM0        NULL                /*!< No ALT_MFP1 setting for PB.8 */
N#define SYS_ALT_MFP2_PB8_TM0        NULL                /*!< No ALT_MFP2 setting for PB.8 */
N#define SYS_ALT_MFP3_PB8_TM0        0x00000000UL        /*!< ALT_MFP3 PB.8 setting for TM0 */
N#define SYS_ALT_MFP4_PB8_TM0        NULL                /*!< No ALT_MFP4 setting for PB.8 */
N
N#define SYS_GPB_MFP_PB8_CLKO        (1UL<<8)            /*!< GPB_MFP PB.8 setting for CLKO */
N#define SYS_ALT_MFP_PB8_CLKO        (1UL<<29)           /*!< ALT_MFP PB.8 setting for CLKO */
N#define SYS_ALT_MFP1_PB8_CLKO       NULL                /*!< No ALT_MFP1 setting for PB.8 */
N#define SYS_ALT_MFP2_PB8_CLKO       NULL                /*!< No ALT_MFP2 setting for PB.8 */
N#define SYS_ALT_MFP3_PB8_CLKO       0x00000000UL        /*!< ALT_MFP3 PB.8 setting for CLKO */
N#define SYS_ALT_MFP4_PB8_CLKO       NULL                /*!< No ALT_MFP4 setting for PB.8 */
N
N#define SYS_GPB_MFP_PB8_BPWM1_CH2   (1UL<<8)            /*!< GPB_MFP PB.8 setting for CLKO */
N#define SYS_ALT_MFP_PB8_BPWM1_CH2   0x00000000UL        /*!< ALT_MFP PB.8 setting for CLKO */
N#define SYS_ALT_MFP1_PB8_BPWM1_CH2  NULL                /*!< No ALT_MFP1 setting for PB.8 */
N#define SYS_ALT_MFP2_PB8_BPWM1_CH2  NULL                /*!< No ALT_MFP2 setting for PB.8 */
N#define SYS_ALT_MFP3_PB8_BPWM1_CH2  (1UL<<20)           /*!< ALT_MFP3 PB.8 setting for CLKO */
N#define SYS_ALT_MFP4_PB8_BPWM1_CH2  NULL                /*!< No ALT_MFP4 setting for PB.8 */
N
N#define SYS_GPB_MFP_PB8_Msk         (1UL<<8)            /*!< GPB_MFP PB.8 mask */
N#define SYS_ALT_MFP_PB8_Msk         (1UL<<29)           /*!< ALT_MFP PB.8 mask */
N#define SYS_ALT_MFP1_PB8_Msk        NULL                /*!< No ALT_MFP1 PB.8 mask */
N#define SYS_ALT_MFP2_PB8_Msk        NULL                /*!< No ALT_MFP2 PB.8 mask */
N#define SYS_ALT_MFP3_PB8_Msk        (1UL<<20)           /*!< ALT_MFP3 PB.8 mask */
N#define SYS_ALT_MFP4_PB8_Msk        NULL                /*!< No ALT_MFP4 PB.8 mask */
N
N//PB.9
N#define SYS_GPB_MFP_PB9_GPIO        0x00000000UL        /*!< GPB_MFP PB.9 setting for GPIO */
N#define SYS_ALT_MFP_PB9_GPIO        NULL                /*!< No ALT_MFP setting for PB.9 */
N#define SYS_ALT_MFP1_PB9_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.9 */
N#define SYS_ALT_MFP2_PB9_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.9 */
N#define SYS_ALT_MFP3_PB9_GPIO       NULL                /*!< No ALT_MFP3 setting for PB.9 */
N#define SYS_ALT_MFP4_PB9_GPIO       NULL                /*!< No ALT_MFP4 setting for PB.9 */
N
N#define SYS_GPB_MFP_PB9_TM1         (1UL<<9)            /*!< GPB_MFP PB.9 setting for TM1 */
N#define SYS_ALT_MFP_PB9_TM1         NULL                /*!< No ALT_MFP setting for PB.9 */
N#define SYS_ALT_MFP1_PB9_TM1        NULL                /*!< No ALT_MFP1 setting for PB.9 */
N#define SYS_ALT_MFP2_PB9_TM1        NULL                /*!< No ALT_MFP2 setting for PB.9 */
N#define SYS_ALT_MFP3_PB9_TM1        NULL                /*!< No ALT_MFP3 setting for PB.9 */
N#define SYS_ALT_MFP4_PB9_TM1        NULL                /*!< No ALT_MFP4 setting for PB.9 */
N
N#define SYS_GPB_MFP_PB9_Msk         (1UL<<9)            /*!< GPB_MFP PB.9 mask */
N#define SYS_ALT_MFP_PB9_Msk         NULL                /*!< No ALT_MFP PB.9 mask */
N#define SYS_ALT_MFP1_PB9_Msk        NULL                /*!< No ALT_MFP1 PB.9 mask */
N#define SYS_ALT_MFP2_PB9_Msk        NULL                /*!< No ALT_MFP2 PB.9 mask */
N#define SYS_ALT_MFP3_PB9_Msk        NULL                /*!< No ALT_MFP3 PB.9 mask */
N#define SYS_ALT_MFP4_PB9_Msk        NULL                /*!< No ALT_MFP4 PB.9 mask */
N
N//PB.10
N#define SYS_GPB_MFP_PB10_GPIO       0x00000000UL        /*!< GPB_MFP PB.10 setting for GPIO */
N#define SYS_ALT_MFP_PB10_GPIO       NULL                /*!< No ALT_MFP setting for PB.10 */
N#define SYS_ALT_MFP1_PB10_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.10 */
N#define SYS_ALT_MFP2_PB10_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.10 */
N#define SYS_ALT_MFP3_PB10_GPIO      NULL                /*!< No ALT_MFP3 setting for PB.10 */
N#define SYS_ALT_MFP4_PB10_GPIO      NULL                /*!< No ALT_MFP4 setting for PB.10 */
N
N#define SYS_GPB_MFP_PB10_TM2        (1UL<<10)           /*!< GPB_MFP PB.10 setting for TM2 */
N#define SYS_ALT_MFP_PB10_TM2        NULL                /*!< No ALT_MFP setting for PB.10 */
N#define SYS_ALT_MFP1_PB10_TM2       NULL                /*!< No ALT_MFP1 setting for PB.10 */
N#define SYS_ALT_MFP2_PB10_TM2       NULL                /*!< No ALT_MFP2 setting for PB.10 */
N#define SYS_ALT_MFP3_PB10_TM2       NULL                /*!< No ALT_MFP3 setting for PB.10 */
N#define SYS_ALT_MFP4_PB10_TM2       NULL                /*!< No ALT_MFP4 setting for PB.10 */
N
N#define SYS_GPB_MFP_PB10_Msk        (1UL<<10)           /*!< GPB_MFP PB.10 mask */
N#define SYS_ALT_MFP_PB10_Msk        NULL                /*!< No ALT_MFP PB.10 mask */
N#define SYS_ALT_MFP1_PB10_Msk       NULL                /*!< No ALT_MFP1 PB.10 mask */
N#define SYS_ALT_MFP2_PB10_Msk       NULL                /*!< No ALT_MFP2 PB.10 mask */
N#define SYS_ALT_MFP3_PB10_Msk       NULL                /*!< No ALT_MFP3 PB.10 mask */
N#define SYS_ALT_MFP4_PB10_Msk       NULL                /*!< No ALT_MFP4 PB.10 mask */
N
N//PB.11
N#define SYS_GPB_MFP_PB11_GPIO       0x00000000UL        /*!< GPB_MFP PB.11 setting for GPIO */
N#define SYS_ALT_MFP_PB11_GPIO       NULL                /*!< No ALT_MFP setting for PB.11 */
N#define SYS_ALT_MFP1_PB11_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.11 */
N#define SYS_ALT_MFP2_PB11_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.11 */
N#define SYS_ALT_MFP3_PB11_GPIO      0x00000000UL        /*!< ALT_MFP3 PB.11 setting for GPIO */
N#define SYS_ALT_MFP4_PB11_GPIO      NULL                /*!< No ALT_MFP4 setting for PB.11 */
N
N#define SYS_GPB_MFP_PB11_TM3        (1UL<<11)           /*!< GPB_MFP PB.11 setting for TM3 */
N#define SYS_ALT_MFP_PB11_TM3        NULL                /*!< No ALT_MFP setting for PB.11 */
N#define SYS_ALT_MFP1_PB11_TM3       NULL                /*!< No ALT_MFP1 setting for PB.11 */
N#define SYS_ALT_MFP2_PB11_TM3       NULL                /*!< No ALT_MFP2 setting for PB.11 */
N#define SYS_ALT_MFP3_PB11_TM3       0x00000000UL        /*!< ALT_MFP3 PB.11 setting for TM3 */
N#define SYS_ALT_MFP4_PB11_TM3       NULL                /*!< No ALT_MFP4 setting for PB.11 */
N
N#define SYS_GPB_MFP_PB11_PWM0_CH4   (1UL<<11)           /*!< GPB_MFP PB.11 setting for PWM0_CH4 */
N#define SYS_ALT_MFP_PB11_PWM0_CH4   NULL                /*!< No ALT_MFP setting for PB.11 */
N#define SYS_ALT_MFP1_PB11_PWM0_CH4  NULL                /*!< No ALT_MFP1 setting for PB.11 */
N#define SYS_ALT_MFP2_PB11_PWM0_CH4  NULL                /*!< No ALT_MFP2 setting for PB.11 */
N#define SYS_ALT_MFP3_PB11_PWM0_CH4  (1UL<<24)           /*!< ALT_MFP3 PB.11 setting for PWM0_CH4 */
N#define SYS_ALT_MFP4_PB11_PWM0_CH4  NULL                /*!< No ALT_MFP4 setting for PB.11 */
N
N#define SYS_GPB_MFP_PB11_Msk        (1UL<<11)           /*!< GPB_MFP PB.11 mask */
N#define SYS_ALT_MFP_PB11_Msk        NULL                /*!< No ALT_MFP PB.11 mask */
N#define SYS_ALT_MFP1_PB11_Msk       NULL                /*!< No ALT_MFP1 PB.11 mask */
N#define SYS_ALT_MFP2_PB11_Msk       NULL                /*!< No ALT_MFP2 PB.11 mask */
N#define SYS_ALT_MFP3_PB11_Msk       (1UL<<24)           /*!< ALT_MFP3 PB.11 mask */
N#define SYS_ALT_MFP4_PB11_Msk       NULL                /*!< No ALT_MFP4 PB.11 mask */
N
N//PB.12
N#define SYS_GPB_MFP_PB12_GPIO       0x00000000UL        /*!< GPB_MFP PB.12 setting for GPIO */
N#define SYS_ALT_MFP_PB12_GPIO       NULL                /*!< No ALT_MFP setting for PB.12 */
N#define SYS_ALT_MFP1_PB12_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.12 */
N#define SYS_ALT_MFP2_PB12_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.12 */
N#define SYS_ALT_MFP3_PB12_GPIO      0x00000000UL        /*!< ALT_MFP3 PB.12 setting for GPIO */
N#define SYS_ALT_MFP4_PB12_GPIO      NULL                /*!< No ALT_MFP4 setting for PB.12 */
N
N#define SYS_GPB_MFP_PB12_CLKO       (1UL<<12)           /*!< GPB_MFP PB.12 setting for CLKO */
N#define SYS_ALT_MFP_PB12_CLKO       NULL                /*!< No ALT_MFP setting for PB.12 */
N#define SYS_ALT_MFP1_PB12_CLKO      NULL                /*!< No ALT_MFP1 setting for PB.12 */
N#define SYS_ALT_MFP2_PB12_CLKO      NULL                /*!< No ALT_MFP2 setting for PB.12 */
N#define SYS_ALT_MFP3_PB12_CLKO      0x00000000UL        /*!< ALT_MFP3 PB.12 setting for CLKO */
N#define SYS_ALT_MFP4_PB12_CLKO      NULL                /*!< No ALT_MFP4 setting for PB.12 */
N
N#define SYS_GPB_MFP_PB12_BPWM1_CH3      (1UL<<12)       /*!< GPB_MFP PB.12 setting for BPWM1_CH3 */
N#define SYS_ALT_MFP_PB12_BPWM1_CH3      NULL            /*!< No ALT_MFP setting for PB.12 */
N#define SYS_ALT_MFP1_PB12_BPWM1_CH3     NULL            /*!< No ALT_MFP1 setting for PB.12 */
N#define SYS_ALT_MFP2_PB12_BPWM1_CH3     NULL            /*!< No ALT_MFP2 setting for PB.12 */
N#define SYS_ALT_MFP3_PB12_BPWM1_CH3     (1UL<<21)       /*!< ALT_MFP3 PB.12 setting for BPWM1_CH3 */
N#define SYS_ALT_MFP4_PB12_BPWM1_CH3     NULL            /*!< No ALT_MFP4 setting for PB.12 */
N
N#define SYS_GPB_MFP_PB12_Msk        (1UL<<12)           /*!< GPB_MFP PB.12 mask */
N#define SYS_ALT_MFP_PB12_Msk        NULL                /*!< No ALT_MFP PB.12 mask */
N#define SYS_ALT_MFP1_PB12_Msk       NULL                /*!< No ALT_MFP1 PB.12 mask */
N#define SYS_ALT_MFP2_PB12_Msk       NULL                /*!< No ALT_MFP2 PB.12 mask */
N#define SYS_ALT_MFP3_PB12_Msk       (1UL<<21)           /*!< ALT_MFP3 PB.12 mask */
N#define SYS_ALT_MFP4_PB12_Msk       NULL                /*!< No ALT_MFP4 PB.12 mask */
N
N//PB.13
N#define SYS_GPB_MFP_PB13_GPIO       0x00000000UL        /*!< GPB_MFP PB.13 setting for GPIO */
N#define SYS_ALT_MFP_PB13_GPIO       NULL                /*!< No ALT_MFP setting for PB.13 */
N#define SYS_ALT_MFP1_PB13_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.13 */
N#define SYS_ALT_MFP2_PB13_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.13 */
N#define SYS_ALT_MFP3_PB13_GPIO      NULL                /*!< No ALT_MFP3 setting for PB.13 */
N#define SYS_ALT_MFP4_PB13_GPIO      NULL                /*!< No ALT_MFP4 setting for PB.13 */
N
N#define SYS_GPB_MFP_PB13_Msk        (1UL<<13)           /*!< GPB_MFP PB.13 mask */
N#define SYS_ALT_MFP_PB13_Msk        NULL                /*!< No ALT_MFP PB.13 mask */
N#define SYS_ALT_MFP1_PB13_Msk       NULL                /*!< No ALT_MFP1 PB.13 mask */
N#define SYS_ALT_MFP2_PB13_Msk       NULL                /*!< No ALT_MFP2 PB.13 mask */
N#define SYS_ALT_MFP3_PB13_Msk       NULL                /*!< No ALT_MFP3 PB.13 mask */
N#define SYS_ALT_MFP4_PB13_Msk       NULL                /*!< No ALT_MFP4 PB.13 mask */
N
N//PB.14
N#define SYS_GPB_MFP_PB14_GPIO       0x00000000UL        /*!< GPB_MFP PB.14 setting for GPIO */
N#define SYS_ALT_MFP_PB14_GPIO       NULL                /*!< No ALT_MFP setting for PB.14 */
N#define SYS_ALT_MFP1_PB14_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.14 */
N#define SYS_ALT_MFP2_PB14_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.14 */
N#define SYS_ALT_MFP3_PB14_GPIO      NULL                /*!< No ALT_MFP3 setting for PB.14 */
N#define SYS_ALT_MFP4_PB14_GPIO      NULL                /*!< No ALT_MFP4 setting for PB.14 */
N
N#define SYS_GPB_MFP_PB14_INT0       (1UL<<14)           /*!< GPB_MFP PB.14 setting for INT0 */
N#define SYS_ALT_MFP_PB14_INT0       NULL                /*!< No ALT_MFP setting for PB.14 */
N#define SYS_ALT_MFP1_PB14_INT0      NULL                /*!< No ALT_MFP1 setting for PB.14 */
N#define SYS_ALT_MFP2_PB14_INT0      NULL                /*!< No ALT_MFP2 setting for PB.14 */
N#define SYS_ALT_MFP3_PB14_INT0      NULL                /*!< No ALT_MFP3 setting for PB.14 */
N#define SYS_ALT_MFP4_PB14_INT0      NULL                /*!< No ALT_MFP4 setting for PB.14 */
N
N#define SYS_GPB_MFP_PB14_Msk        (1UL<<14)           /*!< GPB_MFP PB.14 mask */
N#define SYS_ALT_MFP_PB14_Msk        NULL                /*!< No ALT_MFP PB.14 mask */
N#define SYS_ALT_MFP1_PB14_Msk       NULL                /*!< No ALT_MFP1 PB.14 mask */
N#define SYS_ALT_MFP2_PB14_Msk       NULL                /*!< No ALT_MFP2 PB.14 mask */
N#define SYS_ALT_MFP3_PB14_Msk       NULL                /*!< No ALT_MFP3 PB.14 mask */
N#define SYS_ALT_MFP4_PB14_Msk       NULL                /*!< No ALT_MFP4 PB.14 mask */
N
N//PB.15
N#define SYS_GPB_MFP_PB15_GPIO       0x00000000UL        /*!< GPB_MFP PB.15 setting for GPIO */
N#define SYS_ALT_MFP_PB15_GPIO       0x00000000UL        /*!< ALT_MFP PB.15 setting for GPIO */
N#define SYS_ALT_MFP1_PB15_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_GPIO      0x00000000UL        /*!< ALT_MFP2 PB.15 setting for GPIO */
N#define SYS_ALT_MFP3_PB15_GPIO      0x00000000UL        /*!< ALT_MFP3 PB.15 setting for GPIO */
N#define SYS_ALT_MFP4_PB15_GPIO      NULL                /*!< No ALT_MFP4 setting for PB.15 */
N
N#define SYS_GPB_MFP_PB15_INT1       (1UL<<15)           /*!< GPB_MFP PB.15 setting for INT1 */
N#define SYS_ALT_MFP_PB15_INT1       0x00000000UL        /*!< ALT_MFP PB.15 setting for INT1 */
N#define SYS_ALT_MFP1_PB15_INT1      NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_INT1      0x00000000UL        /*!< ALT_MFP2 PB.15 setting for INT1 */
N#define SYS_ALT_MFP3_PB15_INT1      0x00000000UL        /*!< ALT_MFP3 PB.15 setting for INT1 */
N#define SYS_ALT_MFP4_PB15_INT1      NULL                /*!< No ALT_MFP4 setting for PB.15 */
N
N#define SYS_GPB_MFP_PB15_TM0        (1UL<<15)           /*!< GPB_MFP PB.15 setting for TM0 */
N#define SYS_ALT_MFP_PB15_TM0        0x00000000UL        /*!< ALT_MFP PB.15 setting for TM0 */
N#define SYS_ALT_MFP1_PB15_TM0       NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_TM0       (1UL<<2)            /*!< ALT_MFP2 PB.15 setting for TM0 */
N#define SYS_ALT_MFP3_PB15_TM0       0x00000000UL        /*!< ALT_MFP3 PB.15 setting for TM0 */
N#define SYS_ALT_MFP4_PB15_TM0       NULL                /*!< No ALT_MFP4 setting for PB.15 */
N
N#define SYS_GPB_MFP_PB15_TM0_EXT    (1UL<<15)           /*!< GPB_MFP PB.15 setting for TM0_EXT */
N#define SYS_ALT_MFP_PB15_TM0_EXT    (1UL<<24)           /*!< ALT_MFP PB.15 setting for TM0_EXT */
N#define SYS_ALT_MFP1_PB15_TM0_EXT   NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_TM0_EXT   0x00000000UL        /*!< ALT_MFP2 PB.15 setting for TM0_EXT */
N#define SYS_ALT_MFP3_PB15_TM0_EXT   0x00000000UL        /*!< ALT_MFP3 PB.15 setting for TM0_EXT */
N#define SYS_ALT_MFP4_PB15_TM0_EXT   NULL                /*!< No ALT_MFP4 setting for PB.15 */
N
N#define SYS_GPB_MFP_PB15_BPWM1_CH5      (1UL<<15)       /*!< GPB_MFP PB.15 setting for BPWM1_CH5 */
N#define SYS_ALT_MFP_PB15_BPWM1_CH5      0x00000000UL    /*!< ALT_MFP PB.15 setting for BPWM1_CH5 */
N#define SYS_ALT_MFP1_PB15_BPWM1_CH5     NULL            /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_BPWM1_CH5     (1UL<<2)        /*!< ALT_MFP2 PB.15 setting for BPWM1_CH5 */
N#define SYS_ALT_MFP3_PB15_BPWM1_CH5     (1UL<<23)       /*!< ALT_MFP3 PB.15 setting for BPWM1_CH5 */
N#define SYS_ALT_MFP4_PB15_BPWM1_CH5     NULL            /*!< No ALT_MFP4 setting for PB.15 */
N
N#define SYS_GPB_MFP_PB15_Msk        (1UL<<15)           /*!< GPB_MFP PB.15 mask */
N#define SYS_ALT_MFP_PB15_Msk        (1UL<<24)           /*!< ALT_MFP PB.15 mask */
N#define SYS_ALT_MFP1_PB15_Msk       NULL                /*!< No ALT_MFP1 PB.15 mask */
N#define SYS_ALT_MFP2_PB15_Msk       (1UL<<2)            /*!< ALT_MFP2 PB.15 mask */
N#define SYS_ALT_MFP3_PB15_Msk       (1UL<<23)           /*!< ALT_MFP3 PB.15 mask */
N#define SYS_ALT_MFP4_PB15_Msk       NULL                /*!< No ALT_MFP4 PB.15 mask */
N
N//PC.0
N#define SYS_GPC_MFP_PC0_GPIO        0x00000000UL        /*!< GPC_MFP PC.0 setting for GPIO */
N#define SYS_ALT_MFP_PC0_GPIO        NULL                /*!< No ALT_MFP setting for PC.0 */
N#define SYS_ALT_MFP1_PC0_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.0 */
N#define SYS_ALT_MFP3_PC0_GPIO       0x00000000UL        /*!< ALT_MFP3 PC.0 setting for GPIO */
N#define SYS_ALT_MFP4_PC0_GPIO       NULL                /*!< No ALT_MFP4 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_SPI0_SS0    (1UL<<0)            /*!< GPC_MFP PC.0 setting for SPI0_SS0 */
N#define SYS_ALT_MFP_PC0_SPI0_SS0    NULL                /*!< No ALT_MFP setting for PC.0 */
N#define SYS_ALT_MFP1_PC0_SPI0_SS0   NULL                /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_SPI0_SS0   NULL                /*!< No ALT_MFP2 setting for PC.0 */
N#define SYS_ALT_MFP3_PC0_SPI0_SS0   0x00000000UL        /*!< ALT_MFP3 PC.0 setting for SPI0_SS0 */
N#define SYS_ALT_MFP4_PC0_SPI0_SS0   NULL                /*!< No ALT_MFP4 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_BPWM0_CH0       (1UL<<0)        /*!< GPC_MFP PC.0 setting for BPWM0_CH0 */
N#define SYS_ALT_MFP_PC0_BPWM0_CH0       NULL            /*!< No ALT_MFP setting for PC.0 */
N#define SYS_ALT_MFP1_PC0_BPWM0_CH0      NULL            /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_BPWM0_CH0      NULL            /*!< No ALT_MFP2 setting for PC.0 */
N#define SYS_ALT_MFP3_PC0_BPWM0_CH0      (1UL<<12)       /*!< ALT_MFP3 PC.0 setting for BPWM0_CH0 */
N#define SYS_ALT_MFP4_PC0_BPWM0_CH0      NULL            /*!< No ALT_MFP4 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_Msk         (1UL<<0)            /*!< GPC_MFP PC.0 mask */
N#define SYS_ALT_MFP_PC0_Msk         NULL                /*!< No ALT_MFP PC.0 mask */
N#define SYS_ALT_MFP1_PC0_Msk        NULL                /*!< No ALT_MFP1 PC.0 mask */
N#define SYS_ALT_MFP2_PC0_Msk        NULL                /*!< No ALT_MFP2 PC.0 mask */
N#define SYS_ALT_MFP3_PC0_Msk        (1UL<<12)           /*!< ALT_MFP3 PC.0 mask */
N#define SYS_ALT_MFP4_PC0_Msk        NULL                /*!< No ALT_MFP4 PC.0 mask */
N
N//PC.1
N#define SYS_GPC_MFP_PC1_GPIO        0x00000000UL        /*!< GPC_MFP PC.1 setting for GPIO */
N#define SYS_ALT_MFP_PC1_GPIO        NULL                /*!< No ALT_MFP setting for PC.1 */
N#define SYS_ALT_MFP1_PC1_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.1 */
N#define SYS_ALT_MFP3_PC1_GPIO       0x00000000UL        /*!< ALT_MFP3 PC.1 setting for GPIO */
N#define SYS_ALT_MFP4_PC1_GPIO       NULL                /*!< No ALT_MFP4 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_SPI0_CLK        (1UL<<1)        /*!< GPC_MFP PC.1 setting for SPI0_CLK */
N#define SYS_ALT_MFP_PC1_SPI0_CLK        NULL            /*!< No ALT_MFP setting for PC.1 */
N#define SYS_ALT_MFP1_PC1_SPI0_CLK       NULL            /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_SPI0_CLK       NULL            /*!< No ALT_MFP2 setting for PC.1 */
N#define SYS_ALT_MFP3_PC1_SPI0_CLK       0x00000000UL    /*!< ALT_MFP3 PC.1 setting for SPI0_CLK */
N#define SYS_ALT_MFP4_PC1_SPI0_CLK       NULL            /*!< No ALT_MFP4 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_BPWM0_CH1       (1UL<<1)        /*!< GPC_MFP PC.1 setting for BPWM0_CH1 */
N#define SYS_ALT_MFP_PC1_BPWM0_CH1       NULL            /*!< No ALT_MFP setting for PC.1 */
N#define SYS_ALT_MFP1_PC1_BPWM0_CH1      NULL            /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_BPWM0_CH1      NULL            /*!< No ALT_MFP2 setting for PC.1 */
N#define SYS_ALT_MFP3_PC1_BPWM0_CH1      (1UL<<13)       /*!< ALT_MFP3 PC.1 setting for BPWM0_CH1 */
N#define SYS_ALT_MFP4_PC1_BPWM0_CH1      NULL            /*!< No ALT_MFP4 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_Msk         (1UL<<1)            /*!< GPC_MFP PC.1 mask */
N#define SYS_ALT_MFP_PC1_Msk         NULL                /*!< No ALT_MFP PC.1 mask */
N#define SYS_ALT_MFP1_PC1_Msk        NULL                /*!< No ALT_MFP1 PC.1 mask */
N#define SYS_ALT_MFP2_PC1_Msk        NULL                /*!< No ALT_MFP2 PC.1 mask */
N#define SYS_ALT_MFP3_PC1_Msk        (1UL<<13)           /*!< ALT_MFP3 PC.1 mask */
N#define SYS_ALT_MFP4_PC1_Msk        NULL                /*!< No ALT_MFP4 PC.1 mask */
N
N//PC.2
N#define SYS_GPC_MFP_PC2_GPIO        0x00000000UL        /*!< GPC_MFP PC.2 setting for GPIO */
N#define SYS_ALT_MFP_PC2_GPIO        NULL                /*!< No ALT_MFP setting for PC.2 */
N#define SYS_ALT_MFP1_PC2_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.2 */
N#define SYS_ALT_MFP3_PC2_GPIO       0x00000000UL        /*!< ALT_MFP3 PC.2 setting for GPIO */
N#define SYS_ALT_MFP4_PC2_GPIO       NULL                /*!< No ALT_MFP4 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_SPI0_MISO0      (1UL<<2)        /*!< GPC_MFP PC.2 setting for SPI0_MISO0 */
N#define SYS_ALT_MFP_PC2_SPI0_MISO0      NULL            /*!< No ALT_MFP setting for PC.2 */
N#define SYS_ALT_MFP1_PC2_SPI0_MISO0     NULL            /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_SPI0_MISO0     NULL            /*!< No ALT_MFP2 setting for PC.2 */
N#define SYS_ALT_MFP3_PC2_SPI0_MISO0     0x00000000UL    /*!< ALT_MFP3 PC.2 setting for SPI0_MISO0 */
N#define SYS_ALT_MFP4_PC2_SPI0_MISO0     NULL            /*!< No ALT_MFP4 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_BPWM0_CH2   (1UL<<2)            /*!< GPC_MFP PC.2 setting for BPWM0_CH2 */
N#define SYS_ALT_MFP_PC2_BPWM0_CH2   NULL                /*!< No ALT_MFP setting for PC.2 */
N#define SYS_ALT_MFP1_PC2_BPWM0_CH2  NULL                /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_BPWM0_CH2  NULL                /*!< No ALT_MFP2 setting for PC.2 */
N#define SYS_ALT_MFP3_PC2_BPWM0_CH2  (1UL<<14)           /*!< ALT_MFP3 PC.2 setting for BPWM0_CH2 */
N#define SYS_ALT_MFP4_PC2_BPWM0_CH2  NULL                /*!< No ALT_MFP4 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_Msk         (1UL<<2)            /*!< GPC_MFP PC.2 mask */
N#define SYS_ALT_MFP_PC2_Msk         NULL                /*!< No ALT_MFP PC.2 mask */
N#define SYS_ALT_MFP1_PC2_Msk        NULL                /*!< No ALT_MFP1 PC.2 mask */
N#define SYS_ALT_MFP2_PC2_Msk        NULL                /*!< No ALT_MFP2 PC.2 mask */
N#define SYS_ALT_MFP3_PC2_Msk        (1UL<<14)           /*!< ALT_MFP3 PC.2 mask */
N#define SYS_ALT_MFP4_PC2_Msk        NULL                /*!< No ALT_MFP4 PC.2 mask */
N
N//PC.3
N#define SYS_GPC_MFP_PC3_GPIO        0x00000000UL        /*!< GPC_MFP PC.3 setting for GPIO */
N#define SYS_ALT_MFP_PC3_GPIO        NULL                /*!< No ALT_MFP setting for PC.3 */
N#define SYS_ALT_MFP1_PC3_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.3 */
N#define SYS_ALT_MFP3_PC3_GPIO       0x00000000UL        /*!< ALT_MFP3 PC.3 setting for GPIO */
N#define SYS_ALT_MFP4_PC3_GPIO       NULL                /*!< No ALT_MFP4 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_SPI0_MOSI0      (1UL<<3)        /*!< GPC_MFP PC.3 setting for SPI0_MOSI0 */
N#define SYS_ALT_MFP_PC3_SPI0_MOSI0      NULL            /*!< No ALT_MFP setting for PC.3 */
N#define SYS_ALT_MFP1_PC3_SPI0_MOSI0     NULL            /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_SPI0_MOSI0     NULL            /*!< No ALT_MFP2 setting for PC.3 */
N#define SYS_ALT_MFP3_PC3_SPI0_MOSI0     0x00000000UL    /*!< ALT_MFP3 PC.3 setting for SPI0_MOSI0 */
N#define SYS_ALT_MFP4_PC3_SPI0_MOSI0     NULL            /*!< No ALT_MFP4 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_BPWM0_CH3   (1UL<<3)            /*!< GPC_MFP PC.3 setting for BPWM0_CH3 */
N#define SYS_ALT_MFP_PC3_BPWM0_CH3   NULL                /*!< No ALT_MFP setting for PC.3 */
N#define SYS_ALT_MFP1_PC3_BPWM0_CH3  NULL                /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_BPWM0_CH3  NULL                /*!< No ALT_MFP2 setting for PC.3 */
N#define SYS_ALT_MFP3_PC3_BPWM0_CH3  (1UL<<15)           /*!< ALT_MFP3 PC.3 setting for BPWM0_CH3 */
N#define SYS_ALT_MFP4_PC3_BPWM0_CH3  NULL                /*!< No ALT_MFP4 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_Msk         (1UL<<3)            /*!< GPC_MFP PC.3 mask */
N#define SYS_ALT_MFP_PC3_Msk         NULL                /*!< No ALT_MFP PC.3 mask */
N#define SYS_ALT_MFP1_PC3_Msk        NULL                /*!< No ALT_MFP1 PC.3 mask */
N#define SYS_ALT_MFP2_PC3_Msk        NULL                /*!< No ALT_MFP2 PC.3 mask */
N#define SYS_ALT_MFP3_PC3_Msk        (1UL<<15)           /*!< ALT_MFP3 PC.3 mask */
N#define SYS_ALT_MFP4_PC3_Msk        NULL                /*!< No ALT_MFP4 PC.3 mask */
N
N//PC.6
N#define SYS_GPC_MFP_PC6_GPIO        0x00000000UL        /*!< GPC_MFP PC.6 setting for GPIO */
N#define SYS_ALT_MFP_PC6_GPIO        NULL                /*!< No ALT_MFP setting for PC.6 */
N#define SYS_ALT_MFP1_PC6_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.6 */
N#define SYS_ALT_MFP2_PC6_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.6 */
N#define SYS_ALT_MFP3_PC6_GPIO       0x00000000UL        /*!< ALT_MFP3 PC.4 setting for GPIO */
N#define SYS_ALT_MFP4_PC6_GPIO       0x00000000UL        /*!< ALT_MFP4 PC.4 setting for GPIO */
N
N#define SYS_GPC_MFP_PC6_UART4_TXD   (1UL<<6)            /*!< GPC_MFP PC.4 setting for UART6_TXD */
N#define SYS_ALT_MFP_PC6_UART4_TXD   NULL                /*!< No ALT_MFP setting for PC.6 */
N#define SYS_ALT_MFP1_PC6_UART4_TXD  NULL                /*!< No ALT_MFP1 setting for PC.6 */
N#define SYS_ALT_MFP2_PC6_UART4_TXD  NULL                /*!< No ALT_MFP2 setting for PC.6 */
N#define SYS_ALT_MFP3_PC6_UART4_TXD  0x00000000UL        /*!< ALT_MFP3 PC.6 setting for UART4_TXD */
N#define SYS_ALT_MFP4_PC6_UART4_TXD  0x00000000UL        /*!< ALT_MFP4 PC.6 setting for UART4_TXD */
N
N#define SYS_GPC_MFP_PC6_I2C0_SDA    (1UL<<6)            /*!< GPC_MFP PC.6 setting for I2C0_SDA */
N#define SYS_ALT_MFP_PC6_I2C0_SDA    NULL                /*!< No ALT_MFP setting for PC.6 */
N#define SYS_ALT_MFP1_PC6_I2C0_SDA   NULL                /*!< No ALT_MFP1 setting for PC.6 */
N#define SYS_ALT_MFP2_PC6_I2C0_SDA   NULL                /*!< No ALT_MFP2 setting for PC.6 */
N#define SYS_ALT_MFP3_PC6_I2C0_SDA   0x00000000UL        /*!< ALT_MFP3 PC.6 setting for I2C0_SDA */
N#define SYS_ALT_MFP4_PC6_I2C0_SDA   (1UL<<10)           /*!< ALT_MFP4 PC.6 setting for I2C0_SDA */
N
N#define SYS_GPC_MFP_PC6_PWM0_BRAKE0     (1UL<<6)        /*!< GPC_MFP PC.6 setting for PWM0_BRAKE0 */
N#define SYS_ALT_MFP_PC6_PWM0_BRAKE0     NULL            /*!< No ALT_MFP setting for PC.6 */
N#define SYS_ALT_MFP1_PC6_PWM0_BRAKE0    NULL            /*!< No ALT_MFP1 setting for PC.6 */
N#define SYS_ALT_MFP2_PC6_PWM0_BRAKE0    NULL            /*!< No ALT_MFP2 setting for PC.6 */
N#define SYS_ALT_MFP3_PC6_PWM0_BRAKE0    (1UL<<28)       /*!< ALT_MFP3 PC.6 setting for PWM0_BRAKE0 */
N#define SYS_ALT_MFP4_PC6_PWM0_BRAKE0    0x00000000UL    /*!< ALT_MFP4 PC.6 setting for PWM0_BRAKE0 */
N
N#define SYS_GPC_MFP_PC6_Msk         (1UL<<6)            /*!< GPC_MFP PC.6 mask */
N#define SYS_ALT_MFP_PC6_Msk         NULL                /*!< No ALT_MFP PC.6 mask */
N#define SYS_ALT_MFP1_PC6_Msk        NULL                /*!< No ALT_MFP1 PC.6 mask */
N#define SYS_ALT_MFP2_PC6_Msk        NULL                /*!< No ALT_MFP2 PC.6 mask */
N#define SYS_ALT_MFP3_PC6_Msk        (1UL<<28)           /*!< ALT_MFP3 PC.6 mask */
N#define SYS_ALT_MFP4_PC6_Msk        (1UL<<10)           /*!< ALT_MFP4 PC.6 mask */
N
N//PC.7
N#define SYS_GPC_MFP_PC7_GPIO        0x00000000UL        /*!< GPC_MFP PC.7 setting for GPIO */
N#define SYS_ALT_MFP_PC7_GPIO        NULL                /*!< No ALT_MFP setting for PC.7 */
N#define SYS_ALT_MFP1_PC7_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.7 */
N#define SYS_ALT_MFP2_PC7_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.7 */
N#define SYS_ALT_MFP3_PC7_GPIO       0x00000000UL        /*!< ALT_MFP3 PC.7 setting for GPIO */
N#define SYS_ALT_MFP4_PC7_GPIO       0x00000000UL        /*!< ALT_MFP4 PC.7 setting for GPIO */
N
N#define SYS_GPC_MFP_PC7_UART4_RXD   (1UL<<7)            /*!< GPC_MFP PC.7 setting for UART4_RXD */
N#define SYS_ALT_MFP_PC7_UART4_RXD   NULL                /*!< No ALT_MFP setting for PC.7 */
N#define SYS_ALT_MFP1_PC7_UART4_RXD  NULL                /*!< No ALT_MFP1 setting for PC.7 */
N#define SYS_ALT_MFP2_PC7_UART4_RXD  NULL                /*!< No ALT_MFP2 setting for PC.7 */
N#define SYS_ALT_MFP3_PC7_UART4_RXD  0x00000000UL        /*!< ALT_MFP3 PC.7 setting for UART4_RXD */
N#define SYS_ALT_MFP4_PC7_UART4_RXD  0x00000000UL        /*!< ALT_MFP4 PC.7 setting for UART4_RXD */
N
N#define SYS_GPC_MFP_PC7_I2C0_SCL    (1UL<<7)            /*!< GPC_MFP PC.7 setting for I2C0_SCL */
N#define SYS_ALT_MFP_PC7_I2C0_SCL    NULL                /*!< No ALT_MFP setting for PC.7 */
N#define SYS_ALT_MFP1_PC7_I2C0_SCL   NULL                /*!< No ALT_MFP1 setting for PC.7 */
N#define SYS_ALT_MFP2_PC7_I2C0_SCL   NULL                /*!< No ALT_MFP2 setting for PC.7 */
N#define SYS_ALT_MFP3_PC7_I2C0_SCL   0x00000000UL        /*!< ALT_MFP3 PC.7 setting for I2C0_SCL */
N#define SYS_ALT_MFP4_PC7_I2C0_SCL   (1UL<<11)           /*!< ALT_MFP4 PC.7 setting for I2C0_SCL */
N
N#define SYS_GPC_MFP_PC7_PWM0_BRAKE1     (1UL<<7)        /*!< GPC_MFP PC.7 setting for PWM0_BRAKE1 */
N#define SYS_ALT_MFP_PC7_PWM0_BRAKE1     NULL            /*!< No ALT_MFP setting for PC.7 */
N#define SYS_ALT_MFP1_PC7_PWM0_BRAKE1    NULL            /*!< No ALT_MFP1 setting for PC.7 */
N#define SYS_ALT_MFP2_PC7_PWM0_BRAKE1    NULL            /*!< No ALT_MFP2 setting for PC.7 */
N#define SYS_ALT_MFP3_PC7_PWM0_BRAKE1    (1UL<<29)       /*!< ALT_MFP3 PC.7 setting for PWM0_BRAKE1 */
N#define SYS_ALT_MFP4_PC7_PWM0_BRAKE1    0x00000000UL    /*!< ALT_MFP4 PC.7 setting for PWM0_BRAKE1 */
N
N#define SYS_GPC_MFP_PC7_Msk         (1UL<<7)            /*!< GPC_MFP PC.7 mask */
N#define SYS_ALT_MFP_PC7_Msk         NULL                /*!< No ALT_MFP PC.7 mask */
N#define SYS_ALT_MFP1_PC7_Msk        NULL                /*!< No ALT_MFP1 PC.7 mask */
N#define SYS_ALT_MFP2_PC7_Msk        NULL                /*!< No ALT_MFP2 PC.7 mask */
N#define SYS_ALT_MFP3_PC7_Msk        (1UL<<29)           /*!< ALT_MFP3 PC.7 mask */
N#define SYS_ALT_MFP4_PC7_Msk        (1UL<<11)           /*!< ALT_MFP4 PC.7 mask */
N
N//PC.8
N#define SYS_GPC_MFP_PC8_GPIO        0x00000000UL        /*!< GPC_MFP PC.8 setting for GPIO */
N#define SYS_ALT_MFP_PC8_GPIO        NULL                /*!< No ALT_MFP setting for PC.8 */
N#define SYS_ALT_MFP1_PC8_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.8 */
N#define SYS_ALT_MFP2_PC8_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.8 */
N#define SYS_ALT_MFP3_PC8_GPIO       NULL                /*!< No ALT_MFP3 setting for PC.8 */
N#define SYS_ALT_MFP4_PC8_GPIO       NULL                /*!< No ALT_MFP4 setting for PC.8 */
N
N#define SYS_GPC_MFP_PC8_PWM0_BRAKE0     (1UL<<8)        /*!< GPC_MFP PC.8 setting for PWM0_BRAKE0 */
N#define SYS_ALT_MFP_PC8_PWM0_BRAKE0     NULL            /*!< No ALT_MFP setting for PC.8 */
N#define SYS_ALT_MFP1_PC8_PWM0_BRAKE0    NULL            /*!< No ALT_MFP1 setting for PC.8 */
N#define SYS_ALT_MFP2_PC8_PWM0_BRAKE0    NULL            /*!< No ALT_MFP2 setting for PC.8 */
N#define SYS_ALT_MFP3_PC8_PWM0_BRAKE0    NULL            /*!< No ALT_MFP3 setting for PC.8 */
N#define SYS_ALT_MFP4_PC8_PWM0_BRAKE0    NULL            /*!< No ALT_MFP4 setting for PC.8 */
N
N#define SYS_GPC_MFP_PC8_Msk         (1UL<<8)            /*!< GPC_MFP PC.8 mask */
N#define SYS_ALT_MFP_PC8_Msk         NULL                /*!< No ALT_MFP PC.8 mask */
N#define SYS_ALT_MFP1_PC8_Msk        NULL                /*!< No ALT_MFP1 PC.8 mask */
N#define SYS_ALT_MFP2_PC8_Msk        NULL                /*!< No ALT_MFP2 PC.8 mask */
N#define SYS_ALT_MFP3_PC8_Msk        NULL                /*!< No ALT_MFP3 PC.8 mask */
N#define SYS_ALT_MFP4_PC8_Msk        NULL                /*!< No ALT_MFP4 PC.8 mask */
N
N//PC.9
N#define SYS_GPC_MFP_PC9_GPIO        0x00000000UL        /*!< GPC_MFP PC.9 setting for GPIO */
N#define SYS_ALT_MFP_PC9_GPIO        NULL                /*!< No ALT_MFP setting for PC.9 */
N#define SYS_ALT_MFP1_PC9_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.9 */
N#define SYS_ALT_MFP2_PC9_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.9 */
N#define SYS_ALT_MFP3_PC9_GPIO       NULL                /*!< No ALT_MFP3 setting for PC.9 */
N#define SYS_ALT_MFP4_PC9_GPIO       NULL                /*!< No ALT_MFP4 setting for PC.9 */
N
N#define SYS_GPC_MFP_PC9_PWM0_BRAKE1     (1UL<<9)        /*!< GPC_MFP PC.9 setting for PWM0_BRAKE1 */
N#define SYS_ALT_MFP_PC9_PWM0_BRAKE1     NULL            /*!< No ALT_MFP setting for PC.9 */
N#define SYS_ALT_MFP1_PC9_PWM0_BRAKE1    NULL            /*!< No ALT_MFP1 setting for PC.9 */
N#define SYS_ALT_MFP2_PC9_PWM0_BRAKE1    NULL            /*!< No ALT_MFP2 setting for PC.9 */
N#define SYS_ALT_MFP3_PC9_PWM0_BRAKE1    NULL            /*!< No ALT_MFP3 setting for PC.9 */
N#define SYS_ALT_MFP4_PC9_PWM0_BRAKE1    NULL            /*!< No ALT_MFP4 setting for PC.9 */
N
N#define SYS_GPC_MFP_PC9_Msk         (1UL<<9)            /*!< GPC_MFP PC.9 mask */
N#define SYS_ALT_MFP_PC9_Msk         NULL                /*!< No ALT_MFP PC.9 mask */
N#define SYS_ALT_MFP1_PC9_Msk        NULL                /*!< No ALT_MFP1 PC.9 mask */
N#define SYS_ALT_MFP2_PC9_Msk        NULL                /*!< No ALT_MFP2 PC.9 mask */
N#define SYS_ALT_MFP3_PC9_Msk        NULL                /*!< No ALT_MFP3 PC.9 mask */
N#define SYS_ALT_MFP4_PC9_Msk        NULL                /*!< No ALT_MFP4 PC.9 mask */
N
N//PC.10
N#define SYS_GPC_MFP_PC10_GPIO       0x00000000UL        /*!< GPC_MFP PC.10 setting for GPIO */
N#define SYS_ALT_MFP_PC10_GPIO       NULL                /*!< No ALT_MFP setting for PC.10 */
N#define SYS_ALT_MFP1_PC10_GPIO      NULL                /*!< No ALT_MFP1 setting for PC.10 */
N#define SYS_ALT_MFP2_PC10_GPIO      NULL                /*!< No ALT_MFP2 setting for PC.10 */
N#define SYS_ALT_MFP3_PC10_GPIO      NULL                /*!< No ALT_MFP3 setting for PC.10 */
N#define SYS_ALT_MFP4_PC10_GPIO      NULL                /*!< No ALT_MFP4 setting for PC.10 */
N
N#define SYS_GPC_MFP_PC10_PWM1_BRAKE0    (1UL<<10)       /*!< GPC_MFP PC.10 setting for PWM1_BRAKE0 */
N#define SYS_ALT_MFP_PC10_PWM1_BRAKE0    NULL            /*!< No ALT_MFP setting for PC.10 */
N#define SYS_ALT_MFP1_PC10_PWM1_BRAKE0   NULL            /*!< No ALT_MFP1 setting for PC.10 */
N#define SYS_ALT_MFP2_PC10_PWM1_BRAKE0   NULL            /*!< No ALT_MFP2 setting for PC.10 */
N#define SYS_ALT_MFP3_PC10_PWM1_BRAKE0   NULL            /*!< No ALT_MFP3 setting for PC.10 */
N#define SYS_ALT_MFP4_PC10_PWM1_BRAKE0   NULL            /*!< No ALT_MFP4 setting for PC.10 */
N
N#define SYS_GPC_MFP_PC10_Msk        (1UL<<10)           /*!< GPC_MFP PC.10 mask */
N#define SYS_ALT_MFP_PC10_Msk        NULL                /*!< No ALT_MFP PC.10 mask */
N#define SYS_ALT_MFP1_PC10_Msk       NULL                /*!< No ALT_MFP1 PC.10 mask */
N#define SYS_ALT_MFP2_PC10_Msk       NULL                /*!< No ALT_MFP2 PC.10 mask */
N#define SYS_ALT_MFP3_PC10_Msk       NULL                /*!< No ALT_MFP3 PC.10 mask */
N#define SYS_ALT_MFP4_PC10_Msk       NULL                /*!< No ALT_MFP4 PC.10 mask */
N
N//PC.11
N#define SYS_GPC_MFP_PC11_GPIO       0x00000000UL        /*!< GPC_MFP PC.11 setting for GPIO */
N#define SYS_ALT_MFP_PC11_GPIO       NULL                /*!< No ALT_MFP setting for PC.11 */
N#define SYS_ALT_MFP1_PC11_GPIO      NULL                /*!< No ALT_MFP1 setting for PC.11 */
N#define SYS_ALT_MFP2_PC11_GPIO      NULL                /*!< No ALT_MFP2 setting for PC.11 */
N#define SYS_ALT_MFP3_PC11_GPIO      NULL                /*!< No ALT_MFP3 setting for PC.11 */
N#define SYS_ALT_MFP4_PC11_GPIO      NULL                /*!< No ALT_MFP4 setting for PC.11 */
N
N#define SYS_GPC_MFP_PC11_PWM1_BRAKE1    (1UL<<11)       /*!< GPC_MFP PC.11 setting for PWM1_BRAKE1 */
N#define SYS_ALT_MFP_PC11_PWM1_BRAKE1    NULL            /*!< No ALT_MFP setting for PC.11 */
N#define SYS_ALT_MFP1_PC11_PWM1_BRAKE1   NULL            /*!< No ALT_MFP1 setting for PC.11 */
N#define SYS_ALT_MFP2_PC11_PWM1_BRAKE1   NULL            /*!< No ALT_MFP2 setting for PC.11 */
N#define SYS_ALT_MFP3_PC11_PWM1_BRAKE1   NULL            /*!< No ALT_MFP3 setting for PC.11 */
N#define SYS_ALT_MFP4_PC11_PWM1_BRAKE1   NULL            /*!< No ALT_MFP4 setting for PC.11 */
N
N#define SYS_GPC_MFP_PC11_Msk        (1UL<<11)           /*!< GPC_MFP PC.11 mask */
N#define SYS_ALT_MFP_PC11_Msk        NULL                /*!< No ALT_MFP PC.11 mask */
N#define SYS_ALT_MFP1_PC11_Msk       NULL                /*!< No ALT_MFP1 PC.11 mask */
N#define SYS_ALT_MFP2_PC11_Msk       NULL                /*!< No ALT_MFP2 PC.11 mask */
N#define SYS_ALT_MFP3_PC11_Msk       NULL                /*!< No ALT_MFP3 PC.11 mask */
N#define SYS_ALT_MFP4_PC11_Msk       NULL                /*!< No ALT_MFP4 PC.11 mask */
N
N//PD.6
N#define SYS_GPD_MFP_PD6_GPIO        0x00000000UL        /*!< GPD_MFP PD.6 setting for GPIO */
N#define SYS_ALT_MFP_PD6_GPIO        NULL                /*!< No ALT_MFP setting for PD.6 */
N#define SYS_ALT_MFP1_PD6_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.6 */
N#define SYS_ALT_MFP2_PD6_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.6 */
N#define SYS_ALT_MFP3_PD6_GPIO       0x00000000UL        /*!< ALT_MFP3 PD.6 setting for GPIO */
N#define SYS_ALT_MFP4_PD6_GPIO       NULL                /*!< No ALT_MFP4 setting for PD.6 */
N
N#define SYS_GPD_MFP_PD6_CAN0_RXD    (1UL<<6)            /*!< GPD_MFP PD.6 setting for CAN0_RXD */
N#define SYS_ALT_MFP_PD6_CAN0_RXD    NULL                /*!< No ALT_MFP setting for PD.6 */
N#define SYS_ALT_MFP1_PD6_CAN0_RXD   NULL                /*!< No ALT_MFP1 setting for PD.6 */
N#define SYS_ALT_MFP2_PD6_CAN0_RXD   NULL                /*!< No ALT_MFP2 setting for PD.6 */
N#define SYS_ALT_MFP3_PD6_CAN0_RXD   0x00000000UL        /*!< ALT_MFP3 PD.6 setting for CAN0_RXD */
N#define SYS_ALT_MFP4_PD6_CAN0_RXD   NULL                /*!< No ALT_MFP4 setting for PD.6 */
N
N#define SYS_GPD_MFP_PD6_BPWM1_CH1   (1UL<<6)            /*!< GPD_MFP PD.6 setting for BPWM1_CH1 */
N#define SYS_ALT_MFP_PD6_BPWM1_CH1   NULL                /*!< No ALT_MFP setting for PD.6 */
N#define SYS_ALT_MFP1_PD6_BPWM1_CH1  NULL                /*!< No ALT_MFP1 setting for PD.6 */
N#define SYS_ALT_MFP2_PD6_BPWM1_CH1  NULL                /*!< No ALT_MFP2 setting for PD.6 */
N#define SYS_ALT_MFP3_PD6_BPWM1_CH1  (1UL<<19)           /*!< ALT_MFP3 PD.6 setting for BPWM1_CH1 */
N#define SYS_ALT_MFP4_PD6_BPWM1_CH1  NULL                /*!< No ALT_MFP4 setting for PD.6 */
N
N#define SYS_GPD_MFP_PD6_Msk         (1UL<<6)            /*!< GPD_MFP PD.6 mask */
N#define SYS_ALT_MFP_PD6_Msk         NULL                /*!< No ALT_MFP PD.6 mask */
N#define SYS_ALT_MFP1_PD6_Msk        NULL                /*!< No ALT_MFP1 PD.6 mask */
N#define SYS_ALT_MFP2_PD6_Msk        NULL                /*!< No ALT_MFP2 PD.6 mask */
N#define SYS_ALT_MFP3_PD6_Msk        (1UL<<19)           /*!< ALT_MFP3 PD.6 mask */
N#define SYS_ALT_MFP4_PD6_Msk        NULL                /*!< No ALT_MFP4 PD.6 mask */
N
N//PD.7
N#define SYS_GPD_MFP_PD7_GPIO        0x00000000UL        /*!< GPD_MFP PD.7 setting for GPIO */
N#define SYS_ALT_MFP_PD7_GPIO        NULL                /*!< No ALT_MFP setting for PD.7 */
N#define SYS_ALT_MFP1_PD7_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.7 */
N#define SYS_ALT_MFP2_PD7_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.7 */
N#define SYS_ALT_MFP3_PD7_GPIO       0x00000000UL        /*!< ALT_MFP3 PD.7 setting for GPIO */
N#define SYS_ALT_MFP4_PD7_GPIO       NULL                /*!< No ALT_MFP4 setting for PD.7 */
N
N#define SYS_GPD_MFP_PD7_CAN0_TXD    (1UL<<7)            /*!< GPD_MFP PD.7 setting for CAN0_TXD */
N#define SYS_ALT_MFP_PD7_CAN0_TXD    NULL                /*!< No ALT_MFP setting for PD.7 */
N#define SYS_ALT_MFP1_PD7_CAN0_TXD   NULL                /*!< No ALT_MFP1 setting for PD.7 */
N#define SYS_ALT_MFP2_PD7_CAN0_TXD   NULL                /*!< No ALT_MFP2 setting for PD.7 */
N#define SYS_ALT_MFP3_PD7_CAN0_TXD   0x00000000UL        /*!< ALT_MFP3 PD.7 setting for CAN0_TXD */
N#define SYS_ALT_MFP4_PD7_CAN0_TXD   NULL                /*!< No ALT_MFP4 setting for PD.7 */
N
N#define SYS_GPD_MFP_PD7_BPWM1_CH0   (1UL<<7)            /*!< GPD_MFP PD.7 setting for BPWM1_CH0 */
N#define SYS_ALT_MFP_PD7_BPWM1_CH0   NULL                /*!< No ALT_MFP setting for PD.7 */
N#define SYS_ALT_MFP1_PD7_BPWM1_CH0  NULL                /*!< No ALT_MFP1 setting for PD.7 */
N#define SYS_ALT_MFP2_PD7_BPWM1_CH0  NULL                /*!< No ALT_MFP2 setting for PD.7 */
N#define SYS_ALT_MFP3_PD7_BPWM1_CH0  (1UL<<18)           /*!< ALT_MFP3 PD.7 setting for BPWM1_CH0 */
N#define SYS_ALT_MFP4_PD7_BPWM1_CH0  NULL                /*!< No ALT_MFP4 setting for PD.7 */
N
N#define SYS_GPD_MFP_PD7_Msk         (1UL<<7)            /*!< GPD_MFP PD.7 mask */
N#define SYS_ALT_MFP_PD7_Msk         NULL                /*!< No ALT_MFP PD.7 mask */
N#define SYS_ALT_MFP1_PD7_Msk        NULL                /*!< No ALT_MFP1 PD.7 mask */
N#define SYS_ALT_MFP2_PD7_Msk        NULL                /*!< No ALT_MFP2 PD.7 mask */
N#define SYS_ALT_MFP3_PD7_Msk        (1UL<<18)           /*!< ALT_MFP3 PD.7 mask */
N#define SYS_ALT_MFP4_PD7_Msk        NULL                /*!< No ALT_MFP4 PD.7 mask */
N
N//PD.14
N#define SYS_GPD_MFP_PD14_GPIO       0x00000000UL        /*!< GPD_MFP PD.14 setting for GPIO */
N#define SYS_ALT_MFP_PD14_GPIO       NULL                /*!< No ALT_MFP setting for PD.14 */
N#define SYS_ALT_MFP1_PD14_GPIO      NULL                /*!< No ALT_MFP1 setting for PD.14 */
N#define SYS_ALT_MFP2_PD14_GPIO      NULL                /*!< No ALT_MFP2 setting for PD.14 */
N#define SYS_ALT_MFP3_PD14_GPIO      0x00000000UL        /*!< ALT_MFP3 PD.14 setting for GPIO */
N#define SYS_ALT_MFP4_PD14_GPIO      NULL                /*!< No ALT_MFP4 setting for PD.14 */
N
N#define SYS_GPD_MFP_PD14_UART2_RXD      (1UL<<14)       /*!< GPD_MFP PD.14 setting for UART2_RXD */
N#define SYS_ALT_MFP_PD14_UART2_RXD      NULL            /*!< No ALT_MFP setting for PD.14 */
N#define SYS_ALT_MFP1_PD14_UART2_RXD     NULL            /*!< No ALT_MFP1 setting for PD.14 */
N#define SYS_ALT_MFP2_PD14_UART2_RXD     NULL            /*!< No ALT_MFP2 setting for PD.14 */
N#define SYS_ALT_MFP3_PD14_UART2_RXD     0x00000000UL    /*!< ALT_MFP3 PD.14 setting for UART2_RXD */
N#define SYS_ALT_MFP4_PD14_UART2_RXD     NULL            /*!< No ALT_MFP4 setting for PD.14 */
N
N#define SYS_GPD_MFP_PD14_BPWM0_CH5      (1UL<<14)       /*!< GPD_MFP PD.14 setting for BPWM0_CH5 */
N#define SYS_ALT_MFP_PD14_BPWM0_CH5      NULL            /*!< No ALT_MFP setting for PD.14 */
N#define SYS_ALT_MFP1_PD14_BPWM0_CH5     NULL            /*!< No ALT_MFP1 setting for PD.14 */
N#define SYS_ALT_MFP2_PD14_BPWM0_CH5     NULL            /*!< No ALT_MFP2 setting for PD.14 */
N#define SYS_ALT_MFP3_PD14_BPWM0_CH5     (1UL<<17)       /*!< ALT_MFP3 PD.14 setting for BPWM0_CH5 */
N#define SYS_ALT_MFP4_PD14_BPWM0_CH5     NULL            /*!< No ALT_MFP4 setting for PD.14 */
N
N#define SYS_GPD_MFP_PD14_Msk        (1UL<<14)           /*!< GPD_MFP PD.14 mask */
N#define SYS_ALT_MFP_PD14_Msk        NULL                /*!< No ALT_MFP PD.14 mask */
N#define SYS_ALT_MFP1_PD14_Msk       NULL                /*!< No ALT_MFP1 PD.14 mask */
N#define SYS_ALT_MFP2_PD14_Msk       NULL                /*!< No ALT_MFP2 PD.14 mask */
N#define SYS_ALT_MFP3_PD14_Msk       (1UL<<17)           /*!< ALT_MFP3 PD.14 mask */
N#define SYS_ALT_MFP4_PD14_Msk       NULL                /*!< No ALT_MFP4 PD.14 mask */
N
N//PD.15
N#define SYS_GPD_MFP_PD15_GPIO       0x00000000UL        /*!< GPD_MFP PD.15 setting for GPIO */
N#define SYS_ALT_MFP_PD15_GPIO       NULL                /*!< No ALT_MFP setting for PD.15 */
N#define SYS_ALT_MFP1_PD15_GPIO      NULL                /*!< No ALT_MFP1 setting for PD.15 */
N#define SYS_ALT_MFP2_PD15_GPIO      NULL                /*!< No ALT_MFP2 setting for PD.15 */
N#define SYS_ALT_MFP3_PD15_GPIO      0x00000000UL        /*!< ALT_MFP3 PD.15 setting for GPIO */
N#define SYS_ALT_MFP4_PD15_GPIO      NULL                /*!< No ALT_MFP4 setting for PD.15 */
N
N#define SYS_GPD_MFP_PD15_UART2_TXD      (1UL<<15)       /*!< GPD_MFP PD.15 setting for UART2_TXD */
N#define SYS_ALT_MFP_PD15_UART2_TXD      NULL            /*!< No ALT_MFP setting for PD.15 */
N#define SYS_ALT_MFP1_PD15_UART2_TXD     NULL            /*!< No ALT_MFP1 setting for PD.15 */
N#define SYS_ALT_MFP2_PD15_UART2_TXD     NULL            /*!< No ALT_MFP2 setting for PD.15 */
N#define SYS_ALT_MFP3_PD15_UART2_TXD     0x00000000UL    /*!< ALT_MFP3 PD.15 setting for UART2_TXD */
N#define SYS_ALT_MFP4_PD15_UART2_TXD     NULL            /*!< No ALT_MFP4 setting for PD.15 */
N
N#define SYS_GPD_MFP_PD15_BPWM0_CH4      (1UL<<15)       /*!< GPD_MFP PD.15 setting for BPWM0_CH4 */
N#define SYS_ALT_MFP_PD15_BPWM0_CH4      NULL            /*!< No ALT_MFP setting for PD.15 */
N#define SYS_ALT_MFP1_PD15_BPWM0_CH4     NULL            /*!< No ALT_MFP1 setting for PD.15 */
N#define SYS_ALT_MFP2_PD15_BPWM0_CH4     NULL            /*!< No ALT_MFP2 setting for PD.15 */
N#define SYS_ALT_MFP3_PD15_BPWM0_CH4     (1UL<<16)       /*!< ALT_MFP3 PD.15 setting for BPWM0_CH4 */
N#define SYS_ALT_MFP4_PD15_BPWM0_CH4     NULL            /*!< No ALT_MFP4 setting for PD.15 */
N
N#define SYS_GPD_MFP_PD15_Msk        (1UL<<15)           /*!< GPD_MFP PD.15 mask */
N#define SYS_ALT_MFP_PD15_Msk        NULL                /*!< No ALT_MFP PD.15 mask */
N#define SYS_ALT_MFP1_PD15_Msk        NULL               /*!< No ALT_MFP1 PD.15 mask */
N#define SYS_ALT_MFP2_PD15_Msk       NULL                /*!< No ALT_MFP2 PD.15 mask */
N#define SYS_ALT_MFP3_PD15_Msk       (1UL<<16)           /*!< ALT_MFP3 PD.15 mask */
N#define SYS_ALT_MFP4_PD15_Msk       NULL                /*!< No ALT_MFP4 PD.15 mask */
N
N//PE.5
N#define SYS_GPE_MFP_PE5_GPIO        0x00000000UL        /*!< GPE_MFP PE.5 setting for GPIO */
N#define SYS_ALT_MFP_PE5_GPIO        0x00000000UL        /*!< ALT_MFP PE.5 setting for GPIO */
N#define SYS_ALT_MFP1_PE5_GPIO       NULL                /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_GPIO       0x00000000UL        /*!< ALT_MFP2 PE.5 setting for GPIO */
N#define SYS_ALT_MFP3_PE5_GPIO       NULL                /*!< No ALT_MFP3 setting for PE.5 */
N#define SYS_ALT_MFP4_PE5_GPIO       NULL                /*!< No ALT_MFP4 setting for PE.5 */
N
N#define SYS_GPE_MFP_PE5_PWM0_CH5    (1UL<<5)            /*!< GPE_MFP PE.5 setting for PWM0_CH5 */
N#define SYS_ALT_MFP_PE5_PWM0_CH5    0x00000000UL        /*!< ALT_MFP PE.5 setting for PWM0_CH5 */
N#define SYS_ALT_MFP1_PE5_PWM0_CH5   NULL                /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_PWM0_CH5   0x00000000UL        /*!< ALT_MFP2 PE.5 setting for PWM0_CH5 */
N#define SYS_ALT_MFP3_PE5_PWM0_CH5   NULL                /*!< No ALT_MFP3 setting for PE.5 */
N#define SYS_ALT_MFP4_PE5_PWM0_CH5   NULL                /*!< No ALT_MFP4 setting for PE.5 */
N
N#define SYS_GPE_MFP_PE5_TM1         (1UL<<5)            /*!< GPE_MFP PE.5 setting for TM1 */
N#define SYS_ALT_MFP_PE5_TM1         0x00000000UL        /*!< ALT_MFP PE.5 setting for TM1 */
N#define SYS_ALT_MFP1_PE5_TM1        NULL                /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_TM1        (1UL<<3)            /*!< ALT_MFP2 PE.5 setting for TM1 */
N#define SYS_ALT_MFP3_PE5_TM1        NULL                /*!< No ALT_MFP3 setting for PE.5 */
N#define SYS_ALT_MFP4_PE5_TM1        NULL                /*!< No ALT_MFP4 setting for PE.5 */
N
N#define SYS_GPE_MFP_PE5_TM1_EXT     (1UL<<5)            /*!< GPE_MFP PE.5 setting for TM1_EXT */
N#define SYS_ALT_MFP_PE5_TM1_EXT     (1UL<<25)           /*!< ALT_MFP PE.5 setting for TM1_EXT */
N#define SYS_ALT_MFP1_PE5_TM1_EXT    NULL                /*!< No ALT_MFP1 setting for PE.5_EXT */
N#define SYS_ALT_MFP2_PE5_TM1_EXT    0x00000000UL        /*!< ALT_MFP2 PE.5 setting for TM1_EXT */
N#define SYS_ALT_MFP3_PE5_TM1_EXT    NULL                /*!< No ALT_MFP3 setting for PE.5 */
N#define SYS_ALT_MFP4_PE5_TM1_EXT    NULL                /*!< No ALT_MFP4 setting for PE.5 */
N
N#define SYS_GPE_MFP_PE5_Msk         (1UL<<5)            /*!< GPE_MFP PE.5 mask */
N#define SYS_ALT_MFP_PE5_Msk         (1UL<<25)           /*!< ALT_MFP PE.5 mask */
N#define SYS_ALT_MFP1_PE5_Msk        NULL                /*!< No ALT_MFP1 PE.5 mask */
N#define SYS_ALT_MFP2_PE5_Msk        (1UL<<3)            /*!< ALT_MFP2 PE.5 mask */
N#define SYS_ALT_MFP3_PE5_Msk        NULL                /*!< No ALT_MFP3 PE.5 mask */
N#define SYS_ALT_MFP4_PE5_Msk        NULL                /*!< No ALT_MFP4 PE.5 mask */
N
N//PF.0
N#define SYS_GPF_MFP_PF0_GPIO        0x00000000UL        /*!< GPF_MFP PF.0 setting for GPIO */
N#define SYS_ALT_MFP_PF0_GPIO        NULL                /*!< No ALT_MFP setting for PF.0 */
N#define SYS_ALT_MFP1_PF0_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.0 */
N#define SYS_ALT_MFP2_PF0_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.0 */
N#define SYS_ALT_MFP3_PF0_GPIO       NULL                /*!< No ALT_MFP3 setting for PF.0 */
N#define SYS_ALT_MFP4_PF0_GPIO       NULL                /*!< No ALT_MFP4 setting for PF.0 */
N
N#define SYS_GPF_MFP_PF0_XT1_OUT     (1UL<<0)            /*!< GPF_MFP PF.0 setting for XT1_OUT */
N#define SYS_ALT_MFP_PF0_XT1_OUT     NULL                /*!< No ALT_MFP setting for PF.0 */
N#define SYS_ALT_MFP1_PF0_XT1_OUT    NULL                /*!< No ALT_MFP1 setting for PF.0 */
N#define SYS_ALT_MFP2_PF0_XT1_OUT    NULL                /*!< No ALT_MFP2 setting for PF.0 */
N#define SYS_ALT_MFP3_PF0_XT1_OUT    NULL                /*!< No ALT_MFP3 setting for PF.0 */
N#define SYS_ALT_MFP4_PF0_XT1_OUT    NULL                /*!< No ALT_MFP4 setting for PF.0 */
N
N#define SYS_GPF_MFP_PF0_Msk         (1UL<<0)            /*!< GPE_MFP PF.0 mask */
N#define SYS_ALT_MFP_PF0_Msk         NULL                /*!< No ALT_MFP PF.0 mask */
N#define SYS_ALT_MFP1_PF0_Msk        NULL                /*!< No ALT_MFP1 PF.0 mask */
N#define SYS_ALT_MFP2_PF0_Msk        NULL                /*!< No ALT_MFP2 PF.0 mask */
N#define SYS_ALT_MFP3_PF0_Msk        NULL                /*!< No ALT_MFP3 PF.0 mask */
N#define SYS_ALT_MFP4_PF0_Msk        NULL                /*!< No ALT_MFP4 PF.0 mask */
N
N//PF.1
N#define SYS_GPF_MFP_PF1_GPIO        0x00000000UL        /*!< GPF_MFP PF.1 setting for GPIO */
N#define SYS_ALT_MFP_PF1_GPIO        NULL                /*!< No ALT_MFP setting for PF.1 */
N#define SYS_ALT_MFP1_PF1_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.1 */
N#define SYS_ALT_MFP2_PF1_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.1 */
N#define SYS_ALT_MFP3_PF1_GPIO       NULL                /*!< No ALT_MFP3 setting for PF.1 */
N#define SYS_ALT_MFP4_PF1_GPIO       NULL                /*!< No ALT_MFP4 setting for PF.1 */
N
N#define SYS_GPF_MFP_PF1_XT1_IN      (1UL<<1)            /*!< GPF_MFP PF.1 setting for XT1_IN */
N#define SYS_ALT_MFP_PF1_XT1_IN      NULL                /*!< No ALT_MFP setting for PF.1 */
N#define SYS_ALT_MFP1_PF1_XT1_IN     NULL                /*!< No ALT_MFP1 setting for PF.1 */
N#define SYS_ALT_MFP2_PF1_XT1_IN     NULL                /*!< No ALT_MFP2 setting for PF.1 */
N#define SYS_ALT_MFP3_PF1_XT1_IN     NULL                /*!< No ALT_MFP3 setting for PF.1 */
N#define SYS_ALT_MFP4_PF1_XT1_IN     NULL                /*!< No ALT_MFP4 setting for PF.1 */
N
N#define SYS_GPF_MFP_PF1_Msk         (1UL<<1)            /*!< GPE_MFP PF.1 mask */
N#define SYS_ALT_MFP_PF1_Msk         NULL                /*!< No ALT_MFP PF.1 mask */
N#define SYS_ALT_MFP1_PF1_Msk        NULL                /*!< No ALT_MFP1 PF.1 mask */
N#define SYS_ALT_MFP2_PF1_Msk        NULL                /*!< No ALT_MFP2 PF.1 mask */
N#define SYS_ALT_MFP3_PF1_Msk        NULL                /*!< No ALT_MFP3 PF.1 mask */
N#define SYS_ALT_MFP4_PF1_Msk        NULL                /*!< No ALT_MFP4 PF.1 mask */
N
N//PF.4
N#define SYS_GPF_MFP_PF4_GPIO        0x00000000UL        /*!< GPF_MFP PF.4 setting for GPIO */
N#define SYS_ALT_MFP_PF4_GPIO        NULL                /*!< No ALT_MFP setting for PF.4 */
N#define SYS_ALT_MFP1_PF4_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.4 */
N#define SYS_ALT_MFP2_PF4_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.4 */
N#define SYS_ALT_MFP3_PF4_GPIO       0x00000000UL        /*!< ALT_MFP3 PF.4 setting for GPIO */
N#define SYS_ALT_MFP4_PF4_GPIO       NULL                /*!< No ALT_MFP4 setting for PF.4 */
N
N#define SYS_GPF_MFP_PF4_I2C0_SDA    (1UL<<4)            /*!< GPF_MFP PF.4 setting for I2C0_SDA */
N#define SYS_ALT_MFP_PF4_I2C0_SDA    NULL                /*!< No ALT_MFP setting for PF.4 */
N#define SYS_ALT_MFP1_PF4_I2C0_SDA   NULL                /*!< No ALT_MFP1 setting for PF.4 */
N#define SYS_ALT_MFP2_PF4_I2C0_SDA   NULL                /*!< No ALT_MFP2 setting for PF.4 */
N#define SYS_ALT_MFP3_PF4_I2C0_SDA   0x00000000UL        /*!< ALT_MFP3 PF.4 setting for I2C0_SDA */
N#define SYS_ALT_MFP4_PF4_I2C0_SDA   NULL                /*!< No ALT_MFP4 setting for PF.4 */
N
N#define SYS_GPF_MFP_PF4_PWM1_CH4    (1UL<<4)            /*!< GPF_MFP PF.4 setting for PWM1_CH4 */
N#define SYS_ALT_MFP_PF4_PWM1_CH4    NULL                /*!< No ALT_MFP setting for PF.4 */
N#define SYS_ALT_MFP1_PF4_PWM1_CH4   NULL                /*!< No ALT_MFP1 setting for PF.4 */
N#define SYS_ALT_MFP2_PF4_PWM1_CH4   NULL                /*!< No ALT_MFP2 setting for PF.4 */
N#define SYS_ALT_MFP3_PF4_PWM1_CH4   (1UL<<10)           /*!< ALT_MFP3 PF.4 setting for PWM1_CH4 */
N#define SYS_ALT_MFP4_PF4_PWM1_CH4   NULL                /*!< No ALT_MFP4 setting for PF.4 */
N
N#define SYS_GPF_MFP_PF4_Msk         (1UL<<4)            /*!< GPF_MFP PF.4 mask */
N#define SYS_ALT_MFP_PF4_Msk         NULL                /*!< No ALT_MFP PF.4 mask */
N#define SYS_ALT_MFP1_PF4_Msk        NULL                /*!< No ALT_MFP1 PF.4 mask */
N#define SYS_ALT_MFP2_PF4_Msk        NULL                /*!< No ALT_MFP2 PF.4 mask */
N#define SYS_ALT_MFP3_PF4_Msk        (1UL<<10)           /*!< ALT_MFP3 PF.4 mask */
N#define SYS_ALT_MFP4_PF4_Msk        NULL                /*!< No ALT_MFP4 PF.4 mask */
N
N//PF.5
N#define SYS_GPF_MFP_PF5_GPIO        0x00000000UL        /*!< GPF_MFP PF.5 setting for GPIO */
N#define SYS_ALT_MFP_PF5_GPIO        NULL                /*!< No ALT_MFP setting for PF.5 */
N#define SYS_ALT_MFP1_PF5_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.5 */
N#define SYS_ALT_MFP2_PF5_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.5 */
N#define SYS_ALT_MFP3_PF5_GPIO       0x00000000UL        /*!< ALT_MFP3 PF.5 setting for GPIO */
N#define SYS_ALT_MFP4_PF5_GPIO       NULL                /*!< No ALT_MFP4 setting for PF.5 */
N
N#define SYS_GPF_MFP_PF5_I2C0_SCL    (1UL<<5)            /*!< GPF_MFP PF.5 setting for I2C0_SCL */
N#define SYS_ALT_MFP_PF5_I2C0_SCL    NULL                /*!< No ALT_MFP setting for PF.5 */
N#define SYS_ALT_MFP1_PF5_I2C0_SCL   NULL                /*!< No ALT_MFP1 setting for PF.5 */
N#define SYS_ALT_MFP2_PF5_I2C0_SCL   NULL                /*!< No ALT_MFP2 setting for PF.5 */
N#define SYS_ALT_MFP3_PF5_I2C0_SCL   0x00000000UL        /*!< ALT_MFP3 PF.5 setting for I2C0_SCL */
N#define SYS_ALT_MFP4_PF5_I2C0_SCL   NULL                /*!< No ALT_MFP4 setting for PF.5 */
N
N#define SYS_GPF_MFP_PF5_PWM1_CH5    (1UL<<5)            /*!< GPF_MFP PF.5 setting for PWM1_CH5 */
N#define SYS_ALT_MFP_PF5_PWM1_CH5    NULL                /*!< No ALT_MFP setting for PF.6 */
N#define SYS_ALT_MFP1_PF5_PWM1_CH5   NULL                /*!< No ALT_MFP1 setting for PF.5 */
N#define SYS_ALT_MFP2_PF5_PWM1_CH5   NULL                /*!< No ALT_MFP2 setting for PF.5 */
N#define SYS_ALT_MFP3_PF5_PWM1_CH5   (1UL<<11)           /*!< ALT_MFP3 PF.5 setting for PWM1_CH5 */
N#define SYS_ALT_MFP4_PF5_PWM1_CH5   NULL                /*!< No ALT_MFP4 setting for PF.5 */
N
N#define SYS_GPF_MFP_PF5_Msk         (1UL<<5)            /*!< GPF_MFP PF.5 mask */
N#define SYS_ALT_MFP_PF5_Msk         NULL                /*!< No ALT_MFP PF.5 mask */
N#define SYS_ALT_MFP1_PF5_Msk        NULL                /*!< No ALT_MFP1 PF.5 mask */
N#define SYS_ALT_MFP2_PF5_Msk        NULL                /*!< No ALT_MFP2 PF.5 mask */
N#define SYS_ALT_MFP3_PF5_Msk        (1UL<<11)           /*!< ALT_MFP3 PF.5 mask */
N#define SYS_ALT_MFP4_PF5_Msk        NULL                /*!< No ALT_MFP4 PF.5 mask */
N
N//PF.6
N#define SYS_GPF_MFP_PF6_GPIO        0x00000000UL        /*!< GPF_MFP PF.6 setting for GPIO */
N#define SYS_ALT_MFP_PF6_GPIO        NULL                /*!< No ALT_MFP setting for PF.6 */
N#define SYS_ALT_MFP1_PF6_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.6 */
N#define SYS_ALT_MFP2_PF6_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.6 */
N#define SYS_ALT_MFP3_PF6_GPIO       NULL                /*!< No ALT_MFP3 setting for PF.6 */
N#define SYS_ALT_MFP4_PF6_GPIO       NULL                /*!< No ALT_MFP4 setting for PF.6 */
N
N#define SYS_GPF_MFP_PF6_ICE_CLK     (1UL<<6)            /*!< GPF_MFP PF.6 setting for ICE_CLK */
N#define SYS_ALT_MFP_PF6_ICE_CLK     NULL                /*!< No ALT_MFP setting for PF.6 */
N#define SYS_ALT_MFP1_PF6_ICE_CLK    NULL                /*!< No ALT_MFP1 setting for PF.6 */
N#define SYS_ALT_MFP2_PF6_ICE_CLK    NULL                /*!< No ALT_MFP2 setting for PF.6 */
N#define SYS_ALT_MFP3_PF6_ICE_CLK    NULL                /*!< No ALT_MFP3 setting for PF.6 */
N#define SYS_ALT_MFP4_PF6_ICE_CLK    NULL                /*!< No ALT_MFP4 setting for PF.6 */
N
N#define SYS_GPF_MFP_PF6_Msk         (1UL<<6)            /*!< GPF_MFP PF.6 mask */
N#define SYS_ALT_MFP_PF6_Msk         NULL                /*!< No ALT_MFP PF.6 mask */
N#define SYS_ALT_MFP1_PF6_Msk        NULL                /*!< No ALT_MFP1 PF.6 mask */
N#define SYS_ALT_MFP2_PF6_Msk        NULL                /*!< No ALT_MFP2 PF.6 mask */
N#define SYS_ALT_MFP3_PF6_Msk        NULL                /*!< No ALT_MFP3 PF.6 mask */
N#define SYS_ALT_MFP4_PF6_Msk        NULL                /*!< No ALT_MFP4 PF.6 mask */
N
N//PF.7
N#define SYS_GPF_MFP_PF7_GPIO        0x00000000UL        /*!< GPF_MFP PF.7 setting for GPIO */
N#define SYS_ALT_MFP_PF7_GPIO        NULL                /*!< No ALT_MFP setting for PF.7 */
N#define SYS_ALT_MFP1_PF7_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.7 */
N#define SYS_ALT_MFP2_PF7_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.7 */
N#define SYS_ALT_MFP3_PF7_GPIO       NULL                /*!< No ALT_MFP3 setting for PF.7 */
N#define SYS_ALT_MFP4_PF7_GPIO       NULL                /*!< No ALT_MFP4 setting for PF.7 */
N
N#define SYS_GPF_MFP_PF7_ICE_DAT     (1UL<<7)            /*!< GPF_MFP PF.7 setting for ICE_DAT */
N#define SYS_ALT_MFP_PF7_ICE_DAT     NULL                /*!< No ALT_MFP setting for PF.7 */
N#define SYS_ALT_MFP1_PF7_ICE_DAT    NULL                /*!< No ALT_MFP1 setting for PF.7 */
N#define SYS_ALT_MFP2_PF7_ICE_DAT    NULL                /*!< No ALT_MFP2 setting for PF.7 */
N#define SYS_ALT_MFP3_PF7_ICE_DAT    NULL                /*!< No ALT_MFP3 setting for PF.7 */
N#define SYS_ALT_MFP4_PF7_ICE_DAT    NULL                /*!< No ALT_MFP4 setting for PF.7 */
N
N#define SYS_GPF_MFP_PF7_Msk         (1UL<<7)            /*!< GPF_MFP PF.7 mask */
N#define SYS_ALT_MFP_PF7_Msk         NULL                /*!< No ALT_MFP PF.7 mask */
N#define SYS_ALT_MFP1_PF7_Msk        NULL                /*!< No ALT_MFP1 PF.7 mask */
N#define SYS_ALT_MFP2_PF7_Msk        NULL                /*!< No ALT_MFP2 PF.7 mask */
N#define SYS_ALT_MFP3_PF7_Msk        NULL                /*!< No ALT_MFP3 PF.7 mask */
N#define SYS_ALT_MFP4_PF7_Msk        NULL                /*!< No ALT_MFP4 PF.7 mask */
N
N//PF.8
N#define SYS_GPF_MFP_PF8_GPIO        0x00000000UL        /*!< GPF_MFP PF.8 setting for GPIO */
N#define SYS_ALT_MFP_PF8_GPIO        NULL                /*!< No ALT_MFP setting for PF.8 */
N#define SYS_ALT_MFP1_PF8_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.8 */
N#define SYS_ALT_MFP2_PF8_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.8 */
N#define SYS_ALT_MFP3_PF8_GPIO       0x00000000UL        /*!< ALT_MFP3 PF.8 setting for GPIO */
N#define SYS_ALT_MFP4_PF8_GPIO       NULL                /*!< No ALT_MFP4 setting for PF.8 */
N
N#define SYS_GPF_MFP_PF8_CLKO        (1UL<<8)            /*!< GPF_MFP PF.8 setting for CLKO */
N#define SYS_ALT_MFP_PF8_CLKO        NULL                /*!< No ALT_MFP setting for PF.8 */
N#define SYS_ALT_MFP1_PF8_CLKO       NULL                /*!< No ALT_MFP1 setting for PF.8 */
N#define SYS_ALT_MFP2_PF8_CLKO       NULL                /*!< No ALT_MFP2 setting for PF.8 */
N#define SYS_ALT_MFP3_PF8_CLKO       0x00000000UL        /*!< ALT_MFP3 PF.8 setting for CLKO */
N#define SYS_ALT_MFP4_PF8_CLKO       NULL                /*!< No ALT_MFP4 setting for PF.8 */
N
N#define SYS_GPF_MFP_PF8_BPWM1_CH4       0x00000000UL    /*!< GPF_MFP PF.8 setting for BPWM1_CH4 */
N#define SYS_ALT_MFP_PF8_BPWM1_CH4       NULL            /*!< No ALT_MFP setting for PF.8 */
N#define SYS_ALT_MFP1_PF8_BPWM1_CH4      NULL            /*!< No ALT_MFP1 setting for PF.8 */
N#define SYS_ALT_MFP2_PF8_BPWM1_CH4      NULL            /*!< No ALT_MFP2 setting for PF.8 */
N#define SYS_ALT_MFP3_PF8_BPWM1_CH4      (1UL<<22)       /*!< ALT_MFP3 PF.8 setting for BPWM1_CH4 */
N#define SYS_ALT_MFP4_PF8_BPWM1_CH4      NULL            /*!< No ALT_MFP4 setting for PF.8 */
N
N#define SYS_GPF_MFP_PF8_Msk         (1UL<<8)            /*!< GPF_MFP PF.8 mask */
N#define SYS_ALT_MFP_PF8_Msk         NULL                /*!< No ALT_MFP PF.8 mask */
N#define SYS_ALT_MFP1_PF8_Msk        NULL                /*!< No ALT_MFP1 PF.8 mask */
N#define SYS_ALT_MFP2_PF8_Msk        NULL                /*!< No ALT_MFP2 PF.8 mask */
N#define SYS_ALT_MFP3_PF8_Msk        (1UL<<22)           /*!< ALT_MFP3 PF.8 mask */
N#define SYS_ALT_MFP4_PF8_Msk        NULL                /*!< No ALT_MFP4 PF.8 mask */
N
N
N/*@}*/ /* end of group NUC131_SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup NUC131_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCR |= SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Set Brown-out detector function to normal mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to normal mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCR &= ~SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD()               (SYS->BODCR &= ~SYS_BODCR_BOD_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD()                (SYS->BODCR |= SYS_BODCR_BOD_EN_Msk)
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCR & SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Get Brown-out detector status
N  * @param      None
N  * @retval     0   System voltage is higher than BOD threshold voltage setting or BOD function is disabled.
N  * @retval     >=1 System voltage is lower than BOD threshold voltage setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD function is disabled, this function always return 0.
N  */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCR & SYS_BODCR_BOD_OUT_Msk)
N
N/**
N  * @brief      Enable Brown-out detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCR &= ~SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCR |= SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Set Brown-out detector function low power mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to low power mode.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LPM()               (SYS->BODCR |= SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Set Brown-out detector voltage level
N  * @param[in]  u32Level is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCR_BOD_VL_4_4V
N  *             - \ref SYS_BODCR_BOD_VL_3_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_2V
N  * @return     None
N  * @details    This macro set Brown-out detector voltage level.
N  *             The write-protection function should be disabled before using this macro.
N  */
N#define SYS_SET_BOD_LEVEL(u32Level)     (SYS->BODCR = (SYS->BODCR & ~SYS_BODCR_BOD_VL_Msk) | (u32Level))
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.
N  */
N#define SYS_IS_BOD_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_BOD_Msk)
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset.
N  */
N#define SYS_IS_CPU_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_CPU_Msk)
N
N/**
N  * @brief      Get reset source is from Low-Voltage-Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Low-Voltage-Reset
N  * @retval     >=1 Previous reset source is from Low-Voltage-Reset
N  * @details    This macro get previous reset source is from Low-Voltage-Reset.
N  */
N#define SYS_IS_LVR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_LVR_Msk)
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.
N  */
N#define SYS_IS_POR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_POR_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_RESET_Msk)
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_SYS_Msk)
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.
N  */
N#define SYS_IS_WDT_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_WDT_Msk)
N
N/**
N  * @brief      Disable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Low-Voltage-Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_LVR()               (SYS->BODCR &= ~SYS_BODCR_LVR_EN_Msk)
N
N/**
N  * @brief      Enable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Low-Voltage-Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_LVR()                (SYS->BODCR |= SYS_BODCR_LVR_EN_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCR = 0x5AA5)
N
N/**
N  * @brief      Enable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  *             The register write-protection function should be disabled before using this macro.
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCR = 0)
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including:
N  *             - \ref SYS_RSTSRC_RSTS_CPU_Msk
N  *             - \ref SYS_RSTSRC_RSTS_SYS_Msk
N  *             - \ref SYS_RSTSRC_RSTS_BOD_Msk
N  *             - \ref SYS_RSTSRC_RSTS_LVR_Msk
N  *             - \ref SYS_RSTSRC_RSTS_WDT_Msk
N  *             - \ref SYS_RSTSRC_RSTS_RESET_Msk
N  *             - \ref SYS_RSTSRC_RSTS_POR_Msk
N  * @return     None
N  * @details    This macro clear reset source flag.
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) (SYS->RSTSRC = (u32RstSrc) )
N
N
N/**
N  * @brief      Enable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function enable register write-protection function.
N  *             To lock the protected register to forbid write access.
N  */
Nstatic __INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{
N    SYS->REGWRPROT = 0;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0;
N}
N
N/**
N  * @brief      Disable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function disable register write-protection function.
N  *             To unlock the protected register to allow write access.
N  *
N  */
Nstatic __INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{
N    while(SYS->REGWRPROT != SYS_REGWRPROT_REGPROTDIS_Msk)
X    while(((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT != (1ul << 0))
N    {
N        SYS->REGWRPROT = 0x59;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x59;
N        SYS->REGWRPROT = 0x16;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x16;
N        SYS->REGWRPROT = 0x88;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x88;
N    }
N}
N
N
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nuint32_t  SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);
N
N
N/*@}*/ /* end of group NUC131_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_SYS_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11290 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "ADC.h"
L 1 "..\..\..\Library\StdDriver\inc\ADC.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V3.00
N * $Revision: 5 $
N * $Date: 15/01/16 1:45p $
N * @brief    NUC131 Series ADC Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#include "NUC131.h"
L 1 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 1
N/**************************************************************************//**
N * @file     NUC131.h
N * @version  V3.0
N * $Revision: 62 $
N * $Date: 15/05/22 9:06a $
N * @brief    NUC131 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of NUC131 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N  */
N
N
N/**
N  * \page PG_REV Revision History
N  *
N  * <b>Revision 3.00.002</b>
N  * \li Fix PWM driver bug for output low when duty is 100%
N  * \li Fix BPWM driver bug for output low when duty is 100%
N  * \li Fix CLK driver bug in CLK_SetCoreClock():
N  * \li Fix CLK driver constant definitions error of (B)PWM0/1_MODULE clock source selection.
N  * \li Fix GPIO_ENABLE_DOUT_MASK() and GPIO_DISABLE_DOUT_MASK() bug of GPIO driver.
N  * \li Fix PWM driver bug of PWM_MASK_OUTPUT() to remove redundant parenthesis.
N  * \li Fix BPWM driver bug of BPWM_MASK_OUTPUT() to remove redundant parenthesis.
N  * \li Fix UART driver clear flag bug in UART_ClearIntFlag().
N  * \li Fix I2C driver module reset bug of I2C_Close().
N  * \li Fix clear RS-485 address byte detection flag bug in UART_RS485_CLEAR_ADDR_FLAG() of UART driver.
N  * \li Fix SYS_IS_SYSTEM_RST() bug, it is "SYS_RSTSRC_RSTS_SYS_Msk" but "SYS_RSTSRC_RSTS_MCU_Msk".
N  * \li Fix clear RS-485 address byte detection flag clear bug in RS485_HANDLE() of UART_RS485_Slave sample code.
N  * \li Fix UART RS485 RTS active level to high level active in RS485_9bitModeMaster() of UART RS485 Sample code.
N  * \li Fix NVIC_EnableIRQ() to NVIC_DisableIRQ() after CHIP wake-up in I2C_Wakeup_Slave sample code
N  * \li Add PWM_EnableLoadMode() and PWM_DisableLoadMode() functions to PWM driver
N  * \li Add PWM_SetBrakePinSource() function to PWM driver
N  * \li Add CLK_GetPCLKFreq() function to CLK driver
N  * \li Add new macro PWM_SET_DEADZONE_CLK_SRC() to PWM driver
N  * \li Add new macro SYS_IS_LVR_RST() to SYS driver.
N  * \li Add non-blocking printf implementation and use predefine compiler option to enable/disable it.
N  *
N  * <b>Revision 3.00.001</b>
N  * \li Updated to support new API
N*/
N
N
N
N#ifndef __NUC131_H__
S#define __NUC131_H__
S
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/** @addtogroup Definitions Definitions for CMSIS
S  This file defines all structures and symbols:
S    - registers and bitfields
S    - peripheral base address
S    - peripheral ID
S    - Peripheral definitions
S  @{
S*/
S
S
S/*
S * ==========================================================================
S * ---------- Interrupt Number Definition -----------------------------------
S * ==========================================================================
S*/
S
S/**
S * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
S */
S
Stypedef enum IRQn
S{
S    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
S    NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
S    HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
S    SVCall_IRQn                 = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                       */
S    PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                       */
S    SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                   */
S
S    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
S    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
S    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
S    EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
S    EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
S    GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                 */
S    GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                           */
S    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
S    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
S    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
S    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
S    UART02_IRQn               = 12,       /*!< UART0/UART2 Interrupt                                */
S    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
S    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
S    UART3_IRQn                = 15,       /*!< UART3 Interrupt                                      */
S    UART4_IRQn                = 16,       /*!< UART4 Interrupt                                      */
S    UART5_IRQn                = 17,       /*!< UART5 Interrupt                                      */
S    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
S    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
S    CAN0_IRQn                 = 20,       /*!< CAN0 Interrupt                                       */
S    CAN1_IRQn                 = 21,       /*!< CAN1 Interrupt                                       */
S    PWM0_IRQn                 = 22,       /*!< PWM0 Interrupt                                       */
S    PWM1_IRQn                 = 23,       /*!< PWM1 Interrupt                                       */
S    BPWM0_IRQn                = 24,       /*!< BPWM0 Interrupt                                      */
S    BPWM1_IRQn                = 25,       /*!< BPWM1 Interrupt                                      */
S    BRAKE0_IRQn               = 26,       /*!< PWM0 Brake Interrupt                                 */
S    BRAKE1_IRQn               = 27,       /*!< PWM1 Brake Interrupt                                 */
S    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
S    ADC_IRQn                  = 29,       /*!< ADC Interrupt                                        */
S    CKD_IRQn                  = 30,       /*!< Clock detection Interrupt                            */
S} IRQn_Type;                                            
S                                                        
S                                                        
S/*                                                      
S * ==========================================================================
S * ----------- Processor and Core Peripheral Section ------------------------
S * ==========================================================================
S */
S
S/* Configuration of the Cortex-M0 Processor and Core Peripherals */
S#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
S#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
S#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
S
S
S/*@}*/ /* end of group CMSIS */
S
S
S#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
S#include "system_NUC131.h"               /* NUC131 System                                           */
S
S#if defined ( __CC_ARM   )
S#pragma anon_unions
S#endif
S
S
S/******************************************************************************/
S/*                Device Specific Peripheral registers structures             */
S/******************************************************************************/
S
S/** @addtogroup REGISTER Control Register
S
S  @{
S
S*/
S
S
S/*---------------------- Analog to Digital Converter -------------------------*/
S/**
S    @addtogroup ADC Analog to Digital Converter (ADC)
S    Memory Mapped Structure for ADC Controller
S@{ */
Stypedef struct
S{
S
S    /**
S     * ADDR
S     * ===================================================================================================
S     * Offset: 0x00-0x1C  ADC Data Register 0~7
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RSLT      |A/D Conversion Result
S     * |        |          |This field contains conversion result of ADC.
S     * |        |          |When DMOF bit (ADCR[31]) set to 0, 12-bit ADC conversion result with unsigned format will be filled in RSLT (ADDRx[11:0], x=0~7) and zero will be filled in RSLT (ADDRx[15:12], x=0~7).
S     * |        |          |When DMOF bit (ADCR[31]) set to 1, 12-bit ADC conversion result with 2'complement format will be filled in RSLT(ADDRx[11:0], x=0~7) and signed bits to will be filled in RSLT (ADDRx[15:12], x=0~7).
S     * |[16]    |OVERRUN   |Overrun Flag
S     * |        |          |0 = Data in RSLT (ADDRx[15:0], x=0~7) is recent conversion result.
S     * |        |          |1 = Data in RSLT (ADDRx[15:0], x=0~7) is overwritten.
S     * |        |          |If converted data in RSLT has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone.
S     * |        |          |It is cleared by hardware after ADDR register is read.
S     * |        |          |This is a read only bit.
S     * |[17]    |VALID     |Valid Flag
S     * |        |          |0 = Data in RSLT bits (ADDRx[15:0], x=0~7) is not valid.
S     * |        |          |1 = Data in RSLT bits (ADDRx[15:0], x=0~7) is valid.
S     * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
S     * |        |          |This is a read only bit
S     */
S    __I  uint32_t ADDR[8];
S
S    /**
S     * ADCR
S     * ===================================================================================================
S     * Offset: 0x20  ADC Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADEN      |A/D Converter Enable
S     * |        |          |0 = Disabled.
S     * |        |          |1 = Enabled.
S     * |        |          |Before starting A/D conversion function, this bit should be set to 1.
S     * |        |          |Clear it to 0 to disable A/D converter analog circuit for saving power consumption.
S     * |[1]     |ADIE      |A/D Interrupt Enable
S     * |        |          |0 = A/D interrupt function Disabled.
S     * |        |          |1 = A/D interrupt function Enabled.
S     * |        |          |A/D conversion end interrupt request is generated if ADIE bit (ADCR[1]) is set to 1.
S     * |[3:2]   |ADMD      |A/D Converter Operation Mode
S     * |        |          |00 = Single conversion.
S     * |        |          |01 = Reserved.
S     * |        |          |10 = Single-cycle scan.
S     * |        |          |11 = Continuous scan.
S     * |        |          |When changing the operation mode, software should disable ADST bit (ADCR[11]) firstly.
S     * |[5:4]   |TRGS      |Hardware Trigger Source
S     * |        |          |00 = A/D conversion is started by external STADC pin.
S     * |        |          |11 = A/D conversion is started by PWM Center-aligned trigger.
S     * |        |          |Others = Reserved.
S     * |        |          |Software should disable TRGEN (ADCR[8]) and ADST (ADCR[11]) before change TRGS.
S     * |[7:6]   |TRGCOND   |External Trigger Condition
S     * |        |          |These two bits decide external pin STADC trigger event is level or edge.
S     * |        |          |The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state for edge trigger.
S     * |        |          |00 = Low level.
S     * |        |          |01 = High level.
S     * |        |          |10 = Falling edge.
S     * |        |          |11 = Rising edge.
S     * |[8]     |TRGEN     |Hardware Trigger Enable
S     * |        |          |Enable or disable triggering of A/D conversion by hardware (external STADC pin or PWM Center-aligned trigger).
S     * |        |          |0 = Disabled.
S     * |        |          |1 = Enabled.
S     * |        |          |ADC hardware trigger function is only supported in single-cycle scan mode.
S     * |        |          |If hardware trigger mode, the ADST bit (ADCR[11]) can be set to 1 by the selected hardware trigger source.
S     * |[10]    |DIFFEN    |Differential Input Mode Enable
S     * |        |          |0 = Single-end analog input mode.
S     * |        |          |1 = Differential analog input mode.
S     * |        |          |Differential   input Paired Channel
S     * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus, where Vplus
S     * |        |          |is the analog input; Vminus is the inverted analog input.
S     * |        |          |In differential input mode, only the even number of the two corresponding channels needs to be enabled in ADCHER.
S     * |        |          |The conversion result will be placed to the corresponding data register of the enabled channel.
S     * |[11]    |ADST      |A/D Conversion Start
S     * |        |          |0 = Conversion stops and A/D converter enter idle state.
S     * |        |          |1 = Conversion starts.
S     * |        |          |ADST bit can be set to 1 from three sources: software, PWM Center-aligned trigger and external pin STADC.
S     * |        |          |ADST will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode.
S     * |        |          |In continuous scan mode, A/D conversion is continuously performed until software writes 0 to this bit or chip reset.
S     * |[31]    |DMOF      |A/D Differential Input Mode Output Format
S     * |        |          |0 = A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format.
S     * |        |          |1 = A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format.
S     */
S    __IO uint32_t ADCR;
S
S    /**
S     * ADCHER
S     * ===================================================================================================
S     * Offset: 0x24  ADC Channel Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |CHEN      |Analog Input Channel Enable
S     * |        |          |Set CHEN[7:0] to enable the corresponding analog input channel 7 ~ 0.
S     * |        |          |If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.
S     * |        |          |0 = ADC input channel Disabled.
S     * |        |          |1 = ADC input channel Enabled.
S     * |[9:8]   |PRESEL    |Analog Input Channel 7 Select
S     * |        |          |00 = External analog input.
S     * |        |          |01 = Internal band-gap voltage.
S     * |        |          |10 = Internal temperature sensor.
S     * |        |          |11 = Reserved.
S     * |        |          |Note:
S     * |        |          |When software select the band-gap voltage as the analog input source of ADC channel 7, ADC clock rate needs to be limited to slower than 300 kHz.
S     */
S    __IO uint32_t ADCHER;
S
S    /**
S     * ADCMPR
S     * ===================================================================================================
S     * Offset: 0x28, 0x2C  ADC Compare Register 0 & 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CMPEN     |Compare Enable
S     * |        |          |0 = Compare function Disabled.
S     * |        |          |1 = Compare function Enabled.
S     * |        |          |Set this bit to 1 to enable ADC controller to compare CMPD (ADCMPR0/1[27:16]) with specified channel conversion result when converted data is loaded into ADDR register.
S     * |[1]     |CMPIE     |Compare Interrupt Enable
S     * |        |          |0 = Compare function interrupt Disabled.
S     * |        |          |1 = Compare function interrupt Enabled.
S     * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND (ADCMPR0/1[2]) and CMPMATCNT (ADCMPR0/1[11:8]), CMPF0/1 bit (ADSR[1]/[2]) will be asserted, in the meanwhile, if CMPIE (ADCMPR0/1[1]) is set to 1, a compare interrupt request is generated.
S     * |[2]     |CMPCOND   |Compare Condition
S     * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
S     * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
S     * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8])+1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.
S     * |[5:3]   |CMPCH     |Compare Channel Selection
S     * |        |          |000 = Channel 0 conversion result is selected to be compared.
S     * |        |          |001 = Channel 1 conversion result is selected to be compared.
S     * |        |          |010 = Channel 2 conversion result is selected to be compared.
S     * |        |          |011 = Channel 3 conversion result is selected to be compared.
S     * |        |          |100 = Channel 4 conversion result is selected to be compared.
S     * |        |          |101 = Channel 5 conversion result is selected to be compared.
S     * |        |          |110 = Channel 6 conversion result is selected to be compared.
S     * |        |          |111 = Channel 7 conversion result is selected to be compared.
S     * |[11:8]  |CMPMATCNT |Compare Match Count
S     * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND (ADCMPR0/1[2]), the internal match counter will increase 1.
S     * |        |          |When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) +1), the CMPF0/1 bit (ADSR[1]/[2]) will be set.
S     * |[27:16] |CMPD      |Comparison Data
S     * |        |          |The 12-bit data is used to compare with conversion result of specified channel.
S     * |        |          |When DMOF bit (ADCR[31]) is set to 0, ADC comparator compares CMPD with conversion result with unsigned format.
S     * |        |          |CMPD should be filled in unsigned format.
S     * |        |          |When DMOF bit (ADCR[31]) is set to 1, ADC comparator compares CMPD with conversion result with 2'complement format.
S     * |        |          |CMPD should be filled in 2'complement format.
S     */
S    __IO uint32_t ADCMPR[2];
S
S    /**
S     * ADSR
S     * ===================================================================================================
S     * Offset: 0x30  ADC Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ADF       |A/D Conversion End Flag
S     * |        |          |A status flag that indicates the end of A/D conversion.
S     * |        |          |ADF is set to 1 at these two conditions:
S     * |        |          |1. When A/D conversion ends in Single mode.
S     * |        |          |2. When A/D conversion ends on all specified channels in Scan mode.
S     * |        |          |This flag can be cleared by writing 1 to itself.
S     * |[1]     |CMPF0     |Compare Flag
S     * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit is set to 1.
S     * |        |          |And it is cleared by writing 1 to self.
S     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting.
S     * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting.
S     * |[2]     |CMPF1     |Compare Flag
S     * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit is set to 1.
S     * |        |          |And it is cleared by writing 1 to self.
S     * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting.
S     * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting.
S     * |[3]     |BUSY      |BUSY/IDLE
S     * |        |          |0 = A/D converter is in idle state.
S     * |        |          |1 = A/D converter is busy at conversion.
S     * |        |          |This bit is mirror of as ADST bit (ADCR[11]).
S     * |        |          |It is read only.
S     * |[6:4]   |CHANNEL   |Current Conversion Channel
S     * |        |          |This field reflects the current conversion channel when BUSY = 1 (ADSR[3]).
S     * |        |          |When BUSY = 0, it shows the number of the next converted channel.
S     * |        |          |It is read only.
S     * |[15:8]  |VALID     |Data Valid Flag
S     * |        |          |It is a mirror of VALID bit (ADDR0~7[17]).
S     * |        |          |It is read only.
S     * |[23:16] |OVERRUN   |Overrun Flag
S     * |        |          |It is a mirror to OVERRUN bit (ADDR0~7[16]).
S     * |        |          |It is read only.
S     */
S    __IO uint32_t ADSR;
S
S} ADC_T;
S
S/**
S    @addtogroup ADC_CONST ADC Bit Field Definition
S    Constant Definitions for ADC Controller
S@{ */
S
S
S/* ADDR Bit Field Definitions */
S#define ADC_ADDR_VALID_Pos      17                                /*!< ADC_T::ADDR: VALID Position */
S#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC_T::ADDR: VALID Mask */
S
S#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC_T::ADDR: OVERRUN Position */
S#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC_T::ADDR: OVERRUN Mask */
S
S#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC_T::ADDR: RSLT Position */
S#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC_T::ADDR: RSLT Mask */
S
S/* ADCR Bit Field Definitions */
S#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC_T::ADCR: DMOF Position */
S#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC_T::ADCR: DMOF Mask */
S
S#define ADC_ADCR_ADST_Pos       11                                /*!< ADC_T::ADCR: ADST Position */
S#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC_T::ADCR: ADST Mask */
S
S#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC_T::ADCR: DIFFEN Position */
S#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC_T::ADCR: DIFFEN Mask */
S
S#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC_T::ADCR: TRGEN Position */
S#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC_T::ADCR: TRGEN Mask */
S
S#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC_T::ADCR: TRGCOND Position */
S#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC_T::ADCR: TRGCOND Mask */
S
S#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC_T::ADCR: TRGS Position */
S#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC_T::ADCR: TRGS Mask */
S
S#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC_T::ADCR: ADMD Position */
S#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC_T::ADCR: ADMD Mask */
S
S#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC_T::ADCR: ADIE Position */
S#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC_T::ADCR: ADIE Mask */
S
S#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC_T::ADCR: ADEN Position */
S#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC_T::ADCR: ADEN Mask */
S
S/* ADCHER Bit Field Definitions */
S#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC_T::ADCHER: PRESEL Position */
S#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC_T::ADCHER: PRESEL Mask */
S
S#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC_T::ADCHER: CHEN Position */
S#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC_T::ADCHER: CHEN Mask */
S
S/* ADCMPR Bit Field Definitions */
S#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC_T::ADCMPR: CMPD Position */
S#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC_T::ADCMPR: CMPD Mask */
S
S#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC_T::ADCMPR: CMPMATCNT Position */
S#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC_T::ADCMPR: CMPMATCNT Mask */
S
S#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC_T::ADCMPR: CMPCH Position */
S#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC_T::ADCMPR: CMPCH Mask */
S
S#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC_T::ADCMPR: CMPCOND Position */
S#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC_T::ADCMPR: CMPCOND Mask */
S
S#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC_T::ADCMPR: CMPIE Position */
S#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC_T::ADCMPR: CMPIE Mask */
S
S#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC_T::ADCMPR: CMPEN Position */
S#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC_T::ADCMPR: CMPEN Mask */
S
S/* ADSR Bit Field Definitions */
S#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC_T::ADSR: OVERRUN Position */
S#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC_T::ADSR: OVERRUN Mask */
S
S#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC_T::ADSR: VALID Position */
S#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC_T::ADSR: VALID Mask */
S
S#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC_T::ADSR: CHANNEL Position */
S#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC_T::ADSR: CHANNEL Mask */
S
S#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC_T::ADSR: BUSY Position */
S#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC_T::ADSR: BUSY Mask */
S
S#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC_T::ADSR: CMPF1 Position */
S#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC_T::ADSR: CMPF1 Mask */
S
S#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC_T::ADSR: CMPF0 Position */
S#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC_T::ADSR: CMPF0 Mask */
S
S#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC_T::ADSR: ADF Position */
S#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC_T::ADSR: ADF Mask */
S
S/*@}*/ /* end of group ADC_CONST */
S/*@}*/ /* end of group ADC */
S
S
S
S/*---------------------- Basic Pulse Width Modulation Controller -------------------------*/
S/**
S    @addtogroup BPWM Basic Pulse Width Modulation Controller (BPWM)
S    Memory Mapped Structure for BPWM Controller
S@{ */
Stypedef struct
S{
S    /**
S     * BPWM_CTL0
S     * ===================================================================================================
S     * Offset: 0x00  BPWM Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CTRLDn    |Center Re-Load
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period. CMPDAT
S     * |        |          |will load to CMPBUF at the center point of a period.
S     * |[21:16] |IMMLDENn  |Immediately Load Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = PERIOD will load to PBUF at the end point of each period. CMPDAT will load to CMPBUF
S     * |        |          |at the end point or center point of each period by setting CTRLD bit.
S     * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
S     * |        |          |Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
S     * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
S     * |        |          |If counter halt is enabled, BPWM all counters will keep current value until exit
S     * |        |          |ICE debug mode.
S     * |        |          |0 = ICE debug mode counter halt disable.
S     * |        |          |1 = ICE debug mode counter halt enable.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
S     * |        |          |0 = ICE debug mode acknowledgment effects BPWM output.
S     * |        |          |BPWM pin will be forced as tri-state while ICE debug mode acknowledged.
S     * |        |          |1 = ICE debug mode acknowledgment disabled.
S     * |        |          |BPWM pin will keep output no matter ICE debug mode acknowledged or not.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     */
S    __IO uint32_t CTL0;
S
S    /**
S     * BPWM_CTL1
S     * ===================================================================================================
S     * Offset: 0x04  BPWM Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |CNTTYPE0  |BPWM Counter Behavior Type 0
S     * |        |          |Each bit n controls corresponding BPWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     */
S    __IO uint32_t CTL1;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED0
S     * ===================================================================================================
S     * Offset: 0x0008 ~ 0x000C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED0[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_CLKSRC
S     * ===================================================================================================
S     * Offset: 0x10  BPWM Clock Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |ECLKSRC0  |BPWM_CH01 External Clock Source Select
S     * |        |          |000 = BPWMx_CLK, x denotes 0 or 1.
S     * |        |          |001 = TIMER0 overflow.
S     * |        |          |010 = TIMER1 overflow.
S     * |        |          |011 = TIMER2 overflow.
S     * |        |          |100 = TIMER3 overflow.
S     * |        |          |Others = Reserved.
S     */
S    __IO uint32_t CLKSRC;
S
S    /**
S     * BPWM_CLKPSC
S     * ===================================================================================================
S     * Offset: 0x14  BPWM Clock Pre-scale Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CLKPSC    |BPWM Counter Clock Pre-Scale
S     * |        |          |The clock of BPWM counter is decided by clock prescaler. Each BPWM pair share one BPWM
S     * |        |          |counter clock prescaler. The clock of BPWM counter is divided by (CLKPSC+ 1).
S     */
S    __IO uint32_t CLKPSC;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED1
S     * ===================================================================================================
S     * Offset: 0x0018 ~ 0x001C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED1[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_CNTEN
S     * ===================================================================================================
S     * Offset: 0x20  BPWM Counter Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTEN0    |BPWM Counter Enable 0
S     * |        |          |0 = BPWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = BPWM Counter and clock prescaler Start Running.
S     */
S    __IO uint32_t CNTEN;
S
S    /**
S     * BPWM_CNTCLR
S     * ===================================================================================================
S     * Offset: 0x24  BPWM Clear Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTCLR0   |Clear BPWM Counter Control Bit 0
S     * |        |          |It is automatically cleared by hardware.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit BPWM counter to 0000H.
S     */
S    __IO uint32_t CNTCLR;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED2
S     * ===================================================================================================
S     * Offset: 0x0028 ~ 0x002C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED2[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_PERIOD
S     * ===================================================================================================
S     * Offset: 0x30  BPWM Period Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PERIOD    |BPWM Period Register
S     * |        |          |Up-Count mode: In this mode, BPWM counter counts from 0 to PERIOD, and restarts from 0.
S     * |        |          |Down-Count mode: In this mode, BPWM counter counts from PERIOD to 0, and restarts from PERIOD.
S     * |        |          |BPWM period time = (PERIOD+1) * BPWM_CLK period.
S     * |        |          |Up-Down-Count mode: In this mode, BPWM counter counts from 0 to PERIOD, then decrements to 0
S     * |        |          |and repeats again.
S     * |        |          |BPWM period time = 2 * PERIOD * BPWM_CLK period.
S     */
S    __IO uint32_t PERIOD;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED3
S     * ===================================================================================================
S     * Offset: 0x0034 ~ 0x004C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED3[7];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_CMPDAT0~5
S     * ===================================================================================================
S     * Offset: 0x50~0x64  BPWM Comparator Register 0~5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMPDAT    |BPWM Comparator Register
S     * |        |          |CMPDAT use to compare with CNT to generate BPWM waveform, interrupt and trigger ADC.
S     * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent BPWM_CH0~5 compared point.
S     * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1,
S     * |        |          |3, 5 denote as second compared point for the corresponding 3 complementary
S     * |        |          |pairs BPWM_CH0 and BPWM_CH1, BPWM_CH2 and BPWM_CH3, BPWM_CH4 and BPWM_CH5.
S     */
S    __IO uint32_t CMPDAT[6];
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED4
S     * ===================================================================================================
S     * Offset: 0x0068 ~ 0x008C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED4[10];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_CNT
S     * ===================================================================================================
S     * Offset: 0x90  BPWM Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNT       |BPWM Data Register (Read Only)
S     * |        |          |User can monitor CNT to know the current value in 16-bit period counter.
S     * |[16]    |DIRF      |BPWM Direction Indicator Flag (Read Only)
S     * |        |          |0 = Counter is Down count.
S     * |        |          |1 = Counter is UP count.
S     */
S    __IO uint32_t CNT;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED5
S     * ===================================================================================================
S     * Offset: 0x0094 ~ 0x00AC
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED5[7];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_WGCTL0
S     * ===================================================================================================
S     * Offset: 0xB0  BPWM Generation Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |ZPCTLn    |BPWM Zero Point Control
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = BPWM zero point output Low.
S     * |        |          |10 = BPWM zero point output High.
S     * |        |          |11 = BPWM zero point output Toggle.
S     * |        |          |BPWM can control output level when BPWM counter count to zero.
S     * |[27:16] |PRDPCTLn  |BPWM Period (Center) Point Control
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = BPWM period (center) point output Low.
S     * |        |          |10 = BPWM period (center) point output High.
S     * |        |          |11 = BPWM period (center) point output Toggle.
S     * |        |          |BPWM can control output level when BPWM counter count to (PERIODn+1).
S     * |        |          |Note: This bit is center point control when BPWM counter operating in up-down counter type.
S     */
S    __IO uint32_t WGCTL0;
S
S
S    /**
S     * BPWM_WGCTL1
S     * ===================================================================================================
S     * Offset: 0xB4  BPWM Generation Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CMPUCTLn  |BPWM Compare Up Point Control
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = BPWM compare up point output Low.
S     * |        |          |10 = BPWM compare up point output High.
S     * |        |          |11 = BPWM compare up point output Toggle.
S     * |        |          |BPWM can control output level when BPWM counter up count to CMPDAT.
S     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S     * |[27:16] |CMPDCTLn  |BPWM Compare Down Point Control
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = BPWM compare down point output Low.
S     * |        |          |10 = BPWM compare down point output High.
S     * |        |          |11 = BPWM compare down point output Toggle.
S     * |        |          |BPWM can control output level when BPWM counter down count to CMPDAT.
S     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S     */
S    __IO uint32_t WGCTL1;
S
S    /**
S     * BPWM_MSKEN
S     * ===================================================================================================
S     * Offset: 0xB8  BPWM Mask Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |MSKENn    |BPWM Mask Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |The BPWM output signal will be masked when this bit is enabled. The corresponding BPWM
S     * |        |          |channel n will output MSKDATn (BPWM_MSK[5:0]) data.
S     * |        |          |0 = BPWM output signal is non-masked.
S     * |        |          |1 = BPWM output signal is masked and output MSKDATn data.
S     */
S    __IO uint32_t MSKEN;
S
S    /**
S     * BPWM_MSK
S     * ===================================================================================================
S     * Offset: 0xBC  BPWM Mask Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |MSKDATn   |BPWM Mask Data Bit
S     * |        |          |This data bit control the state of BPWMn output pin, if corresponding mask function
S     * |        |          |is enabled. Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Output logic low to BPWMn.
S     * |        |          |1 = Output logic high to BPWMn.
S     */
S    __IO uint32_t MSK;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED6
S     * ===================================================================================================
S     * Offset: 0x00C0 ~ 0x00D0
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED6[5];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_POLCTL
S     * ===================================================================================================
S     * Offset: 0xD4  BPWM Pin Polar Inverse Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |PINVn     |BPWM PIN Polar Inverse Control
S     * |        |          |The register controls polarity state of BPWM output. Each bit n controls the
S     * |        |          |corresponding BPWM channel n.
S     * |        |          |0 = BPWM output polar inverse Disabled.
S     * |        |          |1 = BPWM output polar inverse Enabled.
S     */
S    __IO uint32_t POLCTL;
S
S    /**
S     * BPWM_POEN
S     * ===================================================================================================
S     * Offset: 0xD8  BPWM Output Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |POENn     |BPWM Pin Output Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = BPWM pin at tri-state.
S     * |        |          |1 = BPWM pin in output mode.
S     */
S    __IO uint32_t POEN;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED7
S     * ===================================================================================================
S     * Offset: 0x00DC
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED7[1];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_INTEN
S     * ===================================================================================================
S     * Offset: 0xE0  BPWM Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ZIEN0     |BPWM Zero Point Interrupt Enable 0
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[8]     |PIEN0     |BPWM Period Point Interrupt Enable 0
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note: When up-down counter type period point means center point.
S     * |[21:16] |CMPUIENn  |BPWM Compare Up Count Interrupt Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S     * |[29:24] |CMPDIENn  |BPWM Compare Down Count Interrupt Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S     */
S    __IO uint32_t INTEN;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED8
S     * ===================================================================================================
S     * Offset: 0x00E4
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED8[1];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_INTSTS
S     * ===================================================================================================
S     * Offset: 0xE8  BPWM Interrupt Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ZIF0      |BPWM Zero Point Interrupt Flag 0
S     * |        |          |This bit is set by hardware when BPWM_CH0 counter reaches zero, software can write 1
S     * |        |          |to clear this bit to zero.
S     * |[8]     |PIF0      |BPWM Period Point Interrupt Flag 0
S     * |        |          |This bit is set by hardware when BPWM_CH0 counter reaches BPWM_PERIOD0, software can
S     * |        |          |write 1 to clear this bit to zero.
S     * |[21:16] |CMPUIFn   |BPWM Compare Up Count Interrupt Flag
S     * |        |          |Flag is set by hardware when BPWM counter up count and reaches BPWM_CMPDATn,
S     * |        |          |software can clear this bit by writing 1 to it. Each bit n controls the
S     * |        |          |corresponding BPWM channel n.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S     * |[29:24] |CMPDIFn   |BPWM Compare Down Count Interrupt Flag
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |Flag is set by hardware when BPWM counter down count and reaches BPWM_CMPDATn,
S     * |        |          |software can clear this bit by writing 1 to it.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
S     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S     */
S    __IO uint32_t INTSTS;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED9
S     * ===================================================================================================
S     * Offset: 0x00EC ~ 0x00F4
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED9[3];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_ADCTS0
S     * ===================================================================================================
S     * Offset: 0xF8  BPWM Trigger ADC Source Select Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |TRGSEL0   |BPWM_CH0 Trigger ADC Source Select
S     * |        |          |0000 = BPWM_CH0 zero point.
S     * |        |          |0001 = BPWM_CH0 period point.
S     * |        |          |0010 = BPWM_CH0 zero or period point.
S     * |        |          |0011 = BPWM_CH0 up-count CMPDAT point.
S     * |        |          |0100 = BPWM_CH0 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = BPWM_CH1 up-count CMPDAT point.
S     * |        |          |1001 = BPWM_CH1 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[7]     |TRGEN0    |BPWM_CH0 Trigger ADC Enable Bit
S     * |[11:8]  |TRGSEL1   |BPWM_CH1 Trigger ADC Source Select
S     * |        |          |0000 = BPWM_CH0 zero point.
S     * |        |          |0001 = BPWM_CH0 period point.
S     * |        |          |0010 = BPWM_CH0 zero or period point.
S     * |        |          |0011 = BPWM_CH0 up-count CMPDAT point.
S     * |        |          |0100 = BPWM_CH0 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = BPWM_CH1 up-count CMPDAT point.
S     * |        |          |1001 = BPWM_CH1 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[15]    |TRGEN1    |BPWM_CH1 Trigger ADC Enable Bit
S     * |[19:16] |TRGSEL2   |BPWM_CH2 Trigger ADC Source Select
S     * |        |          |0000 = BPWM_CH2 zero point.
S     * |        |          |0001 = BPWM_CH2 period point.
S     * |        |          |0010 = BPWM_CH2 zero or period point.
S     * |        |          |0011 = BPWM_CH2 up-count CMPDAT point.
S     * |        |          |0100 = BPWM_CH2 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = BPWM_CH3 up-count CMPDAT point.
S     * |        |          |1001 = BPWM_CH3 down-count CMPDAT point.
S     * |        |          |Others = Reserved.
S     * |[23]    |TRGEN2    |BPWM_CH2 Trigger ADC Enable Bit
S     * |[27:24] |TRGSEL3   |BPWM_CH3 Trigger ADC Source Select
S     * |        |          |0000 = BPWM_CH2 zero point.
S     * |        |          |0001 = BPWM_CH2 period point.
S     * |        |          |0010 = BPWM_CH2 zero or period point.
S     * |        |          |0011 = BPWM_CH2 up-count CMPDAT point.
S     * |        |          |0100 = BPWM_CH2 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = BPWM_CH3 up-count CMPDAT point.
S     * |        |          |1001 = BPWM_CH3 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[31]    |TRGEN3    |BPWM_CH3 Trigger ADC Enable Bit
S     */
S    __IO uint32_t ADCTS0;
S
S    /**
S     * BPWM_ADCTS1
S     * ===================================================================================================
S     * Offset: 0xFC  BPWM Trigger ADC Source Select Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |TRGSEL4   |BPWM_CH4 Trigger ADC Source Select
S     * |        |          |0000 = BPWM_CH4 zero point.
S     * |        |          |0001 = BPWM_CH4 period point.
S     * |        |          |0010 = BPWM_CH4 zero or period point.
S     * |        |          |0011 = BPWM_CH4 up-count CMPDAT point.
S     * |        |          |0100 = BPWM_CH4 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = BPWM_CH5 up-count CMPDAT point.
S     * |        |          |1001 = BPWM_CH5 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[7]     |TRGEN4    |BPWM_CH4 Trigger ADC Enable Bit
S     * |[11:8]  |TRGSEL5   |BPWM_CH5 Trigger ADC Source Select
S     * |        |          |0000 = BPWM_CH4 zero point.
S     * |        |          |0001 = BPWM_CH4 period point.
S     * |        |          |0010 = BPWM_CH4 zero or period point.
S     * |        |          |0011 = BPWM_CH4 up-count CMPDAT point.
S     * |        |          |0100 = BPWM_CH4 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = BPWM_CH5 up-count CMPDAT point.
S     * |        |          |1001 = BPWM_CH5 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[15]    |TRGEN5    |BPWM_CH5 Trigger ADC Enable Bit
S     */
S    __IO uint32_t ADCTS1;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED10
S     * ===================================================================================================
S     * Offset: 0x0100 ~ 0x010C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED10[4];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_SSCTL
S     * ===================================================================================================
S     * Offset: 0x110  BPWM Synchronous Start Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SSEN0     |BPWM Synchronous Start Function Enable 0
S     * |        |          |When synchronous start function is enabled, the BPWM_CH0 counter enable bit (CNTEN0)
S     * |        |          |can be enabled by writing BPWM synchronous start trigger bit (CNTSEN).
S     * |        |          |0 = BPWM synchronous start function Disabled.
S     * |        |          |1 = BPWM synchronous start function Enabled.
S     * |[9:8]   |SSRC      |BPWM Synchronous Start Source Select
S     * |        |          |00 = Synchronous start source come from BPWM0.
S     * |        |          |01 = Synchronous start source come from BPWM1.
S     * |        |          |10 = Synchronous start source come from BPWM0.
S     * |        |          |11 = Synchronous start source come from BPWM1.
S     */
S    __IO uint32_t SSCTL;
S
S    /**
S     * BPWM_SSTRG
S     * ===================================================================================================
S     * Offset: 0x114  BPWM Synchronous Start Trigger Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTSEN    |BPWM Counter Synchronous Start Enable (Write Only)
S     * |        |          |PMW counter synchronous enable function is used to make selected BPWM channels
S     * |        |          |(include BPWM0_CHx and BPWM1_CHx) start counting at the same time.
S     * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0
S     * |        |          |to 5) if correlated BPWM channel counter synchronous start function is enabled.
S     * |        |          |Note: This bit only present in BPWM0_BA.
S     */
S    __IO uint32_t SSTRG;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED11
S     * ===================================================================================================
S     * Offset: 0x0118 ~ 0x011C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED11[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_STATUS
S     * ===================================================================================================
S     * Offset: 0x120  BPWM Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTMAX0   |Time-Base Counter 0 Equal To 0xFFFF Latched Status
S     * |        |          |0 = Indicates the time-base counter never reached its maximum value 0xFFFF.
S     * |        |          |1 = Indicates the time-base counter reached its maximum value, software can write 1 to clear
S     * |        |          |this bit.
S     * |[21:16] |ADCTRGn   |ADC Start Of Conversion Status
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can
S     * |        |          |write 1 to clear this bit.
S     */
S    __IO uint32_t STATUS;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED12
S     * ===================================================================================================
S     * Offset: 0x0124 ~ 0x01FC
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED12[55];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_CAPINEN
S     * ===================================================================================================
S     * Offset: 0x200  BPWM Capture Input Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CAPINENn  |Capture Input Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = BPWM Channel capture input path Disabled. The input of BPWM channel capture function
S     * |        |          |is always regarded as 0.
S     * |        |          |1 = BPWM Channel capture input path Enabled. The input of BPWM channel capture function
S     * |        |          |comes from correlative multifunction pin.
S     */
S    __IO uint32_t CAPINEN;
S
S    /**
S     * BPWM_CAPCTL
S     * ===================================================================================================
S     * Offset: 0x204  BPWM Capture Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CAPENn    |Capture Function Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
S     * |        |          |1 = Capture function Enabled. Capture latched the BPWM counter value when detected
S     * |        |          |rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT
S     * |        |          |(Falling latch).
S     * |[13:8]  |CAPINVn   |Capture Inverter Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Capture source inverter Disabled.
S     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S     * |[21:16] |RCRLDENn  |Rising Capture Reload Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Rising capture reload counter Disabled.
S     * |        |          |1 = Rising capture reload counter Enabled.
S     * |[29:24] |FCRLDENn  |Falling Capture Reload Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Falling capture reload counter Disabled.
S     * |        |          |1 = Falling capture reload counter Enabled.
S     */
S    __IO uint32_t CAPCTL;
S
S    /**
S     * BPWM_CAPSTS
S     * ===================================================================================================
S     * Offset: 0x208  BPWM Capture Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CRIFOVn   |Capture Rising Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if rising latch happened when the corresponding CAPRIF is 1.
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CAPRIF.
S     * |[13:8]  |CFIFOVn   |Capture Falling Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if falling latch happened when the corresponding CAPFIF is 1.
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CAPFIF.
S     */
S    __IO uint32_t CAPSTS;
S
S    /**
S     * BPWM_RCAPDAT0
S     * ===================================================================================================
S     * Offset: 0x20C  BPWM Rising Capture Data Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT0;
S
S    /**
S     * BPWM_FCAPDAT0
S     * ===================================================================================================
S     * Offset: 0x210  BPWM Falling Capture Data Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT0;
S
S    /**
S     * BPWM_RCAPDAT1
S     * ===================================================================================================
S     * Offset: 0x214  BPWM Rising Capture Data Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT1;
S
S    /**
S     * BPWM_FCAPDAT1
S     * ===================================================================================================
S     * Offset: 0x218  BPWM Falling Capture Data Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT1;
S
S    /**
S     * BPWM_RCAPDAT2
S     * ===================================================================================================
S     * Offset: 0x21C  BPWM Rising Capture Data Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT2;
S
S    /**
S     * BPWM_FCAPDAT2
S     * ===================================================================================================
S     * Offset: 0x220  BPWM Falling Capture Data Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT2;
S
S    /**
S     * BPWM_RCAPDAT3
S     * ===================================================================================================
S     * Offset: 0x224  BPWM Rising Capture Data Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT3;
S
S    /**
S     * BPWM_FCAPDAT3
S     * ===================================================================================================
S     * Offset: 0x228  BPWM Falling Capture Data Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT3;
S
S
S    /**
S     * BPWM_RCAPDAT4
S     * ===================================================================================================
S     * Offset: 0x22C  BPWM Rising Capture Data Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT4;
S
S    /**
S     * BPWM_FCAPDAT4
S     * ===================================================================================================
S     * Offset: 0x230  BPWM Falling Capture Data Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT4;
S
S    /**
S     * BPWM_RCAPDAT5
S     * ===================================================================================================
S     * Offset: 0x234  BPWM Rising Capture Data Register 5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |BPWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT5;
S
S    /**
S     * BPWM_FCAPDAT5
S     * ===================================================================================================
S     * Offset: 0x238  BPWM Falling Capture Data Register 5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |BPWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the BPWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT5;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED13
S     * ===================================================================================================
S     * Offset: 0x023C ~ 0x024C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED13[5];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_CAPIEN
S     * ===================================================================================================
S     * Offset: 0x250  BPWM Capture Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CAPRIENn  |BPWM Capture Rising Latch Interrupt Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Capture rising edge latch interrupt Disabled.
S     * |        |          |1 = Capture rising edge latch interrupt Enabled.
S     * |[13:8]  |CAPFIENn  |BPWM Capture Falling Latch Interrupt Enable
S     * |        |          |Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = Capture falling edge latch interrupt Disabled.
S     * |        |          |1 = Capture falling edge latch interrupt Enabled.
S     */
S    __IO uint32_t CAPIEN;
S
S
S    /**
S     * BPWM_CAPIF
S     * ===================================================================================================
S     * Offset: 0x254  BPWM Capture Interrupt Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CAPRIFn   |BPWM Capture Rising Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = No capture rising latch condition happened.
S     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S     * |[13:8]  |CAPFIFn   |BPWM Capture Falling Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding BPWM channel n.
S     * |        |          |0 = No capture falling latch condition happened.
S     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S     */
S    __IO uint32_t CAPIF;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED14
S     * ===================================================================================================
S     * Offset: 0x0258 ~ 0x0300
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED14[43];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_PBUF
S     * ===================================================================================================
S     * Offset: 0x304  BPWM PERIOD Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PBUF      |BPWM Period Register Buffer (Read Only)
S     * |        |          |Used as PERIOD active register.
S     */
S    __I  uint32_t PBUF;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED15
S     * ===================================================================================================
S     * Offset: 0x0308 ~ 0x0318
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED15[5];
S    /**
S     * @endcond
S     */
S
S    /**
S     * BPWM_CMPBUF0~5
S     * ===================================================================================================
S     * Offset: 0x31C~0x330  BPWM CMP0~5 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMPBUF    |BPWM Comparator Register Buffer (Read Only)
S     * |        |          |Used as CMP active register.
S     */
S    __I  uint32_t CMPBUF[6];
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED16
S     * ===================================================================================================
S     * Offset: 0x0334 ~ 0x0FFC
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED16[819];
S    /**
S     * @endcond
S     */
S} BPWM_T;
S
S/**
S    @addtogroup BPWM_CONST BPWM Bit Field Definition
S    Constant Definitions for BPWM Controller
S@{ */
S
S#define BPWM_CTL0_CTRLDn_Pos             (0)                                                /*!< BPWM_T::CTL0: CTRLDn Position              */
S#define BPWM_CTL0_CTRLDn_Msk             (0x3ful << BPWM_CTL0_CTRLDn_Pos)                   /*!< BPWM_T::CTL0: CTRLDn Mask                  */
S
S#define BPWM_CTL0_CTRLD0_Pos             (0)                                                /*!< BPWM_T::CTL0: CTRLD0 Position              */
S#define BPWM_CTL0_CTRLD0_Msk             (0x1ul << BPWM_CTL0_CTRLD0_Pos)                    /*!< BPWM_T::CTL0: CTRLD0 Mask                  */
S
S#define BPWM_CTL0_CTRLD1_Pos             (1)                                                /*!< BPWM_T::CTL0: CTRLD1 Position              */
S#define BPWM_CTL0_CTRLD1_Msk             (0x1ul << BPWM_CTL0_CTRLD1_Pos)                    /*!< BPWM_T::CTL0: CTRLD1 Mask                  */
S
S#define BPWM_CTL0_CTRLD2_Pos             (2)                                                /*!< BPWM_T::CTL0: CTRLD2 Position              */
S#define BPWM_CTL0_CTRLD2_Msk             (0x1ul << BPWM_CTL0_CTRLD2_Pos)                    /*!< BPWM_T::CTL0: CTRLD2 Mask                  */
S
S#define BPWM_CTL0_CTRLD3_Pos             (3)                                                /*!< BPWM_T::CTL0: CTRLD3 Position              */
S#define BPWM_CTL0_CTRLD3_Msk             (0x1ul << BPWM_CTL0_CTRLD3_Pos)                    /*!< BPWM_T::CTL0: CTRLD3 Mask                  */
S
S#define BPWM_CTL0_CTRLD4_Pos             (4)                                                /*!< BPWM_T::CTL0: CTRLD4 Position              */
S#define BPWM_CTL0_CTRLD4_Msk             (0x1ul << BPWM_CTL0_CTRLD4_Pos)                    /*!< BPWM_T::CTL0: CTRLD4 Mask                  */
S
S#define BPWM_CTL0_CTRLD5_Pos             (5)                                                /*!< BPWM_T::CTL0: CTRLD5 Position              */
S#define BPWM_CTL0_CTRLD5_Msk             (0x1ul << BPWM_CTL0_CTRLD5_Pos)                    /*!< BPWM_T::CTL0: CTRLD5 Mask                  */
S
S#define BPWM_CTL0_IMMLDENn_Pos           (16)                                               /*!< BPWM_T::CTL0: IMMLDENn Position            */
S#define BPWM_CTL0_IMMLDENn_Msk           (0x3ful << BPWM_CTL0_IMMLDENn_Pos)                 /*!< BPWM_T::CTL0: IMMLDENn Mask                */
S
S#define BPWM_CTL0_IMMLDEN0_Pos           (16)                                               /*!< BPWM_T::CTL0: IMMLDEN0 Position            */
S#define BPWM_CTL0_IMMLDEN0_Msk           (0x1ul << BPWM_CTL0_IMMLDEN0_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN0 Mask                */
S
S#define BPWM_CTL0_IMMLDEN1_Pos           (17)                                               /*!< BPWM_T::CTL0: IMMLDEN1 Position            */
S#define BPWM_CTL0_IMMLDEN1_Msk           (0x1ul << BPWM_CTL0_IMMLDEN1_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN1 Mask                */
S
S#define BPWM_CTL0_IMMLDEN2_Pos           (18)                                               /*!< BPWM_T::CTL0: IMMLDEN2 Position            */
S#define BPWM_CTL0_IMMLDEN2_Msk           (0x1ul << BPWM_CTL0_IMMLDEN2_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN2 Mask                */
S
S#define BPWM_CTL0_IMMLDEN3_Pos           (19)                                               /*!< BPWM_T::CTL0: IMMLDEN3 Position            */
S#define BPWM_CTL0_IMMLDEN3_Msk           (0x1ul << BPWM_CTL0_IMMLDEN3_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN3 Mask                */
S
S#define BPWM_CTL0_IMMLDEN4_Pos           (20)                                               /*!< BPWM_T::CTL0: IMMLDEN4 Position            */
S#define BPWM_CTL0_IMMLDEN4_Msk           (0x1ul << BPWM_CTL0_IMMLDEN4_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN4 Mask                */
S
S#define BPWM_CTL0_IMMLDEN5_Pos           (21)                                               /*!< BPWM_T::CTL0: IMMLDEN5 Position            */
S#define BPWM_CTL0_IMMLDEN5_Msk           (0x1ul << BPWM_CTL0_IMMLDEN5_Pos)                  /*!< BPWM_T::CTL0: IMMLDEN5 Mask                */
S
S#define BPWM_CTL0_DBGHALT_Pos            (30)                                               /*!< BPWM_T::CTL0: DBGHALT Position             */
S#define BPWM_CTL0_DBGHALT_Msk            (0x1ul << BPWM_CTL0_DBGHALT_Pos)                   /*!< BPWM_T::CTL0: DBGHALT Mask                 */
S
S#define BPWM_CTL0_DBGTRIOFF_Pos          (31)                                               /*!< BPWM_T::CTL0: DBGTRIOFF Position           */
S#define BPWM_CTL0_DBGTRIOFF_Msk          (0x1ul << BPWM_CTL0_DBGTRIOFF_Pos)                 /*!< BPWM_T::CTL0: DBGTRIOFF Mask               */
S
S#define BPWM_CTL1_CNTTYPE0_Pos           (0)                                                /*!< BPWM_T::CTL1: CNTTYPE0 Position            */
S#define BPWM_CTL1_CNTTYPE0_Msk           (0x3ul << BPWM_CTL1_CNTTYPE0_Pos)                  /*!< BPWM_T::CTL1: CNTTYPE0 Mask                */
S
S#define BPWM_CLKSRC_ECLKSRC0_Pos         (0)                                                /*!< BPWM_T::CLKSRC: ECLKSRC0 Position          */
S#define BPWM_CLKSRC_ECLKSRC0_Msk         (0x7ul << BPWM_CLKSRC_ECLKSRC0_Pos)                /*!< BPWM_T::CLKSRC: ECLKSRC0 Mask              */
S
S#define BPWM_CLKPSC_CLKPSC_Pos           (0)                                                /*!< BPWM_T::CLKSRC: CLKPSC Position            */
S#define BPWM_CLKPSC_CLKPSC_Msk           (0xffful << BPWM_CLKPSC_CLKPSC_Pos)                /*!< BPWM_T::CLKSRC: CLKPSC Mask                */
S
S#define BPWM_CNTEN_CNTEN0_Pos            (0)                                                /*!< BPWM_T::CNTEN: CNTEN0 Position             */
S#define BPWM_CNTEN_CNTEN0_Msk            (0x1ul << BPWM_CNTEN_CNTEN0_Pos)                   /*!< BPWM_T::CNTEN: CNTEN0 Mask                 */
S
S#define BPWM_CNTCLR_CNTCLR0_Pos          (0)                                                /*!< BPWM_T::CNTCLR: CNTCLR0 Position           */
S#define BPWM_CNTCLR_CNTCLR0_Msk          (0x1ul << BPWM_CNTCLR_CNTCLR0_Pos)                 /*!< BPWM_T::CNTCLR: CNTCLR0 Mask               */
S
S#define BPWM_PERIOD_PERIOD_Pos           (0)                                                /*!< BPWM_T::PERIOD: PERIOD Position            */
S#define BPWM_PERIOD_PERIOD_Msk           (0xfffful << BPWM_PERIOD_PERIOD_Pos)               /*!< BPWM_T::PERIOD: PERIOD Mask                */
S
S#define BPWM_CMPDAT_CMP_Pos              (0)                                                /*!< BPWM_T::CMPDAT: CMP Position               */
S#define BPWM_CMPDAT_CMP_Msk              (0xfffful << BPWM_CMPDAT_CMP_Pos)                  /*!< BPWM_T::CMPDAT: CMP Mask                   */
S
S#define BPWM_CNT_CNT_Pos                 (0)                                                /*!< BPWM_T::CNT: CNT Position                  */
S#define BPWM_CNT_CNT_Msk                 (0xfffful << BPWM_CNT_CNT_Pos)                     /*!< BPWM_T::CNT: CNT Mask                      */
S
S#define BPWM_CNT_DIRF_Pos                (16)                                               /*!< BPWM_T::CNT: DIRF Position                 */
S#define BPWM_CNT_DIRF_Msk                (0x1ul << BPWM_CNT_DIRF_Pos)                       /*!< BPWM_T::CNT: DIRF Mask                     */
S
S#define BPWM_WGCTL0_ZPCTLn_Pos           (0)                                                /*!< BPWM_T::WGCTL0: ZPCTLn Position            */
S#define BPWM_WGCTL0_ZPCTLn_Msk           (0xffful << BPWM_WGCTL0_ZPCTLn_Pos)                /*!< BPWM_T::WGCTL0: ZPCTLn Mask                */
S
S#define BPWM_WGCTL0_ZPCTL0_Pos           (0)                                                /*!< BPWM_T::WGCTL0: ZPCTL0 Position            */
S#define BPWM_WGCTL0_ZPCTL0_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL0_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL0 Mask                */
S
S#define BPWM_WGCTL0_ZPCTL1_Pos           (2)                                                /*!< BPWM_T::WGCTL0: ZPCTL1 Position            */
S#define BPWM_WGCTL0_ZPCTL1_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL1_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL1 Mask                */
S
S#define BPWM_WGCTL0_ZPCTL2_Pos           (4)                                                /*!< BPWM_T::WGCTL0: ZPCTL2 Position            */
S#define BPWM_WGCTL0_ZPCTL2_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL2_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL2 Mask                */
S
S#define BPWM_WGCTL0_ZPCTL3_Pos           (6)                                                /*!< BPWM_T::WGCTL0: ZPCTL3 Position            */
S#define BPWM_WGCTL0_ZPCTL3_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL3_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL3 Mask                */
S
S#define BPWM_WGCTL0_ZPCTL4_Pos           (8)                                                /*!< BPWM_T::WGCTL0: ZPCTL4 Position            */
S#define BPWM_WGCTL0_ZPCTL4_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL4_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL4 Mask                */
S
S#define BPWM_WGCTL0_ZPCTL5_Pos           (10)                                               /*!< BPWM_T::WGCTL0: ZPCTL5 Position            */
S#define BPWM_WGCTL0_ZPCTL5_Msk           (0x3ul << BPWM_WGCTL0_ZPCTL5_Pos)                  /*!< BPWM_T::WGCTL0: ZPCTL5 Mask                */
S
S#define BPWM_WGCTL0_PRDPCTLn_Pos         (16)                                               /*!< BPWM_T::WGCTL0: PRDPCTLn Position          */
S#define BPWM_WGCTL0_PRDPCTLn_Msk         (0xffful << BPWM_WGCTL0_PRDPCTLn_Pos)              /*!< BPWM_T::WGCTL0: PRDPCTLn Mask              */
S
S#define BPWM_WGCTL0_PRDPCTL0_Pos         (16)                                               /*!< BPWM_T::WGCTL0: PRDPCTL0 Position          */
S#define BPWM_WGCTL0_PRDPCTL0_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL0_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL0 Mask              */
S
S#define BPWM_WGCTL0_PRDPCTL1_Pos         (18)                                               /*!< BPWM_T::WGCTL0: PRDPCTL1 Position          */
S#define BPWM_WGCTL0_PRDPCTL1_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL1_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL1 Mask              */
S
S#define BPWM_WGCTL0_PRDPCTL2_Pos         (20)                                               /*!< BPWM_T::WGCTL0: PRDPCTL2 Position          */
S#define BPWM_WGCTL0_PRDPCTL2_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL2_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL2 Mask              */
S
S#define BPWM_WGCTL0_PRDPCTL3_Pos         (22)                                               /*!< BPWM_T::WGCTL0: PRDPCTL3 Position          */
S#define BPWM_WGCTL0_PRDPCTL3_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL3_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL3 Mask              */
S
S#define BPWM_WGCTL0_PRDPCTL4_Pos         (24)                                               /*!< BPWM_T::WGCTL0: PRDPCTL4 Position          */
S#define BPWM_WGCTL0_PRDPCTL4_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL4_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL4 Mask              */
S
S#define BPWM_WGCTL0_PRDPCTL5_Pos         (26)                                               /*!< BPWM_T::WGCTL0: PRDPCTL5 Position          */
S#define BPWM_WGCTL0_PRDPCTL5_Msk         (0x3ul << BPWM_WGCTL0_PRDPCTL5_Pos)                /*!< BPWM_T::WGCTL0: PRDPCTL5 Mask              */
S
S#define BPWM_WGCTL1_CMPUCTLn_Pos         (0)                                                /*!< BPWM_T::WGCTL1: CMPUCTLn Position          */
S#define BPWM_WGCTL1_CMPUCTLn_Msk         (0xffful << BPWM_WGCTL1_CMPUCTLn_Pos)              /*!< BPWM_T::WGCTL1: CMPUCTLn Mask              */
S
S#define BPWM_WGCTL1_CMPUCTL0_Pos         (0)                                                /*!< BPWM_T::WGCTL1: CMPUCTL0 Position          */
S#define BPWM_WGCTL1_CMPUCTL0_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL0_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL0 Mask              */
S
S#define BPWM_WGCTL1_CMPUCTL1_Pos         (2)                                                /*!< BPWM_T::WGCTL1: CMPUCTL1 Position          */
S#define BPWM_WGCTL1_CMPUCTL1_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL1_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL1 Mask              */
S
S#define BPWM_WGCTL1_CMPUCTL2_Pos         (4)                                                /*!< BPWM_T::WGCTL1: CMPUCTL2 Position          */
S#define BPWM_WGCTL1_CMPUCTL2_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL2_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL2 Mask              */
S
S#define BPWM_WGCTL1_CMPUCTL3_Pos         (6)                                                /*!< BPWM_T::WGCTL1: CMPUCTL3 Position          */
S#define BPWM_WGCTL1_CMPUCTL3_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL3_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL3 Mask              */
S
S#define BPWM_WGCTL1_CMPUCTL4_Pos         (8)                                                /*!< BPWM_T::WGCTL1: CMPUCTL4 Position          */
S#define BPWM_WGCTL1_CMPUCTL4_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL4_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL4 Mask              */
S
S#define BPWM_WGCTL1_CMPUCTL5_Pos         (10)                                               /*!< BPWM_T::WGCTL1: CMPUCTL5 Position          */
S#define BPWM_WGCTL1_CMPUCTL5_Msk         (0x3ul << BPWM_WGCTL1_CMPUCTL5_Pos)                /*!< BPWM_T::WGCTL1: CMPUCTL5 Mask              */
S
S#define BPWM_WGCTL1_CMPDCTLn_Pos         (16)                                               /*!< BPWM_T::WGCTL1: CMPDCTLn Position          */
S#define BPWM_WGCTL1_CMPDCTLn_Msk         (0xffful << BPWM_WGCTL1_CMPDCTLn_Pos)              /*!< BPWM_T::WGCTL1: CMPDCTLn Mask              */
S
S#define BPWM_WGCTL1_CMPDCTL0_Pos         (16)                                               /*!< BPWM_T::WGCTL1: CMPDCTL0 Position          */
S#define BPWM_WGCTL1_CMPDCTL0_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL0_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL0 Mask              */
S
S#define BPWM_WGCTL1_CMPDCTL1_Pos         (18)                                               /*!< BPWM_T::WGCTL1: CMPDCTL1 Position          */
S#define BPWM_WGCTL1_CMPDCTL1_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL1_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL1 Mask              */
S
S#define BPWM_WGCTL1_CMPDCTL2_Pos         (20)                                               /*!< BPWM_T::WGCTL1: CMPDCTL2 Position          */
S#define BPWM_WGCTL1_CMPDCTL2_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL2_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL2 Mask              */
S
S#define BPWM_WGCTL1_CMPDCTL3_Pos         (22)                                               /*!< BPWM_T::WGCTL1: CMPDCTL3 Position          */
S#define BPWM_WGCTL1_CMPDCTL3_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL3_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL3 Mask              */
S
S#define BPWM_WGCTL1_CMPDCTL4_Pos         (24)                                               /*!< BPWM_T::WGCTL1: CMPDCTL4 Position          */
S#define BPWM_WGCTL1_CMPDCTL4_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL4_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL4 Mask              */
S
S#define BPWM_WGCTL1_CMPDCTL5_Pos         (26)                                               /*!< BPWM_T::WGCTL1: CMPDCTL5 Position          */
S#define BPWM_WGCTL1_CMPDCTL5_Msk         (0x3ul << BPWM_WGCTL1_CMPDCTL5_Pos)                /*!< BPWM_T::WGCTL1: CMPDCTL5 Mask              */
S
S#define BPWM_MSKEN_MSKENn_Pos            (0)                                                /*!< BPWM_T::MSKEN: MSKENn Position             */
S#define BPWM_MSKEN_MSKENn_Msk            (0x3ful << BPWM_MSKEN_MSKENn_Pos)                  /*!< BPWM_T::MSKEN: MSKENn Mask                 */
S
S#define BPWM_MSKEN_MSKEN0_Pos            (0)                                                /*!< BPWM_T::MSKEN: MSKEN0 Position             */
S#define BPWM_MSKEN_MSKEN0_Msk            (0x1ul << BPWM_MSKEN_MSKEN0_Pos)                   /*!< BPWM_T::MSKEN: MSKEN0 Mask                 */
S
S#define BPWM_MSKEN_MSKEN1_Pos            (1)                                                /*!< BPWM_T::MSKEN: MSKEN1 Position             */
S#define BPWM_MSKEN_MSKEN1_Msk            (0x1ul << BPWM_MSKEN_MSKEN1_Pos)                   /*!< BPWM_T::MSKEN: MSKEN1 Mask                 */
S
S#define BPWM_MSKEN_MSKEN2_Pos            (2)                                                /*!< BPWM_T::MSKEN: MSKEN2 Position             */
S#define BPWM_MSKEN_MSKEN2_Msk            (0x1ul << BPWM_MSKEN_MSKEN2_Pos)                   /*!< BPWM_T::MSKEN: MSKEN2 Mask                 */
S
S#define BPWM_MSKEN_MSKEN3_Pos            (3)                                                /*!< BPWM_T::MSKEN: MSKEN3 Position             */
S#define BPWM_MSKEN_MSKEN3_Msk            (0x1ul << BPWM_MSKEN_MSKEN3_Pos)                   /*!< BPWM_T::MSKEN: MSKEN3 Mask                 */
S
S#define BPWM_MSKEN_MSKEN4_Pos            (4)                                                /*!< BPWM_T::MSKEN: MSKEN4 Position             */
S#define BPWM_MSKEN_MSKEN4_Msk            (0x1ul << BPWM_MSKEN_MSKEN4_Pos)                   /*!< BPWM_T::MSKEN: MSKEN4 Mask                 */
S
S#define BPWM_MSKEN_MSKEN5_Pos            (5)                                                /*!< BPWM_T::MSKEN: MSKEN5 Position             */
S#define BPWM_MSKEN_MSKEN5_Msk            (0x1ul << BPWM_MSKEN_MSKEN5_Pos)                   /*!< BPWM_T::MSKEN: MSKEN5 Mask                 */
S
S#define BPWM_MSK_MSKDATn_Pos             (0)                                                /*!< BPWM_T::MSK: MSKDATn Position              */
S#define BPWM_MSK_MSKDATn_Msk             (0x3ful << BPWM_MSK_MSKDATn_Pos)                   /*!< BPWM_T::MSK: MSKDATn Mask                  */
S
S#define BPWM_MSK_MSKDAT0_Pos             (0)                                                /*!< BPWM_T::MSK: MSKDAT0 Position              */
S#define BPWM_MSK_MSKDAT0_Msk             (0x1ul << BPWM_MSK_MSKDAT0_Pos)                    /*!< BPWM_T::MSK: MSKDAT0 Mask                  */
S
S#define BPWM_MSK_MSKDAT1_Pos             (1)                                                /*!< BPWM_T::MSK: MSKDAT1 Position              */
S#define BPWM_MSK_MSKDAT1_Msk             (0x1ul << BPWM_MSK_MSKDAT1_Pos)                    /*!< BPWM_T::MSK: MSKDAT1 Mask                  */
S
S#define BPWM_MSK_MSKDAT2_Pos             (2)                                                /*!< BPWM_T::MSK: MSKDAT2 Position              */
S#define BPWM_MSK_MSKDAT2_Msk             (0x1ul << BPWM_MSK_MSKDAT2_Pos)                    /*!< BPWM_T::MSK: MSKDAT2 Mask                  */
S
S#define BPWM_MSK_MSKDAT3_Pos             (3)                                                /*!< BPWM_T::MSK: MSKDAT3 Position              */
S#define BPWM_MSK_MSKDAT3_Msk             (0x1ul << BPWM_MSK_MSKDAT3_Pos)                    /*!< BPWM_T::MSK: MSKDAT3 Mask                  */
S
S#define BPWM_MSK_MSKDAT4_Pos             (4)                                                /*!< BPWM_T::MSK: MSKDAT4 Position              */
S#define BPWM_MSK_MSKDAT4_Msk             (0x1ul << BPWM_MSK_MSKDAT4_Pos)                    /*!< BPWM_T::MSK: MSKDAT4 Mask                  */
S
S#define BPWM_MSK_MSKDAT5_Pos             (5)                                                /*!< BPWM_T::MSK: MSKDAT5 Position              */
S#define BPWM_MSK_MSKDAT5_Msk             (0x1ul << BPWM_MSK_MSKDAT5_Pos)                    /*!< BPWM_T::MSK: MSKDAT5 Mask                  */
S
S#define BPWM_POLCTL_PINVn_Pos            (0)                                                /*!< BPWM_T::POLCTL: PINVn Position             */
S#define BPWM_POLCTL_PINVn_Msk            (0x3ful << BPWM_POLCTL_PINVn_Pos)                  /*!< BPWM_T::POLCTL: PINVn Mask                 */
S
S#define BPWM_POLCTL_PINV0_Pos            (0)                                                /*!< BPWM_T::POLCTL: PINV0 Position             */
S#define BPWM_POLCTL_PINV0_Msk            (0x1ul << BPWM_POLCTL_PINV0_Pos)                   /*!< BPWM_T::POLCTL: PINV0 Mask                 */
S
S#define BPWM_POLCTL_PINV1_Pos            (1)                                                /*!< BPWM_T::POLCTL: PINV1 Position             */
S#define BPWM_POLCTL_PINV1_Msk            (0x1ul << BPWM_POLCTL_PINV1_Pos)                   /*!< BPWM_T::POLCTL: PINV1 Mask                 */
S
S#define BPWM_POLCTL_PINV2_Pos            (2)                                                /*!< BPWM_T::POLCTL: PINV2 Position             */
S#define BPWM_POLCTL_PINV2_Msk            (0x1ul << BPWM_POLCTL_PINV2_Pos)                   /*!< BPWM_T::POLCTL: PINV2 Mask                 */
S
S#define BPWM_POLCTL_PINV3_Pos            (3)                                                /*!< BPWM_T::POLCTL: PINV3 Position             */
S#define BPWM_POLCTL_PINV3_Msk            (0x1ul << BPWM_POLCTL_PINV3_Pos)                   /*!< BPWM_T::POLCTL: PINV3 Mask                 */
S
S#define BPWM_POLCTL_PINV4_Pos            (4)                                                /*!< BPWM_T::POLCTL: PINV4 Position             */
S#define BPWM_POLCTL_PINV4_Msk            (0x1ul << BPWM_POLCTL_PINV4_Pos)                   /*!< BPWM_T::POLCTL: PINV4 Mask                 */
S
S#define BPWM_POLCTL_PINV5_Pos            (5)                                                /*!< BPWM_T::POLCTL: PINV5 Position             */
S#define BPWM_POLCTL_PINV5_Msk            (0x1ul << BPWM_POLCTL_PINV5_Pos)                   /*!< BPWM_T::POLCTL: PINV5 Mask                 */
S
S#define BPWM_POEN_POENn_Pos              (0)                                                /*!< BPWM_T::POEN: POENn Position               */
S#define BPWM_POEN_POENn_Msk              (0x3ful << BPWM_POEN_POENn_Pos)                    /*!< BPWM_T::POEN: POENn Mask                   */
S
S#define BPWM_POEN_POEN0_Pos              (0)                                                /*!< BPWM_T::POEN: POEN0 Position               */
S#define BPWM_POEN_POEN0_Msk              (0x1ul << BPWM_POEN_POEN0_Pos)                     /*!< BPWM_T::POEN: POEN0 Mask                   */
S
S#define BPWM_POEN_POEN1_Pos              (1)                                                /*!< BPWM_T::POEN: POEN1 Position               */
S#define BPWM_POEN_POEN1_Msk              (0x1ul << BPWM_POEN_POEN1_Pos)                     /*!< BPWM_T::POEN: POEN1 Mask                   */
S
S#define BPWM_POEN_POEN2_Pos              (2)                                                /*!< BPWM_T::POEN: POEN2 Position               */
S#define BPWM_POEN_POEN2_Msk              (0x1ul << BPWM_POEN_POEN2_Pos)                     /*!< BPWM_T::POEN: POEN2 Mask                   */
S
S#define BPWM_POEN_POEN3_Pos              (3)                                                /*!< BPWM_T::POEN: POEN3 Position               */
S#define BPWM_POEN_POEN3_Msk              (0x1ul << BPWM_POEN_POEN3_Pos)                     /*!< BPWM_T::POEN: POEN3 Mask                   */
S
S#define BPWM_POEN_POEN4_Pos              (4)                                                /*!< BPWM_T::POEN: POEN4 Position               */
S#define BPWM_POEN_POEN4_Msk              (0x1ul << BPWM_POEN_POEN4_Pos)                     /*!< BPWM_T::POEN: POEN4 Mask                   */
S
S#define BPWM_POEN_POEN5_Pos              (5)                                                /*!< BPWM_T::POEN: POEN5 Position               */
S#define BPWM_POEN_POEN5_Msk              (0x1ul << BPWM_POEN_POEN5_Pos)                     /*!< BPWM_T::POEN: POEN5 Mask                   */
S
S#define BPWM_INTEN_ZIEN0_Pos             (0)                                                /*!< BPWM_T::INTEN: ZIEN0 Position              */
S#define BPWM_INTEN_ZIEN0_Msk             (0x1ul << BPWM_INTEN_ZIEN0_Pos)                    /*!< BPWM_T::INTEN: ZIEN0 Mask                  */
S
S#define BPWM_INTEN_PIEN0_Pos             (8)                                                /*!< BPWM_T::INTEN: PIEN0 Position              */
S#define BPWM_INTEN_PIEN0_Msk             (0x1ul << BPWM_INTEN_PIEN0_Pos)                    /*!< BPWM_T::INTEN: PIEN0 Mask                  */
S
S#define BPWM_INTEN_CMPUIENn_Pos          (16)                                               /*!< BPWM_T::INTEN: CMPUIENn Position           */
S#define BPWM_INTEN_CMPUIENn_Msk          (0x3ful << BPWM_INTEN_CMPUIENn_Pos)                /*!< BPWM_T::INTEN: CMPUIENn Mask               */
S
S#define BPWM_INTEN_CMPUIEN0_Pos          (16)                                               /*!< BPWM_T::INTEN: CMPUIEN0 Position           */
S#define BPWM_INTEN_CMPUIEN0_Msk          (0x1ul << BPWM_INTEN_CMPUIEN0_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN0 Mask               */
S
S#define BPWM_INTEN_CMPUIEN1_Pos          (17)                                               /*!< BPWM_T::INTEN: CMPUIEN1 Position           */
S#define BPWM_INTEN_CMPUIEN1_Msk          (0x1ul << BPWM_INTEN_CMPUIEN1_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN1 Mask               */
S
S#define BPWM_INTEN_CMPUIEN2_Pos          (18)                                               /*!< BPWM_T::INTEN: CMPUIEN2 Position           */
S#define BPWM_INTEN_CMPUIEN2_Msk          (0x1ul << BPWM_INTEN_CMPUIEN2_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN2 Mask               */
S
S#define BPWM_INTEN_CMPUIEN3_Pos          (19)                                               /*!< BPWM_T::INTEN: CMPUIEN3 Position           */
S#define BPWM_INTEN_CMPUIEN3_Msk          (0x1ul << BPWM_INTEN_CMPUIEN3_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN3 Mask               */
S
S#define BPWM_INTEN_CMPUIEN4_Pos          (20)                                               /*!< BPWM_T::INTEN: CMPUIEN4 Position           */
S#define BPWM_INTEN_CMPUIEN4_Msk          (0x1ul << BPWM_INTEN_CMPUIEN4_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN4 Mask               */
S
S#define BPWM_INTEN_CMPUIEN5_Pos          (21)                                               /*!< BPWM_T::INTEN: CMPUIEN5 Position           */
S#define BPWM_INTEN_CMPUIEN5_Msk          (0x1ul << BPWM_INTEN_CMPUIEN5_Pos)                 /*!< BPWM_T::INTEN: CMPUIEN5 Mask               */
S
S#define BPWM_INTEN_CMPDIENn_Pos          (24)                                               /*!< BPWM_T::INTEN: CMPDIENn Position           */
S#define BPWM_INTEN_CMPDIENn_Msk          (0x3ful << BPWM_INTEN_CMPDIENn_Pos)                /*!< BPWM_T::INTEN: CMPDIENn Mask               */
S
S#define BPWM_INTEN_CMPDIEN0_Pos          (24)                                               /*!< BPWM_T::INTEN: CMPDIEN0 Position           */
S#define BPWM_INTEN_CMPDIEN0_Msk          (0x1ul << BPWM_INTEN_CMPDIEN0_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN0 Mask               */
S
S#define BPWM_INTEN_CMPDIEN1_Pos          (25)                                               /*!< BPWM_T::INTEN: CMPDIEN1 Position           */
S#define BPWM_INTEN_CMPDIEN1_Msk          (0x1ul << BPWM_INTEN_CMPDIEN1_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN1 Mask               */
S
S#define BPWM_INTEN_CMPDIEN2_Pos          (26)                                               /*!< BPWM_T::INTEN: CMPDIEN2 Position           */
S#define BPWM_INTEN_CMPDIEN2_Msk          (0x1ul << BPWM_INTEN_CMPDIEN2_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN2 Mask               */
S
S#define BPWM_INTEN_CMPDIEN3_Pos          (27)                                               /*!< BPWM_T::INTEN: CMPDIEN3 Position           */
S#define BPWM_INTEN_CMPDIEN3_Msk          (0x1ul << BPWM_INTEN_CMPDIEN3_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN3 Mask               */
S
S#define BPWM_INTEN_CMPDIEN4_Pos          (28)                                               /*!< BPWM_T::INTEN: CMPDIEN4 Position           */
S#define BPWM_INTEN_CMPDIEN4_Msk          (0x1ul << BPWM_INTEN_CMPDIEN4_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN4 Mask               */
S
S#define BPWM_INTEN_CMPDIEN5_Pos          (29)                                               /*!< BPWM_T::INTEN: CMPDIEN5 Position           */
S#define BPWM_INTEN_CMPDIEN5_Msk          (0x1ul << BPWM_INTEN_CMPDIEN5_Pos)                 /*!< BPWM_T::INTEN: CMPDIEN5 Mask               */
S
S#define BPWM_INTSTS_ZIF0_Pos             (0)                                                /*!< BPWM_T::INTSTS: ZIF0 Position              */
S#define BPWM_INTSTS_ZIF0_Msk             (0x1ul << BPWM_INTSTS_ZIF0_Pos)                    /*!< BPWM_T::INTSTS: ZIF0 Mask                  */
S
S#define BPWM_INTSTS_PIF0_Pos             (8)                                                /*!< BPWM_T::INTSTS: PIF0 Position              */
S#define BPWM_INTSTS_PIF0_Msk             (0x1ul << BPWM_INTSTS_PIF0_Pos)                    /*!< BPWM_T::INTSTS: PIF0 Mask                  */
S
S#define BPWM_INTSTS_CMPUIFn_Pos          (16)                                               /*!< BPWM_T::INTSTS: CMPUIFn Position           */
S#define BPWM_INTSTS_CMPUIFn_Msk          (0x3ful << BPWM_INTSTS_CMPUIFn_Pos)                /*!< BPWM_T::INTSTS: CMPUIFn Mask               */
S
S#define BPWM_INTSTS_CMPUIF0_Pos          (16)                                               /*!< BPWM_T::INTSTS: CMPUIF0 Position           */
S#define BPWM_INTSTS_CMPUIF0_Msk          (0x1ul << BPWM_INTSTS_CMPUIF0_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF0 Mask               */
S
S#define BPWM_INTSTS_CMPUIF1_Pos          (17)                                               /*!< BPWM_T::INTSTS: CMPUIF1 Position           */
S#define BPWM_INTSTS_CMPUIF1_Msk          (0x1ul << BPWM_INTSTS_CMPUIF1_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF1 Mask               */
S
S#define BPWM_INTSTS_CMPUIF2_Pos          (18)                                               /*!< BPWM_T::INTSTS: CMPUIF2 Position           */
S#define BPWM_INTSTS_CMPUIF2_Msk          (0x1ul << BPWM_INTSTS_CMPUIF2_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF2 Mask               */
S
S#define BPWM_INTSTS_CMPUIF3_Pos          (19)                                               /*!< BPWM_T::INTSTS: CMPUIF3 Position           */
S#define BPWM_INTSTS_CMPUIF3_Msk          (0x1ul << BPWM_INTSTS_CMPUIF3_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF3 Mask               */
S
S#define BPWM_INTSTS_CMPUIF4_Pos          (20)                                               /*!< BPWM_T::INTSTS: CMPUIF4 Position           */
S#define BPWM_INTSTS_CMPUIF4_Msk          (0x1ul << BPWM_INTSTS_CMPUIF4_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF4 Mask               */
S
S#define BPWM_INTSTS_CMPUIF5_Pos          (21)                                               /*!< BPWM_T::INTSTS: CMPUIF5 Position           */
S#define BPWM_INTSTS_CMPUIF5_Msk          (0x1ul << BPWM_INTSTS_CMPUIF5_Pos)                 /*!< BPWM_T::INTSTS: CMPUIF5 Mask               */
S
S#define BPWM_INTSTS_CMPDIFn_Pos          (24)                                               /*!< BPWM_T::INTSTS: CMPDIFn Position           */
S#define BPWM_INTSTS_CMPDIFn_Msk          (0x3ful << BPWM_INTSTS_CMPDIFn_Pos)                /*!< BPWM_T::INTSTS: CMPDIFn Mask               */
S
S#define BPWM_INTSTS_CMPDIF0_Pos          (24)                                               /*!< BPWM_T::INTSTS: CMPDIF0 Position           */
S#define BPWM_INTSTS_CMPDIF0_Msk          (0x1ul << BPWM_INTSTS_CMPDIF0_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF0 Mask               */
S
S#define BPWM_INTSTS_CMPDIF1_Pos          (25)                                               /*!< BPWM_T::INTSTS: CMPDIF1 Position           */
S#define BPWM_INTSTS_CMPDIF1_Msk          (0x1ul << BPWM_INTSTS_CMPDIF1_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF1 Mask               */
S
S#define BPWM_INTSTS_CMPDIF2_Pos          (26)                                               /*!< BPWM_T::INTSTS: CMPDIF2 Position           */
S#define BPWM_INTSTS_CMPDIF2_Msk          (0x1ul << BPWM_INTSTS_CMPDIF2_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF2 Mask               */
S
S#define BPWM_INTSTS_CMPDIF3_Pos          (27)                                               /*!< BPWM_T::INTSTS: CMPDIF3 Position           */
S#define BPWM_INTSTS_CMPDIF3_Msk          (0x1ul << BPWM_INTSTS_CMPDIF3_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF3 Mask               */
S
S#define BPWM_INTSTS_CMPDIF4_Pos          (28)                                               /*!< BPWM_T::INTSTS: CMPDIF4 Position           */
S#define BPWM_INTSTS_CMPDIF4_Msk          (0x1ul << BPWM_INTSTS_CMPDIF4_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF4 Mask               */
S
S#define BPWM_INTSTS_CMPDIF5_Pos          (29)                                               /*!< BPWM_T::INTSTS: CMPDIF5 Position           */
S#define BPWM_INTSTS_CMPDIF5_Msk          (0x1ul << BPWM_INTSTS_CMPDIF5_Pos)                 /*!< BPWM_T::INTSTS: CMPDIF5 Mask               */
S
S#define BPWM_ADCTS0_TRGSEL0_Pos          (0)                                                /*!< BPWM_T::ADCTS0: TRGSEL0 Position           */
S#define BPWM_ADCTS0_TRGSEL0_Msk          (0xful << BPWM_ADCTS0_TRGSEL0_Pos)                 /*!< BPWM_T::ADCTS0: TRGSEL0 Mask               */
S
S#define BPWM_ADCTS0_TRGEN0_Pos           (7)                                                /*!< BPWM_T::ADCTS0: TRGEN0 Position            */
S#define BPWM_ADCTS0_TRGEN0_Msk           (0x1ul << BPWM_ADCTS0_TRGEN0_Pos)                  /*!< BPWM_T::ADCTS0: TRGEN0 Mask                */
S
S#define BPWM_ADCTS0_TRGSEL1_Pos          (8)                                                /*!< BPWM_T::ADCTS0: TRGSEL1 Position           */
S#define BPWM_ADCTS0_TRGSEL1_Msk          (0xful << BPWM_ADCTS0_TRGSEL1_Pos)                 /*!< BPWM_T::ADCTS0: TRGSEL1 Mask               */
S
S#define BPWM_ADCTS0_TRGEN1_Pos           (15)                                               /*!< BPWM_T::ADCTS0: TRGEN1 Position            */
S#define BPWM_ADCTS0_TRGEN1_Msk           (0x1ul << BPWM_ADCTS0_TRGEN1_Pos)                  /*!< BPWM_T::ADCTS0: TRGEN1 Mask                */
S
S#define BPWM_ADCTS0_TRGSEL2_Pos          (16)                                               /*!< BPWM_T::ADCTS0: TRGSEL2 Position           */
S#define BPWM_ADCTS0_TRGSEL2_Msk          (0xful << BPWM_ADCTS0_TRGSEL2_Pos)                 /*!< BPWM_T::ADCTS0: TRGSEL2 Mask               */
S
S#define BPWM_ADCTS0_TRGEN2_Pos           (23)                                               /*!< BPWM_T::ADCTS0: TRGEN2 Position            */
S#define BPWM_ADCTS0_TRGEN2_Msk           (0x1ul << BPWM_ADCTS0_TRGEN2_Pos)                  /*!< BPWM_T::ADCTS0: TRGEN2 Mask                */
S
S#define BPWM_ADCTS0_TRGSEL3_Pos          (24)                                               /*!< BPWM_T::ADCTS0: TRGSEL3 Position           */
S#define BPWM_ADCTS0_TRGSEL3_Msk          (0xful << BPWM_ADCTS0_TRGSEL3_Pos)                 /*!< BPWM_T::ADCTS0: TRGSEL3 Mask               */
S
S#define BPWM_ADCTS0_TRGEN3_Pos           (31)                                               /*!< BPWM_T::ADCTS0: TRGEN3 Position            */
S#define BPWM_ADCTS0_TRGEN3_Msk           (0x1ul << BPWM_ADCTS0_TRGEN3_Pos)                  /*!< BPWM_T::ADCTS0: TRGEN3 Mask                */
S
S#define BPWM_ADCTS1_TRGSEL4_Pos          (0)                                                /*!< BPWM_T::ADCTS1: TRGSEL4 Position           */
S#define BPWM_ADCTS1_TRGSEL4_Msk          (0xful << BPWM_ADCTS1_TRGSEL4_Pos)                 /*!< BPWM_T::ADCTS1: TRGSEL4 Mask               */
S
S#define BPWM_ADCTS1_TRGEN4_Pos           (7)                                                /*!< BPWM_T::ADCTS1: TRGEN4 Position            */
S#define BPWM_ADCTS1_TRGEN4_Msk           (0x1ul << BPWM_ADCTS1_TRGEN4_Pos)                  /*!< BPWM_T::ADCTS1: TRGEN4 Mask                */
S
S#define BPWM_ADCTS1_TRGSEL5_Pos          (8)                                                /*!< BPWM_T::ADCTS1: TRGSEL5 Position           */
S#define BPWM_ADCTS1_TRGSEL5_Msk          (0xful << BPWM_ADCTS1_TRGSEL5_Pos)                 /*!< BPWM_T::ADCTS1: TRGSEL5 Mask               */
S
S#define BPWM_ADCTS1_TRGEN5_Pos           (15)                                               /*!< BPWM_T::ADCTS1: TRGEN5 Position            */
S#define BPWM_ADCTS1_TRGEN5_Msk           (0x1ul << BPWM_ADCTS1_TRGEN5_Pos)                  /*!< BPWM_T::ADCTS1: TRGEN5 Mask                */
S
S#define BPWM_SSCTL_SSEN0_Pos             (0)                                                /*!< BPWM_T::SSCTL: SSEN0 Position              */
S#define BPWM_SSCTL_SSEN0_Msk             (0x1ul << BPWM_SSCTL_SSEN0_Pos)                    /*!< BPWM_T::SSCTL: SSEN0 Mask                  */
S
S#define BPWM_SSCTL_SSRC_Pos              (8)                                                /*!< BPWM_T::SSCTL: SSRC Position               */
S#define BPWM_SSCTL_SSRC_Msk              (0x3ul << BPWM_SSCTL_SSRC_Pos)                     /*!< BPWM_T::SSCTL: SSRC Mask                   */
S
S#define BPWM_SSTRG_CNTSEN_Pos            (0)                                                /*!< BPWM_T::SSTRG: CNTSEN Position             */
S#define BPWM_SSTRG_CNTSEN_Msk            (0x1ul << BPWM_SSTRG_CNTSEN_Pos)                   /*!< BPWM_T::SSTRG: CNTSEN Mask                 */
S
S#define BPWM_STATUS_CNTMAXF0_Pos         (0)                                                /*!< BPWM_T::STATUS: CNTMAXF0 Position          */
S#define BPWM_STATUS_CNTMAXF0_Msk         (0x1ul << BPWM_STATUS_CNTMAXF0_Pos)                /*!< BPWM_T::STATUS: CNTMAXF0 Mask              */
S
S#define BPWM_STATUS_ADCTRGFn_Pos         (16)                                               /*!< BPWM_T::STATUS: ADCTRGFn Position          */
S#define BPWM_STATUS_ADCTRGFn_Msk         (0x3ful << BPWM_STATUS_ADCTRGFn_Pos)               /*!< BPWM_T::STATUS: ADCTRGFn Mask              */
S
S#define BPWM_STATUS_ADCTRGF0_Pos         (16)                                               /*!< BPWM_T::STATUS: ADCTRGF0 Position          */
S#define BPWM_STATUS_ADCTRGF0_Msk         (0x1ul << BPWM_STATUS_ADCTRGF0_Pos)                /*!< BPWM_T::STATUS: ADCTRGF0 Mask              */
S
S#define BPWM_STATUS_ADCTRGF1_Pos         (17)                                               /*!< BPWM_T::STATUS: ADCTRGF1 Position          */
S#define BPWM_STATUS_ADCTRGF1_Msk         (0x1ul << BPWM_STATUS_ADCTRGF1_Pos)                /*!< BPWM_T::STATUS: ADCTRGF1 Mask              */
S
S#define BPWM_STATUS_ADCTRGF2_Pos         (18)                                               /*!< BPWM_T::STATUS: ADCTRGF2 Position          */
S#define BPWM_STATUS_ADCTRGF2_Msk         (0x1ul << BPWM_STATUS_ADCTRGF2_Pos)                /*!< BPWM_T::STATUS: ADCTRGF2 Mask              */
S
S#define BPWM_STATUS_ADCTRGF3_Pos         (19)                                               /*!< BPWM_T::STATUS: ADCTRGF3 Position          */
S#define BPWM_STATUS_ADCTRGF3_Msk         (0x1ul << BPWM_STATUS_ADCTRGF3_Pos)                /*!< BPWM_T::STATUS: ADCTRGF3 Mask              */
S
S#define BPWM_STATUS_ADCTRGF4_Pos         (20)                                               /*!< BPWM_T::STATUS: ADCTRGF4 Position          */
S#define BPWM_STATUS_ADCTRGF4_Msk         (0x1ul << BPWM_STATUS_ADCTRGF4_Pos)                /*!< BPWM_T::STATUS: ADCTRGF4 Mask              */
S
S#define BPWM_STATUS_ADCTRGF5_Pos         (21)                                               /*!< BPWM_T::STATUS: ADCTRGF5 Position          */
S#define BPWM_STATUS_ADCTRGF5_Msk         (0x1ul << BPWM_STATUS_ADCTRGF5_Pos)                /*!< BPWM_T::STATUS: ADCTRGF5 Mask              */
S
S#define BPWM_CAPINEN_CAPINENn_Pos        (0)                                                /*!< BPWM_T::CAPINEN: CAPINENn Position         */
S#define BPWM_CAPINEN_CAPINENn_Msk        (0x3ful << BPWM_CAPINEN_CAPINENn_Pos)              /*!< BPWM_T::CAPINEN: CAPINENn Mask             */
S
S#define BPWM_CAPINEN_CAPINEN0_Pos        (0)                                                /*!< BPWM_T::CAPINEN: CAPINEN0 Position         */
S#define BPWM_CAPINEN_CAPINEN0_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN0_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN0 Mask             */
S
S#define BPWM_CAPINEN_CAPINEN1_Pos        (1)                                                /*!< BPWM_T::CAPINEN: CAPINEN1 Position         */
S#define BPWM_CAPINEN_CAPINEN1_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN1_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN1 Mask             */
S
S#define BPWM_CAPINEN_CAPINEN2_Pos        (2)                                                /*!< BPWM_T::CAPINEN: CAPINEN2 Position         */
S#define BPWM_CAPINEN_CAPINEN2_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN2_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN2 Mask             */
S
S#define BPWM_CAPINEN_CAPINEN3_Pos        (3)                                                /*!< BPWM_T::CAPINEN: CAPINEN3 Position         */
S#define BPWM_CAPINEN_CAPINEN3_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN3_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN3 Mask             */
S
S#define BPWM_CAPINEN_CAPINEN4_Pos        (4)                                                /*!< BPWM_T::CAPINEN: CAPINEN4 Position         */
S#define BPWM_CAPINEN_CAPINEN4_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN4_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN4 Mask             */
S
S#define BPWM_CAPINEN_CAPINEN5_Pos        (5)                                                /*!< BPWM_T::CAPINEN: CAPINEN5 Position         */
S#define BPWM_CAPINEN_CAPINEN5_Msk        (0x1ul << BPWM_CAPINEN_CAPINEN5_Pos)               /*!< BPWM_T::CAPINEN: CAPINEN5 Mask             */
S
S#define BPWM_CAPCTL_CAPENn_Pos           (0)                                                /*!< BPWM_T::CAPCTL: CAPENn Position            */
S#define BPWM_CAPCTL_CAPENn_Msk           (0x3ful << BPWM_CAPCTL_CAPENn_Pos)                 /*!< BPWM_T::CAPCTL: CAPENn Mask                */
S
S#define BPWM_CAPCTL_CAPEN0_Pos           (0)                                                /*!< BPWM_T::CAPCTL: CAPEN0 Position            */
S#define BPWM_CAPCTL_CAPEN0_Msk           (0x1ul << BPWM_CAPCTL_CAPEN0_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN0 Mask                */
S
S#define BPWM_CAPCTL_CAPEN1_Pos           (1)                                                /*!< BPWM_T::CAPCTL: CAPEN1 Position            */
S#define BPWM_CAPCTL_CAPEN1_Msk           (0x1ul << BPWM_CAPCTL_CAPEN1_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN1 Mask                */
S
S#define BPWM_CAPCTL_CAPEN2_Pos           (2)                                                /*!< BPWM_T::CAPCTL: CAPEN2 Position            */
S#define BPWM_CAPCTL_CAPEN2_Msk           (0x1ul << BPWM_CAPCTL_CAPEN2_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN2 Mask                */
S
S#define BPWM_CAPCTL_CAPEN3_Pos           (3)                                                /*!< BPWM_T::CAPCTL: CAPEN3 Position            */
S#define BPWM_CAPCTL_CAPEN3_Msk           (0x1ul << BPWM_CAPCTL_CAPEN3_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN3 Mask                */
S
S#define BPWM_CAPCTL_CAPEN4_Pos           (4)                                                /*!< BPWM_T::CAPCTL: CAPEN4 Position            */
S#define BPWM_CAPCTL_CAPEN4_Msk           (0x1ul << BPWM_CAPCTL_CAPEN4_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN4 Mask                */
S
S#define BPWM_CAPCTL_CAPEN5_Pos           (5)                                                /*!< BPWM_T::CAPCTL: CAPEN5 Position            */
S#define BPWM_CAPCTL_CAPEN5_Msk           (0x1ul << BPWM_CAPCTL_CAPEN5_Pos)                  /*!< BPWM_T::CAPCTL: CAPEN5 Mask                */
S
S#define BPWM_CAPCTL_CAPINVn_Pos          (8)                                                /*!< BPWM_T::CAPCTL: CAPINVn Position           */
S#define BPWM_CAPCTL_CAPINVn_Msk          (0x3ful << BPWM_CAPCTL_CAPINVn_Pos)                /*!< BPWM_T::CAPCTL: CAPINVn Mask               */
S
S#define BPWM_CAPCTL_CAPINV0_Pos          (8)                                                /*!< BPWM_T::CAPCTL: CAPINV0 Position           */
S#define BPWM_CAPCTL_CAPINV0_Msk          (0x1ul << BPWM_CAPCTL_CAPINV0_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV0 Mask               */
S
S#define BPWM_CAPCTL_CAPINV1_Pos          (9)                                                /*!< BPWM_T::CAPCTL: CAPINV1 Position           */
S#define BPWM_CAPCTL_CAPINV1_Msk          (0x1ul << BPWM_CAPCTL_CAPINV1_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV1 Mask               */
S
S#define BPWM_CAPCTL_CAPINV2_Pos          (10)                                               /*!< BPWM_T::CAPCTL: CAPINV2 Position           */
S#define BPWM_CAPCTL_CAPINV2_Msk          (0x1ul << BPWM_CAPCTL_CAPINV2_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV2 Mask               */
S
S#define BPWM_CAPCTL_CAPINV3_Pos          (11)                                               /*!< BPWM_T::CAPCTL: CAPINV3 Position           */
S#define BPWM_CAPCTL_CAPINV3_Msk          (0x1ul << BPWM_CAPCTL_CAPINV3_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV3 Mask               */
S
S#define BPWM_CAPCTL_CAPINV4_Pos          (12)                                               /*!< BPWM_T::CAPCTL: CAPINV4 Position           */
S#define BPWM_CAPCTL_CAPINV4_Msk          (0x1ul << BPWM_CAPCTL_CAPINV4_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV4 Mask               */
S
S#define BPWM_CAPCTL_CAPINV5_Pos          (13)                                               /*!< BPWM_T::CAPCTL: CAPINV5 Position           */
S#define BPWM_CAPCTL_CAPINV5_Msk          (0x1ul << BPWM_CAPCTL_CAPINV5_Pos)                 /*!< BPWM_T::CAPCTL: CAPINV5 Mask               */
S
S#define BPWM_CAPCTL_RCRLDENn_Pos         (16)                                               /*!< BPWM_T::CAPCTL: RCRLDENn Position          */
S#define BPWM_CAPCTL_RCRLDENn_Msk         (0x3ful << BPWM_CAPCTL_RCRLDENn_Pos)               /*!< BPWM_T::CAPCTL: RCRLDENn Mask              */
S
S#define BPWM_CAPCTL_RCRLDEN0_Pos         (16)                                               /*!< BPWM_T::CAPCTL: RCRLDEN0 Position          */
S#define BPWM_CAPCTL_RCRLDEN0_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN0_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN0 Mask              */
S
S#define BPWM_CAPCTL_RCRLDEN1_Pos         (17)                                               /*!< BPWM_T::CAPCTL: RCRLDEN1 Position          */
S#define BPWM_CAPCTL_RCRLDEN1_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN1_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN1 Mask              */
S
S#define BPWM_CAPCTL_RCRLDEN2_Pos         (18)                                               /*!< BPWM_T::CAPCTL: RCRLDEN2 Position          */
S#define BPWM_CAPCTL_RCRLDEN2_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN2_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN2 Mask              */
S
S#define BPWM_CAPCTL_RCRLDEN3_Pos         (19)                                               /*!< BPWM_T::CAPCTL: RCRLDEN3 Position          */
S#define BPWM_CAPCTL_RCRLDEN3_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN3_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN3 Mask              */
S
S#define BPWM_CAPCTL_RCRLDEN4_Pos         (20)                                               /*!< BPWM_T::CAPCTL: RCRLDEN4 Position          */
S#define BPWM_CAPCTL_RCRLDEN4_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN4_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN4 Mask              */
S
S#define BPWM_CAPCTL_RCRLDEN5_Pos         (21)                                               /*!< BPWM_T::CAPCTL: RCRLDEN5 Position          */
S#define BPWM_CAPCTL_RCRLDEN5_Msk         (0x1ul << BPWM_CAPCTL_RCRLDEN5_Pos)                /*!< BPWM_T::CAPCTL: RCRLDEN5 Mask              */
S
S#define BPWM_CAPCTL_FCRLDENn_Pos         (24)                                               /*!< BPWM_T::CAPCTL: FCRLDENn Position          */
S#define BPWM_CAPCTL_FCRLDENn_Msk         (0x3ful << BPWM_CAPCTL_FCRLDENn_Pos)               /*!< BPWM_T::CAPCTL: FCRLDENn Mask              */
S
S#define BPWM_CAPCTL_FCRLDEN0_Pos         (24)                                               /*!< BPWM_T::CAPCTL: FCRLDEN0 Position          */
S#define BPWM_CAPCTL_FCRLDEN0_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN0_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN0 Mask              */
S
S#define BPWM_CAPCTL_FCRLDEN1_Pos         (25)                                               /*!< BPWM_T::CAPCTL: FCRLDEN1 Position          */
S#define BPWM_CAPCTL_FCRLDEN1_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN1_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN1 Mask              */
S
S#define BPWM_CAPCTL_FCRLDEN2_Pos         (26)                                               /*!< BPWM_T::CAPCTL: FCRLDEN2 Position          */
S#define BPWM_CAPCTL_FCRLDEN2_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN2_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN2 Mask              */
S
S#define BPWM_CAPCTL_FCRLDEN3_Pos         (27)                                               /*!< BPWM_T::CAPCTL: FCRLDEN3 Position          */
S#define BPWM_CAPCTL_FCRLDEN3_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN3_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN3 Mask              */
S
S#define BPWM_CAPCTL_FCRLDEN4_Pos         (28)                                               /*!< BPWM_T::CAPCTL: FCRLDEN4 Position          */
S#define BPWM_CAPCTL_FCRLDEN4_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN4_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN4 Mask              */
S
S#define BPWM_CAPCTL_FCRLDEN5_Pos         (29)                                               /*!< BPWM_T::CAPCTL: FCRLDEN5 Position          */
S#define BPWM_CAPCTL_FCRLDEN5_Msk         (0x1ul << BPWM_CAPCTL_FCRLDEN5_Pos)                /*!< BPWM_T::CAPCTL: FCRLDEN5 Mask              */
S
S#define BPWM_CAPSTS_CRLIFOVn_Pos         (0)                                                /*!< BPWM_T::CAPSTS: CRLIFOVn Position          */
S#define BPWM_CAPSTS_CRLIFOVn_Msk         (0x3ful << BPWM_CAPSTS_CRLIFOVn_Pos)               /*!< BPWM_T::CAPSTS: CRLIFOVn Mask              */
S
S#define BPWM_CAPSTS_CRLIFOV0_Pos         (0)                                                /*!< BPWM_T::CAPSTS: CRLIFOV0 Position          */
S#define BPWM_CAPSTS_CRLIFOV0_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV0_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV0 Mask              */
S
S#define BPWM_CAPSTS_CRLIFOV1_Pos         (1)                                                /*!< BPWM_T::CAPSTS: CRLIFOV1 Position          */
S#define BPWM_CAPSTS_CRLIFOV1_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV1_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV1 Mask              */
S
S#define BPWM_CAPSTS_CRLIFOV2_Pos         (2)                                                /*!< BPWM_T::CAPSTS: CRLIFOV2 Position          */
S#define BPWM_CAPSTS_CRLIFOV2_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV2_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV2 Mask              */
S
S#define BPWM_CAPSTS_CRLIFOV3_Pos         (3)                                                /*!< BPWM_T::CAPSTS: CRLIFOV3 Position          */
S#define BPWM_CAPSTS_CRLIFOV3_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV3_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV3 Mask              */
S
S#define BPWM_CAPSTS_CRLIFOV4_Pos         (4)                                                /*!< BPWM_T::CAPSTS: CRLIFOV4 Position          */
S#define BPWM_CAPSTS_CRLIFOV4_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV4_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV4 Mask              */
S
S#define BPWM_CAPSTS_CRLIFOV5_Pos         (5)                                                /*!< BPWM_T::CAPSTS: CRLIFOV5 Position          */
S#define BPWM_CAPSTS_CRLIFOV5_Msk         (0x1ul << BPWM_CAPSTS_CRLIFOV5_Pos)                /*!< BPWM_T::CAPSTS: CRLIFOV5 Mask              */
S
S#define BPWM_CAPSTS_CFLIFOVn_Pos         (8)                                                /*!< BPWM_T::CAPSTS: CFLIFOVn Position          */
S#define BPWM_CAPSTS_CFLIFOVn_Msk         (0x3ful << BPWM_CAPSTS_CFLIFOVn_Pos)               /*!< BPWM_T::CAPSTS: CFLIFOVn Mask              */
S
S#define BPWM_CAPSTS_CFLIFOV0_Pos         (8)                                                /*!< BPWM_T::CAPSTS: CFLIFOV0 Position          */
S#define BPWM_CAPSTS_CFLIFOV0_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV0_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV0 Mask              */
S
S#define BPWM_CAPSTS_CFLIFOV1_Pos         (9)                                                /*!< BPWM_T::CAPSTS: CFLIFOV1 Position          */
S#define BPWM_CAPSTS_CFLIFOV1_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV1_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV1 Mask              */
S
S#define BPWM_CAPSTS_CFLIFOV2_Pos         (10)                                               /*!< BPWM_T::CAPSTS: CFLIFOV2 Position          */
S#define BPWM_CAPSTS_CFLIFOV2_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV2_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV2 Mask              */
S
S#define BPWM_CAPSTS_CFLIFOV3_Pos         (11)                                               /*!< BPWM_T::CAPSTS: CFLIFOV3 Position          */
S#define BPWM_CAPSTS_CFLIFOV3_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV3_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV3 Mask              */
S
S#define BPWM_CAPSTS_CFLIFOV4_Pos         (12)                                               /*!< BPWM_T::CAPSTS: CFLIFOV4 Position          */
S#define BPWM_CAPSTS_CFLIFOV4_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV4_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV4 Mask              */
S
S#define BPWM_CAPSTS_CFLIFOV5_Pos         (13)                                               /*!< BPWM_T::CAPSTS: CFLIFOV5 Position          */
S#define BPWM_CAPSTS_CFLIFOV5_Msk         (0x1ul << BPWM_CAPSTS_CFLIFOV5_Pos)                /*!< BPWM_T::CAPSTS: CFLIFOV5 Mask              */
S
S#define BPWM_RCAPDAT0_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT0: RCAPDAT Position         */
S#define BPWM_RCAPDAT0_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT0_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT0: RCAPDAT Mask             */
S
S#define BPWM_FCAPDAT0_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT0: FCAPDAT Position         */
S#define BPWM_FCAPDAT0_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT0_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT0: FCAPDAT Mask             */
S
S#define BPWM_RCAPDAT1_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT1: RCAPDAT Position         */
S#define BPWM_RCAPDAT1_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT1_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT1: RCAPDAT Mask             */
S
S#define BPWM_FCAPDAT1_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT1: FCAPDAT Position         */
S#define BPWM_FCAPDAT1_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT1_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT1: FCAPDAT Mask             */
S
S#define BPWM_RCAPDAT2_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT2: RCAPDAT Position         */
S#define BPWM_RCAPDAT2_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT2_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT2: RCAPDAT Mask             */
S
S#define BPWM_FCAPDAT2_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT2: FCAPDAT Position         */
S#define BPWM_FCAPDAT2_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT2_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT2: FCAPDAT Mask             */
S
S#define BPWM_RCAPDAT3_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT3: RCAPDAT Position         */
S#define BPWM_RCAPDAT3_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT3_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT3: RCAPDAT Mask             */
S
S#define BPWM_FCAPDAT3_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT3: FCAPDAT Position         */
S#define BPWM_FCAPDAT3_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT3_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT3: FCAPDAT Mask             */
S
S#define BPWM_RCAPDAT4_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT4: RCAPDAT Position         */
S#define BPWM_RCAPDAT4_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT4_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT4: RCAPDAT Mask             */
S
S#define BPWM_FCAPDAT4_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT4: FCAPDAT Position         */
S#define BPWM_FCAPDAT4_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT4_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT4: FCAPDAT Mask             */
S
S#define BPWM_RCAPDAT5_RCAPDAT_Pos        (0)                                                /*!< BPWM_T::RCAPDAT5: RCAPDAT Position         */
S#define BPWM_RCAPDAT5_RCAPDAT_Msk        (0xfffful << BPWM_RCAPDAT5_RCAPDAT_Pos)            /*!< BPWM_T::RCAPDAT5: RCAPDAT Mask             */
S
S#define BPWM_FCAPDAT5_FCAPDAT_Pos        (0)                                                /*!< BPWM_T::FCAPDAT5: FCAPDAT Position         */
S#define BPWM_FCAPDAT5_FCAPDAT_Msk        (0xfffful << BPWM_FCAPDAT5_FCAPDAT_Pos)            /*!< BPWM_T::FCAPDAT5: FCAPDAT Mask             */
S
S#define BPWM_CAPIEN_CAPRIENn_Pos         (0)                                                /*!< BPWM_T::CAPIEN: CAPRIENn Position          */
S#define BPWM_CAPIEN_CAPRIENn_Msk         (0x3ful << BPWM_CAPIEN_CAPRIENn_Pos)               /*!< BPWM_T::CAPIEN: CAPRIENn Mask              */
S
S#define BPWM_CAPIEN_CAPRIEN0_Pos         (0)                                                /*!< BPWM_T::CAPIEN: CAPRIEN0 Position          */
S#define BPWM_CAPIEN_CAPRIEN0_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN0_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN0 Mask              */
S
S#define BPWM_CAPIEN_CAPRIEN1_Pos         (1)                                                /*!< BPWM_T::CAPIEN: CAPRIEN1 Position          */
S#define BPWM_CAPIEN_CAPRIEN1_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN1_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN1 Mask              */
S
S#define BPWM_CAPIEN_CAPRIEN2_Pos         (2)                                                /*!< BPWM_T::CAPIEN: CAPRIEN2 Position          */
S#define BPWM_CAPIEN_CAPRIEN2_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN2_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN2 Mask              */
S
S#define BPWM_CAPIEN_CAPRIEN3_Pos         (3)                                                /*!< BPWM_T::CAPIEN: CAPRIEN3 Position          */
S#define BPWM_CAPIEN_CAPRIEN3_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN3_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN3 Mask              */
S
S#define BPWM_CAPIEN_CAPRIEN4_Pos         (4)                                                /*!< BPWM_T::CAPIEN: CAPRIEN4 Position          */
S#define BPWM_CAPIEN_CAPRIEN4_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN4_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN4 Mask              */
S
S#define BPWM_CAPIEN_CAPRIEN5_Pos         (5)                                                /*!< BPWM_T::CAPIEN: CAPRIEN5 Position          */
S#define BPWM_CAPIEN_CAPRIEN5_Msk         (0x1ul << BPWM_CAPIEN_CAPRIEN5_Pos)                /*!< BPWM_T::CAPIEN: CAPRIEN5 Mask              */
S
S#define BPWM_CAPIEN_CAPFIENn_Pos         (8)                                                /*!< BPWM_T::CAPIEN: CAPFIENn Position          */
S#define BPWM_CAPIEN_CAPFIENn_Msk         (0x3ful << BPWM_CAPIEN_CAPFIENn_Pos)               /*!< BPWM_T::CAPIEN: CAPFIENn Mask              */
S
S#define BPWM_CAPIEN_CAPFIEN0_Pos         (8)                                                /*!< BPWM_T::CAPIEN: CAPFIEN0 Position          */
S#define BPWM_CAPIEN_CAPFIEN0_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN0_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN0 Mask              */
S
S#define BPWM_CAPIEN_CAPFIEN1_Pos         (9)                                                /*!< BPWM_T::CAPIEN: CAPFIEN1 Position          */
S#define BPWM_CAPIEN_CAPFIEN1_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN1_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN1 Mask              */
S
S#define BPWM_CAPIEN_CAPFIEN2_Pos         (10)                                               /*!< BPWM_T::CAPIEN: CAPFIEN2 Position          */
S#define BPWM_CAPIEN_CAPFIEN2_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN2_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN2 Mask              */
S
S#define BPWM_CAPIEN_CAPFIEN3_Pos         (11)                                               /*!< BPWM_T::CAPIEN: CAPFIEN3 Position          */
S#define BPWM_CAPIEN_CAPFIEN3_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN3_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN3 Mask              */
S
S#define BPWM_CAPIEN_CAPFIEN4_Pos         (12)                                               /*!< BPWM_T::CAPIEN: CAPFIEN4 Position          */
S#define BPWM_CAPIEN_CAPFIEN4_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN4_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN4 Mask              */
S
S#define BPWM_CAPIEN_CAPFIEN5_Pos         (13)                                               /*!< BPWM_T::CAPIEN: CAPFIEN5 Position          */
S#define BPWM_CAPIEN_CAPFIEN5_Msk         (0x1ul << BPWM_CAPIEN_CAPFIEN5_Pos)                /*!< BPWM_T::CAPIEN: CAPFIEN5 Mask              */
S
S#define BPWM_CAPIF_CRLIFn_Pos            (0)                                                /*!< BPWM_T::CAPIF: CRLIFn Position             */
S#define BPWM_CAPIF_CRLIFn_Msk            (0x3ful << BPWM_CAPIF_CRLIFn_Pos)                  /*!< BPWM_T::CAPIF: CRLIFn Mask                 */
S
S#define BPWM_CAPIF_CRLIF0_Pos            (0)                                                /*!< BPWM_T::CAPIF: CRLIF0 Position             */
S#define BPWM_CAPIF_CRLIF0_Msk            (0x1ul << BPWM_CAPIF_CRLIF0_Pos)                   /*!< BPWM_T::CAPIF: CRLIF0 Mask                 */
S
S#define BPWM_CAPIF_CRLIF1_Pos            (1)                                                /*!< BPWM_T::CAPIF: CRLIF1 Position             */
S#define BPWM_CAPIF_CRLIF1_Msk            (0x1ul << BPWM_CAPIF_CRLIF1_Pos)                   /*!< BPWM_T::CAPIF: CRLIF1 Mask                 */
S
S#define BPWM_CAPIF_CRLIF2_Pos            (2)                                                /*!< BPWM_T::CAPIF: CRLIF2 Position             */
S#define BPWM_CAPIF_CRLIF2_Msk            (0x1ul << BPWM_CAPIF_CRLIF2_Pos)                   /*!< BPWM_T::CAPIF: CRLIF2 Mask                 */
S
S#define BPWM_CAPIF_CRLIF3_Pos            (3)                                                /*!< BPWM_T::CAPIF: CRLIF3 Position             */
S#define BPWM_CAPIF_CRLIF3_Msk            (0x1ul << BPWM_CAPIF_CRLIF3_Pos)                   /*!< BPWM_T::CAPIF: CRLIF3 Mask                 */
S
S#define BPWM_CAPIF_CRLIF4_Pos            (4)                                                /*!< BPWM_T::CAPIF: CRLIF4 Position             */
S#define BPWM_CAPIF_CRLIF4_Msk            (0x1ul << BPWM_CAPIF_CRLIF4_Pos)                   /*!< BPWM_T::CAPIF: CRLIF4 Mask                 */
S
S#define BPWM_CAPIF_CRLIF5_Pos            (5)                                                /*!< BPWM_T::CAPIF: CRLIF5 Position             */
S#define BPWM_CAPIF_CRLIF5_Msk            (0x1ul << BPWM_CAPIF_CRLIF5_Pos)                   /*!< BPWM_T::CAPIF: CRLIF5 Mask                 */
S
S#define BPWM_CAPIF_CFLIFn_Pos            (8)                                                /*!< BPWM_T::CAPIF: CFLIFn Position             */
S#define BPWM_CAPIF_CFLIFn_Msk            (0x3ful << BPWM_CAPIF_CFLIFn_Pos)                  /*!< BPWM_T::CAPIF: CFLIFn Mask                 */
S
S#define BPWM_CAPIF_CFLIF0_Pos            (8)                                                /*!< BPWM_T::CAPIF: CFLIF0 Position             */
S#define BPWM_CAPIF_CFLIF0_Msk            (0x1ul << BPWM_CAPIF_CFLIF0_Pos)                   /*!< BPWM_T::CAPIF: CFLIF0 Mask                 */
S
S#define BPWM_CAPIF_CFLIF1_Pos            (9)                                                /*!< BPWM_T::CAPIF: CFLIF1 Position             */
S#define BPWM_CAPIF_CFLIF1_Msk            (0x1ul << BPWM_CAPIF_CFLIF1_Pos)                   /*!< BPWM_T::CAPIF: CFLIF1 Mask                 */
S
S#define BPWM_CAPIF_CFLIF2_Pos            (10)                                               /*!< BPWM_T::CAPIF: CFLIF2 Position             */
S#define BPWM_CAPIF_CFLIF2_Msk            (0x1ul << BPWM_CAPIF_CFLIF2_Pos)                   /*!< BPWM_T::CAPIF: CFLIF2 Mask                 */
S
S#define BPWM_CAPIF_CFLIF3_Pos            (11)                                               /*!< BPWM_T::CAPIF: CFLIF3 Position             */
S#define BPWM_CAPIF_CFLIF3_Msk            (0x1ul << BPWM_CAPIF_CFLIF3_Pos)                   /*!< BPWM_T::CAPIF: CFLIF3 Mask                 */
S
S#define BPWM_CAPIF_CFLIF4_Pos            (12)                                               /*!< BPWM_T::CAPIF: CFLIF4 Position             */
S#define BPWM_CAPIF_CFLIF4_Msk            (0x1ul << BPWM_CAPIF_CFLIF4_Pos)                   /*!< BPWM_T::CAPIF: CFLIF4 Mask                 */
S
S#define BPWM_CAPIF_CFLIF5_Pos            (13)                                               /*!< BPWM_T::CAPIF: CFLIF5 Position             */
S#define BPWM_CAPIF_CFLIF5_Msk            (0x1ul << BPWM_CAPIF_CFLIF5_Pos)                   /*!< BPWM_T::CAPIF: CFLIF5 Mask                 */
S
S#define BPWM_PBUF_PBUF_Pos               (0)                                                /*!< BPWM_T::PBUF: PBUF Position                */
S#define BPWM_PBUF_PBUF_Msk               (0xfffful << BPWM_PBUF_PBUF_Pos)                   /*!< BPWM_T::PBUF: PBUF Mask                    */
S
S#define BPWM_CMPBUF_CMPBUF_Pos           (0)                                                /*!< BPWM_T::CMPBUF: CMPBUF Position            */
S#define BPWM_CMPBUF_CMPBUF_Msk           (0xfffful << BPWM_CMPBUF_CMPBUF_Pos)               /*!< BPWM_T::CMPBUF: CMPBUF Mask                */
S
S/*@}*/ /* end of group BPWM_CONST */
S/*@}*/ /* end of group BPWM */
S
S
S/*----------------------------- CAN Controller ------------------------------*/
S/** @addtogroup NUC131_CAN Controller Area Network (CAN)
S  Register Structure for CAN Device Controller
S  @{
S */
S
Stypedef struct
S{
S
S    /**
S     * CAN_IFn_CREQ
S     * ===================================================================================================
S     * Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |MessageNumber|Message Number
S     * |        |          |0x01-0x20: Valid Message Number, the Message Object in the Message
S     * |        |          |RAM is selected for data transfer.
S     * |        |          |0x00: Not a valid Message Number, interpreted as 0x20.
S     * |        |          |0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.
S     * |[15]    |Busy      |Busy Flag
S     * |        |          |0 = Read/write action has finished.
S     * |        |          |1 = Writing to the IFn Command Request Register is in progress.
S     * |        |          |This bit can only be read by the software.
S     */
S    __IO uint32_t CREQ;
S
S    /**
S     * CAN_IFn_CMASK
S     * ===================================================================================================
S     * Offset: 0x24, 0x84  IFn Command Mask Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DAT_B     |Access Data Bytes [7:4]
S     * |        |          |Write Operation:
S     * |        |          |0 = Data Bytes [7:4] unchanged.
S     * |        |          |1 = Transfer Data Bytes [7:4] to Message Object.
S     * |        |          |Read Operation:
S     * |        |          |0 = Data Bytes [7:4] unchanged.
S     * |        |          |1 = Transfer Data Bytes [7:4] to IFn Message Buffer Register.
S     * |[1]     |DAT_A     |Access Data Bytes [3:0]
S     * |        |          |Write Operation:
S     * |        |          |0 = Data Bytes [3:0] unchanged.
S     * |        |          |1 = Transfer Data Bytes [3:0] to Message Object.
S     * |        |          |Read Operation:
S     * |        |          |0 = Data Bytes [3:0] unchanged.
S     * |        |          |1 = Transfer Data Bytes [3:0] to IFn Message Buffer Register.
S     * |[2]     |TxRqst_NewDat|Access Transmission Request Bit When Write Operation
S     * |        |          |0 = TxRqst bit unchanged.
S     * |        |          |1 = Set TxRqst bit.
S     * |        |          |Note: If a transmission is requested by programming bit TxRqst/NewDat in the IFn Command Mask Register, bit TxRqst in the IFn Message Control Register will be ignored.
S     * |        |          |Access New Data Bit when Read Operation.
S     * |        |          |0 = NewDat bit remains unchanged.
S     * |        |          |1 = Clear NewDat bit in the Message Object.
S     * |        |          |Note: A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat.
S     * |        |          |The values of these bits transferred to the IFn Message Control Register always reflect the status before resetting these bits.
S     * |[3]     |ClrIntPnd |Clear Interrupt Pending Bit
S     * |        |          |Write Operation:
S     * |        |          |When writing to a Message Object, this bit is ignored.
S     * |        |          |Read Operation:
S     * |        |          |0 = IntPnd bit (CAN_IFn_MCON[13]) remains unchanged.
S     * |        |          |1 = Clear IntPnd bit in the Message Object.
S     * |[4]     |Control   |Control Access Control Bits
S     * |        |          |Write Operation:
S     * |        |          |0 = Control Bits unchanged.
S     * |        |          |1 = Transfer Control Bits to Message Object.
S     * |        |          |Read Operation:
S     * |        |          |0 = Control Bits unchanged.
S     * |        |          |1 = Transfer Control Bits to IFn Message Buffer Register.
S     * |[5]     |Arb       |Access Arbitration Bits
S     * |        |          |Write Operation:
S     * |        |          |0 = Arbitration bits unchanged.
S     * |        |          |1 = Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal (CAN_IFn_APB2[15]) to Message Object.
S     * |        |          |Read Operation:
S     * |        |          |0 = Arbitration bits unchanged.
S     * |        |          |1 = Transfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register.
S     * |[6]     |Mask      |Access Mask Bits
S     * |        |          |Write Operation:
S     * |        |          |0 = Mask bits unchanged.
S     * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
S     * |        |          |Read Operation:
S     * |        |          |0 = Mask bits unchanged.
S     * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register.
S     * |[7]     |WR_RD     |Write / Read Mode
S     * |        |          |0 = Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers.
S     * |        |          |1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register.
S     */
S    __IO uint32_t CMASK;
S
S    /**
S     * CAN_IFn_MASK1
S     * ===================================================================================================
S     * Offset: 0x28, 0x88  IFn Mask 1 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |Msk[15:0] |Identifier Mask 15-0
S     * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
S     * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
S     */
S    __IO uint32_t MASK1;
S
S    /**
S     * CAN_IFn_MASK2
S     * ===================================================================================================
S     * Offset: 0x2C, 0x8C  IFn Mask 2 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[12:0]  |Msk[28:16]|Identifier Mask 28-16
S     * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.
S     * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
S     * |[14]    |MDir      |Mask Message Direction
S     * |        |          |0 = The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance filtering.
S     * |        |          |1 = The message direction bit (Dir) is used for acceptance filtering.
S     * |[15]    |MXtd      |Mask Extended Identifier
S     * |        |          |0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
S     * |        |          |1 = The extended identifier bit (IDE) is used for acceptance filtering.
S     * |        |          |Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]).
S     * |        |          |For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 (CAN_IFn_MASK2[12:2]) are considered.
S     */
S    __IO uint32_t MASK2;
S
S    /**
S     * CAN_IFn_ARB1
S     * ===================================================================================================
S     * Offset: 0x30, 0x90  IFn Arbitration 1 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |ID[15:0]  |Message Identifier 15-0
S     * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
S     * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
S     */
S    __IO uint32_t ARB1;
S
S    /**
S     * CAN_IFn_ARB2
S     * ===================================================================================================
S     * Offset: 0x34, 0x94  IFn Arbitration 2 Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[12:0]  |ID[28:16] |Message Identifier 28-16
S     * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
S     * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
S     * |[13]    |Dir       |Message Direction
S     * |        |          |0 = Direction is receive.
S     * |        |          |On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted.
S     * |        |          |On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
S     * |        |          |1 = Direction is transmit.
S     * |        |          |On TxRqst, the respective Message Object is transmitted as a Data Frame.
S     * |        |          |On reception of a Remote Frame with matching identifier, the TxRqst bit (CAN_IFn_CMASK[2]) of this Message Object is set (if RmtEn (CAN_IFn_MCON[9]) = one).
S     * |[14]    |Xtd       |Extended Identifier
S     * |        |          |0 = The 11-bit ("standard") Identifier will be used for this Message Object.
S     * |        |          |1 = The 29-bit ("extended") Identifier will be used for this Message Object.
S     * |[15]    |MsgVal    |Message Valid
S     * |        |          |0 = The Message Object is ignored by the Message Handler.
S     * |        |          |1 = The Message Object is configured and should be considered by the Message Handler.
S     * |        |          |Note: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init (CAN_CON[0]).
S     * |        |          |This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd (CAN_IFn_ARB2[14]), Dir (CAN_IFn_APB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0]) are modified, or if the Messages Object is no longer required.
S     */
S    __IO uint32_t ARB2;
S
S    /**
S     * CAN_IFn_MCON
S     * ===================================================================================================
S     * Offset: 0x38, 0x98  IFn Message Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |DLC       |Data Length Code
S     * |        |          |0-8: Data Frame has 0-8 data bytes.
S     * |        |          |9-15: Data Frame has 8 data bytes
S     * |        |          |Note: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes.
S     * |        |          |When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.
S     * |        |          |Data 0: 1st data byte of a CAN Data Frame
S     * |        |          |Data 1: 2nd data byte of a CAN Data Frame
S     * |        |          |Data 2: 3rd data byte of a CAN Data Frame
S     * |        |          |Data 3: 4th data byte of a CAN Data Frame
S     * |        |          |Data 4: 5th data byte of a CAN Data Frame
S     * |        |          |Data 5: 6th data byte of a CAN Data Frame
S     * |        |          |Data 6: 7th data byte of a CAN Data Frame
S     * |        |          |Data 7 : 8th data byte of a CAN Data Frame
S     * |        |          |Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last.
S     * |        |          |When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object.
S     * |        |          |If the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.
S     * |[7]     |EoB       |End Of Buffer
S     * |        |          |0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer.
S     * |        |          |1 = Single Message Object or last Message Object of a FIFO Buffer.
S     * |        |          |Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer.
S     * |        |          |For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.
S     * |[8]     |TxRqst    |Transmit Request
S     * |        |          |0 = This Message Object is not waiting for transmission.
S     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S     * |[9]     |RmtEn     |Remote Enable Control
S     * |        |          |0 = At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged.
S     * |        |          |1 = At the reception of a Remote Frame, TxRqst is set.
S     * |[10]    |RxIE      |Receive Interrupt Enable Control
S     * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame.
S     * |        |          |1 = IntPnd will be set after a successful reception of a frame.
S     * |[11]    |TxIE      |Transmit Interrupt Enable Control
S     * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a frame.
S     * |        |          |1 = IntPnd will be set after a successful transmission of a frame.
S     * |[12]    |UMask     |Use Acceptance Mask
S     * |        |          |0 = Mask ignored.
S     * |        |          |1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
S     * |        |          |Note: If the UMask bit is set to one, the Message Object's mask bits have to be programmed during initialization of the Message Object before MsgVal bit (CAN_IFn_APB2[15]) is set to one.
S     * |[13]    |IntPnd    |Interrupt Pending
S     * |        |          |0 = This message object is not the source of an interrupt.
S     * |        |          |1 = This message object is the source of an interrupt.
S     * |        |          |The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
S     * |[14]    |MsgLst    |Message Lost (only valid for Message Objects with direction = receive).
S     * |        |          |0 = No message lost since last time this bit was reset by the CPU.
S     * |        |          |1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message.
S     * |[15]    |NewDat    |New Data
S     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software.
S     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
S     */
S    __IO uint32_t MCON;
S
S    /**
S     * CAN_IFn_DAT_A1
S     * ===================================================================================================
S     * Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |Data0     |Data Byte 0
S     * |        |          |1st data byte of a CAN Data Frame
S     * |[15:8]  |Data1     |Data Byte 1
S     * |        |          |2nd data byte of a CAN Data Frame
S     */
S    __IO uint32_t DAT_A1;
S
S    /**
S     * CAN_IFn_DAT_A2
S     * ===================================================================================================
S     * Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |Data2     |Data Byte 2
S     * |        |          |3rd data byte of CAN Data Frame
S     * |[15:8]  |Data3     |Data Byte 3
S     * |        |          |4th data byte of CAN Data Frame
S     */
S    __IO uint32_t DAT_A2;
S
S    /**
S     * CAN_IFn_DAT_B1
S     * ===================================================================================================
S     * Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |Data4     |Data Byte 4
S     * |        |          |5th data byte of CAN Data Frame
S     * |[15:8]  |Data5     |Data Byte 5
S     * |        |          |6th data byte of CAN Data Frame
S     */
S    __IO uint32_t DAT_B1;
S
S    /**
S     * CAN_IFn_DAT_B2
S     * ===================================================================================================
S     * Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |Data6     |Data Byte 6
S     * |        |          |7th data byte of CAN Data Frame.
S     * |[15:8]  |Data7     |Data Byte 7
S     * |        |          |8th data byte of CAN Data Frame.
S     */
S    __IO uint32_t DAT_B2;
S
S    /**
S     * @cond HIDDEN_SYMBOLS     
S     */    
S    __I uint32_t RESERVE0[13];
S    /**
S     * @endcond
S     */
S
S} CAN_IF_T;
S
Stypedef struct
S{
S
S    /**
S     * CAN_CON
S     * ===================================================================================================
S     * Offset: 0x00  Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |Init      |Init Initialization
S     * |        |          |0 = Normal Operation.
S     * |        |          |1 = Initialization is started.
S     * |[1]     |IE        |Module Interrupt Enable Control
S     * |        |          |0 = Disabled.
S     * |        |          |1 = Enabled.
S     * |[2]     |SIE       |Status Change Interrupt Enable Control
S     * |        |          |0 = Disabled - No Status Change Interrupt will be generated.
S     * |        |          |1 = Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
S     * |[3]     |EIE       |Error Interrupt Enable Control
S     * |        |          |0 = Disabled - No Error Status Interrupt will be generated.
S     * |        |          |1 = Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status Register will generate an interrupt.
S     * |[5]     |DAR       |Automatic Re-Transmission Disable Control
S     * |        |          |0 = Automatic Retransmission of disturbed messages enabled.
S     * |        |          |1 = Automatic Retransmission disabled.
S     * |[6]     |CCE       |Configuration Change Enable Control
S     * |        |          |0 = No write access to the Bit Timing Register.
S     * |        |          |1 = Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1).
S     * |[7]     |Test      |Test Mode Enable Control
S     * |        |          |0 = Normal Operation.
S     * |        |          |1 = Test Mode.
S     */
S    __IO uint32_t   CON;
S
S    /**
S     * CAN_STATUS
S     * ===================================================================================================
S     * Offset: 0x04  Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |LEC       |Last Error Code (Type Of The Last Error To Occur On The CAN Bus)
S     * |        |          |The LEC field holds a code, which indicates the type of the last error to occur on the CAN bus.
S     * |        |          |This field will be cleared to '0' when a message has been transferred (reception or transmission) without error.
S     * |        |          |The unused code '7' may be written by the CPU to check for updates.
S     * |        |          |The following table describes the error code.
S     * |[3]     |TxOK      |Transmitted A Message Successfully
S     * |        |          |0 = Since this bit was reset by the CPU, no message has been successfully transmitted.
S     * |        |          |This bit is never reset by the CAN Core.
S     * |        |          |1 = Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted.
S     * |[4]     |RxOK      |Received A Message Successfully
S     * |        |          |0 = No message has been successfully received since this bit was last reset by the CPU.
S     * |        |          |This bit is never reset by the CAN Core.
S     * |        |          |1 = A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering).
S     * |[5]     |EPass     |Error Passive (Read Only)
S     * |        |          |0 = The CAN Core is error active.
S     * |        |          |1 = The CAN Core is in the error passive state as defined in the CAN Specification.
S     * |[6]     |EWarn     |Error Warning Status (Read Only)
S     * |        |          |0 = Both error counters are below the error warning limit of 96.
S     * |        |          |1 = At least one of the error counters in the EML has reached the error warning limit of 96.
S     * |[7]     |BOff      |Bus-Off Status (Read Only)
S     * |        |          |0 = The CAN module is not in bus-off state.
S     * |        |          |1 = The CAN module is in bus-off state.
S     */
S    __IO uint32_t   STATUS;
S
S    /**
S     * CAN_ERR
S     * ===================================================================================================
S     * Offset: 0x08  Error Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |TEC       |Transmit Error Counter
S     * |        |          |Actual state of the Transmit Error Counter. Values between 0 and 255.
S     * |[14:8]  |REC       |Receive Error Counter
S     * |        |          |Actual state of the Receive Error Counter. Values between 0 and 127.
S     * |[15]    |RP        |Receive Error Passive
S     * |        |          |0 = The Receive Error Counter is below the error passive level.
S     * |        |          |1 = The Receive Error Counter has reached the error passive level as defined in the CAN Specification.
S     */
S    __IO uint32_t   ERR;
S
S    /**
S     * CAN_BTIME
S     * ===================================================================================================
S     * Offset: 0x0C  Bit Timing Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |BRP       |Baud Rate Prescaler
S     * |        |          |0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta.
S     * |        |          |The bit time is built up from a multiple of this quanta.
S     * |        |          |Valid values for the Baud Rate Prescaler are [ 0 ... 63 ].
S     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
S     * |[7:6]   |SJW       |(Re)Synchronization Jump Width
S     * |        |          |0x0-0x3: Valid programmed values are [0 ... 3].
S     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
S     * |[11:8]  |TSeg1     |Time Segment Before The Sample Point Minus Sync_Seg
S     * |        |          |0x01-0x0F: valid values for TSeg1 are [1 ... 15].
S     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed is used.
S     * |[14:12] |TSeg2     |Time Segment After Sample Point
S     * |        |          |0x0-0x7: Valid values for TSeg2 are [0 ... 7].
S     * |        |          |The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.
S     */
S    __IO uint32_t   BTIME;
S
S    /**
S     * CAN_IIDR
S     * ===================================================================================================
S     * Offset: 0x10  Interrupt Identifier Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |IntId     |Interrupt Identifier (Indicates The Source Of The Interrupt)
S     * |        |          |If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order.
S     * |        |          |An interrupt remains pending until the application software has cleared it.
S     * |        |          |If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to the EIC is active.
S     * |        |          |The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.
S     * |        |          |The Status Interrupt has the highest priority.
S     * |        |          |Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.
S     * |        |          |A message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]).
S     * |        |          |The Status Interrupt is cleared by reading the Status Register.
S     */
S    __IO uint32_t   IIDR;
S
S    /**
S     * CAN_TEST
S     * ===================================================================================================
S     * Offset: 0x14  Test Register (Register Map Note 1)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |Res       |Reserved
S     * |        |          |There are reserved bits.
S     * |        |          |These bits are always read as '0' and must always be written with '0'.
S     * |[2]     |Basic     |Basic Mode
S     * |        |          |0 = Basic Mode disabled.
S     * |        |          |1= IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer.
S     * |[3]     |Silent    |Silent Mode
S     * |        |          |0 = Normal operation.
S     * |        |          |1 = The module is in Silent Mode.
S     * |[4]     |LBack     |Loop Back Mode Enable Control
S     * |        |          |0 = Loop Back Mode is disabled.
S     * |        |          |1 = Loop Back Mode is enabled.
S     * |[6:5]   |Tx10      |Tx[1:0]: Control Of CAN_TX Pin
S     * |        |          |00 = Reset value, CAN_TX pin is controlled by the CAN Core.
S     * |        |          |01 = Sample Point can be monitored at CAN_TX pin.
S     * |        |          |10 = CAN_TX pin drives a dominant ('0') value.
S     * |        |          |11 = CAN_TX pin drives a recessive ('1') value.
S     * |[7]     |Rx        |Monitors The Actual Value Of CAN_RX Pin (Read Only)
S     * |        |          |0 = The CAN bus is dominant (CAN_RX = '0').
S     * |        |          |1 = The CAN bus is recessive (CAN_RX = '1').
S     */
S    __IO uint32_t   TEST;
S
S    /**
S     * CAN_BRPE
S     * ===================================================================================================
S     * Offset: 0x18  Baud Rate Prescaler Extension Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |BRPE      |BRPE: Baud Rate Prescaler Extension
S     * |        |          |0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023.
S     * |        |          |The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.
S     */
S    __IO uint32_t   BRPE;
S
S    /**
S     * @cond HIDDEN_SYMBOLS     
S     */
S    __I uint32_t    RESERVE0[1];
S    /**
S     * @endcond
S     */
S
S    __IO CAN_IF_T   IF[2];
S
S    /**
S     * @cond HIDDEN_SYMBOLS     
S     */
S    __I uint32_t    RESERVE1[8];
S    /**
S     * @endcond
S     */
S    
S
S    /**
S     * CAN_TXREQ1
S     * ===================================================================================================
S     * Offset: 0x100  Transmission Request Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |TxRqst161 |Transmission Request Bits 16-1 (Of All Message Objects)
S     * |        |          |0 = This Message Object is not waiting for transmission.
S     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S     * |        |          |These bits are read only.
S     */
S    __IO uint32_t   TXREQ1;
S
S    /**
S     * CAN_TXREQ2
S     * ===================================================================================================
S     * Offset: 0x104  Transmission Request Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |TxRqst3217|Transmission Request Bits 32-17 (Of All Message Objects)
S     * |        |          |0 = This Message Object is not waiting for transmission.
S     * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S     * |        |          |These bits are read only.
S     */
S    __IO uint32_t   TXREQ2;
S
S    /**
S     * @cond HIDDEN_SYMBOLS     
S     */
S    __I uint32_t    RESERVE2[6];
S    /**
S     * @endcond
S     */
S
S    /**
S     * CAN_NDAT1
S     * ===================================================================================================
S     * Offset: 0x120  New Data Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |NewData161|New Data Bits 16-1 (Of All Message Objects)
S     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
S     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
S     */
S    __IO uint32_t   NDAT1;
S
S    /**
S     * CAN_NDAT2
S     * ===================================================================================================
S     * Offset: 0x124  New Data Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |NewData3217|New Data Bits 32-17 (Of All Message Objects)
S     * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.
S     * |        |          |1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
S     */
S    __IO uint32_t   NDAT2;
S
S    /**
S     * @cond HIDDEN_SYMBOLS     
S     */
S    __I uint32_t    RESERVE3[6];
S    /**
S     * @endcond
S     */
S    
S
S    /**
S     * CAN_IPND1
S     * ===================================================================================================
S     * Offset: 0x140  Interrupt Pending Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |IntPnd161 |Interrupt Pending Bits 16-1 (Of All Message Objects)
S     * |        |          |0 = This message object is not the source of an interrupt.
S     * |        |          |1 = This message object is the source of an interrupt.
S     */
S    __IO uint32_t   IPND1;
S
S    /**
S     * CAN_IPND2
S     * ===================================================================================================
S     * Offset: 0x144  Interrupt Pending Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |IntPnd3217|Interrupt Pending Bits 32-17(Of All Message Objects)
S     * |        |          |0 = This message object is not the source of an interrupt.
S     * |        |          |1 = This message object is the source of an interrupt.
S     */
S    __IO uint32_t   IPND2;
S
S    /**
S     * @cond HIDDEN_SYMBOLS     
S     */
S    __I uint32_t    RESERVE4[6];
S    /**
S     * @endcond
S     */
S
S    /**
S     * CAN_MVLD1
S     * ===================================================================================================
S     * Offset: 0x160  Message Valid Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |MsgVal161 |Message Valid Bits 16-1 (Of All Message Objects) (Read Only)
S     * |        |          |0 = This Message Object is ignored by the Message Handler.
S     * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
S     * |        |          |Ex.
S     * |        |          |CAN_MVLD1[0] means Message object No.1 is valid or not.
S     * |        |          |If CAN_MVLD1[0] is set, message object No.1 is configured.
S     */
S    __IO uint32_t   MVLD1;
S
S    /**
S     * CAN_MVLD2
S     * ===================================================================================================
S     * Offset: 0x164  Message Valid Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |MsgVal3217|Message Valid Bits 32-17 (Of All Message Objects) (Read Only)
S     * |        |          |0 = This Message Object is ignored by the Message Handler.
S     * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
S     * |        |          |Ex.CAN_MVLD2[15] means Message object No.32 is valid or not.
S     * |        |          |If CAN_MVLD2[15] is set, message object No.32 is configured.
S     */
S    __IO uint32_t   MVLD2;
S
S    /**
S     * CAN_WU_EN
S     * ===================================================================================================
S     * Offset: 0x168  Wake-up Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WAKUP_EN  |Wake-Up Enable Control
S     * |        |          |0 = The wake-up function Disabled.
S     * |        |          |1 = The wake-up function Enabled.
S     * |        |          |Note: User can wake-up system when there is a falling edge in the CAN_Rx pin.
S     */
S    __IO uint32_t   WU_EN;
S
S    /**
S     * CAN_WU_STATUS
S     * ===================================================================================================
S     * Offset: 0x16C  Wake-up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WAKUP_STS |Wake-Up Status
S     * |        |          |0 = No wake-up event occurred.
S     * |        |          |1 = Wake-up event occurred.
S     * |        |          |Note: This bit can be cleared by writing '0'.
S     */
S    __IO uint32_t   WU_STATUS;
S} CAN_T;
S
S/** @addtogroup CAN_CONST CAN Bit Field Definition
S    Constant Definitions for CAN Controller
S  @{
S */
S
S
S
S
S/* CAN CON Bit Field Definitions */
S#define CAN_CON_TEST_Pos           7                                    /*!< CAN_T::CON: TEST Position */
S#define CAN_CON_TEST_Msk           (1ul << CAN_CON_TEST_Pos)            /*!< CAN_T::CON: TEST Mask     */
S
S#define CAN_CON_CCE_Pos            6                                    /*!< CAN_T::CON: CCE Position  */
S#define CAN_CON_CCE_Msk            (1ul << CAN_CON_CCE_Pos)             /*!< CAN_T::CON: CCE Mask      */
S
S#define CAN_CON_DAR_Pos            5                                    /*!< CAN_T::CON: DAR Position  */
S#define CAN_CON_DAR_Msk            (1ul << CAN_CON_DAR_Pos)             /*!< CAN_T::CON: DAR Mask      */
S
S#define CAN_CON_EIE_Pos            3                                    /*!< CAN_T::CON: EIE Position  */
S#define CAN_CON_EIE_Msk            (1ul << CAN_CON_EIE_Pos)             /*!< CAN_T::CON: EIE Mask      */
S
S#define CAN_CON_SIE_Pos            2                                    /*!< CAN_T::CON: SIE Position  */
S#define CAN_CON_SIE_Msk            (1ul << CAN_CON_SIE_Pos)             /*!< CAN_T::CON: SIE Mask      */
S
S#define CAN_CON_IE_Pos             1                                    /*!< CAN_T::CON: IE Position   */
S#define CAN_CON_IE_Msk             (1ul << CAN_CON_IE_Pos)              /*!< CAN_T::CON: IE Mask       */
S
S#define CAN_CON_INIT_Pos           0                                    /*!< CAN_T::CON: INIT Position */
S#define CAN_CON_INIT_Msk           (1ul << CAN_CON_INIT_Pos)            /*!< CAN_T::CON: INIT Mask     */
S
S/* CAN STATUS Bit Field Definitions */
S#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN_T::STATUS: BOFF Position  */
S#define CAN_STATUS_BOFF_Msk        (1ul << CAN_STATUS_BOFF_Pos)         /*!< CAN_T::STATUS: BOFF Mask      */
S
S#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN_T::STATUS: EWARN Position */
S#define CAN_STATUS_EWARN_Msk       (1ul << CAN_STATUS_EWARN_Pos)        /*!< CAN_T::STATUS: EWARN Mask     */
S
S#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN_T::STATUS: EPASS Position */
S#define CAN_STATUS_EPASS_Msk       (1ul << CAN_STATUS_EPASS_Pos)        /*!< CAN_T::STATUS: EPASS Mask     */
S
S#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN_T::STATUS: RXOK Position  */
S#define CAN_STATUS_RXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN_T::STATUS: RXOK Mask      */
S
S#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN_T::STATUS: TXOK Position  */
S#define CAN_STATUS_TXOK_Msk        (1ul << CAN_STATUS_TXOK_Pos)         /*!< CAN_T::STATUS: TXOK Mask      */
S
S#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN_T::STATUS: LEC Position   */
S#define CAN_STATUS_LEC_Msk         (0x3ul << CAN_STATUS_LEC_Pos)        /*!< CAN_T::STATUS: LEC Mask       */
S
S/* CAN ERR Bit Field Definitions */                                             
S#define CAN_ERR_RP_Pos             15                                   /*!< CAN_T::ERR: RP Position       */
S#define CAN_ERR_RP_Msk             (1ul << CAN_ERR_RP_Pos)              /*!< CAN_T::ERR: RP Mask           */
S
S#define CAN_ERR_REC_Pos            8                                    /*!< CAN_T::ERR: REC Position      */
S#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN_T::ERR: REC Mask          */
S
S#define CAN_ERR_TEC_Pos            0                                    /*!< CAN_T::ERR: TEC Position      */
S#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN_T::ERR: TEC Mask          */
S
S/* CAN BTIME Bit Field Definitions */                                           
S#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN_T::BTIME: TSEG2 Position  */
S#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN_T::BTIME: TSEG2 Mask      */
S
S#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN_T::BTIME: TSEG1 Position  */
S#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN_T::BTIME: TSEG1 Mask      */
S
S#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN_T::BTIME: SJW Position    */
S#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN_T::BTIME: SJW Mask        */
S
S#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN_T::BTIME: BRP Position    */
S#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN_T::BTIME: BRP Mask        */
S
S/* CAN IIDR Bit Field Definitions */                                            
S#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN_T::IIDR: INTID Position   */
S#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN_T::IIDR: INTID Mask       */
S
S/* CAN TEST Bit Field Definitions */                                            
S#define CAN_TEST_RX_Pos            7                                    /*!< CAN_T::TEST: RX Position      */
S#define CAN_TEST_RX_Msk            (1ul << CAN_TEST_RX_Pos)             /*!< CAN_T::TEST: RX Mask          */
S
S#define CAN_TEST_TX_Pos            5                                    /*!< CAN_T::TEST: TX Position      */
S#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN_T::TEST: TX Mask          */
S
S#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN_T::TEST: LBACK Position   */
S#define CAN_TEST_LBACK_Msk         (1ul << CAN_TEST_LBACK_Pos)          /*!< CAN_T::TEST: LBACK Mask       */
S
S#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN_T::TEST: Silent Position  */
S#define CAN_TEST_SILENT_Msk        (1ul << CAN_TEST_SILENT_Pos)         /*!< CAN_T::TEST: Silent Mask      */
S
S#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN_T::TEST: Basic Position   */
S#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)          /*!< CAN_T::TEST: Basic Mask       */
S
S/* CAN BPRE Bit Field Definitions */                                            
S#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN_T::BRPE: BRPE Position    */
S#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN_T::BRPE: BRPE Mask        */
S
S/* CAN IFn_CREQ Bit Field Definitions */                                        
S#define CAN_IF_CREQ_BUSY_Pos       15                                   /*!< CAN_T::IFnCREQ: BUSY Position */
S#define CAN_IF_CREQ_BUSY_Msk       (1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN_T::IFnCREQ: BUSY Mask     */
S
S#define CAN_IF_CREQ_MSGNUM_Pos     0                                    /*!< CAN_T::IFnCREQ: MSGNUM Position */
S#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)   /*!< CAN_T::IFnCREQ: MSGNUM Mask     */
S
S/* CAN IFn_CMASK Bit Field Definitions */                                      
S#define CAN_IF_CMASK_WRRD_Pos      7                                    /*!< CAN_T::IFnCMASK: WRRD Position */
S#define CAN_IF_CMASK_WRRD_Msk      (1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN_T::IFnCMASK: WRRD Mask     */
S
S#define CAN_IF_CMASK_MASK_Pos      6                                    /*!< CAN_T::IFnCMASK: MASK Position */
S#define CAN_IF_CMASK_MASK_Msk      (1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN_T::IFnCMASK: MASK Mask     */
S
S#define CAN_IF_CMASK_ARB_Pos       5                                    /*!< CAN_T::IFnCMASK: ARB Position  */
S#define CAN_IF_CMASK_ARB_Msk       (1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN_T::IFnCMASK: ARB Mask      */
S
S#define CAN_IF_CMASK_CONTROL_Pos   4                                    /*!< CAN_T::IFnCMASK: CONTROL Position */
S#define CAN_IF_CMASK_CONTROL_Msk   (1ul << CAN_IF_CMASK_CONTROL_Pos)    /*!< CAN_T::IFnCMASK: CONTROL Mask */
S
S#define CAN_IF_CMASK_CLRINTPND_Pos 3                                    /*!< CAN_T::IFnCMASK: CLRINTPND Position */
S#define CAN_IF_CMASK_CLRINTPND_Msk (1ul << CAN_IF_CMASK_CLRINTPND_Pos)  /*!< CAN_T::IFnCMASK: CLRINTPND Mask */
S
S#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN_T::IFnCMASK: TXRQSTNEWDAT Position */
S#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)    /*!< CAN_T::IFnCMASK: TXRQSTNEWDAT Mask     */
S
S#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN_T::IFnCMASK: DATAA Position */
S#define CAN_IF_CMASK_DATAA_Msk     (1ul << CAN_IF_CMASK_DATAA_Pos)      /*!< CAN_T::IFnCMASK: DATAA Mask     */
S
S#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN_T::IFnCMASK: DATAB Position */
S#define CAN_IF_CMASK_DATAB_Msk     (1ul << CAN_IF_CMASK_DATAB_Pos)      /*!< CAN_T::IFnCMASK: DATAB Mask     */
S
S/* CAN IFn_MASK1 Bit Field Definitions */                                       
S#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN_T::IFnMASK1: MSK Position   */
S#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN_T::IFnMASK1: MSK Mask       */
S
S/* CAN IFn_MASK2 Bit Field Definitions */                                       
S#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN_T::IFnMASK2: MXTD Position */
S#define CAN_IF_MASK2_MXTD_Msk      (1ul << CAN_IF_MASK2_MXTD_Pos)       /*!< CAN_T::IFnMASK2: MXTD Mask     */
S
S#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN_T::IFnMASK2: MDIR Position */
S#define CAN_IF_MASK2_MDIR_Msk      (1ul << CAN_IF_MASK2_MDIR_Pos)       /*!< CAN_T::IFnMASK2: MDIR Mask     */
S
S#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN_T::IFnMASK2: MSK Position */
S#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN_T::IFnMASK2: MSK Mask     */
S
S/* CAN IFn_ARB1 Bit Field Definitions */                                        
S#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN_T::IFnARB1: ID Position   */
S#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN_T::IFnARB1: ID Mask       */
S
S/* CAN IFn_ARB2 Bit Field Definitions */                                        
S#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN_T::IFnARB2: MSGVAL Position */
S#define CAN_IF_ARB2_MSGVAL_Msk     (1ul << CAN_IF_ARB2_MSGVAL_Pos)      /*!< CAN_T::IFnARB2: MSGVAL Mask     */
S
S#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN_T::IFnARB2: XTD Position    */
S#define CAN_IF_ARB2_XTD_Msk        (1ul << CAN_IF_ARB2_XTD_Pos)         /*!< CAN_T::IFnARB2: XTD Mask        */
S
S#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN_T::IFnARB2: DIR Position    */
S#define CAN_IF_ARB2_DIR_Msk        (1ul << CAN_IF_ARB2_DIR_Pos)         /*!< CAN_T::IFnARB2: DIR Mask        */
S
S#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN_T::IFnARB2: ID Position     */
S#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN_T::IFnARB2: ID Mask         */
S
S/* CAN IFn_MCON Bit Field Definitions */                                        
S#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN_T::IFnMCON: NEWDAT Position */
S#define CAN_IF_MCON_NEWDAT_Msk     (1ul << CAN_IF_MCON_NEWDAT_Pos)      /*!< CAN_T::IFnMCON: NEWDAT Mask     */
S
S#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN_T::IFnMCON: MSGLST Position */
S#define CAN_IF_MCON_MSGLST_Msk     (1ul << CAN_IF_MCON_MSGLST_Pos)      /*!< CAN_T::IFnMCON: MSGLST Mask     */
S
S#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN_T::IFnMCON: INTPND Position */
S#define CAN_IF_MCON_INTPND_Msk     (1ul << CAN_IF_MCON_INTPND_Pos)      /*!< CAN_T::IFnMCON: INTPND Mask     */
S
S#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN_T::IFnMCON: UMASK Position  */
S#define CAN_IF_MCON_UMASK_Msk      (1ul << CAN_IF_MCON_UMASK_Pos)       /*!< CAN_T::IFnMCON: UMASK Mask      */
S
S#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN_T::IFnMCON: TXIE Position   */
S#define CAN_IF_MCON_TXIE_Msk       (1ul << CAN_IF_MCON_TXIE_Pos)        /*!< CAN_T::IFnMCON: TXIE Mask       */
S
S#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN_T::IFnMCON: RXIE Position   */
S#define CAN_IF_MCON_RXIE_Msk       (1ul << CAN_IF_MCON_RXIE_Pos)        /*!< CAN_T::IFnMCON: RXIE Mask       */
S
S#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN_T::IFnMCON: RMTEN Position  */
S#define CAN_IF_MCON_RMTEN_Msk      (1ul << CAN_IF_MCON_RMTEN_Pos)       /*!< CAN_T::IFnMCON: RMTEN Mask      */
S
S#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN_T::IFnMCON: TXRQST Position */
S#define CAN_IF_MCON_TXRQST_Msk     (1ul << CAN_IF_MCON_TXRQST_Pos)      /*!< CAN_T::IFnMCON: TXRQST Mask     */
S
S#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN_T::IFnMCON: EOB Position    */
S#define CAN_IF_MCON_EOB_Msk        (1ul << CAN_IF_MCON_EOB_Pos)         /*!< CAN_T::IFnMCON: EOB Mask        */
S
S#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN_T::IFnMCON: DLC Position    */
S#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN_T::IFnMCON: DLC Mask        */
S
S/* CAN IFn_DATA_A1 Bit Field Definitions */                                     
S#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN_T::IFnDATAA1: DATA1 Position */
S#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN_T::IFnDATAA1: DATA1 Mask     */
S
S#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN_T::IFnDATAA1: DATA0 Position */
S#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN_T::IFnDATAA1: DATA0 Mask     */
S
S/* CAN IFn_DATA_A2 Bit Field Definitions */                                     
S#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN_T::IFnDATAA1: DATA3 Position */
S#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN_T::IFnDATAA1: DATA3 Mask     */
S
S#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN_T::IFnDATAA1: DATA2 Position */
S#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN_T::IFnDATAA1: DATA2 Mask     */
S
S/* CAN IFn_DATA_B1 Bit Field Definitions */                                     
S#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN_T::IFnDATAB1: DATA5 Position */
S#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN_T::IFnDATAB1: DATA5 Mask */
S
S#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN_T::IFnDATAB1: DATA4 Position */
S#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN_T::IFnDATAB1: DATA4 Mask */
S
S/* CAN IFn_DATA_B2 Bit Field Definitions */                                     
S#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN_T::IFnDATAB2: DATA7 Position */
S#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN_T::IFnDATAB2: DATA7 Mask     */
S
S#define CAN_IF_DAT_B2_DATA6_Pos    0                                    /*!< CAN_T::IFnDATAB2: DATA6 Position */
S#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN_T::IFnDATAB2: DATA6 Mask     */
S
S/* CAN IFn_TXRQST1 Bit Field Definitions */
S#define CAN_IF_TXRQST1_TXRQST_Pos  0                                        /*!< CAN_T::IFnTXRQST1: TXRQST Position */
S#define CAN_IF_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST1_TXRQST_Pos)  /*!< CAN_T::IFnTXRQST1: TXRQST Mask     */
S
S/* CAN IFn_TXRQST2 Bit Field Definitions */                                         
S#define CAN_IF_TXRQST2_TXRQST_Pos  0                                        /*!< CAN_T::IFnTXRQST2: TXRQST Position  */
S#define CAN_IF_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST2_TXRQST_Pos)  /*!< CAN_T::IFnTXRQST2: TXRQST Mask      */
S
S/* CAN IFn_NDAT1 Bit Field Definitions */                                           
S#define CAN_IF_NDAT1_NEWDATA_Pos   0                                        /*!< CAN_T::IFnNDAT1: NEWDATA Position */
S#define CAN_IF_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT1_NEWDATA_Pos)   /*!< CAN_T::IFnNDAT1: NEWDATA Mask     */
S
S/* CAN IFn_NDAT2 Bit Field Definitions */                                           
S#define CAN_IF_NDAT2_NEWDATA_Pos   0                                        /*!< CAN_T::IFnNDAT2: NEWDATA Position */
S#define CAN_IF_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT2_NEWDATA_Pos)   /*!< CAN_T::IFnNDAT2: NEWDATA Mask     */
S
S/* CAN IFn_IPND1 Bit Field Definitions */                                           
S#define CAN_IF_IPND1_INTPND_Pos   0                                         /*!< CAN_T::IFnIPND1: INTPND Position */
S#define CAN_IF_IPND1_INTPND_Msk   (0xFFFFul << CAN_IF_IPND1_INTPND_Pos)     /*!< CAN_T::IFnIPND1: INTPND Mask     */
S
S/* CAN IFn_IPND2 Bit Field Definitions */                                           
S#define CAN_IF_IPND2_INTPND_Pos   0                                         /*!< CAN_T::IFnIPND2: INTPND Position */
S#define CAN_IF_IPND2_INTPND_Msk   (0xFFFFul << CAN_IF_IPND2_INTPND_Pos)     /*!< CAN_T::IFnIPND2: INTPND Mask     */
S
S/* CAN IFn_MVLD1 Bit Field Definitions */                                           
S#define CAN_IF_MVLD1_MSGVAL_Pos   0                                         /*!< CAN_T::IFnMVLD1: MSGVAL Position */
S#define CAN_IF_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD1_MSGVAL_Pos)     /*!< CAN_T::IFnMVLD1: MSGVAL Mask     */
S
S/* CAN IFn_MVLD2 Bit Field Definitions */                                           
S#define CAN_IF_MVLD2_MSGVAL_Pos   0                                         /*!< CAN_T::IFnMVLD2: MSGVAL Position */
S#define CAN_IF_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD2_MSGVAL_Pos)     /*!< CAN_T::IFnMVLD2: MSGVAL Mask     */
S
S/* CAN WUEN Bit Field Definitions */                                                
S#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN_T::WUEN: WAKUP_EN Position */
S#define CAN_WUEN_WAKUP_EN_Msk    (1ul << CAN_WUEN_WAKUP_EN_Pos)             /*!< CAN_T::WUEN: WAKUP_EN Mask     */
S
S/* CAN WUSTATUS Bit Field Definitions */                                           
S#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                    /*!< CAN_T::WUSTATUS: WAKUP_STS Position */
S#define CAN_WUSTATUS_WAKUP_STS_Msk    (1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN_T::WUSTATUS: WAKUP_STS Mask     */
S/*@}*/ /* end of group CAN_CONST */
S/*@}*/ /* end of group CAN */
S
S
S
S
S/*---------------------- System Clock Controller -------------------------*/
S/**
S    @addtogroup CLK System Clock Controller (CLK)
S    Memory Mapped Structure for CLK Controller
S@{ */
Stypedef struct
S{
S
S    /**
S     * PWRCON
S     * ===================================================================================================
S     * Offset: 0x00  System Power-down Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |XTL12M_EN |External 4~24 MHz High Speed Crystal Enable (HXT) Control (Write Protect)
S     * |        |          |The bit default value is set by flash controller user configuration register CONFIG0 [26:24].
S     * |        |          |When the default clock source is from external 4~24 MHz high speed crystal, this bit is set to 1 automatically.
S     * |        |          |0 = External 4~24 MHz high speed crystal oscillator (HXT) Disabled.
S     * |        |          |1 = External 4~24 MHz high speed crystal oscillator (HXT) Enabled.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[2]     |OSC22M_EN |Internal 22.1184 MHz High Speed Oscillator (HIRC) Enable Control (Write Protect)
S     * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) Disabled.
S     * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) Enabled.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[3]     |OSC10K_EN |Internal 10 KHz Low Speed Oscillator (LIRC) Enable Control (Write Protect)
S     * |        |          |0 = Internal 10 kHz low speed oscillator (LIRC) Disabled.
S     * |        |          |1 = Internal 10 kHz low speed oscillator (LIRC) Enabled.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[4]     |PD_WU_DLY |Wake-up Delay Counter Enable Control (Write Protect)
S     * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles to wait system clock stable.
S     * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.
S     * |        |          |0 = Clock cycles delay Disabled.
S     * |        |          |1 = Clock cycles delay Enabled.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[5]     |PD_WU_INT_EN|Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)
S     * |        |          |0 = Disabled.
S     * |        |          |1 = Enabled.
S     * |        |          |Note1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.
S     * |        |          |Note2: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[6]     |PD_WU_STS |Power-Down Mode Wake-Up Interrupt Status
S     * |        |          |Set by "Power-down wake-up event", it indicates that resume from Power-down mode.
S     * |        |          |The flag is set if the GPIO, UART, WDT, I2C, TIMER or BOD wake-up occurred. Write 1 to clear the bit to 0.
S     * |        |          |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.
S     * |[7]     |PWR_DOWN_EN|System Power-Down Enable Bit (Write Protect)
S     * |        |          |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior will depends on the PD_WAIT_CPU bit
S     * |        |          |(a) If the PD_WAIT_CPU is 0, then the chip enters Power-down mode immediately after the PWR_DOWN_EN bit set.
S     * |        |          |(b) if the PD_WAIT_CPU is 1, then the chip keeps active till the CPU sleep mode is also active and then the chip enters Power-down mode (recommend)
S     * |        |          |When chip wakes up from Power-down mode, this bit is cleared by hardware.
S     * |        |          |User needs to set this bit again for next Power-down.
S     * |        |          |In Power-down mode, external 4~24 MHz high speed crystal oscillator and the internal 22.1184 MHz high speed oscillator will be disabled in this mode, but the internal 10 kHz low speed oscillator are not controlled by Power-down mode.
S     * |        |          |In Power- down mode, the PLL and system clock are disabled, and ignored the clock source selection.
S     * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source is from the internal 10 kHz low speed oscillator.
S     * |        |          |0 = Chip operating normally or chip in Idle mode because of WFI command.
S     * |        |          |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[8]     |PD_WAIT_CPU|This Bit Control The Power-Down Entry Condition (Write Protect)
S     * |        |          |0 = Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1.
S     * |        |          |1 = Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and CPU run WFI instruction.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     */
S    __IO uint32_t PWRCON;
S
S    /**
S    * AHBCLK
S    * ===================================================================================================
S    * Offset: 0x04  AHB Devices Clock Enable Control Register
S    * ---------------------------------------------------------------------------------------------------
S    * |Bits    |Field     |Descriptions
S    * | :----: | :----:   | :---- |
S    * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control
S    * |        |          |0 = Flash ISP peripheral clock Disabled.
S    * |        |          |1 = Flash ISP peripheral clock Enabled.
S    */
S    __IO uint32_t AHBCLK;
S
S    /**
S     * APBCLK
S     * ===================================================================================================
S     * Offset: 0x08  APB Devices Clock Enable Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control (Write Protect)
S     * |        |          |0 = Watchdog Timer clock Disabled.
S     * |        |          |1 = Watchdog Timer clock Enabled.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
S     * |        |          |0 = Timer0 clock Disabled.
S     * |        |          |1 = Timer0 clock Enabled.
S     * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
S     * |        |          |0 = Timer1 clock Disabled.
S     * |        |          |1 = Timer1 clock Enabled.
S     * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
S     * |        |          |0 = Timer2 clock Disabled.
S     * |        |          |1 = Timer2 clock Enabled.
S     * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
S     * |        |          |0 = Timer3 clock Disabled.
S     * |        |          |1 = Timer3 clock Enabled.
S     * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
S     * |        |          |0 = FDIV clock Disabled.
S     * |        |          |1 = FDIV clock Enabled.
S     * |[8]     |I2C0_EN   |I2C0 Clock Enable Control
S     * |        |          |0 = I2C0 clock Disabled.
S     * |        |          |1 = I2C0 clock Enabled.
S     * |[9]     |I2C1_EN   |I2C1 Clock Enable Control
S     * |        |          |0 = I2C1 clock Disabled.
S     * |        |          |1 = I2C1 clock Enabled.
S     * |[12]    |SPI0_EN   |SPI0 Clock Enable Control
S     * |        |          |0 = SPI0 clock Disabled.
S     * |        |          |1 = SPI0 clock Enabled.
S     * |[16]    |UART0_EN  |UART0 Clock Enable Control
S     * |        |          |0 = UART0 clock Disabled.
S     * |        |          |1 = UART0 clock Enabled.
S     * |[17]    |UART1_EN  |UART1 Clock Enable Control
S     * |        |          |0 = UART1 clock Disabled.
S     * |        |          |1 = UART1 clock Enabled.
S     * |[18]    |UART2_EN  |UART2 Clock Enable Control
S     * |        |          |0 = UART2 clock Disabled.
S     * |        |          |1 = UART2 clock Enabled.
S     * |[24]    |CAN0_EN   |CAN Bus Controller-0 Clock Enable Control
S     * |        |          |0 = CAN0 clock Disabled.
S     * |        |          |1 = CAN0 clock Enable.     
S     * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control
S     * |        |          |0 = ADC clock Disabled.
S     * |        |          |1 = ADC clock Enabled.
S     */
S    __IO uint32_t APBCLK;
S
S    /**
S     * CLKSTATUS
S     * ===================================================================================================
S     * Offset: 0x0C  Clock status monitor Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |XTL12M_STB|External 4~24 MHz High Speed Crystal (HXT) Clock Source Stable Flag (Read Only)
S     * |        |          |0 = External 4~24 MHz high speed crystal clock (HXT) is not stable or disabled.
S     * |        |          |1 = External 4~24 MHz high speed crystal clock (HXT) is stable.
S     * |[2]     |PLL_STB   |Internal PLL Clock Source Stable Flag (Read Only)
S     * |        |          |0 = Internal PLL clock is not stable or disabled.
S     * |        |          |1 = Internal PLL clock is stable.
S     * |[3]     |OSC10K_STB|Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)
S     * |        |          |0 = Internal 10 kHz low speed oscillator clock (LIRC) is not stable or disabled.
S     * |        |          |1 = Internal 10 kHz low speed oscillator clock (LIRC) is stable.
S     * |[4]     |OSC22M_STB|Internal 22.1184 MHz High Speed Oscillator (HIRC) Clock Source Stable Flag (Read Only)
S     * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is not stable or disabled.
S     * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is stable.
S     * |[7]     |CLK_SW_FAIL|Clock Switching Fail Flag (Read Only)
S     * |        |          |0 = Clock switching success.
S     * |        |          |1 = Clock switching failure.
S     * |        |          |This bit is an index that if current system clock source is match as user defined at HCLK_S (CLKSEL[2:0]).
S     * |        |          |When user switch system clock, the system clock source will keep old clock until the new clock is stable.
S     * |        |          |During the period that waiting new clock stable, this bit will be an index shows system clock source is not match as user wanted.
S     */
S    __IO uint32_t CLKSTATUS;
S
S    /**
S     * CLKSEL0
S     * ===================================================================================================
S     * Offset: 0x10  Clock Source Select Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |HCLK_S    |HCLK Clock Source Select (Write Protect)
S     * |        |          |1. Before clock switching, the related clock sources (both pre-select and new-select) must be turn on.
S     * |        |          |2. The 3-bit default value is reloaded from the value of CFOSC (CONFIG0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.
S     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S     * |        |          |010 = Clock source from PLL clock.
S     * |        |          |011 = Clock source from internal 10 kHz low speed oscillator clock.
S     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[5:3]   |STCLK_S   |Cortex-M0 SysTick Clock Source Select (Write Protect)
S     * |        |          |If SYST_CSR[2] = 1, SysTick clock source is from HCLK.
S     * |        |          |If SYST_CSR[2] = 0, SysTick clock source is defined by STCLK_S(CLKSEL0[5:3]).
S     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S     * |        |          |010 = Clock source from external 4~24 MHz high speed crystal clock/2.
S     * |        |          |011 = Clock source from HCLK/2.
S     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock/2.
S     * |        |          |Note1: These bits are protected bit. It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |        |          |Note2: if SysTick clock source is not from HCLK (i.e. SYST_CSR[2] = 0), SysTick clock source must less than or equal to HCLK/2.
S     */
S    __IO uint32_t CLKSEL0;
S
S    /**
S     * CLKSEL1
S     * ===================================================================================================
S     * Offset: 0x14  Clock Source Select Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |WDT_S     |Watchdog Timer Clock Source Select (Write Protect)
S     * |        |          |10 = Clock source from HCLK/2048 clock.
S     * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[3:2]   |ADC_S     |ADC Clock Source Select
S     * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S     * |        |          |01 = Clock source from PLL clock.
S     * |        |          |10 = Clock source from HCLK.
S     * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S     * |[4]     |SPI0_S    |SPI0 Clock Source Selection
S     * |        |          |0 = Clock source from PLL clock.
S     * |        |          |1 = Clock source from HCLK.
S     * |[10:8]  |TMR0_S    |TIMER0 Clock Source Selection
S     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S     * |        |          |010 = Clock source from HCLK.
S     * |        |          |011 = Clock source from external trigger.
S     * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
S     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S     * |        |          |Others = reserved.
S     * |[14:12] |TMR1_S    |TIMER1 Clock Source Selection
S     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S     * |        |          |010 = Clock source from HCLK.
S     * |        |          |011 = Clock source from external trigger.
S     * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
S     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S     * |        |          |Others = reserved.
S     * |[18:16] |TMR2_S    |TIMER2 Clock Source Selection
S     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S     * |        |          |010 = Clock source from HCLK.
S     * |        |          |011 = Clock source from external trigger.
S     * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
S     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S     * |        |          |Others = reserved.
S     * |[22:20] |TMR3_S    |TIMER3 Clock Source Selection
S     * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S     * |        |          |010 = Clock source from HCLK.
S     * |        |          |011 = Clock source from external trigger.
S     * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
S     * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S     * |        |          |Others = reserved.
S     * |[25:24] |UART_S    |UART Clock Source Selection
S     * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S     * |        |          |01 = Clock source from PLL clock.
S     * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S     */
S    __IO uint32_t CLKSEL1;
S
S    /**
S     * CLKDIV
S     * ===================================================================================================
S     * Offset: 0x18  Clock Divider Number Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |HCLK_N    |HCLK Clock Divide Number From HCLK Clock Source
S     * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1).
S     * |[11:8]  |UART_N    |UART Clock Divide Number From UART Clock Source
S     * |        |          |UART clock frequency = (UART clock source frequency) / (UART_N + 1).
S     * |[23:16] |ADC_N     |ADC Clock Divide Number From ADC Clock Source
S     * |        |          |ADC clock frequency = (ADC clock source frequency) / (ADC_N + 1).
S     */
S    __IO uint32_t CLKDIV;
S
S    /**
S     * CLKSEL2
S     * ===================================================================================================
S     * Offset: 0x1C  Clock Source Select Control Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Selection
S     * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S     * |        |          |10 = Clock source from HCLK.
S     * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S     * |[17:16] |WWDT_S    |Window Watchdog Timer Clock Source Selection
S     * |        |          |10 = Clock source from HCLK/2048 clock.
S     * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S     */
S    __IO uint32_t CLKSEL2;
S
S    /**
S     * PLLCON
S     * ===================================================================================================
S     * Offset: 0x20  PLL Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8:0]   |FB_DV     |PLL Feedback Divider Control Bits
S     * |        |          |Refer to the formulas below the table.
S     * |[13:9]  |IN_DV     |PLL Input Divider Control Bits
S     * |        |          |Refer to the formulas below the table.
S     * |[15:14] |OUT_DV    |PLL Output Divider Control Bits
S     * |        |          |Refer to the formulas below the table.
S     * |[16]    |PD        |Power-Down Mode
S     * |        |          |If the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too.
S     * |        |          |0 = PLL is in Normal mode.
S     * |        |          |1 = PLL is in Power-down mode (default).
S     * |[17]    |BP        |PLL Bypass Control
S     * |        |          |0 = PLL is in Normal mode (default).
S     * |        |          |1 = PLL clock output is same as PLL source clock input.
S     * |[18]    |OE        |PLL OE (FOUT Enable) Pin Control
S     * |        |          |0 = PLL FOUT Enabled.
S     * |        |          |1 = PLL FOUT is fixed low.
S     * |[19]    |PLL_SRC   |PLL Source Clock Selection
S     * |        |          |0 = PLL source clock from external 4~24 MHz high speed crystal.
S     * |        |          |1 = PLL source clock from internal 22.1184 MHz high speed oscillator.
S     */
S    __IO uint32_t PLLCON;
S
S    /**
S     * FRQDIV
S     * ===================================================================================================
S     * Offset: 0x24  Frequency Divider Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
S     * |        |          |The formula of output frequency is Fout = Fin/2(N+1).
S     * |        |          |Fin is the input clock frequency.
S     * |        |          |Fout is the frequency of divider output clock.
S     * |        |          |N is the 4-bit value of FSEL[3:0].
S     * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
S     * |        |          |0 = Frequency Divider function Disabled.
S     * |        |          |1 = Frequency Divider function Enabled.
S     * |[5]     |DIVIDER1  |Frequency Divider One Enable Bit
S     * |        |          |0 = Frequency divider will output clock with source frequency divided by FSEL.
S     * |        |          |1 = Frequency divider will output clock with source frequency.
S     */
S    __IO uint32_t FRQDIV;
S
S    __IO uint32_t RESERVE0[2];
S
S    /**
S     * APBCLK1
S     * ===================================================================================================
S     * Offset: 0x30  APB Devices Clock Enable Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8]     |UART3_EN  |UART3 Clock Enable Bit
S     * |        |          |0 = UART3 clock Disabled.
S     * |        |          |1 = UART3 clock Enabled.
S     * |[9]     |UART4_EN  |UART4 Clock Enable Bit
S     * |        |          |0 = UART4 clock Disabled.
S     * |        |          |1 = UART4 clock Enabled.
S     * |[10]    |UART5_EN  |UART5 Clock Enable Bit
S     * |        |          |0 = UART5 clock Disabled.
S     * |        |          |1 = UART5 clock Enabled.
S     * |[16]    |PWM0_EN   |PWM0 Clock Enable Bit
S     * |        |          |0 = PWM0 clock Disabled.
S     * |        |          |1 = PWM0 clock Enabled.
S     * |[17]    |PWM1_EN   |PWM1 Clock Enable Bit
S     * |        |          |0 = PWM1 clock Disabled.
S     * |        |          |1 = PWM1 clock Enabled.
S     * |[18]    |BPWM0_EN  |BPWM0 Clock Enable Bit
S     * |        |          |0 = BPWM0 clock Disabled.
S     * |        |          |1 = BPWM0 clock Enabled.
S     * |[19]    |BPWM1_EN  |BPWM1 Clock Enable Bit
S     * |        |          |0 = BPWM1 clock Disabled.
S     * |        |          |1 = BPWM1 clock Enabled.
S     */
S    __IO uint32_t APBCLK1;
S
S    /**
S     * CLKSEL3
S     * ===================================================================================================
S     * Offset: 0x34  Clock Source Select Control Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[16]    |PWM0_S    |PWM0 Clock Source Selection
S     * |        |          |The peripheral clock source of PWM0 is defined by PWM0_S.
S     * |        |          |0 = Clock source from PLL.
S     * |        |          |1 = Clock source from PCLK.
S     * |[17]    |PWM1_S    |PWM1 Clock Source Selection
S     * |        |          |The peripheral clock source of PWM1 is defined by PWM1_S.
S     * |        |          |0 = Clock source from PLL.
S     * |        |          |1 = Clock source from PCLK.
S     * |[18]    |BPWM0_S   |BPWM0 Clock Source Selection
S     * |        |          |The peripheral clock source of BPWM0 is defined by BPWM0_S.
S     * |        |          |0 = Clock source from PLL.
S     * |        |          |1 = Clock source from PCLK.
S     * |[19]    |BPWM1_S   |BPWM1 Clock Source Selection
S     * |        |          |The peripheral clock source of BPWM1 is defined by BPWM1_S.
S     * |        |          |0 = Clock source from PLL.
S     * |        |          |1 = Clock source from PCLK.
S     */
S    __IO uint32_t CLKSEL3;
S
S    __IO uint32_t RESERVE1[14];
S
S    /**
S     * CLKDCTL
S     * ===================================================================================================
S     * Offset: 0x70  Clock Fail Detector Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |HXTFDEN   |HXT Clock Fail Detector Enable Bit
S     * |        |          |0 = HXT clock Fail detector Disabled.
S     * |        |          |1 = HXT clock Fail detector Enabled.
S     * |[5]     |HXTFIEN   |HXT Clock Fail Interrupt Enable Bit
S     * |        |          |0 = HXT clock Fail interrupt Disabled.
S     * |        |          |1 = HXT clock Fail interrupt Enabled.
S     * |[16]    |HXTFQDEN  |HXT Clock Frequency Monitor Enable Bit
S     * |        |          |0 = HXT clock frequency monitor Disabled.
S     * |        |          |1 = HXT clock frequency monitor Enabled.
S     * |[17]    |HXTFQIEN  |HXT Clock Frequency Monitor Interrupt Enable Bit
S     * |        |          |0 = HXT clock frequency monitor fail interrupt Disabled.
S     * |        |          |1 = HXT clock frequency monitor fail interrupt Enabled.
S     */
S    __IO uint32_t CLKDCTL;
S
S    /**
S     * CLKDSTS
S     * ===================================================================================================
S     * Offset: 0x74  Clock Fail Detector Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |HXTFIF    |HXT Clock Fail Interrupt Flag
S     * |        |          |0 = HXT clock normal.
S     * |        |          |1 = HXT clock stop (write "1" to clear).
S     * |[8]     |HXTFQIF   |HXT Clock Frequency Monitor Interrupt Flag
S     * |        |          |0 = HXT clock normal.
S     * |        |          |1 = HXT clock frequency abnormal (write "1" to clear).
S     */
S    __IO uint32_t CLKDSTS;
S
S    /**
S     * CDUPB
S     * ===================================================================================================
S     * Offset: 0x78  Clock Frequency Detector Upper Boundary Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[9:0]   |UPERBD    |HXT Clock Frequency Detector Upper Boundary
S     * |        |          |The bits define the high value of frequency monitor window.
S     * |        |          |When HXT frequency monitor value higher than this register,
S     * |        |          |the HXT frequency detect fail interrupt flag will set to 1.
S     */
S    __IO uint32_t CDUPB;
S
S    /**
S     * CDLOWB
S     * ===================================================================================================
S     * Offset: 0x7C  Clock Frequency Detector Lower Boundary Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[9:0]   |LOWERBD   |HXT Clock Frequency Detector Lower Boundary
S     * |        |          |The bits define the low value of frequency monitor window.
S     * |        |          |When HXT frequency monitor values lower than this register,
S     * |        |          |the HXT frequency detect fail interrupt flag will set to 1.
S     */
S    __IO uint32_t CDLOWB;
S
S
S} CLK_T;
S
S/**
S    @addtogroup CLK_CONST CLK Bit Field Definition
S    Constant Definitions for CLK Controller
S@{ */
S
S/* CLK PWRCON Bit Field Definitions */
S#define CLK_PWRCON_PD_WAIT_CPU_Pos           8                                    /*!< CLK_T::PWRCON: PD_WAIT_CPU Position */
S#define CLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << CLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< CLK_T::PWRCON: PD_WAIT_CPU Mask */
S
S#define CLK_PWRCON_PWR_DOWN_EN_Pos           7                                    /*!< CLK_T::PWRCON: PWR_DOWN_EN Position */
S#define CLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< CLK_T::PWRCON: PWR_DOWN_EN Mask */
S
S#define CLK_PWRCON_PD_WU_STS_Pos             6                                    /*!< CLK_T::PWRCON: PD_WU_STS Position */
S#define CLK_PWRCON_PD_WU_STS_Msk             (1ul << CLK_PWRCON_PD_WU_STS_Pos)    /*!< CLK_T::PWRCON: PD_WU_STS Mask */
S
S#define CLK_PWRCON_PD_WU_INT_EN_Pos          5                                    /*!< CLK_T::PWRCON: PD_WU_INT_EN Position */
S#define CLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << CLK_PWRCON_PD_WU_INT_EN_Pos) /*!< CLK_T::PWRCON: PD_WU_INT_EN Mask */
S
S#define CLK_PWRCON_PD_WU_DLY_Pos             4                                    /*!< CLK_T::PWRCON: PD_WU_DLY Position */
S#define CLK_PWRCON_PD_WU_DLY_Msk             (1ul << CLK_PWRCON_PD_WU_DLY_Pos)    /*!< CLK_T::PWRCON: PD_WU_DLY Mask */
S
S#define CLK_PWRCON_OSC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
S#define CLK_PWRCON_OSC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
S#define CLK_PWRCON_IRC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: IRC10K_EN Position */
S#define CLK_PWRCON_IRC10K_EN_Msk             (1ul << CLK_PWRCON_IRC10K_EN_Pos)    /*!< CLK_T::PWRCON: IRC10K_EN Mask */
S
S#define CLK_PWRCON_OSC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
S#define CLK_PWRCON_OSC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
S#define CLK_PWRCON_IRC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: IRC22M_EN Position */
S#define CLK_PWRCON_IRC22M_EN_Msk             (1ul << CLK_PWRCON_IRC22M_EN_Pos)    /*!< CLK_T::PWRCON: IRC22M_EN Mask */
S
S#define CLK_PWRCON_XTL12M_EN_Pos             0                                    /*!< CLK_T::PWRCON: XTL12M_EN Position */
S#define CLK_PWRCON_XTL12M_EN_Msk             (1ul << CLK_PWRCON_XTL12M_EN_Pos)    /*!< CLK_T::PWRCON: XTL12M_EN Mask */
S
S/* CLK AHBCLK Bit Field Definitions */
S#define CLK_AHBCLK_ISP_EN_Pos                2                                    /*!< CLK_T::AHBCLK: ISP_EN Position */
S#define CLK_AHBCLK_ISP_EN_Msk                (1ul << CLK_AHBCLK_ISP_EN_Pos)       /*!< CLK_T::AHBCLK: ISP_EN Mask */
S
S/* CLK APBCLK Bit Field Definitions */
S#define CLK_APBCLK_ADC_EN_Pos                28                                   /*!< CLK_T::APBCLK: ADC_EN Position */
S#define CLK_APBCLK_ADC_EN_Msk                (1ul << CLK_APBCLK_ADC_EN_Pos)       /*!< CLK_T::APBCLK: ADC_EN Mask */
S
S#define CLK_APBCLK_CAN0_EN_Pos               24                                   /*!< CLK APBCLK: CAN0_EN Position */
S#define CLK_APBCLK_CAN0_EN_Msk               (1ul << CLK_APBCLK_CAN0_EN_Pos)      /*!< CLK APBCLK: CAN0_EN Mask */
S
S#define CLK_APBCLK_UART2_EN_Pos              18                                   /*!< CLK_T::APBCLK: UART2_EN Position */
S#define CLK_APBCLK_UART2_EN_Msk              (1ul << CLK_APBCLK_UART2_EN_Pos)     /*!< CLK_T::APBCLK: UART2_EN Mask */
S
S#define CLK_APBCLK_UART1_EN_Pos              17                                   /*!< CLK_T::APBCLK: UART1_EN Position */
S#define CLK_APBCLK_UART1_EN_Msk              (1ul << CLK_APBCLK_UART1_EN_Pos)     /*!< CLK_T::APBCLK: UART1_EN Mask */
S
S#define CLK_APBCLK_UART0_EN_Pos              16                                   /*!< CLK_T::APBCLK: UART0_EN Position */
S#define CLK_APBCLK_UART0_EN_Msk              (1ul << CLK_APBCLK_UART0_EN_Pos)     /*!< CLK_T::APBCLK: UART0_EN Mask */
S
S#define CLK_APBCLK_SPI0_EN_Pos               12                                   /*!< CLK_T::APBCLK: SPI0_EN Position */
S#define CLK_APBCLK_SPI0_EN_Msk               (1ul << CLK_APBCLK_SPI0_EN_Pos)      /*!< CLK_T::APBCLK: SPI0_EN Mask */
S
S#define CLK_APBCLK_I2C1_EN_Pos               9                                    /*!< CLK_T::APBCLK: I2C1_EN Position */
S#define CLK_APBCLK_I2C1_EN_Msk               (1ul << CLK_APBCLK_I2C1_EN_Pos)      /*!< CLK_T::APBCLK: I2C1_EN Mask */
S
S#define CLK_APBCLK_I2C0_EN_Pos               8                                    /*!< CLK_T::APBCLK: I2C0_EN_ Position */
S#define CLK_APBCLK_I2C0_EN_Msk               (1ul << CLK_APBCLK_I2C0_EN_Pos)      /*!< CLK_T::APBCLK: I2C0_EN_ Mask */
S
S#define CLK_APBCLK_FDIV_EN_Pos               6                                    /*!< CLK_T::APBCLK: FDIV_EN Position */
S#define CLK_APBCLK_FDIV_EN_Msk               (1ul << CLK_APBCLK_FDIV_EN_Pos)      /*!< CLK_T::APBCLK: FDIV_EN Mask */
S
S#define CLK_APBCLK_TMR3_EN_Pos               5                                    /*!< CLK_T::APBCLK: TMR3_EN Position */
S#define CLK_APBCLK_TMR3_EN_Msk               (1ul << CLK_APBCLK_TMR3_EN_Pos)      /*!< CLK_T::APBCLK: TMR3_EN Mask */
S
S#define CLK_APBCLK_TMR2_EN_Pos               4                                    /*!< CLK_T::APBCLK: TMR2_EN Position */
S#define CLK_APBCLK_TMR2_EN_Msk               (1ul << CLK_APBCLK_TMR2_EN_Pos)      /*!< CLK_T::APBCLK: TMR2_EN Mask */
S
S#define CLK_APBCLK_TMR1_EN_Pos               3                                    /*!< CLK_T::APBCLK: TMR1_EN Position */
S#define CLK_APBCLK_TMR1_EN_Msk               (1ul << CLK_APBCLK_TMR1_EN_Pos)      /*!< CLK_T::APBCLK: TMR1_EN Mask */
S
S#define CLK_APBCLK_TMR0_EN_Pos               2                                    /*!< CLK_T::APBCLK: TMR0_EN Position */
S#define CLK_APBCLK_TMR0_EN_Msk               (1ul << CLK_APBCLK_TMR0_EN_Pos)      /*!< CLK_T::APBCLK: TMR0_EN Mask */
S
S#define CLK_APBCLK_WDT_EN_Pos                0                                    /*!< CLK_T::APBCLK: WDT_EN Position */
S#define CLK_APBCLK_WDT_EN_Msk                (1ul << CLK_APBCLK_WDT_EN_Pos)       /*!< CLK_T::APBCLK: WDT_EN Mask */
S
S/* CLK APBCLK1 Bit Field Definitions */
S#define CLK_APBCLK1_BPWM1_EN_Pos             19                                   /*!< CLK_T::APBCLK1: BPWM1_EN Position */
S#define CLK_APBCLK1_BPWM1_EN_Msk             (1ul << CLK_APBCLK1_BPWM1_EN_Pos)    /*!< CLK_T::APBCLK1: BPWM1_EN Mask */
S
S#define CLK_APBCLK1_BPWM0_EN_Pos             18                                   /*!< CLK_T::APBCLK1: BPWM0_EN Position */
S#define CLK_APBCLK1_BPWM0_EN_Msk             (1ul << CLK_APBCLK1_BPWM0_EN_Pos)    /*!< CLK_T::APBCLK1: BPWM0_EN Mask */
S
S#define CLK_APBCLK1_PWM1_EN_Pos              17                                   /*!< CLK_T::APBCLK1: PWM1_EN Position */
S#define CLK_APBCLK1_PWM1_EN_Msk              (1ul << CLK_APBCLK1_PWM1_EN_Pos)     /*!< CLK_T::APBCLK1: PWM1_EN Mask */
S
S#define CLK_APBCLK1_PWM0_EN_Pos              16                                   /*!< CLK_T::APBCLK1: PWM0_EN Position */
S#define CLK_APBCLK1_PWM0_EN_Msk              (1ul << CLK_APBCLK1_PWM0_EN_Pos)     /*!< CLK_T::APBCLK1: PWM0_EN Mask */
S
S#define CLK_APBCLK1_UART5_EN_Pos             10                                   /*!< CLK_T::APBCLK1: UART5_EN Position */
S#define CLK_APBCLK1_UART5_EN_Msk             (1ul << CLK_APBCLK1_UART5_EN_Pos)    /*!< CLK_T::APBCLK1: UART5_EN Mask */
S
S#define CLK_APBCLK1_UART4_EN_Pos             9                                    /*!< CLK_T::APBCLK1: UART4_EN Position */
S#define CLK_APBCLK1_UART4_EN_Msk             (1ul << CLK_APBCLK1_UART4_EN_Pos)    /*!< CLK_T::APBCLK1: UART4_EN Mask */
S
S#define CLK_APBCLK1_UART3_EN_Pos             8                                    /*!< CLK_T::APBCLK1: UART3_EN Position */
S#define CLK_APBCLK1_UART3_EN_Msk             (1ul << CLK_APBCLK1_UART3_EN_Pos)    /*!< CLK_T::APBCLK1: UART3_EN Mask */
S
S/* CLK CLKSTATUS Bit Field Definitions */
S#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                        /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position */
S#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask */
S
S#define CLK_CLKSTATUS_OSC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: OSC22M_STB Position */
S#define CLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC22M_STB Mask */
S#define CLK_CLKSTATUS_IRC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: IRC22M_STB Position */
S#define CLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << CLK_CLKSTATUS_IRC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC22M_STB Mask */
S
S#define CLK_CLKSTATUS_OSC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: OSC10K_STB Position */
S#define CLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC10K_STB Mask */
S#define CLK_CLKSTATUS_IRC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: IRC10K_STB Position */
S#define CLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << CLK_CLKSTATUS_IRC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC10K_STB Mask */
S
S#define CLK_CLKSTATUS_PLL_STB_Pos            2                                        /*!< CLK_T::CLKSTATUS: PLL_STB Position */
S#define CLK_CLKSTATUS_PLL_STB_Msk            (1ul << CLK_CLKSTATUS_PLL_STB_Pos)       /*!< CLK_T::CLKSTATUS: PLL_STB Mask */
S
S#define CLK_CLKSTATUS_XTL12M_STB_Pos         0                                        /*!< CLK_T::CLKSTATUS: XTL12M_STB Position */
S#define CLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << CLK_CLKSTATUS_XTL12M_STB_Pos)    /*!< CLK_T::CLKSTATUS: XTL12M_STB Mask */
S
S/* CLK CLKSEL0 Bit Field Definitions */
S#define CLK_CLKSEL0_STCLK_S_Pos              3                                        /*!< CLK_T::CLKSEL0: STCLK_S Position */
S#define CLK_CLKSEL0_STCLK_S_Msk              (7ul << CLK_CLKSEL0_STCLK_S_Pos)         /*!< CLK_T::CLKSEL0: STCLK_S Mask */
S
S#define CLK_CLKSEL0_HCLK_S_Pos               0                                        /*!< CLK_T::CLKSEL0: HCLK_S Position */
S#define CLK_CLKSEL0_HCLK_S_Msk               (7ul << CLK_CLKSEL0_HCLK_S_Pos)          /*!< CLK_T::CLKSEL0: HCLK_S Mask */
S
S/* CLK CLKSEL1 Bit Field Definitions */
S#define CLK_CLKSEL1_UART_S_Pos               24                                       /*!< CLK_T::CLKSEL1: UART_S Position */
S#define CLK_CLKSEL1_UART_S_Msk               (3ul << CLK_CLKSEL1_UART_S_Pos)          /*!< CLK_T::CLKSEL1: UART_S Mask */
S
S#define CLK_CLKSEL1_TMR3_S_Pos               20                                       /*!< CLK_T::CLKSEL1: TMR3_S Position */
S#define CLK_CLKSEL1_TMR3_S_Msk               (7ul << CLK_CLKSEL1_TMR3_S_Pos)          /*!< CLK_T::CLKSEL1: TMR3_S Mask */
S
S#define CLK_CLKSEL1_TMR2_S_Pos               16                                       /*!< CLK_T::CLKSEL1: TMR2_S Position */
S#define CLK_CLKSEL1_TMR2_S_Msk               (7ul << CLK_CLKSEL1_TMR2_S_Pos)          /*!< CLK_T::CLKSEL1: TMR2_S Mask */
S
S#define CLK_CLKSEL1_TMR1_S_Pos               12                                       /*!< CLK_T::CLKSEL1: TMR1_S Position */
S#define CLK_CLKSEL1_TMR1_S_Msk               (7ul << CLK_CLKSEL1_TMR1_S_Pos)          /*!< CLK_T::CLKSEL1: TMR1_S Mask */
S
S#define CLK_CLKSEL1_TMR0_S_Pos               8                                        /*!< CLK_T::CLKSEL1: TMR0_S Position */
S#define CLK_CLKSEL1_TMR0_S_Msk               (7ul << CLK_CLKSEL1_TMR0_S_Pos)          /*!< CLK_T::CLKSEL1: TMR0_S Mask */
S
S#define CLK_CLKSEL1_SPI0_S_Pos               4                                        /*!< CLK_T::CLKSEL1: SPI0_S Position */
S#define CLK_CLKSEL1_SPI0_S_Msk               (1ul << CLK_CLKSEL1_SPI0_S_Pos)          /*!< CLK_T::CLKSEL1: SPI0_S Mask */
S
S#define CLK_CLKSEL1_ADC_S_Pos                2                                        /*!< CLK_T::CLKSEL1: ADC_S Position */
S#define CLK_CLKSEL1_ADC_S_Msk                (3ul << CLK_CLKSEL1_ADC_S_Pos)           /*!< CLK_T::CLKSEL1: ADC_S Mask */
S
S#define CLK_CLKSEL1_WDT_S_Pos                0                                        /*!< CLK_T::CLKSEL1: WDT_S Position */
S#define CLK_CLKSEL1_WDT_S_Msk                (3ul << CLK_CLKSEL1_WDT_S_Pos)           /*!< CLK_T::CLKSEL1: WDT_S Mask */
S
S/* CLK CLKSEL2 Bit Field Definitions */
S#define CLK_CLKSEL2_WWDT_S_Pos               16                                       /*!< CLK_T::CLKSEL2: WWDT_S Position */
S#define CLK_CLKSEL2_WWDT_S_Msk               (3ul << CLK_CLKSEL2_WWDT_S_Pos)          /*!< CLK_T::CLKSEL2: WWDT_S Mask */
S
S#define CLK_CLKSEL2_FRQDIV_S_Pos             2                                        /*!< CLK_T::CLKSEL2: FRQDIV_S Position */
S#define CLK_CLKSEL2_FRQDIV_S_Msk             (3ul << CLK_CLKSEL2_FRQDIV_S_Pos)        /*!< CLK_T::CLKSEL2: FRQDIV_S Mask */
S
S/* CLK CLKSEL3 Bit Field Definitions */
S#define CLK_CLKSEL3_BPWM1_S_Pos              19                                       /*!< CLK_T::CLKSEL3: BPWM1_S Position */
S#define CLK_CLKSEL3_BPWM1_S_Msk              (1ul << CLK_CLKSEL3_BPWM1_S_Pos)         /*!< CLK_T::CLKSEL3: BPWM1_S Mask */
S
S#define CLK_CLKSEL3_BPWM0_S_Pos              18                                       /*!< CLK_T::CLKSEL3: BPWM0_S Position */
S#define CLK_CLKSEL3_BPWM0_S_Msk              (1ul << CLK_CLKSEL3_BPWM0_S_Pos)         /*!< CLK_T::CLKSEL3: BPWM0_S Mask */
S
S#define CLK_CLKSEL3_PWM1_S_Pos               17                                       /*!< CLK_T::CLKSEL3: PWM1_S Position */
S#define CLK_CLKSEL3_PWM1_S_Msk               (1ul << CLK_CLKSEL3_PWM1_S_Pos)          /*!< CLK_T::CLKSEL3: PWM1_S Mask */
S
S#define CLK_CLKSEL3_PWM0_S_Pos               16                                       /*!< CLK_T::CLKSEL3: PWM0_S Position */
S#define CLK_CLKSEL3_PWM0_S_Msk               (1ul << CLK_CLKSEL3_PWM0_S_Pos)          /*!< CLK_T::CLKSEL3: PWM0_S Mask */
S
S/* CLK CLKDIV Bit Field Definitions */
S#define CLK_CLKDIV_ADC_N_Pos                 16                                       /*!< CLK_T::CLKDIV: ADC_N Position */
S#define CLK_CLKDIV_ADC_N_Msk                 (0xFFul << CLK_CLKDIV_ADC_N_Pos)         /*!< CLK_T::CLKDIV: ADC_N Mask */
S
S#define CLK_CLKDIV_UART_N_Pos                8                                        /*!< CLK_T::CLKDIV: UART_N Position */
S#define CLK_CLKDIV_UART_N_Msk                (0xFul << CLK_CLKDIV_UART_N_Pos)         /*!< CLK_T::CLKDIV: UART_N Mask */
S
S#define CLK_CLKDIV_HCLK_N_Pos                0                                        /*!< CLK_T::CLKDIV: HCLK_N Position */
S#define CLK_CLKDIV_HCLK_N_Msk                (0xFul << CLK_CLKDIV_HCLK_N_Pos)         /*!< CLK_T::CLKDIV: HCLK_N Mask */
S
S/* CLK PLLCON Bit Field Definitions */
S#define CLK_PLLCON_PLL_SRC_Pos               19                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
S#define CLK_PLLCON_PLL_SRC_Msk               (1ul << CLK_PLLCON_PLL_SRC_Pos)          /*!< CLK_T::PLLCON: PLL_SRC Mask */
S
S#define CLK_PLLCON_OE_Pos                    18                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
S#define CLK_PLLCON_OE_Msk                    (1ul << CLK_PLLCON_OE_Pos)               /*!< CLK_T::PLLCON: PLL_SRC Mask */
S
S#define CLK_PLLCON_BP_Pos                    17                                       /*!< CLK_T::PLLCON: OE Position */
S#define CLK_PLLCON_BP_Msk                    (1ul << CLK_PLLCON_BP_Pos)               /*!< CLK_T::PLLCON: OE Mask */
S
S#define CLK_PLLCON_PD_Pos                    16                                       /*!< CLK_T::PLLCON: PD Position */
S#define CLK_PLLCON_PD_Msk                    (1ul << CLK_PLLCON_PD_Pos)               /*!< CLK_T::PLLCON: PD Mask */
S
S#define CLK_PLLCON_OUT_DV_Pos                14                                       /*!< CLK_T::PLLCON: OUT_DV Position */
S#define CLK_PLLCON_OUT_DV_Msk                (3ul << CLK_PLLCON_OUT_DV_Pos)           /*!< CLK_T::PLLCON: OUT_DV Mask */
S
S#define CLK_PLLCON_IN_DV_Pos                 9                                        /*!< CLK_T::PLLCON: IN_DV Position */
S#define CLK_PLLCON_IN_DV_Msk                 (0x1Ful << CLK_PLLCON_IN_DV_Pos)         /*!< CLK_T::PLLCON: IN_DV Mask */
S
S#define CLK_PLLCON_FB_DV_Pos                 0                                        /*!< CLK_T::PLLCON: FB_DV Position */
S#define CLK_PLLCON_FB_DV_Msk                 (0x1FFul << CLK_PLLCON_FB_DV_Pos)        /*!< CLK_T::PLLCON: FB_DV Mask */
S
S/* CLK FRQDIV Bit Field Definitions */
S#define CLK_FRQDIV_DIVIDER1_Pos              5                                        /*!< CLK_T::FRQDIV: DIVIDER1 Position */
S#define CLK_FRQDIV_DIVIDER1_Msk              (1ul << CLK_FRQDIV_DIVIDER1_Pos)         /*!< CLK_T::FRQDIV: DIVIDER1 Mask */
S
S#define CLK_FRQDIV_DIVIDER_EN_Pos            4                                        /*!< CLK_T::FRQDIV: DIVIDER_EN Position */
S#define CLK_FRQDIV_DIVIDER_EN_Msk            (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)       /*!< CLK_T::FRQDIV: DIVIDER_EN Mask */
S
S#define CLK_FRQDIV_FSEL_Pos                  0                                        /*!< CLK_T::FRQDIV: FRQDIV_FSEL Position */
S#define CLK_FRQDIV_FSEL_Msk                  (0xFul << CLK_FRQDIV_FSEL_Pos)           /*!< CLK_T::FRQDIV: FRQDIV_FSEL Mask */
S
S/* CLK CLKDCTL Bit Field Definitions */
S#define CLK_CLKDCTL_HXTFQIEN_Pos           17                                         /*!< CLK_T::CLKDCTL: HXTFQIEN Position */
S#define CLK_CLKDCTL_HXTFQIEN_Msk           (1ul << CLK_CLKDCTL_HXTFQIEN_Pos)          /*!< CLK_T::CLKDCTL: HXTFQIEN Mask */
S
S#define CLK_CLKDCTL_HXTFQDEN_Pos           16                                         /*!< CLK_T::CLKDCTL: HXTFQDEN Position */
S#define CLK_CLKDCTL_HXTFQDEN_Msk           (1ul << CLK_CLKDCTL_HXTFQDEN_Pos)          /*!< CLK_T::CLKDCTL: HXTFQDEN Mask */
S
S#define CLK_CLKDCTL_HXTFIEN_Pos           5                                           /*!< CLK_T::CLKDCTL: HXTFIEN Position */
S#define CLK_CLKDCTL_HXTFIEN_Msk           (1ul << CLK_CLKDCTL_HXTFIEN_Pos)            /*!< CLK_T::CLKDCTL: HXTFIEN Mask */
S                                                                                    
S#define CLK_CLKDCTL_HXTFDEN_Pos           4                                           /*!< CLK_T::CLKDCTL: HXTFDEN Position */
S#define CLK_CLKDCTL_HXTFDEN_Msk           (1ul << CLK_CLKDCTL_HXTFDEN_Pos)            /*!< CLK_T::CLKDCTL: HXTFDEN Mask */
S
S/* CLK CLKDSTS Bit Field Definitions */
S#define CLK_CLKDSTS_HXTFQIF_Pos           8                                           /*!< CLK_T::CLKDSTS: HXTFQIF Position */
S#define CLK_CLKDSTS_HXTFQIF_Msk           (1ul << CLK_CLKDSTS_HXTFQIF_Pos)            /*!< CLK_T::CLKDSTS: HXTFQIF Mask */
S
S#define CLK_CLKDSTS_HXTFIF_Pos           0                                            /*!< CLK_T::CLKDSTS: HXTFIF Position */
S#define CLK_CLKDSTS_HXTFIF_Msk           (1ul << CLK_CLKDSTS_HXTFIF_Pos)              /*!< CLK_T::CLKDSTS: HXTFIF Mask */
S
S/* CLK CDUPB Bit Field Definitions */
S#define CLK_CDUPB_UPERBD_Pos           0                                             /*!< CLK_T::CDUPB: UPERBD Position */
S#define CLK_CDUPB_UPERBD_Msk           (0x3Ful << CLK_CDUPB_UPERBD_Pos)              /*!< CLK_T::CDUPB: UPERBD Mask */
S
S/* CLK CDLOWB Bit Field Definitions */
S#define CLK_CDLOWB_UPERBD_Pos           0                                            /*!< CLK_T::CDLOWB: LOWRBD Position */
S#define CLK_CDLOWB_UPERBD_Msk           (0x3Ful << CLK_CDLOWB_LOWERBD_Pos)           /*!< CLK_T::CDLOWB: LOWERBD Mask */
S
S/*@}*/ /* end of group CLK_CONST */
S/*@}*/ /* end of group CLK */
S
S
S
S
S/*---------------------- Flash Memory Controller -------------------------*/
S/**
S    @addtogroup FMC Flash Memory Controller (FMC)
S    Memory Mapped Structure for FMC Controller
S@{ */
Stypedef struct
S{
S    /**
S     * ISPCON
S     * ===================================================================================================
S     * Offset: 0x00  ISP Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPEN     |ISP Enable (Write Protect)
S     * |        |          |ISP function enable bit. Set this bit to enable ISP function.
S     * |        |          |0 = ISP function Disabled.     
S     * |        |          |1 = ISP function Enabled.
S     * |[1]     |BS        |Boot Select (Write Protect)
S     * |        |          |Set/clear this bit to select next booting from LDROM/APROM,
S     * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check where
S     * |        |          |MCU booted from. This bit is initiated with the inverted value of CBS in Config0 after power-
S     * |        |          |on reset; It keeps the same value at other reset.
S     * |        |          |0 = boot from APROM     
S     * |        |          |1 = boot from LDROM
S     * |[3]     |APUEN     |APROM Update Enable Bit (Write Protect)
S     * |        |          |0 = APROM cannot be updated when the chip runs in APROM.
S     * |        |          |1 = APROM can be updated when the chip runs in APROM.
S     * |[4]     |CFGUEN    |Config Update Enable (Write Protect)
S     * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program
S     * |        |          |code is running in APROM or LDROM.
S     * |        |          |0 = Config update disable     
S     * |        |          |1 = Config update enable
S     * |[5]     |LDUEN     |LDROM Update Enable (Write Protect)
S     * |        |          |LDROM update enable bit.
S     * |        |          |0 = LDROM cannot be updated
S     * |        |          |1 = LDROM can be updated when chip runs in APROM.     
S     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
S     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
S     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
S     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
S     * |        |          |(4) Destination address is illegal, such as over an available range.
S     * |        |          |Note: Write 1 to clear.
S     */
S    __IO uint32_t ISPCON;
S
S    /**
S     * ISPADR
S     * ===================================================================================================
S     * Offset: 0x04  ISP Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPADR    |ISP Address
S     * |        |          |NuMicro NUC131 series has a maximum of 17Kx32(68KB) embedded Flash, which supports word program only.
S     * |        |          |ISPADR[1:0] must be kept 00b for ISP operation.
S     */
S    __IO uint32_t ISPADR;
S
S    /**
S     * ISPDAT
S     * ===================================================================================================
S     * Offset: 0x08  ISP Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |ISPDAT    |ISP Data
S     * |        |          |Write data to this register before ISP program operation
S     * |        |          |Read data from this register after ISP read operation
S     */
S    __IO uint32_t ISPDAT;
S
S    /**
S     * ISPCMD
S     * ===================================================================================================
S     * Offset: 0x0C  ISP Command Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |ISPCMD    |ISP Command
S     * |        |          |ISP command table is shown below:
S     * |        |          |0x00 = Read.
S     * |        |          |0x04 = Read Unique ID.
S     * |        |          |0x0B = Read Company ID (0xDA).
S     * |        |          |0x21 = Program.
S     * |        |          |0x22 = Page Erase.
S     * |        |          |0x2E = Set Vector Page Re-Map.
S     */
S    __IO uint32_t ISPCMD;
S
S    /**
S     * ISPTRG
S     * ===================================================================================================
S     * Offset: 0x10  IISP Trigger Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPGO     |ISP Start Trigger (Write Protect)
S     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP
S     * |        |          |operation is finish.
S     * |        |          |0 = ISP operation is finished.
S     * |        |          |1 = ISP is in progress.     
S     */
S    __IO uint32_t ISPTRG;
S
S    /**
S     * DFBADR
S     * ===================================================================================================
S     * Offset: 0x14  Data Flash Base Address Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |DFBA      |Data Flash Base Address
S     * |        |          |This register indicates data flash start address.
S     * |        |          |It is a read only register.
S     * |        |          |When DFVSEN is set to 0, the data flash is shared with APROM. The data flash size is defined by user configuration and the content of this register is loaded from Config1.
S     * |        |          |When DFVSEN is set to 1, the data flash size is fixed as 4K and the start address can be read from this register is fixed at 0x0001_F000.
S     */
S    __I  uint32_t DFBADR;
S
S    /**
S     * FATCON
S     * ===================================================================================================
S     * Offset: 0x18  Flash Access Time Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |FOMSEL0   |Chip Frequency Optimization Mode Select 0 (Write Protect)
S     * |        |          |When CPU frequency is lower than 25MHz, user can modify flash access delay cycle by FOMSEL1 and FOMSEL0 to improve system performance.
S     * |        |          |00 = CPU runs up to 50MHz with zero wait cycle for continuous address read access.
S     * |        |          |01 = CPU runs up to 25MHz with zero wait cycle for random address read access.
S     * |        |          |10 = Reserved.
S     * |        |          |11 = Reserved.
S     * |        |          |Note: Where 00 means FOMSEL1=0, FOMSEL0=0; 01 means FOMSEL1 = 0, FOMSEL0=1 and etc.
S     * |[6]     |FOMSEL1   |Chip Frequency Optimization Mode Select 1 (Write Protect)
S     * |        |          |When CPU frequency is lower than 25MHz, user can modify flash access delay cycle by FOMSEL1 and FOMSEL0 to improve system performance.
S     * |        |          |00 = CPU runs up to 50MHz with zero wait cycle for continuous address read access.
S     * |        |          |01 = CPU runs up to 25MHz with zero wait cycle for random address read access.
S     * |        |          |10 = Reserved.
S     * |        |          |11 = Reserved.
S     * |        |          |Note: Where 00 means FOMSEL1=0, FOMSEL0=0; 01 means FOMSEL1 = 0, FOMSEL0=1 and etc.
S     */
S    __IO uint32_t FATCON;
S
S    __I  uint32_t  RESERVED[9];
S
S    /**
S     * ISPSTA
S     * ===================================================================================================
S     * Offset: 0x40  ISP Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ISPGO     |ISP Start Trigger (Read Only)
S     * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
S     * |        |          |This bit is the mirror of ISPGO(FMC_ISPTRG[0]).
S     * |        |          |0 = ISP operation is finished.
S     * |        |          |1 = ISP operation is progressed.
S     * |[2:1]   |CBS       |Boot Selection Of CONFIG (Read Only)
S     * |        |          |This bit is initiated with the CBS (CONFIG0[7:6]) after any reset is happened except CPU reset (CPU is 1) or system reset (SYS) is happened.
S     * |        |          |00 = LDROM with IAP mode.
S     * |        |          |01 = LDROM without IAP mode.
S     * |        |          |10 = APROM with IAP mode.
S     * |        |          |11 = APROM without IAP mode.
S     * |[6]     |ISPFF     |ISP Fail Flag (Write Protect)
S     * |        |          |This bit is the mirror of ISPFF (FMC_ISPCON[6]), it needs to be cleared by writing 1 to FMC_ISPCON[6] or FMC_ISPSTA[6].
S     * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S     * |        |          |(1) APROM writes to itself if APUEN is set to 0.
S     * |        |          |(2) LDROM writes to itself if LDUEN is set to 0.
S     * |        |          |(3) CONFIG is erased/programmed if CFGUEN is set to 0.
S     * |        |          |(4) Destination address is illegal, such as over an available range.
S     * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
S     * |        |          |All access to 0x0000_0000~0x0000_01FF is remapped to the flash memory address {VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}
S    */
S    __IO uint32_t ISPSTA;
S
S} FMC_T;
S
S/**
S    @addtogroup FMC_CONST FMC Bit Field Definition
S    Constant Definitions for FMC Controller
S@{ */
S
S
S/* FMC ISPCON Bit Field Definitions */
S#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC_T::ISPCON: ISPFF Position */
S#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC_T::ISPCON: ISPFF Mask */
S
S#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC_T::ISPCON: LDUEN Position */
S#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC_T::ISPCON: LDUEN Mask */
S
S#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC_T::ISPCON: CFGUEN Position */
S#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC_T::ISPCON: CFGUEN Mask */
S
S#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC_T::ISPCON: APUEN Position */
S#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC_T::ISPCON: APUEN Mask */
S
S#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC_T::ISPCON: BS Position */
S#define FMC_ISPCON_BS_Msk                       (0x1ul << FMC_ISPCON_BS_Pos)            /*!< FMC_T::ISPCON: BS Mask */
S
S#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC_T::ISPCON: ISPEN Position */
S#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC_T::ISPCON: ISPEN Mask */
S
S/* FMC ISPADR Bit Field Definitions */
S#define FMC_ISPADR_ISPADR_Pos                   0                                       /*!< FMC_T::ISPADR: ISPADR Position */
S#define FMC_ISPADR_ISPADR_Msk                   (0xFFFFFFFFul << FMC_ISPADR_ISPADR_Pos) /*!< FMC_T::ISPADR: ISPADR Mask */
S
S/* FMC ISPDAT Bit Field Definitions */
S#define FMC_ISPDAT_ISPDAT_Pos                   0                                       /*!< FMC_T::ISPDAT: ISPDAT Position */
S#define FMC_ISPDAT_ISPDAT_Msk                   (0xFFFFFFFFul << FMC_ISPDAT_ISPDAT_Pos) /*!< FMC_T::ISPDAT: ISPDAT Mask */
S
S/* FMC ISPCMD Bit Field Definitions */
S#define FMC_ISPCMD_ISPCMD_Pos                   0                                       /*!< FMC_T::ISPCMD: ISPCMD Position */
S#define FMC_ISPCMD_ISPCMD_Msk                   (0xFul << FMC_ISPCMD_ISPCMD_Pos)        /*!< FMC_T::ISPCMD: ISPCMD Mask */
S
S/* FMC ISPTRG Bit Field Definitions */
S#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC_T::ISPTRG: ISPGO Position */
S#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC_T::ISPTRG: ISPGO Mask */
S
S/* FMC DFBADR Bit Field Definitions */
S#define FMC_DFBADR_DFBA_Pos                     0                                       /*!< FMC_T::DFBADR: DFBA Position */
S#define FMC_DFBADR_DFBA_Msk                     (0xFFFFFFFFul << FMC_DFBADR_DFBA_Pos)   /*!< FMC_T::DFBADR: DFBA Mask */
S
S/* FMC FATCON Bit Field Definitions */
S#define FMC_FATCON_FOMSEL1_Pos                  6                                       /*!< FMC_T::FATCON: FOMSEL1 Position */
S#define FMC_FATCON_FOMSEL1_Msk                  (1ul << FMC_FATCON_FOMSEL1_Pos)         /*!< FMC_T::FATCON: FOMSEL1 Mask */
S
S#define FMC_FATCON_FOMSEL0_Pos                  4                                       /*!< FMC_T::FATCON: FOMSEL0 Position */
S#define FMC_FATCON_FOMSEL0_Msk                  (1ul << FMC_FATCON_FOMSEL0_Pos)         /*!< FMC_T::FATCON: FOMSEL0 Mask */
S
S/* FMC ISPSTA Bit Field Definitions */
S#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC_T::ISPSTA: VECMAP Position */
S#define FMC_ISPSTA_VECMAP_Msk                   (0xFFFul << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC_T::ISPSTA: VECMAP Mask */
S
S#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC_T::ISPSTA: ISPFF Position */
S#define FMC_ISPSTA_ISPFF_Msk                    (0x3ul << FMC_ISPSTA_ISPFF_Pos)         /*!< FMC_T::ISPSTA: ISPFF Mask */
S
S#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC_T::ISPSTA: CBS Position */
S#define FMC_ISPSTA_CBS_Msk                      (0x3ul << FMC_ISPSTA_CBS_Pos)           /*!< FMC_T::ISPSTA: CBS Mask */
S
S#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC_T::ISPSTA: ISPGO Position */
S#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC_T::ISPSTA: ISPGO Mask */
S/*@}*/ /* end of group FMC_CONST */
S/*@}*/ /* end of group FMC */
S
S
S
S
S
S/*--------------------- General Purpose I/O (GPIO) ---------------------*/
S/** @addtogroup GPIO General purpose I/O (GPIO)
S  Memory Mapped Structure for NUC131 Series General Purpose I/O
S  @{
S */
Stypedef struct
S{
S    /**
S     * GPIOx_PMD
S     * ===================================================================================================
S     * Offset: 0x00  GPIO Port [A/B/C/D/E/F] Pin I/O Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2n+1:2n]|PMDn     |GPIOx I/O Pin[n] Mode Control
S     * |        |          |Determine each I/O mode of GPIOx pins.
S     * |        |          |00 = GPIO port [n] pin is in Input mode.
S     * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
S     * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
S     * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S     * |        |          |Note1:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     * |        |          |Note2:
S     * |        |          |The initial value of this field is defined by CIOINI (CONFIG0[10]).
S     * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional mode after chip is powered on.
S     * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode after chip is powered on.
S     */
S    __IO uint32_t  PMD;
S
S    /**
S     * GPIOx_OFFD
S     * ===================================================================================================
S     * Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:16] |OFFD      |GPIOx Pin[n] Digital Input Path Disable Control
S     * |        |          |Each of these bits is used to control if the digital input path of corresponding GPIO pin is disabled.
S     * |        |          |If input is analog signal, users can disable GPIO digital input path to avoid current leakage.
S     * |        |          |0 = I/O digital input path Enabled.
S     * |        |          |1 = I/O digital input path Disabled (digital input tied to low).
S     * |        |          |Note:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     */
S    __IO uint32_t  OFFD;
S
S    /**
S     * GPIOx_DOUT
S     * ===================================================================================================
S     * Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |DOUTn     |GPIOx Pin[n] Output Value
S     * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as Push-pull output, open-drain output or quasi-bidirectional mode.
S     * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull output, Open-drain output or Quasi-bidirectional mode.
S     * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull output or Quasi-bidirectional mode.
S     * |        |          |Note:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     */
S    __IO uint32_t  DOUT;
S
S    /**
S     * GPIOx_DMASK
S     * ===================================================================================================
S     * Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |DMASKn    |Port [A/B/C/D/E/F] Data Output Write Mask
S     * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
S     * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
S     * |        |          |If the write signal is masked, write data to the protect bit is ignored.
S     * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
S     * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
S     * |        |          |Note1: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect the corresponding bit control register (GPIOAx_DOUT, GPIOBx_DOUT, GPIOCx_DOUT, GPIODx_DOUT, GPIOEx_DOUT and GPIOFx_DOUT).
S     * |        |          |Note2:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     */
S    __IO uint32_t  DMASK;
S
S    /**
S     * GPIOx_PIN
S     * ===================================================================================================
S     * Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |PINn      |Port [A/B/C/D/E/F] Pin Values
S     * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
S     * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
S     * |        |          |Note:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     */
S    __I  uint32_t  PIN;
S
S    /**
S     * GPIOx_DBEN
S     * ===================================================================================================
S     * Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |DBENn     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
S     * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
S     * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the input signal transition is seen as the signal bounce and will not trigger the interrupt.
S     * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is controlled by DBNCECON[3:0].
S     * |        |          |0 = Bit[n] de-bounce function Disabled.
S     * |        |          |1 = Bit[n] de-bounce function Enabled.
S     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
S     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S     * |        |          |Note:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     */
S    __IO uint32_t  DBEN;
S
S    /**
S     * GPIOA_IMD
S     * ===================================================================================================
S     * Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |IMDn      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
S     * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
S     * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
S     * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
S     * |        |          |clock and generates the interrupt.
S     * |        |          |0 = Edge trigger interrupt.
S     * |        |          |1 = Level trigger interrupt.
S     * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers GPIOx_IEN.
S     * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
S     * |        |          |The de-bounce function is valid only for edge triggered interrupt.
S     * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S     * |        |          |Note:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     */
S    __IO uint32_t  IMD;
S
S    /**
S     * GPIOx_IEN
S     * ===================================================================================================
S     * Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |IF_ENn    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
S     * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
S     * |        |          |Set bit to 1 also enable the pin wake-up function.
S     * |        |          |When setting the IF_EN[n] bit to 1:
S     * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
S     * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
S     * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
S     * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
S     * |        |          |Note:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     * |[n+16]  |IR_ENn    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
S     * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
S     * |        |          |Set bit to 1 also enable the pin wake-up function.
S     * |        |          |When setting the IR_EN[n] bit to 1:
S     * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
S     * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
S     * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
S     * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
S     * |        |          |Note:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     */
S    __IO uint32_t  IEN;
S
S    /**
S     * GPIOx_ISRC
S     * ===================================================================================================
S     * Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[n]     |ISRCn     |Port [A/B/C/D/E/F] Interrupt Source Flag
S     * |        |          |Read :
S     * |        |          |0 = No interrupt at GPIOx[n].
S     * |        |          |1 = GPIOx[n] generates an interrupt.
S     * |        |          |Write :
S     * |        |          |0= No action.
S     * |        |          |1= Clear the corresponding pending interrupt.
S     * |        |          |Note:
S     * |        |          |n = 0~15 for GPIOA/GPIOB;
S     * |        |          |n = 0~3, 6~11, 14, 15 for GPIOC;
S     * |        |          |n = 6, 7, 14, 15 for GPIOD;
S     * |        |          |n = 5 for GPIOE;
S     * |        |          |n = 0, 1, 4~8 for GPIOF.
S     */
S    __IO uint32_t  ISRC;
S} GPIO_T;
S
Stypedef struct
S{
S    /**
S     * DBNCECON
S     * ===================================================================================================
S     * Offset: 0x180  External Interrupt De-bounce Control
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |DBCLKSEL  |De-Bounce Sampling Cycle Selection
S     * |        |          |0000 = Sample interrupt input once per 1 clocks
S     * |        |          |0001 = Sample interrupt input once per 2 clocks
S     * |        |          |0010 = Sample interrupt input once per 4 clocks
S     * |        |          |0011 = Sample interrupt input once per 8 clocks
S     * |        |          |0100 = Sample interrupt input once per 16 clocks
S     * |        |          |0101 = Sample interrupt input once per 32 clocks
S     * |        |          |0110 = Sample interrupt input once per 64 clocks
S     * |        |          |0111 = Sample interrupt input once per 128 clocks
S     * |        |          |1000 = Sample interrupt input once per 256 clocks
S     * |        |          |1001 = Sample interrupt input once per 2*256 clocks
S     * |        |          |1010 = Sample interrupt input once per 4*256clocks
S     * |        |          |1011 = Sample interrupt input once per 8*256 clocks
S     * |        |          |1100 = Sample interrupt input once per 16*256 clocks
S     * |        |          |1101 = Sample interrupt input once per 32*256 clocks
S     * |        |          |1110 = Sample interrupt input once per 64*256 clocks
S     * |        |          |1111 = Sample interrupt input once per 128*256 clocks
S     * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
S     * |        |          |0 = De-bounce counter clock source is the HCLK.
S     * |        |          |1 = De-bounce counter clock source is the internal 10 kHz low speed oscillator.
S     * |[5]     |ICLK_ON   |Interrupt Clock On Mode
S     * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to 1.
S     * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
S     * |        |          |It is recommended to turn off this bit to save system power if no special application concern.
S     */
S    __IO uint32_t  DBNCECON;
S} GPIO_DBNCECON_T;
S
S/** @addtogroup GPIO_CONST GPIO Bit Field Definition
S    Constant Definitions for GPIO Controller
S  @{
S */
S
S/* GPIO PMD Bit Field Definitions */
S#define GPIO_PMD_PMD15_Pos          30                                          /*!< GPIO_T::PMD: PMD15 Position */
S#define GPIO_PMD_PMD15_Msk          (0x3ul << GPIO_PMD_PMD15_Pos)               /*!< GPIO_T::PMD: PMD15 Mask */
S
S#define GPIO_PMD_PMD14_Pos          28                                          /*!< GPIO_T::PMD: PMD14 Position */
S#define GPIO_PMD_PMD14_Msk          (0x3ul << GPIO_PMD_PMD14_Pos)               /*!< GPIO_T::PMD: PMD14 Mask */
S
S#define GPIO_PMD_PMD13_Pos          26                                          /*!< GPIO_T::PMD: PMD13 Position */
S#define GPIO_PMD_PMD13_Msk          (0x3ul << GPIO_PMD_PMD13_Pos)               /*!< GPIO_T::PMD: PMD13 Mask */
S
S#define GPIO_PMD_PMD12_Pos          24                                          /*!< GPIO_T::PMD: PMD12 Position */
S#define GPIO_PMD_PMD12_Msk          (0x3ul << GPIO_PMD_PMD12_Pos)               /*!< GPIO_T::PMD: PMD12 Mask */
S
S#define GPIO_PMD_PMD11_Pos          22                                          /*!< GPIO_T::PMD: PMD11 Position */
S#define GPIO_PMD_PMD11_Msk          (0x3ul << GPIO_PMD_PMD11_Pos)               /*!< GPIO_T::PMD: PMD11 Mask */
S
S#define GPIO_PMD_PMD10_Pos          20                                          /*!< GPIO_T::PMD: PMD10 Position */
S#define GPIO_PMD_PMD10_Msk          (0x3ul << GPIO_PMD_PMD10_Pos)               /*!< GPIO_T::PMD: PMD10 Mask */
S
S#define GPIO_PMD_PMD9_Pos           18                                          /*!< GPIO_T::PMD: PMD9 Position */
S#define GPIO_PMD_PMD9_Msk           (0x3ul << GPIO_PMD_PMD9_Pos)                /*!< GPIO_T::PMD: PMD9 Mask */
S
S#define GPIO_PMD_PMD8_Pos           16                                          /*!< GPIO_T::PMD: PMD8 Position */
S#define GPIO_PMD_PMD8_Msk           (0x3ul << GPIO_PMD_PMD8_Pos)                /*!< GPIO_T::PMD: PMD8 Mask */
S
S#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO_T::PMD: PMD7 Position */
S#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO_T::PMD: PMD7 Mask */
S
S#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO_T::PMD: PMD6 Position */
S#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO_T::PMD: PMD6 Mask */
S
S#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO_T::PMD: PMD5 Position */
S#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO_T::PMD: PMD5 Mask */
S
S#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO_T::PMD: PMD4 Position */
S#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO_T::PMD: PMD4 Mask */
S
S#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO_T::PMD: PMD3 Position */
S#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO_T::PMD: PMD3 Mask */
S
S#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO_T::PMD: PMD2 Position */
S#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO_T::PMD: PMD2 Mask */
S
S#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO_T::PMD: PMD1 Position */
S#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO_T::PMD: PMD1 Mask */
S
S#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO_T::PMD: PMD0 Position */
S#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO_T::PMD: PMD0 Mask */
S
S/* GPIO OFFD Bit Field Definitions */
S#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO_T::OFFD: OFFD Position */
S#define GPIO_OFFD_OFFD_Msk          (0xFFFFul << GPIO_OFFD_OFFD_Pos)            /*!< GPIO_T::OFFD: OFFD Mask */
S
S/* GPIO DOUT Bit Field Definitions */
S#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO_T::DOUT: DOUT Position */
S#define GPIO_DOUT_DOUT_Msk          (0xFFFFul << GPIO_DOUT_DOUT_Pos)            /*!< GPIO_T::DOUT: DOUT Mask */
S
S/* GPIO DMASK Bit Field Definitions */
S#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO_T::DMASK: DMASK Position */
S#define GPIO_DMASK_DMASK_Msk        (0xFFFFul << GPIO_DMASK_DMASK_Pos)          /*!< GPIO_T::DMASK: DMASK Mask */
S
S/* GPIO PIN Bit Field Definitions */
S#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO_T::PIN: PIN Position */
S#define GPIO_PIN_PIN_Msk            (0xFFFFul << GPIO_PIN_PIN_Pos)              /*!< GPIO_T::PIN: PIN Mask */
S
S/* GPIO DBEN Bit Field Definitions */
S#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO_T::DBEN: DBEN Position */
S#define GPIO_DBEN_DBEN_Msk          (0xFFFFul << GPIO_DBEN_DBEN_Pos)            /*!< GPIO_T::DBEN: DBEN Mask */
S
S/* GPIO IMD Bit Field Definitions */
S#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO_T::IMD: IMD Position */
S#define GPIO_IMD_IMD_Msk            (0xFFFFul << GPIO_IMD_IMD_Pos)              /*!< GPIO_T::IMD: IMD Mask */
S
S/* GPIO IEN Bit Field Definitions */
S#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO_T::IEN: IR_EN Position */
S#define GPIO_IEN_IR_EN_Msk          (0xFFFFul << GPIO_IEN_IR_EN_Pos)            /*!< GPIO_T::IEN: IR_EN Mask */
S
S#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO_T::IEN: IF_EN Position */
S#define GPIO_IEN_IF_EN_Msk          (0xFFFFul << GPIO_IEN_IF_EN_Pos)            /*!< GPIO_T::IEN: IF_EN Mask */
S
S/* GPIO ISRC Bit Field Definitions */
S#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO_T::ISRC: ISRC Position */
S#define GPIO_ISRC_ISRC_Msk          (0xFFFFul << GPIO_ISRC_ISRC_Pos)            /*!< GPIO_T::ISRC: ISRC Mask */
S
S/* GPIO DBNCECON Bit Field Definitions */
S#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO_T::DBNCECON: ICLK_ON  Position */
S#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO_T::DBNCECON: ICLK_ON  Mask */
S
S#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO_T::DBNCECON: DBCLKSRC Position */
S#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO_T::DBNCECON: DBCLKSRC Mask */
S
S#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO_T::DBNCECON: DBCLKSEL Position */
S#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO_T::DBNCECON: DBCLKSEL Mask */
S/*@}*/ /* end of group GPIO_CONST */
S/*@}*/ /* end of group NUC131_GPIO */
S
S
S
S
S
S/*---------------------- Inter-IC Bus Controller -------------------------*/
S/**
S    @addtogroup I2C Inter-IC Bus Controller (I2C)
S    Memory Mapped Structure for I2C Controller
S@{ */
Stypedef struct
S{
S    /**
S     * I2CON
S     * ===================================================================================================
S     * Offset: 0x00  I2C Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2]     |AA        |Assert Acknowledge Control
S     * |        |          |When AA = 0 prior to address or data received, a Not acknowledged (high level to I2Cn_SDA) will be returned during the acknowledge clock pulse on the I2Cn_SCL line.     
S     * |        |          |When AA = 1 prior to address or data received, an acknowledged (low level to I2Cn_SDA) will be returned during the acknowledge clock pulse on the I2Cn_SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter.
S     * |[3]     |SI        |I2C Interrupt Flag
S     * |        |          |When a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested.
S     * |        |          |SI must be cleared by software.
S     * |        |          |Clear SI by writing 1 to this bit.
S     * |[4]     |STO       |I2C STOP Control
S     * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically.
S     * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode.
S     * |        |          |This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.
S     * |[5]     |STA       |I2C START Control
S     * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.
S     * |[6]     |ENS1      |I2C Controller Enable
S     * |        |          |0 = Disabled.
S     * |        |          |1 = Enabled.
S     * |        |          |Set to enable I2C serial function controller.
S     * |        |          |When ENS1=1 the I2C serial function enables.
S     * |        |          |The multi-function pin function of I2Cn_SDA and I2Cn_SCL must set to I2C function first.
S     * |[7]     |EI        |Enable Interrupt
S     * |        |          |0 = I2C interrupt Disabled.
S     * |        |          |1 = I2C interrupt Enabled.
S     */
S    __IO uint32_t I2CON;
S
S    /**
S     * I2CADDR0
S     * ===================================================================================================
S     * Offset: 0x04  I2C Slave Address Register0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S     * |        |          |The I2C hardware will react if either of the address is matched.
S     */
S    __IO uint32_t I2CADDR0;
S
S    /**
S     * I2CDAT
S     * ===================================================================================================
S     * Offset: 0x08  I2C Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CDAT    |I2C Data Register
S     * |        |          |Bit [7:0] is located with the 8-bit transferred data of I2C serial port.
S     */
S    __IO uint32_t I2CDAT;
S
S    /**
S     * I2CSTATUS
S     * ===================================================================================================
S     * Offset: 0x0C  I2C Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CSTATUS |I2C Status Register
S     * |        |          |The status register of I2C:
S     * |        |          |There are 26 possible status codes.
S     * |        |          |When I2CSTATUS contains F8H, no serial interrupt is requested.
S     * |        |          |All other I2CSTATUS values correspond to defined I2C states.
S     * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
S     * |        |          |A valid status code is present in I2CSTATUS one cycle after SI is set by hardware and is still present one cycle after SI has been reset by software.
S     * |        |          |In addition, states 00H stands for a Bus Error.
S     * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame.
S     * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.
S     */
S    __I  uint32_t I2CSTATUS;
S
S    /**
S     * I2CLK
S     * ===================================================================================================
S     * Offset: 0x10  I2C Clock Divided Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |I2CLK     |I2C Clock Divided Register
S     * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4x (I2CLK+1)).
S     * |        |          |Note: The minimum value of I2CLK is 4.
S     */
S    __IO uint32_t I2CLK;
S
S    /**
S     * I2CTOC
S     * ===================================================================================================
S     * Offset: 0x14  I2C Time-out Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TIF       |Time-out Flag
S     * |        |          |This bit is set by H/W when I2C time-out happened and it can interrupt CPU if I2C interrupt enable bit (EI) is set to 1.
S     * |        |          |Note: Write 1 to clear this bit.
S     * |[1]     |DIV4      |Time-out Counter Input Clock Divided by 4
S     * |        |          |0 = Disabled.
S     * |        |          |1 = Enabled.
S     * |        |          |When Enabled, The time-out period is extend 4 times.
S     * |[2]     |ENTI      |Time-out Counter Enable/Disable
S     * |        |          |0 = Disabled.
S     * |        |          |1 = Enabled.
S     * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
S     * |        |          |Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
S     */
S    __IO uint32_t I2CTOC;
S
S    /**
S     * I2CADDR1
S     * ===================================================================================================
S     * Offset: 0x18  I2C Slave Address Register1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S     * |        |          |The I2C hardware will react if either of the address is matched.
S     */
S    __IO uint32_t I2CADDR1;
S
S    /**
S     * I2CADDR2
S     * ===================================================================================================
S     * Offset: 0x1C  I2C Slave Address Register2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S     * |        |          |The I2C hardware will react if either of the address is matched.
S     */
S    __IO uint32_t I2CADDR2;
S
S    /**
S     * I2CADDR3
S     * ===================================================================================================
S     * Offset: 0x20  I2C Slave Address Register3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GC        |General Call Function
S     * |        |          |0 = General Call Function Disabled.
S     * |        |          |1 = General Call Function Enabled.
S     * |[7:1]   |I2CADDR   |I2C Address Register
S     * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S     * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S     * |        |          |The I2C hardware will react if either of the address is matched.
S     */
S    __IO uint32_t I2CADDR3;
S
S    /**
S     * I2CADM0
S     * ===================================================================================================
S     * Offset: 0x24  I2C Slave Address Mask Register0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2CADM    |I2C Address Mask Register
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     */
S    __IO uint32_t I2CADM0;
S
S    /**
S     * I2CADM1
S     * ===================================================================================================
S     * Offset: 0x28  I2C Slave Address Mask Register1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2CADM    |I2C Address Mask Register
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     */
S    __IO uint32_t I2CADM1;
S
S    /**
S     * I2CADM2
S     * ===================================================================================================
S     * Offset: 0x2C  I2C Slave Address Mask Register2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2CADM    |I2C Address Mask Register
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     */
S    __IO uint32_t I2CADM2;
S
S    /**
S     * I2CADM3
S     * ===================================================================================================
S     * Offset: 0x30  I2C Slave Address Mask Register3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:1]   |I2CADM    |I2C Address Mask Register
S     * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address register.).
S     * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S     * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S     * |        |          |When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care.
S     * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.
S     */
S    __IO uint32_t I2CADM3;
S
S    /**
S     * RESERVED0
S     * ===================================================================================================
S     *
S     * ---------------------------------------------------------------------------------------------------
S     */
S    uint32_t RESERVED0[2];
S
S    /**
S     * I2CWKUPCON
S     * ===================================================================================================
S     * Offset: 0x3C  I2C Wake-up Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKUPEN    |I2C Wake-up Enable
S     * |        |          |0 = I2C wake-up function Disabled.
S     * |        |          |1 = I2C wake-up function Enabled.
S     */
S    __IO uint32_t I2CWKUPCON;
S
S    /**
S     * I2CWKUPSTS
S     * ===================================================================================================
S     * Offset: 0x40  I2C Wake-up Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WKUPIF    |I2C Wake-up Flag
S     * |        |          |0 = Chip is not woken-up from Power-down mode by I2C.
S     * |        |          |1 = Chip is woken-up from Power-down mode by I2C.
S     * |        |          |Note: Software can write 1 to clear this bit.
S     */
S    __IO uint32_t I2CWKUPSTS;
S} I2C_T;
S
S
S/**
S    @addtogroup I2C_CONST I2C Bit Field Definition
S    Constant Definitions for I2C Controller
S@{ */
S
S
S/* I2C I2CON Bit Field Definitions */
S#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C_T::I2CON: EI Position */
S#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C_T::I2CON: EI Mask */
S
S#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C_T::I2CON: ENS1 Position */
S#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C_T::I2CON: ENS1 Mask */
S
S#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C_T::I2CON: STA Position */
S#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C_T::I2CON: STA Mask */
S
S#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C_T::I2CON: STO Position */
S#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C_T::I2CON: STO Mask */
S
S#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C_T::I2CON: SI Position */
S#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C_T::I2CON: SI Mask */
S
S#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C_T::I2CON: AA Position */
S#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C_T::I2CON: AA Mask */
S
S/* I2C I2CADDR Bit Field Definitions */
S#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C_T::I2CADDR0: I2CADDR Position */
S#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C_T::I2CADDR0: I2CADDR Mask */
S
S#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C_T::I2CADDR0: GC Position */
S#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C_T::I2CADDR0: GC Mask */
S
S/* I2C I2CDAT Bit Field Definitions */
S#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C_T::I2CDAT: I2CDAT Position */
S#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C_T::I2CDAT: I2CDAT Mask */
S
S/* I2C I2CSTATUS Bit Field Definitions */
S#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C_T::I2CSTATUS: I2CSTATUS Position */
S#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C_T::I2CSTATUS: I2CSTATUS Mask */
S
S/* I2C I2CLK Bit Field Definitions */
S#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C_T::I2CLK: I2CLK Position */
S#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C_T::I2CLK: I2CLK Mask */
S
S/* I2C I2CTOC Bit Field Definitions */
S#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C_T::I2CTOC: ENTI Position */
S#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C_T::I2CTOC: ENTI Mask */
S
S#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C_T::I2CTOC: DIV4 Position */
S#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C_T::I2CTOC: DIV4 Mask */
S
S#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C_T::I2CTOC: TIF Position */
S#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C_T::I2CTOC: TIF Mask */
S
S/* I2C I2CADM Bit Field Definitions */
S#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C_T::I2CADM0: I2CADM Position */
S#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C_T::I2CADM0: I2CADM Mask */
S
S/* I2C I2CWKUPCON Bit Field Definitions */
S#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C_T::I2CWKUPCON: WKUPEN Position */
S#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C_T::I2CWKUPCON: WKUPEN Mask */
S
S/* I2C I2CWKUPSTS Bit Field Definitions */
S#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C_T::I2CWKUPSTS: WKUPIF Position */
S#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C_T::I2CWKUPSTS: WKUPIF Mask */
S/*@}*/ /* end of group I2C_CONST */
S/*@}*/ /* end of group I2C */
S
S
S/*---------------------- Pulse Width Modulation Controller -------------------------*/
S/**
S    @addtogroup PWM Pulse Width Modulation Controller (PWM)
S    Memory Mapped Structure for PWM Controller
S@{ */
Stypedef struct
S{
S    /**
S     * CTL0
S     * ===================================================================================================
S     * Offset: 0x00  PWM Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CTRLDn    |Center Re-Load
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |In up-down counter type, PERIOD will load to PBUF at the end point of each period.
S     * |        |          |CMPDAT will load to CMPBUF at the center point of a period.
S     * |[21:16] |IMMLDENn  |Immediately Load Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PERIOD will load to PBUF at the end point of each period.
S     * |        |          |CMPDAT will load to CMPBUF at the end point or center point of each period by setting CTRLD bit.
S     * |        |          |1 = PERIOD/CMPDAT will load to PBUF and CMPBUF immediately when software update PERIOD/CMPDAT.
S     * |        |          |Note: If IMMLDENn is enabled, WINLDENn and CTRLDn will be invalid.
S     * |[30]    |DBGHALT   |ICE Debug Mode Counter Halt (Write Protect)
S     * |        |          |If counter halt is enabled, PWM all counters will keep current value until exit ICE debug mode.
S     * |        |          |0 = ICE debug mode counter halt disable.
S     * |        |          |1 = ICE debug mode counter halt enable.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     * |[31]    |DBGTRIOFF |ICE Debug Mode Acknowledge Disable (Write Protect)
S     * |        |          |0 = ICE debug mode acknowledgment effects PWM output.
S     * |        |          |PWM pin will be forced as tri-state while ICE debug mode acknowledged.
S     * |        |          |1 = ICE debug mode acknowledgment disabled.
S     * |        |          |PWM pin will keep output no matter ICE debug mode acknowledged or not.
S     * |        |          |Note: This register is write protected. Refer toSYS_REGLCTL register.
S     */
S    __IO uint32_t CTL0;
S
S    /**
S     * CTL1
S     * ===================================================================================================
S     * Offset: 0x04  PWM Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |CNTTYPE0  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[5:4]   |CNTTYPE2  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[9:8]   |CNTTYPE4  |PWM Counter Behavior Type
S     * |        |          |Each bit n controls corresponding PWM channel n.
S     * |        |          |00 = Up counter type (supports in capture mode).
S     * |        |          |01 = Down count type (supports in capture mode).
S     * |        |          |10 = Up-down counter type.
S     * |        |          |11 = Reserved.
S     * |[26:24] |OUTMODEn  |PWM Output Mode
S     * |        |          |Each bit n controls the output mode of corresponding PWM channel n.
S     * |        |          |0 = PWM independent mode.
S     * |        |          |1 = PWM complementary mode.
S     * |        |          |Note: When operating in group function, these bits must all set to the same mode.
S     */
S    __IO uint32_t CTL1;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED0
S     * ===================================================================================================
S     * Offset: 0x0008 ~ 0x000C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED0[2];
S    /**
S      @endcond
S     */
S
S
S    /**
S     * CLKSRC
S     * ===================================================================================================
S     * Offset: 0x10  PWM Clock Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |ECLKSRC0  |PWM_CH01 External Clock Source Select
S     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S     * |        |          |001 = TIMER0 overflow.
S     * |        |          |010 = TIMER1 overflow.
S     * |        |          |011 = TIMER2 overflow.
S     * |        |          |100 = TIMER3 overflow.
S     * |        |          |Others = Reserved.
S     * |[10:8]  |ECLKSRC2  |PWM_CH23 External Clock Source Select
S     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S     * |        |          |001 = TIMER0 overflow.
S     * |        |          |010 = TIMER1 overflow.
S     * |        |          |011 = TIMER2 overflow.
S     * |        |          |100 = TIMER3 overflow.
S     * |        |          |Others = Reserved.
S     * |[18:16] |ECLKSRC4  |PWM_CH45 External Clock Source Select
S     * |        |          |000 = PWMx_CLK, x denotes 0 or 1.
S     * |        |          |001 = TIMER0 overflow.
S     * |        |          |010 = TIMER1 overflow.
S     * |        |          |011 = TIMER2 overflow.
S     * |        |          |100 = TIMER3 overflow.
S     * |        |          |Others = Reserved.
S     */
S    __IO uint32_t CLKSRC;
S
S    /**
S     * CLKPSC0_1
S     * ===================================================================================================
S     * Offset: 0x14  PWM Clock Pre-scale Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
S     * |        |          |The clock of PWM counter is decided by clock prescaler.
S     * |        |          |Each PWM pair share one PWM counter clock prescaler.
S     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S     */
S    __IO uint32_t CLKPSC0_1;
S
S    /**
S     * CLKPSC2_3
S     * ===================================================================================================
S     * Offset: 0x18  PWM Clock Pre-scale Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
S     * |        |          |The clock of PWM counter is decided by clock prescaler.
S     * |        |          |Each PWM pair share one PWM counter clock prescaler.
S     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S     */
S    __IO uint32_t CLKPSC2_3;
S
S    /**
S     * CLKPSC4_5
S     * ===================================================================================================
S     * Offset: 0x1C  PWM Clock Pre-scale Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CLKPSC    |PWM Counter Clock Pre-Scale
S     * |        |          |The clock of PWM counter is decided by clock prescaler.
S     * |        |          |Each PWM pair share one PWM counter clock prescaler.
S     * |        |          |The clock of PWM counter is divided by (CLKPSC+ 1).
S     */
S    __IO uint32_t CLKPSC4_5;
S
S    /**
S     * CNTEN
S     * ===================================================================================================
S     * Offset: 0x20  PWM Counter Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTEN0    |PWM Counter Enable 0
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     * |[2]     |CNTEN2    |PWM Counter Enable 2
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     * |[4]     |CNTEN0    |PWM Counter Enable 4
S     * |        |          |0 = PWM Counter and clock prescaler Stop Running.
S     * |        |          |1 = PWM Counter and clock prescaler Start Running.
S     */
S    __IO uint32_t CNTEN;
S
S    /**
S     * CNTCLR
S     * ===================================================================================================
S     * Offset: 0x24  PWM Clear Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTCLR0   |Clear PWM Counter Control Bit 0
S     * |        |          |It is automatically cleared by hardware.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0000H.
S     * |[2]     |CNTCLR2   |Clear PWM Counter Control Bit 2
S     * |        |          |It is automatically cleared by hardware.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0000H.
S     * |[4]     |CNTCLR4   |Clear PWM Counter Control Bit 4
S     * |        |          |It is automatically cleared by hardware.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear 16-bit PWM counter to 0000H.
S     */
S    __IO uint32_t CNTCLR;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED1
S     * ===================================================================================================
S     * Offset: 0x0028 ~ 0x002C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED1[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * PERIOD0, 2, 4
S     * ===================================================================================================
S     * Offset: 0x30, 0x38, 0x40  PWM Period Register 0, 2, 4 (offset: 0x34, 0x3C, 0x44 are reserved)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PERIOD    |PWM Period Register
S     * |        |          |Up-Count mode: In this mode, PWM counter counts from 0 to PERIOD, and restarts from 0.
S     * |        |          |Down-Count mode: In this mode, PWM counter counts from PERIOD to 0, and restarts from PERIOD.
S     * |        |          |PWM period time = (PERIOD+1) * PWM_CLK period.
S     * |        |          |Up-Down-Count mode: In this mode, PWM counter counts from 0 to PERIOD, then decrements to 0 and repeats again.
S     * |        |          |PWM period time = 2 * PERIOD * PWM_CLK period.
S     */
S    __IO uint32_t PERIOD[6];
S
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED2
S     * ===================================================================================================
S     * Offset: 0x0048 ~ 0x004C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED2[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * CMPDAT0~5
S     * ===================================================================================================
S     * Offset: 0x50~0x64  PWM Comparator Register 0~5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMP       |PWM Comparator Register
S     * |        |          |CMP use to compare with CNTR to generate PWM waveform, interrupt and trigger ADC.
S     * |        |          |In independent mode, CMPDAT0~5 denote as 6 independent PWM_CH0~5 compared point.
S     * |        |          |In complementary mode, CMPDAT0, 2, 4 denote as first compared point, and CMPDAT1, 3, 5
S     * |        |          |denote as second compared point for the corresponding 3 complementary pairs PWM_CH0 and PWM_CH1, PWM_CH2 and PWM_CH3, PWM_CH4 and PWM_CH5.
S     */
S    __IO uint32_t CMPDAT[6];
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED3
S     * ===================================================================================================
S     * Offset: 0x0068 ~ 0x006C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED3[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * DTCTL0_1
S     * ===================================================================================================
S     * Offset: 0x70  PWM Dead-Time Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
S     * |        |          |The dead-time can be calculated from the following formula:
S     * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3)
S     * |        |          |(PWM_CH4, PWM_CH5) (Write Protect)
S     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled. If
S     * |        |          |dead-time insertion is inactive, the outputs of pin pair are complementary
S     * |        |          |without any delay.
S     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect)
S     * |        |          |0 = Dead-time clock source from PWM_CLK.
S     * |        |          |1 = Dead-time clock source from prescaler output.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     */
S    __IO uint32_t DTCTL0_1;
S
S    /**
S     * DTCTL2_3
S     * ===================================================================================================
S     * Offset: 0x74  PWM Dead-Time Control Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
S     * |        |          |The dead-time can be calculated from the following formula:
S     * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3)
S     * |        |          |(PWM_CH4, PWM_CH5) (Write Protect)
S     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled. If
S     * |        |          |dead-time insertion is inactive, the outputs of pin pair are complementary
S     * |        |          |without any delay.
S     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect)
S     * |        |          |0 = Dead-time clock source from PWM_CLK.
S     * |        |          |1 = Dead-time clock source from prescaler output.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     */
S    __IO uint32_t DTCTL2_3;
S
S    /**
S     * DTCTL4_5
S     * ===================================================================================================
S     * Offset: 0x78  PWM Dead-Time Control Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |DTCNT     |Dead-Time Counter (Write Protect)
S     * |        |          |The dead-time can be calculated from the following formula:
S     * |        |          |Dead-time = (DTCNT[11:0]+1) * PWM_CLK period.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[16]    |DTEN      |Enable Dead-Time Insertion For PWM Pair (PWM_CH0, PWM_CH1) (PWM_CH2, PWM_CH3)
S     * |        |          |(PWM_CH4, PWM_CH5) (Write Protect)
S     * |        |          |Dead-time insertion is only active when this pair of complementary PWM is enabled. If
S     * |        |          |dead- time insertion is inactive, the outputs of pin pair are complementary
S     * |        |          |without any delay.
S     * |        |          |0 = Dead-time insertion Disabled on the pin pair.
S     * |        |          |1 = Dead-time insertion Enabled on the pin pair.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[24]    |DTCKSEL   |Dead-Time Clock Select (Write Protect)
S     * |        |          |0 = Dead-time clock source from PWM_CLK.
S     * |        |          |1 = Dead-time clock source from prescaler output.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     */
S    __IO uint32_t DTCTL4_5;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED4
S     * ===================================================================================================
S     * Offset: 0x007C ~ 0x008C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED4[5];
S    /**
S     * @endcond
S     */
S
S    /**
S     * CNT0, 2, 4
S     * ===================================================================================================
S     * Offset: 0x90, 0x98, 0xA0  PWM Counter Register 0, 2, 4 (offset: 0x94, 0x9C, 0xA4 are reserved)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CNT       |PWM Data Register (Read Only)
S     * |        |          |User can monitor CNTR to know the current value in 16-bit period counter.
S     * |[16]    |DIRF      |PWM Direction Indicator Flag (Read Only)
S     * |        |          |0 = Counter is Down count.
S     * |        |          |1 = Counter is UP count.
S     */
S    __IO uint32_t CNT[6];
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED5
S     * ===================================================================================================
S     * Offset: 0x00A8 ~ 0x00AC
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED5[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * WGCTL0
S     * ===================================================================================================
S     * Offset: 0xB0  PWM Generation Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |ZPCTLn    |PWM Zero Point Control
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM zero point output Low.
S     * |        |          |10 = PWM zero point output High.
S     * |        |          |11 = PWM zero point output Toggle.
S     * |        |          |PWM can control output level when PWM counter count to zero.
S     * |[27:16] |PRDPCTLn  |PWM Period (Center) Point Control
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM period (center) point output Low.
S     * |        |          |10 = PWM period (center) point output High.
S     * |        |          |11 = PWM period (center) point output Toggle.
S     * |        |          |PWM can control output level when PWM counter count to (PERIODn+1).
S     * |        |          |Note: This bit is center point control when PWM counter operating in up-down counter type.
S     */
S    __IO uint32_t WGCTL0;
S
S    /**
S     * WGCTL1
S     * ===================================================================================================
S     * Offset: 0xB4  PWM Generation Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[11:0]  |CMPUCTLn  |PWM Compare Up Point Control
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare up point output Low.
S     * |        |          |10 = PWM compare up point output High.
S     * |        |          |11 = PWM compare up point output Toggle.
S     * |        |          |PWM can control output level when PWM counter up count to CMPDAT.
S     * |        |          |Note: In complementary mode, CMPUCTL1, 3, 5 use as another CMPUCTL for channel 0, 2, 4.
S     * |[27:16] |CMPDCTLn  |PWM Compare Down Point Control
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |00 = Do nothing.
S     * |        |          |01 = PWM compare down point output Low.
S     * |        |          |10 = PWM compare down point output High.
S     * |        |          |11 = PWM compare down point output Toggle.
S     * |        |          |PWM can control output level when PWM counter down count to CMPDAT.
S     * |        |          |Note: In complementary mode, CMPDCTL1, 3, 5 use as another CMPDCTL for channel 0, 2, 4.
S     */
S    __IO uint32_t WGCTL1;
S
S    /**
S     * MSKEN
S     * ===================================================================================================
S     * Offset: 0xB8  PWM Mask Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |MSKENn    |PWM Mask Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |The PWM output signal will be masked when this bit is enabled.
S     * |        |          |The corresponding PWM channel n will output MSKDATn (PWM_MSK[5:0]) data.
S     * |        |          |0 = PWM output signal is non-masked.
S     * |        |          |1 = PWM output signal is masked and output MSKDATn data.
S     */
S    __IO uint32_t MSKEN;
S
S    /**
S     * MSK
S     * ===================================================================================================
S     * Offset: 0xBC  PWM Mask Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |MSKDATn   |PWM Mask Data Bit
S     * |        |          |This data bit control the state of PWMn output pin, if corresponding mask function is enabled.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Output logic low to PWMn.
S     * |        |          |1 = Output logic high to PWMn.
S     */
S    __IO uint32_t MSK;
S
S    /**
S     * BNF
S     * ===================================================================================================
S     * Offset: 0xC0  PWM Brake Noise Filter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRK0FEN   |PWM Brake 0 Noise Filter Enable
S     * |        |          |0 = Noise filter of PWM Brake 0 Disabled.
S     * |        |          |1 = Noise filter of PWM Brake 0 Enabled.
S     * |[3:1]   |BRK0FCS   |Brake 0 Edge Detector Filter Clock Selection
S     * |        |          |000 = Filter clock = HCLK.
S     * |        |          |001 = Filter clock = HCLK/2.
S     * |        |          |010 = Filter clock = HCLK/4.
S     * |        |          |011 = Filter clock = HCLK/8.
S     * |        |          |100 = Filter clock = HCLK/16.
S     * |        |          |101 = Filter clock = HCLK/32.
S     * |        |          |110 = Filter clock = HCLK/64.
S     * |        |          |111 = Filter clock = HCLK/128.
S     * |[6:4]   |BRK0FCNT  |Brake 0 Edge Detector Filter Count
S     * |        |          |The register bits control the Brake0 filter counter to count from 0 to BRK1FCNT.
S     * |[7]     |BRK0PINV  |Brake 0 Pin Inverse
S     * |        |          |0 = The state of pin PWMx_BRAKE0 is passed to the negative edge detector.
S     * |        |          |1 = The inverted state of pin PWMx_BRAKE10 is passed to the negative edge detector.
S     * |[8]     |BRK1FEN   |PWM Brake 1 Noise Filter Enable
S     * |        |          |0 = Noise filter of PWM Brake 1 Disabled.
S     * |        |          |1 = Noise filter of PWM Brake 1 Enabled.
S     * |[11:9]  |BRK1FCS   |Brake 1 Edge Detector Filter Clock Selection
S     * |        |          |000 = Filter clock = HCLK.
S     * |        |          |001 = Filter clock = HCLK/2.
S     * |        |          |010 = Filter clock = HCLK/4.
S     * |        |          |011 = Filter clock = HCLK/8.
S     * |        |          |100 = Filter clock = HCLK/16.
S     * |        |          |101 = Filter clock = HCLK/32.
S     * |        |          |110 = Filter clock = HCLK/64.
S     * |        |          |111 = Filter clock = HCLK/128.
S     * |[14:12] |BRK1FCNT  |Brake 1 Edge Detector Filter Count
S     * |        |          |The register bits control the Brake1 filter counter to count from 0 to BRK1FCNT.
S     * |[15]    |BRK1PINV  |Brake 1 Pin Inverse
S     * |        |          |0 = The state of pin PWMx_BRAKE1 is passed to the negative edge detector.
S     * |        |          |1 = The inverted state of pin PWMx_BRAKE1 is passed to the negative edge detector.
S     * |[16]    |BK0SRC    |Brake 0 Pin Source Select
S     * |        |          |For PWM0 setting:
S     * |        |          |0 = Brake 0 pin source come from PWM0_BRAKE0.
S     * |        |          |1 = Brake 0 pin source come from PWM1_BRAKE0.
S     * |        |          |For PWM1 setting:
S     * |        |          |0 = Brake 0 pin source come from PWM1_BRAKE0.
S     * |        |          |1 = Brake 0 pin source come from PWM0_BRAKE0.
S     * |[24]    |BK1SRC    |Brake 1 Pin Source Select
S     * |        |          |For PWM0 setting:
S     * |        |          |0 = Brake 1 pin source come from PWM0_BRAKE1.
S     * |        |          |1 = Brake 1 pin source come from PWM1_BRAKE1.
S     * |        |          |For PWM1 setting:
S     * |        |          |0 = Brake 1 pin source come from PWM1_BRAKE1.
S     * |        |          |1 = Brake 1 pin source come from PWM0_BRAKE1.
S     */
S    __IO uint32_t BNF;
S
S    /**
S     * FAILBRK
S     * ===================================================================================================
S     * Offset: 0xC4  PWM System Fail Brake Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CSSBRKEN  |Clock Security System Detection Trigger PWM Brake Function 0 Enable
S     * |        |          |0 = Brake Function triggered by CSS detection Disabled.
S     * |        |          |1 = Brake Function triggered by CSS detection Enabled.
S     * |[1]     |BODBRKEN  |Brown-Out Detection Trigger PWM Brake Function 0 Enable
S     * |        |          |0 = Brake Function triggered by BOD Disabled.
S     * |        |          |1 = Brake Function triggered by BOD Enabled.
S     * |[3]     |CORBRKEN  |Core Lockup Detection Trigger PWM Brake Function 0 Enable
S     * |        |          |0 = Brake Function triggered by Core lockup detection Disabled.
S     * |        |          |1 = Brake Function triggered by Core lockup detection Enabled.
S     */
S    __IO uint32_t FAILBRK;
S
S    /**
S     * BRKCTL0_1
S     * ===================================================================================================
S     * Offset: 0xC8  PWM Brake Edge Detect Control Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
S     * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
S     * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[7]     |SYSEEN    |Enable System Fail As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[15]    |SYSLEN    |Enable System Fail As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
S     * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
S     * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
S     * |        |          |10 = PWM even channel output low level when level-detect brake happened.
S     * |        |          |11 = PWM even channel output high level when level-detect brake happened.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
S     * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
S     * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
S     * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
S     * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     */
S    __IO uint32_t BRKCTL0_1;
S
S    /**
S     * PWM_BRKCTL2_3
S     * ===================================================================================================
S     * Offset: 0xCC  PWM Brake Edge Detect Control Register 2_3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
S     * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
S     * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[7]     |SYSEEN    |Enable System Fail As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[15]    |SYSLEN    |Enable System Fail As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
S     * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
S     * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
S     * |        |          |10 = PWM even channel output low level when level-detect brake happened.
S     * |        |          |11 = PWM even channel output high level when level-detect brake happened.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
S     * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
S     * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
S     * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
S     * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     */
S    __IO uint32_t BRKCTL2_3;
S
S    /**
S     * PWM_BRKCTL4_5
S     * ===================================================================================================
S     * Offset: 0xD0  PWM Brake Edge Detect Control Register 4_5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |BRKP0EEN  |Enable PWMx_BRAKE0 Pin As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = BKP0 pin as edge-detect brake source Disabled.
S     * |        |          |1 = BKP0 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[5]     |BRKP1EEN  |Enable PWMx_BRAKE1 Pin As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = BKP1 pin as edge-detect brake source Disabled.
S     * |        |          |1 = BKP1 pin as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[7]     |SYSEEN    |Enable System Fail As Edge-Detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as edge-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as edge-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[12]    |BRKP0LEN  |Enable BKP0 Pin As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE0 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE0 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[13]    |BRKP1LEN  |Enable BKP1 Pin As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = PWMx_BRAKE1 pin as level-detect brake source Disabled.
S     * |        |          |1 = PWMx_BRAKE1 pin as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[15]    |SYSLEN    |Enable System Fail As Level-Detect Brake Source (Write Protect)
S     * |        |          |0 = System Fail condition as level-detect brake source Disabled.
S     * |        |          |1 = System Fail condition as level-detect brake source Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[17:16] |BRKAEVEN  |PWM Brake Action Select For Even Channel (Write Protect)
S     * |        |          |00 = PWM even channel level-detect brake function not affect channel output.
S     * |        |          |01 = PWM even channel output tri-state when level-detect brake happened.
S     * |        |          |10 = PWM even channel output low level when level-detect brake happened.
S     * |        |          |11 = PWM even channel output high level when level-detect brake happened.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[19:18] |BRKAODD   |PWM Brake Action Select For Odd Channel (Write Protect)
S     * |        |          |00 = PWM odd channel level-detect brake function not affect channel output.
S     * |        |          |01 = PWM odd channel output tri-state when level-detect brake happened.
S     * |        |          |10 = PWM odd channel output low level when level-detect brake happened.
S     * |        |          |11 = PWM odd channel output high level when level-detect brake happened.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     */
S    __IO uint32_t BRKCTL4_5;
S
S    /**
S     * POLCTL
S     * ===================================================================================================
S     * Offset: 0xD4  PWM Pin Polar Inverse Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |PINVn     |PWM PIN Polar Inverse Control
S     * |        |          |The register controls polarity state of PWM output.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM output polar inverse Disabled.
S     * |        |          |1 = PWM output polar inverse Enabled.
S     */
S    __IO uint32_t POLCTL;
S
S    /**
S     * POEN
S     * ===================================================================================================
S     * Offset: 0xD8  PWM Output Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |POENn     |PWM Pin Output Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM pin at tri-state.
S     * |        |          |1 = PWM pin in output mode.
S     */
S    __IO uint32_t POEN;
S
S    /**
S     * SWBRK
S     * ===================================================================================================
S     * Offset: 0xDC  PWM Software Brake Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2:0]   |BRKETRGn  |PWM Edge Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Each bit n controls the corresponding PWM pair n.
S     * |        |          |Write 1 to this bit will trigger Edge brake, and set BRKEIFn to 1 in PWM_INTSTS1 register.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[10:8]  |BRKLTRGn  |PWM Level Brake Software Trigger (Write Only) (Write Protect)
S     * |        |          |Each bit n controls the corresponding PWM pair n.
S     * |        |          |Write 1 to this bit will trigger level brake, and set BRKLIFn to 1 in PWM_INTSTS1 register.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     */
S    __IO uint32_t SWBRK;
S
S    /**
S     * PWM_INTEN0
S     * ===================================================================================================
S     * Offset: 0xE0  PWM Interrupt Enable Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ZIEN0     |PWM Zero Point Interrupt Enable 0
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[2]     |ZIEN2     |PWM Zero Point Interrupt Enable 2
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[4]     |ZIEN4     |PWM Zero Point Interrupt Enable 4
S     * |        |          |0 = Zero point interrupt Disabled.
S     * |        |          |1 = Zero point interrupt Enabled.
S     * |        |          |Note: Odd channels will read always 0 at complementary mode.
S     * |[8]     |PIEN0     |PWM Period Point Interrupt Enable 0
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note: When up-down counter type period point means center point.
S     * |[10]    |PIEN2     |PWM Period Point Interrupt Enable 2
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note: When up-down counter type period point means center point.
S     * |[12]    |PIEN4     |PWM Period Point Interrupt Enable 4
S     * |        |          |0 = Period point interrupt Disabled.
S     * |        |          |1 = Period point interrupt Enabled.
S     * |        |          |Note: When up-down counter type period point means center point.
S     * |[21:16] |CMPUIENn  |PWM Compare Up Count Interrupt Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare up count interrupt Disabled.
S     * |        |          |1 = Compare up count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPUIEN1, 3, 5 use as another CMPUIEN for channel 0, 2, 4.
S     * |[29:24] |CMPDIENn  |PWM Compare Down Count Interrupt Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Compare down count interrupt Disabled.
S     * |        |          |1 = Compare down count interrupt Enabled.
S     * |        |          |Note: In complementary mode, CMPDIEN1, 3, 5 use as another CMPDIEN for channel 0, 2, 4.
S     */
S    __IO uint32_t INTEN0;
S
S    /**
S     * PWM_INTEN1
S     * ===================================================================================================
S     * Offset: 0xE4  PWM Interrupt Enable Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKEIEN0_1|PWM Edge-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
S     * |        |          |0 = Edge-detect Brake interrupt for channel0/1 Disabled.
S     * |        |          |1 = Edge-detect Brake interrupt for channel0/1 Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[1]     |BRKEIEN2_3|PWM Edge-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)
S     * |        |          |0 = Edge-detect Brake interrupt for channel2/3 Disabled.
S     * |        |          |1 = Edge-detect Brake interrupt for channel2/3 Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[2]     |BRKEIEN4_5|PWM Edge-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)
S     * |        |          |0 = Edge-detect Brake interrupt for channel4/5 Disabled.
S     * |        |          |1 = Edge-detect Brake interrupt for channel4/5 Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[8]     |BRKLIEN0_1|PWM Level-Detect Brake Interrupt Enable For Channel0/1 (Write Protect)
S     * |        |          |0 = Level-detect Brake interrupt for channel0/1 Disabled.
S     * |        |          |1 = Level-detect Brake interrupt for channel0/1 Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[9]     |BRKLIEN2_3|PWM Level-Detect Brake Interrupt Enable For Channel2/3 (Write Protect)
S     * |        |          |0 = Level-detect Brake interrupt for channel2/3 Disabled.
S     * |        |          |1 = Level-detect Brake interrupt for channel2/3 Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[10]    |BRKLIEN4_5|PWM Level-Detect Brake Interrupt Enable For Channel4/5 (Write Protect)
S     * |        |          |0 = Level-detect Brake interrupt for channel4/5 Disabled.
S     * |        |          |1 = Level-detect Brake interrupt for channel4/5 Enabled.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     */
S    __IO uint32_t INTEN1;
S
S    /**
S     * PWM_INTSTS0
S     * ===================================================================================================
S     * Offset: 0xE8  PWM Interrupt Flag Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |ZIF0      |PWM Zero Point Interrupt Flag 0
S     * |        |          |This bit is set by hardware when PWM_CH0 counter reaches zero, software can write 1
S     * |        |          |to clear this bit to zero.
S     * |[2]     |ZIF2      |PWM Zero Point Interrupt Flag 2
S     * |        |          |This bit is set by hardware when PWM_CH2 counter reaches zero, software can write 1
S     * |        |          |to clear this bit to zero.
S     * |[4]     |ZIF4      |PWM Zero Point Interrupt Flag 4
S     * |        |          |This bit is set by hardware when PWM_CH4 counter reaches zero, software can write 1
S     * |        |          |to clear this bit to zero.
S     * |[8]     |PIF0      |PWM Period Point Interrupt Flag 0
S     * |        |          |This bit is set by hardware when PWM_CH0 counter reaches PWM_PERIOD0, software can
S     * |        |          |write 1 to clear this bit to zero.
S     * |[10]    |PIF2      |PWM Period Point Interrupt Flag 2
S     * |        |          |This bit is set by hardware when PWM_CH2 counter reaches PWM_PERIOD2, software can
S     * |        |          |write 1 to clear this bit to zero.
S     * |[12]    |PIF4      |PWM Period Point Interrupt Flag 4
S     * |        |          |This bit is set by hardware when PWM_CH4 counter reaches PWM_PERIOD4, software can write
S     * |        |          |1 to clear this bit to zero.
S     * |[21:16] |CMPUIFn   |PWM Compare Up Count Interrupt Flag
S     * |        |          |Flag is set by hardware when PWM counter up count and reaches PWM_CMPDATn, software
S     * |        |          |can clear this bit by writing 1 to it. Each bit n controls the corresponding
S     * |        |          |PWM channel n.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in up counter type selection.
S     * |        |          |Note2: In complementary mode, CMPUIF1, 3, 5 use as another CMPUIF for channel 0, 2, 4.
S     * |[29:24] |CMPDIFn   |PWM Compare Down Count Interrupt Flag
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Flag is set by hardware when PWM counter down count and reaches PWM_CMPDATn,
S     * |        |          |software can clear this bit by writing 1 to it.
S     * |        |          |Note1: If CMPDAT equal to PERIOD, this flag is not working in down counter type selection.
S     * |        |          |Note2: In complementary mode, CMPDIF1, 3, 5 use as another CMPDIF for channel 0, 2, 4.
S     */
S    __IO uint32_t INTSTS0;
S
S    /**
S     * PWM_INTSTS1
S     * ===================================================================================================
S     * Offset: 0xEC  PWM Interrupt Flag Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BRKEIF0   |PWM Channel0 Edge-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel0 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel0 edge-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[1]     |BRKEIF1   |PWM Channel1 Edge-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel1 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel1 edge-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[2]     |BRKEIF2   |PWM Channel2 Edge-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel2 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel2 edge-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[3]     |BRKEIF3   |PWM Channel3 Edge-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel3 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel3 edge-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[4]     |BRKEIF4   |PWM Channel4 Edge-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel4 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel4 edge-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[5]     |BRKEIF5   |PWM Channel5 Edge-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel5 edge-detect brake event do not happened.
S     * |        |          |1 = When PWM channel5 edge-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[8]     |BRKLIF0   |PWM Channel0 Level-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel0 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel0 level-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[9]     |BRKLIF1   |PWM Channel1 Level-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel1 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel1 level-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[10]    |BRKLIF2   |PWM Channel2 Level-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel2 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel2 level-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[11]    |BRKLIF3   |PWM Channel3 Level-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel3 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel3 level-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[12]    |BRKLIF4   |PWM Channel4 Level-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel4 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel4 level-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer to REGWRPROT register.
S     * |[13]    |BRKLIF5   |PWM Channel5 Level-Detect Brake Interrupt Flag (Write Protect)
S     * |        |          |0 = PWM channel5 level-detect brake event do not happened.
S     * |        |          |1 = When PWM channel5 level-detect brake event happened, this bit is set to 1,
S     * |        |          |writing 1 to clear.
S     * |        |          |Note: This register is write protected. Refer toREGWRPROT register.
S     * |[16]    |BRKESTS0  |PWM Channel0 Edge-Detect Brake Status
S     * |        |          |0 = PWM channel0 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel0 edge-detect brake detects a falling edge of any enabled brake
S     * |        |          |source; this flag will be set to indicate the PWM channel0 at brake state,
S     * |        |          |writing 1 to clear.
S     * |[17]    |BRKESTS1  |PWM Channel1 Edge-Detect Brake Status
S     * |        |          |0 = PWM channel1 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel1 edge-detect brake detects a falling edge of any enabled brake
S     * |        |          |source; this flag will be set to indicate the PWM channel1 at brake state,
S     * |        |          |writing 1 to clear.
S     * |[18]    |BRKESTS2  |PWM Channel2 Edge-Detect Brake Status
S     * |        |          |0 = PWM channel2 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel2 edge-detect brake detects a falling edge of any enabled brake
S     * |        |          |source; this flag will be set to indicate the PWM channel2 at brake state,
S     * |        |          |writing 1 to clear.
S     * |[19]    |BRKESTS3  |PWM Channel3 Edge-Detect Brake Status
S     * |        |          |0 = PWM channel3 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel3 edge-detect brake detects a falling edge of any enabled brake
S     * |        |          |source; this flag will be set to indicate the PWM channel3 at brake state,
S     * |        |          |writing 1 to clear.
S     * |[20]    |BRKESTS4  |PWM Channel4 Edge-Detect Brake Status
S     * |        |          |0 = PWM channel4 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel4 edge-detect brake detects a falling edge of any enabled brake
S     * |        |          |source; this flag will be set to indicate the PWM channel4 at brake state,
S     * |        |          |writing 1 to clear.
S     * |[21]    |BRKESTS5  |PWM Channel5 Edge-Detect Brake Status
S     * |        |          |0 = PWM channel5 edge-detect brake state is released.
S     * |        |          |1 = When PWM channel5 edge-detect brake detects a falling edge of any enabled brake
S     * |        |          |source; this flag will be set to indicate the PWM channel5 at brake state,
S     * |        |          |writing 1 to clear.
S     * |[24]    |BRKLSTS0  |PWM Channel0 Level-Detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel0 level-detect brake state is released.
S     * |        |          |1 = When PWM channel0 level-detect brake detects a falling edge of any enabled
S     * |        |          |brake source; this flag will be set to indicate the PWM channel0 at brake state.
S     * |        |          |Note: This bit is read only and auto
S     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
S     * |        |          |release brake state until current PWM period finished. The PWM waveform will
S     * |        |          |start output from next full PWM period.
S     * |[25]    |BRKLSTS1  |PWM Channel1 Level-Detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel1 level-detect brake state is released.
S     * |        |          |1 = When PWM channel1 level-detect brake detects a falling edge of any enabled
S     * |        |          |brake source; this flag will be set to indicate the PWM channel1 at brake state.
S     * |        |          |Note: This bit is read only and auto
S     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
S     * |        |          |release brake state until current PWM period finished. The PWM waveform will
S     * |        |          |start output from next full PWM period.
S     * |[26]    |BRKLSTS2  |PWM Channel2 Level-Detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel2 level-detect brake state is released.
S     * |        |          |1 = When PWM channel2 level-detect brake detects a falling edge of any enabled
S     * |        |          |brake source; this flag will be set to indicate the PWM channel2 at brake
S     * |        |          |state.
S     * |        |          |Note: This bit is read only and auto
S     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
S     * |        |          |release brake state until current PWM period finished. The PWM waveform will
S     * |        |          |start output from next full PWM period.
S     * |[27]    |BRKLSTS3  |PWM Channel3 Level-Detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel3 level-detect brake state is released.
S     * |        |          |1 = When PWM channel3 level-detect brake detects a falling edge of any enabled
S     * |        |          |brake source; this flag will be set to indicate the PWM channel3 at brake
S     * |        |          |state.
S     * |        |          |Note: This bit is read only and auto
S     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
S     * |        |          |release brake state until current PWM period finished. The PWM waveform will
S     * |        |          |start output from next full PWM period.
S     * |[28]    |BRKLSTS4  |PWM Channel4 Level-Detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel4 level-detect brake state is released.
S     * |        |          |1 = When PWM channel4 level-detect brake detects a falling edge of any enabled
S     * |        |          |brake source; this flag will be set to indicate the PWM channel4 at brake
S     * |        |          |state.
S     * |        |          |Note: This bit is read only and auto
S     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
S     * |        |          |release brake state until current PWM period finished. The PWM waveform will
S     * |        |          |start output from next full PWM period.
S     * |[29]    |BRKLSTS5  |PWM Channel5 Level-Detect Brake Status (Read Only)
S     * |        |          |0 = PWM channel5 level-detect brake state is released.
S     * |        |          |1 = When PWM channel5 level-detect brake detects a falling edge of any enabled
S     * |        |          |brake source; this flag will be set to indicate the PWM channel5 at brake
S     * |        |          |state.
S     * |        |          |Note: This bit is read only and auto
S     * |        |          |cleared by hardware. When enabled brake source return to high level, PWM will
S     * |        |          |release brake state until current PWM period finished. The PWM waveform will
S     * |        |          |start output from next full PWM period.
S     */
S    __IO uint32_t INTSTS1;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED6
S     * ===================================================================================================
S     * Offset: 0x00F0 ~ 0x00F4
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED6[2];
S    /**
S     * @endcond
S     */
S
S    /**
S     * PWM_ADCTS0
S     * ===================================================================================================
S     * Offset: 0xF8  PWM Trigger ADC Source Select Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |TRGSEL0   |PWM_CH0 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH0 zero point.
S     * |        |          |0001 = PWM_CH0 period point.
S     * |        |          |0010 = PWM_CH0 zero or period point.
S     * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
S     * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
S     * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[7]     |TRGEN0    |PWM_CH0 Trigger ADC Enable Bit
S     * |[11:8]  |TRGSEL1   |PWM_CH1 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH0 zero point.
S     * |        |          |0001 = PWM_CH0 period point.
S     * |        |          |0010 = PWM_CH0 zero or period point.
S     * |        |          |0011 = PWM_CH0 up-count CMPDAT point.
S     * |        |          |0100 = PWM_CH0 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = PWM_CH1 up-count CMPDAT point.
S     * |        |          |1001 = PWM_CH1 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[15]    |TRGEN1    |PWM_CH1 Trigger ADC Enable Bit
S     * |[19:16] |TRGSEL2   |PWM_CH2 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH2 zero point.
S     * |        |          |0001 = PWM_CH2 period point.
S     * |        |          |0010 = PWM_CH2 zero or period point.
S     * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
S     * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
S     * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[23]    |TRGEN2    |PWM_CH2 Trigger ADC Enable Bit
S     * |[27:24] |TRGSEL3   |PWM_CH3 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH2 zero point.
S     * |        |          |0001 = PWM_CH2 period point.
S     * |        |          |0010 = PWM_CH2 zero or period point.
S     * |        |          |0011 = PWM_CH2 up-count CMPDAT point.
S     * |        |          |0100 = PWM_CH2 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = PWM_CH3 up-count CMPDAT point.
S     * |        |          |1001 = PWM_CH3 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[31]    |TRGEN3    |PWM_CH3 Trigger ADC Enable Bit
S     */
S    __IO uint32_t ADCTS0;
S
S    /**
S     * PWM_ADCTS1
S     * ===================================================================================================
S     * Offset: 0xFC  PWM Trigger ADC Source Select Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |TRGSEL4   |PWM_CH4 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH4 zero point.
S     * |        |          |0001 = PWM_CH4 period point.
S     * |        |          |0010 = PWM_CH4 zero or period point.
S     * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
S     * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
S     * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[7]     |TRGEN4    |PWM_CH4 Trigger ADC Enable Bit
S     * |[11:8]  |TRGSEL5   |PWM_CH5 Trigger ADC Source Select
S     * |        |          |0000 = PWM_CH4 zero point.
S     * |        |          |0001 = PWM_CH4 period point.
S     * |        |          |0010 = PWM_CH4 zero or period point.
S     * |        |          |0011 = PWM_CH4 up-count CMPDAT point.
S     * |        |          |0100 = PWM_CH4 down-count CMPDAT point.
S     * |        |          |0101 = Reserved.
S     * |        |          |0110 = Reserved.
S     * |        |          |0111 = Reserved.
S     * |        |          |1000 = PWM_CH5 up-count CMPDAT point.
S     * |        |          |1001 = PWM_CH5 down-count CMPDAT point.
S     * |        |          |Others = reserved.
S     * |[15]    |TRGEN5    |PWM_CH5 Trigger ADC Enable Bit
S     */
S    __IO uint32_t ADCTS1;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED7
S     * ===================================================================================================
S     * Offset: 0x0100 ~ 0x010C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED7[4];
S    /**
S     * @endcond
S     */
S
S    /**
S     * PWM_SSCTL
S     * ===================================================================================================
S     * Offset: 0x110  PWM Synchronous Start Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SSEN0     |PWM Synchronous Start Function Enable 0
S     * |        |          |When synchronous start function is enabled, the PWM_CH0 counter enable bit (CNTEN0)
S     * |        |          |can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[2]     |SSEN2     |PWM Synchronous Start Function Enable 2
S     * |        |          |When synchronous start function is enabled, the PWM_CH2 counter enable bit (CNTEN2)
S     * |        |          |can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[4]     |SSEN4     |PWM Synchronous Start Function Enable 4
S     * |        |          |When synchronous start function is enabled, the PWM_CH4 counter enable bit (CNTEN4)
S     * |        |          |can be enabled by writing PWM synchronous start trigger bit (CNTSEN).
S     * |        |          |0 = PWM synchronous start function Disabled.
S     * |        |          |1 = PWM synchronous start function Enabled.
S     * |[9:8]   |SSRC      |PWM Synchronous Start Source Select
S     * |        |          |00 = Synchronous start source come from PWM0.
S     * |        |          |01 = Synchronous start source come from PWM1.
S     * |        |          |10 = Synchronous start source come from BPWM0.
S     * |        |          |11 = Synchronous start source come from BPWM1.
S     */
S    __IO uint32_t SSCTL;
S
S    /**
S     * PWM_SSTRG
S     * ===================================================================================================
S     * Offset: 0x114  PWM Synchronous Start Trigger Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTSEN    |PWM Counter Synchronous Start Enable (Write Only)
S     * |        |          |PMW counter synchronous enable function is used to make selected PWM channels
S     * |        |          |(include PWM0_CHx and PWM1_CHx) start counting at the same time.
S     * |        |          |Writing this bit to 1 will also set the counter enable bit (CNTENn, n denotes channel 0
S     * |        |          |to 5) if correlated PWM channel counter synchronous start function is enabled.
S     * |        |          |Note: This bit only present in PWM0_BA.
S     */
S    __IO uint32_t SSTRG;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED8
S     * ===================================================================================================
S     * Offset: 0x0118 ~ 0x011C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED8[2];
S    /**
S     * @endcond
S     */
S
S
S    /**
S     * PWM_STATUS
S     * ===================================================================================================
S     * Offset: 0x120  PWM Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CNTMAX0   |Time-Base Counter 0 Equal To 0xFFFF Latched Status
S     * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1
S     * |        |          |to clear this bit.
S     * |[2]     |CNTMAX2   |Time-Base Counter 2 Equal To 0xFFFF Latched Status
S     * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1
S     * |        |          |to clear this bit.
S     * |[4]     |CNTMAX4   |Time-Base Counter 4 Equal To 0xFFFF Latched Status
S     * |        |          |0 = indicates the time-base counter never reached its maximum value 0xFFFF.
S     * |        |          |1 = indicates the time-base counter reached its maximum value, software can write 1
S     * |        |          |to clear this bit.
S     * |[21:16] |ADCTRGn   |ADC Start Of Conversion Status
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Indicates no ADC start of conversion trigger event has occurred.
S     * |        |          |1 = Indicates an ADC start of conversion trigger event has occurred, software can
S     * |        |          |write 1 to clear this bit.
S     */
S    __IO uint32_t STATUS;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED9
S     * ===================================================================================================
S     * Offset: 0x0124 ~ 0x01FC
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED9[55];
S    /**
S     * @endcond
S     */
S
S    /**
S     * PWM_CAPINEN
S     * ===================================================================================================
S     * Offset: 0x200  PWM Capture Input Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CAPINENn  |Capture Input Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = PWM Channel capture input path Disabled. The input of PWM channel capture
S     * |        |          |function is always regarded as 0.
S     * |        |          |1 = PWM Channel capture input path Enabled. The input of PWM channel capture
S     * |        |          |function comes from correlative multifunction pin.
S     */
S    __IO uint32_t CAPINEN;
S
S    /**
S     * PWM_CAPCTL
S     * ===================================================================================================
S     * Offset: 0x204  PWM Capture Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CAPENn    |Capture Function Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture function Disabled. RCAPDAT/FCAPDAT register will not be updated.
S     * |        |          |1 = Capture function Enabled. Capture latched the PWM counter value when detected
S     * |        |          |rising or falling edge of input signal and saved to RCAPDAT (Rising latch) and FCAPDAT
S     * |        |          |(Falling latch).
S     * |[13:8]  |CAPINVn   |Capture Inverter Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture source inverter Disabled.
S     * |        |          |1 = Capture source inverter Enabled. Reverse the input signal from GPIO.
S     * |[21:16] |RCRLDENn  |Rising Capture Reload Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Rising capture reload counter Disabled.
S     * |        |          |1 = Rising capture reload counter Enabled.
S     * |[29:24] |FCRLDENn  |Falling Capture Reload Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Falling capture reload counter Disabled.
S     * |        |          |1 = Falling capture reload counter Enabled.
S     */
S    __IO uint32_t CAPCTL;
S
S    /**
S     * PWM_CAPSTS
S     * ===================================================================================================
S     * Offset: 0x208  PWM Capture Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CRIFOVn   |Capture Rising Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if rising latch happened when the corresponding CAPRIF is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CAPRIF.
S     * |[13:8]  |CFIFOVn   |Capture Falling Interrupt Flag Overrun Status (Read Only)
S     * |        |          |This flag indicates if falling latch happened when the corresponding CAPFIF is 1.
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |Note: This bit will be cleared automatically when user clear corresponding CAPFIF.
S     */
S    __IO uint32_t CAPSTS;
S
S    /**
S     * PWM_RCAPDAT0
S     * ===================================================================================================
S     * Offset: 0x20C  PWM Rising Capture Data Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT0;
S
S    /**
S     * PWM_FCAPDAT0
S     * ===================================================================================================
S     * Offset: 0x210  PWM Falling Capture Data Register 0
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT0;
S
S    /**
S     * PWM_RCAPDAT1
S     * ===================================================================================================
S     * Offset: 0x214  PWM Rising Capture Data Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT1;
S
S    /**
S     * FCAPDAT1
S     * ===================================================================================================
S     * Offset: 0x218  PWM Falling Capture Data Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT1;
S
S    /**
S     * RCAPDAT2
S     * ===================================================================================================
S     * Offset: 0x21C  PWM Rising Capture Data Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT2;
S
S    /**
S     * FCAPDAT2
S     * ===================================================================================================
S     * Offset: 0x220  PWM Falling Capture Data Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT2;
S
S    /**
S     * RCAPDAT3
S     * ===================================================================================================
S     * Offset: 0x224  PWM Rising Capture Data Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT3;
S
S    /**
S     * FCAPDAT3
S     * ===================================================================================================
S     * Offset: 0x228  PWM Falling Capture Data Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT3;
S
S    /**
S     * RCAPDAT4
S     * ===================================================================================================
S     * Offset: 0x22C  PWM Rising Capture Data Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT4;
S
S    /**
S     * FCAPDAT4
S     * ===================================================================================================
S     * Offset: 0x230  PWM Falling Capture Data Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT4;
S
S    /**
S     * RCAPDAT5
S     * ===================================================================================================
S     * Offset: 0x234  PWM Rising Capture Data Register 5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |RCAPDAT   |PWM Rising Capture Data Register (Read Only)
S     * |        |          |When rising capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t RCAPDAT5;
S
S    /**
S     * FCAPDAT5
S     * ===================================================================================================
S     * Offset: 0x238  PWM Falling Capture Data Register 5
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |FCAPDAT   |PWM Falling Capture Data Register (Read Only)
S     * |        |          |When falling capture condition happened, the PWM counter value will be saved in this register.
S     */
S    __IO uint32_t FCAPDAT5;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED10
S     * ===================================================================================================
S     * Offset: 0x023C ~ 0x024C
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED10[5];
S    /**
S     * @endcond
S     */
S
S    /**
S     * CAPIEN
S     * ===================================================================================================
S     * Offset: 0x250  PWM Capture Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CAPRIENn  |PWM Capture Rising Latch Interrupt Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture rising edge latch interrupt Disabled.
S     * |        |          |1 = Capture rising edge latch interrupt Enabled.
S     * |[13:8]  |CAPFIENn  |PWM Capture Falling Latch Interrupt Enable
S     * |        |          |Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = Capture falling edge latch interrupt Disabled.
S     * |        |          |1 = Capture falling edge latch interrupt Enabled.
S     */
S    __IO uint32_t CAPIEN;
S
S    /**
S     * CAPIF
S     * ===================================================================================================
S     * Offset: 0x254  PWM Capture Interrupt Flag Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |CRLIFn    |PWM Capture Rising Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture rising latch condition happened.
S     * |        |          |1 = Capture rising latch condition happened, this flag will be set to high.
S     * |[13:8]  |CFLIFn    |PWM Capture Falling Latch Interrupt Flag
S     * |        |          |This bit is writing 1 to clear. Each bit n controls the corresponding PWM channel n.
S     * |        |          |0 = No capture falling latch condition happened.
S     * |        |          |1 = Capture falling latch condition happened, this flag will be set to high.
S     */
S    __IO uint32_t CAPIF;
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED11
S     * ===================================================================================================
S     * Offset: 0x0258 ~ 0x0300
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED11[43];
S    /**
S     * @endcond
S     */
S
S    /**
S     * PBUF0, 2, 4
S     * ===================================================================================================
S     * Offset: 0x304, 0x30C, 0x314  PWM PERIOD0, 2, 4 Buffer (offset: 0x308, 0x310, 0x318 are reserved)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |PBUF      |PWM Period Register Buffer (Read Only)
S     * |        |          |Used as PERIOD active register.
S     */
S    __I uint32_t PBUF[6];
S
S    /**
S     * CMPBUF0~5
S     * ===================================================================================================
S     * Offset: 0x31C~0x330  PWM CMPDAT0~5 Buffer
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |CMPBUF    |PWM Comparator Register Buffer (Read Only)
S     * |        |          |Used as CMP active register.
S     */
S    __I uint32_t CMPBUF[6];
S
S    /**
S     * @cond HIDDEN_SYMBOLS
S     * RESERVED12
S     * ===================================================================================================
S     * Offset: 0x0334 ~ 0x0FFC
S     * ---------------------------------------------------------------------------------------------------
S     */
S    __I  uint32_t RESERVED12[819];          /*!< Offset: 0x0334 ~ 0x0FFC    Reserved*/
S    /**
S     * @endcond
S     */
S
S} PWM_T;
S
S/**
S    @addtogroup PWM_CONST PWM Bit Field Definition
S    Constant Definitions for PWM Controller
S@{ */
S
S
S#define PWM_CTL0_CTRLDn_Pos              (0)                                                /*!< PWM_T::CTL0: CTRLDn Position              */
S#define PWM_CTL0_CTRLDn_Msk              (0x3ful << PWM_CTL0_CTRLDn_Pos)                    /*!< PWM_T::CTL0: CTRLDn Mask                  */
S
S#define PWM_CTL0_CTRLD0_Pos              (0)                                                /*!< PWM_T::CTL0: CTRLD0 Position              */
S#define PWM_CTL0_CTRLD0_Msk              (0x1ul << PWM_CTL0_CTRLD0_Pos)                     /*!< PWM_T::CTL0: CTRLD0 Mask                  */
S
S#define PWM_CTL0_CTRLD1_Pos              (1)                                                /*!< PWM_T::CTL0: CTRLD1 Position              */
S#define PWM_CTL0_CTRLD1_Msk              (0x1ul << PWM_CTL0_CTRLD1_Pos)                     /*!< PWM_T::CTL0: CTRLD1 Mask                  */
S
S#define PWM_CTL0_CTRLD2_Pos              (2)                                                /*!< PWM_T::CTL0: CTRLD2 Position              */
S#define PWM_CTL0_CTRLD2_Msk              (0x1ul << PWM_CTL0_CTRLD2_Pos)                     /*!< PWM_T::CTL0: CTRLD2 Mask                  */
S
S#define PWM_CTL0_CTRLD3_Pos              (3)                                                /*!< PWM_T::CTL0: CTRLD3 Position              */
S#define PWM_CTL0_CTRLD3_Msk              (0x1ul << PWM_CTL0_CTRLD3_Pos)                     /*!< PWM_T::CTL0: CTRLD3 Mask                  */
S
S#define PWM_CTL0_CTRLD4_Pos              (4)                                                /*!< PWM_T::CTL0: CTRLD4 Position              */
S#define PWM_CTL0_CTRLD4_Msk              (0x1ul << PWM_CTL0_CTRLD4_Pos)                     /*!< PWM_T::CTL0: CTRLD4 Mask                  */
S
S#define PWM_CTL0_CTRLD5_Pos              (5)                                                /*!< PWM_T::CTL0: CTRLD5 Position              */
S#define PWM_CTL0_CTRLD5_Msk              (0x1ul << PWM_CTL0_CTRLD5_Pos)                     /*!< PWM_T::CTL0: CTRLD5 Mask                  */
S
S#define PWM_CTL0_IMMLDENn_Pos            (16)                                               /*!< PWM_T::CTL0: IMMLDENn Position            */
S#define PWM_CTL0_IMMLDENn_Msk            (0x3ful << PWM_CTL0_IMMLDENn_Pos)                  /*!< PWM_T::CTL0: IMMLDENn Mask                */
S
S#define PWM_CTL0_IMMLDEN0_Pos            (16)                                               /*!< PWM_T::CTL0: IMMLDEN0 Position            */
S#define PWM_CTL0_IMMLDEN0_Msk            (0x1ul << PWM_CTL0_IMMLDEN0_Pos)                   /*!< PWM_T::CTL0: IMMLDEN0 Mask                */
S
S#define PWM_CTL0_IMMLDEN1_Pos            (17)                                               /*!< PWM_T::CTL0: IMMLDEN1 Position            */
S#define PWM_CTL0_IMMLDEN1_Msk            (0x1ul << PWM_CTL0_IMMLDEN1_Pos)                   /*!< PWM_T::CTL0: IMMLDEN1 Mask                */
S
S#define PWM_CTL0_IMMLDEN2_Pos            (18)                                               /*!< PWM_T::CTL0: IMMLDEN2 Position            */
S#define PWM_CTL0_IMMLDEN2_Msk            (0x1ul << PWM_CTL0_IMMLDEN2_Pos)                   /*!< PWM_T::CTL0: IMMLDEN2 Mask                */
S
S#define PWM_CTL0_IMMLDEN3_Pos            (19)                                               /*!< PWM_T::CTL0: IMMLDEN3 Position            */
S#define PWM_CTL0_IMMLDEN3_Msk            (0x1ul << PWM_CTL0_IMMLDEN3_Pos)                   /*!< PWM_T::CTL0: IMMLDEN3 Mask                */
S
S#define PWM_CTL0_IMMLDEN4_Pos            (20)                                               /*!< PWM_T::CTL0: IMMLDEN4 Position            */
S#define PWM_CTL0_IMMLDEN4_Msk            (0x1ul << PWM_CTL0_IMMLDEN4_Pos)                   /*!< PWM_T::CTL0: IMMLDEN4 Mask                */
S
S#define PWM_CTL0_IMMLDEN5_Pos            (21)                                               /*!< PWM_T::CTL0: IMMLDEN5 Position            */
S#define PWM_CTL0_IMMLDEN5_Msk            (0x1ul << PWM_CTL0_IMMLDEN5_Pos)                   /*!< PWM_T::CTL0: IMMLDEN5 Mask                */
S
S#define PWM_CTL0_DBGHALT_Pos             (30)                                               /*!< PWM_T::CTL0: DBGHALT Position             */
S#define PWM_CTL0_DBGHALT_Msk             (0x1ul << PWM_CTL0_DBGHALT_Pos)                    /*!< PWM_T::CTL0: DBGHALT Mask                 */
S
S#define PWM_CTL0_DBGTRIOFF_Pos           (31)                                               /*!< PWM_T::CTL0: DBGTRIOFF Position           */
S#define PWM_CTL0_DBGTRIOFF_Msk           (0x1ul << PWM_CTL0_DBGTRIOFF_Pos)                  /*!< PWM_T::CTL0: DBGTRIOFF Mask               */
S
S#define PWM_CTL1_CNTTYPEn_Pos            (0)                                                /*!< PWM_T::CTL1: CNTTYPEn Position            */
S#define PWM_CTL1_CNTTYPEn_Msk            (0x333ul << PWM_CTL1_CNTTYPEn_Pos)                 /*!< PWM_T::CTL1: CNTTYPEn Mask                */
S
S#define PWM_CTL1_CNTTYPE0_Pos            (0)                                                /*!< PWM_T::CTL1: CNTTYPE0 Position            */
S#define PWM_CTL1_CNTTYPE0_Msk            (0x3ul << PWM_CTL1_CNTTYPE0_Pos)                   /*!< PWM_T::CTL1: CNTTYPE0 Mask                */
S
S#define PWM_CTL1_CNTTYPE2_Pos            (4)                                                /*!< PWM_T::CTL1: CNTTYPE2 Position            */
S#define PWM_CTL1_CNTTYPE2_Msk            (0x3ul << PWM_CTL1_CNTTYPE2_Pos)                   /*!< PWM_T::CTL1: CNTTYPE2 Mask                */
S
S#define PWM_CTL1_CNTTYPE4_Pos            (8)                                                /*!< PWM_T::CTL1: CNTTYPE4 Position            */
S#define PWM_CTL1_CNTTYPE4_Msk            (0x3ul << PWM_CTL1_CNTTYPE4_Pos)                   /*!< PWM_T::CTL1: CNTTYPE4 Mask                */
S
S#define PWM_CTL1_OUTMODEn_Pos            (24)                                               /*!< PWM_T::CTL1: OUTMODEn Position            */
S#define PWM_CTL1_OUTMODEn_Msk            (0x7ul << PWM_CTL1_OUTMODEn_Pos)                   /*!< PWM_T::CTL1: OUTMODEn Mask                */
S
S#define PWM_CTL1_OUTMODE0_Pos            (24)                                               /*!< PWM_T::CTL1: OUTMODE0 Position            */
S#define PWM_CTL1_OUTMODE0_Msk            (0x1ul << PWM_CTL1_OUTMODE0_Pos)                   /*!< PWM_T::CTL1: OUTMODE0 Mask                */
S
S#define PWM_CTL1_OUTMODE2_Pos            (25)                                               /*!< PWM_T::CTL1: OUTMODE2 Position            */
S#define PWM_CTL1_OUTMODE2_Msk            (0x1ul << PWM_CTL1_OUTMODE2_Pos)                   /*!< PWM_T::CTL1: OUTMODE2 Mask                */
S
S#define PWM_CTL1_OUTMODE4_Pos            (26)                                               /*!< PWM_T::CTL1: OUTMODE4 Position            */
S#define PWM_CTL1_OUTMODE4_Msk            (0x1ul << PWM_CTL1_OUTMODE4_Pos)                   /*!< PWM_T::CTL1: OUTMODE4 Mask                */
S
S#define PWM_CLKSRC_ECLKSRC0_Pos          (0)                                                /*!< PWM_T::CLKSRC: ECLKSRC0 Position          */
S#define PWM_CLKSRC_ECLKSRC0_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC0_Pos)                 /*!< PWM_T::CLKSRC: ECLKSRC0 Mask              */
S
S#define PWM_CLKSRC_ECLKSRC2_Pos          (8)                                                /*!< PWM_T::CLKSRC: ECLKSRC2 Position          */
S#define PWM_CLKSRC_ECLKSRC2_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC2_Pos)                 /*!< PWM_T::CLKSRC: ECLKSRC2 Mask              */
S
S#define PWM_CLKSRC_ECLKSRC4_Pos          (16)                                               /*!< PWM_T::CLKSRC: ECLKSRC4 Position          */
S#define PWM_CLKSRC_ECLKSRC4_Msk          (0x7ul << PWM_CLKSRC_ECLKSRC4_Pos)                 /*!< PWM_T::CLKSRC: ECLKSRC4 Mask              */
S
S#define PWM_CLKPSC0_1_CLKPSC_Pos         (0)                                                /*!< PWM_T::CLKPSC0_1: CLKPSC Position         */
S#define PWM_CLKPSC0_1_CLKPSC_Msk         (0xffful << PWM_CLKPSC0_1_CLKPSC_Pos)              /*!< PWM_T::CLKPSC0_1: CLKPSC Mask             */
S
S#define PWM_CLKPSC2_3_CLKPSC_Pos         (0)                                                /*!< PWM_T::CLKPSC2_3: CLKPSC Position         */
S#define PWM_CLKPSC2_3_CLKPSC_Msk         (0xffful << PWM_CLKPSC2_3_CLKPSC_Pos)              /*!< PWM_T::CLKPSC2_3: CLKPSC Mask             */
S
S#define PWM_CLKPSC4_5_CLKPSC_Pos         (0)                                                /*!< PWM_T::CLKPSC4_5: CLKPSC Position         */
S#define PWM_CLKPSC4_5_CLKPSC_Msk         (0xffful << PWM_CLKPSC4_5_CLKPSC_Pos)              /*!< PWM_T::CLKPSC4_5: CLKPSC Mask             */
S
S#define PWM_CNTEN_CNTENn_Pos             (0)                                                /*!< PWM_T::CNTEN: CNTENn Position             */
S#define PWM_CNTEN_CNTENn_Msk             (0x15ul << PWM_CNTEN_CNTENn_Pos)                   /*!< PWM_T::CNTEN: CNTENn Mask                 */
S
S#define PWM_CNTEN_CNTEN0_Pos             (0)                                                /*!< PWM_T::CNTEN: CNTEN0 Position             */
S#define PWM_CNTEN_CNTEN0_Msk             (0x1ul << PWM_CNTEN_CNTEN0_Pos)                    /*!< PWM_T::CNTEN: CNTEN0 Mask                 */
S
S#define PWM_CNTEN_CNTEN2_Pos             (2)                                                /*!< PWM_T::CNTEN: CNTEN2 Position             */
S#define PWM_CNTEN_CNTEN2_Msk             (0x1ul << PWM_CNTEN_CNTEN2_Pos)                    /*!< PWM_T::CNTEN: CNTEN2 Mask                 */
S
S#define PWM_CNTEN_CNTEN4_Pos             (4)                                                /*!< PWM_T::CNTEN: CNTEN4 Position             */
S#define PWM_CNTEN_CNTEN4_Msk             (0x1ul << PWM_CNTEN_CNTEN4_Pos)                    /*!< PWM_T::CNTEN: CNTEN4 Mask                 */
S
S#define PWM_CNTCLR_CNTCLRn_Pos           (0)                                                /*!< PWM_T::CNTCLR: CNTCLRn Position           */
S#define PWM_CNTCLR_CNTCLRn_Msk           (0x15ul << PWM_CNTCLR_CNTCLRn_Pos)                 /*!< PWM_T::CNTCLR: CNTCLRn Mask               */
S
S#define PWM_CNTCLR_CNTCLR0_Pos           (0)                                                /*!< PWM_T::CNTCLR: CNTCLR0 Position           */
S#define PWM_CNTCLR_CNTCLR0_Msk           (0x1ul << PWM_CNTCLR_CNTCLR0_Pos)                  /*!< PWM_T::CNTCLR: CNTCLR0 Mask               */
S
S#define PWM_CNTCLR_CNTCLR2_Pos           (2)                                                /*!< PWM_T::CNTCLR: CNTCLR2 Position           */
S#define PWM_CNTCLR_CNTCLR2_Msk           (0x1ul << PWM_CNTCLR_CNTCLR2_Pos)                  /*!< PWM_T::CNTCLR: CNTCLR2 Mask               */
S
S#define PWM_CNTCLR_CNTCLR4_Pos           (4)                                                /*!< PWM_T::CNTCLR: CNTCLR4 Position           */
S#define PWM_CNTCLR_CNTCLR4_Msk           (0x1ul << PWM_CNTCLR_CNTCLR4_Pos)                  /*!< PWM_T::CNTCLR: CNTCLR4 Mask               */
S
S#define PWM_PERIOD_PERIOD_Pos            (0)                                                /*!< PWM_T::PERIOD: PERIOD Position            */
S#define PWM_PERIOD_PERIOD_Msk            (0xfffful << PWM_PERIOD_PERIOD_Pos)                /*!< PWM_T::PERIOD: PERIOD Mask                */
S
S#define PWM_CMPDAT_CMP_Pos               (0)                                                /*!< PWM_T::CMPDAT: CMP Position               */
S#define PWM_CMPDAT_CMP_Msk               (0xfffful << PWM_CMPDAT_CMP_Pos)                   /*!< PWM_T::CMPDAT: CMP Mask                   */
S
S#define PWM_DTCTL0_1_DTCNT_Pos           (0)                                                /*!< PWM_T::DTCTL0_1: DTCNT Position           */
S#define PWM_DTCTL0_1_DTCNT_Msk           (0xffful << PWM_DTCTL0_1_DTCNT_Pos)                /*!< PWM_T::DTCTL0_1: DTCNT Mask               */
S
S#define PWM_DTCTL0_1_DTEN_Pos            (16)                                               /*!< PWM_T::DTCTL0_1: DTEN Position            */
S#define PWM_DTCTL0_1_DTEN_Msk            (0x1ul << PWM_DTCTL0_1_DTEN_Pos)                   /*!< PWM_T::DTCTL0_1: DTEN Mask                */
S
S#define PWM_DTCTL0_1_DTCKSEL_Pos         (24)                                               /*!< PWM_T::DTCTL0_1: DTCKSEL Position         */
S#define PWM_DTCTL0_1_DTCKSEL_Msk         (0x1ul << PWM_DTCTL0_1_DTCKSEL_Pos)                /*!< PWM_T::DTCTL0_1: DTCKSEL Mask             */
S
S#define PWM_DTCTL2_3_DTCNT_Pos           (0)                                                /*!< PWM_T::DTCTL2_3: DTCNT Position           */
S#define PWM_DTCTL2_3_DTCNT_Msk           (0xffful << PWM_DTCTL2_3_DTCNT_Pos)                /*!< PWM_T::DTCTL2_3: DTCNT Mask               */
S
S#define PWM_DTCTL2_3_DTEN_Pos            (16)                                               /*!< PWM_T::DTCTL2_3: DTEN Position            */
S#define PWM_DTCTL2_3_DTEN_Msk            (0x1ul << PWM_DTCTL2_3_DTEN_Pos)                   /*!< PWM_T::DTCTL2_3: DTEN Mask                */
S
S#define PWM_DTCTL2_3_DTCKSEL_Pos         (24)                                               /*!< PWM_T::DTCTL2_3: DTCKSEL Position         */
S#define PWM_DTCTL2_3_DTCKSEL_Msk         (0x1ul << PWM_DTCTL2_3_DTCKSEL_Pos)                /*!< PWM_T::DTCTL2_3: DTCKSEL Mask             */
S
S#define PWM_DTCTL4_5_DTCNT_Pos           (0)                                                /*!< PWM_T::DTCTL4_5: DTCNT Position           */
S#define PWM_DTCTL4_5_DTCNT_Msk           (0xffful << PWM_DTCTL4_5_DTCNT_Pos)                /*!< PWM_T::DTCTL4_5: DTCNT Mask               */
S
S#define PWM_DTCTL4_5_DTEN_Pos            (16)                                               /*!< PWM_T::DTCTL4_5: DTEN Position            */
S#define PWM_DTCTL4_5_DTEN_Msk            (0x1ul << PWM_DTCTL4_5_DTEN_Pos)                   /*!< PWM_T::DTCTL4_5: DTEN Mask                */
S
S#define PWM_DTCTL4_5_DTCKSEL_Pos         (24)                                               /*!< PWM_T::DTCTL4_5: DTCKSEL Position         */
S#define PWM_DTCTL4_5_DTCKSEL_Msk         (0x1ul << PWM_DTCTL4_5_DTCKSEL_Pos)                /*!< PWM_T::DTCTL4_5: DTCKSEL Mask             */
S
S#define PWM_CNT_CNT_Pos                  (0)                                                /*!< PWM_T::CNT: CNT Position                  */
S#define PWM_CNT_CNT_Msk                  (0xfffful << PWM_CNT_CNT_Pos)                      /*!< PWM_T::CNT: CNT Mask                      */
S
S#define PWM_CNT_DIRF_Pos                 (16)                                               /*!< PWM_T::CNT: DIRF Position                 */
S#define PWM_CNT_DIRF_Msk                 (0x1ul << PWM_CNT_DIRF_Pos)                        /*!< PWM_T::CNT: DIRF Mask                     */
S
S#define PWM_WGCTL0_ZPCTLn_Pos            (0)                                                /*!< PWM_T::WGCTL0: ZPCTLn Position            */
S#define PWM_WGCTL0_ZPCTLn_Msk            (0xffful << PWM_WGCTL0_ZPCTLn_Pos)                 /*!< PWM_T::WGCTL0: ZPCTLn Mask                */
S
S#define PWM_WGCTL0_ZPCTL0_Pos            (0)                                                /*!< PWM_T::WGCTL0: ZPCTL0 Position            */
S#define PWM_WGCTL0_ZPCTL0_Msk            (0x3ul << PWM_WGCTL0_ZPCTL0_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL0 Mask                */
S
S#define PWM_WGCTL0_ZPCTL1_Pos            (2)                                                /*!< PWM_T::WGCTL0: ZPCTL1 Position            */
S#define PWM_WGCTL0_ZPCTL1_Msk            (0x3ul << PWM_WGCTL0_ZPCTL1_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL1 Mask                */
S
S#define PWM_WGCTL0_ZPCTL2_Pos            (4)                                                /*!< PWM_T::WGCTL0: ZPCTL2 Position            */
S#define PWM_WGCTL0_ZPCTL2_Msk            (0x3ul << PWM_WGCTL0_ZPCTL2_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL2 Mask                */
S
S#define PWM_WGCTL0_ZPCTL3_Pos            (6)                                                /*!< PWM_T::WGCTL0: ZPCTL3 Position            */
S#define PWM_WGCTL0_ZPCTL3_Msk            (0x3ul << PWM_WGCTL0_ZPCTL3_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL3 Mask                */
S
S#define PWM_WGCTL0_ZPCTL4_Pos            (8)                                                /*!< PWM_T::WGCTL0: ZPCTL4 Position            */
S#define PWM_WGCTL0_ZPCTL4_Msk            (0x3ul << PWM_WGCTL0_ZPCTL4_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL4 Mask                */
S
S#define PWM_WGCTL0_ZPCTL5_Pos            (10)                                               /*!< PWM_T::WGCTL0: ZPCTL5 Position            */
S#define PWM_WGCTL0_ZPCTL5_Msk            (0x3ul << PWM_WGCTL0_ZPCTL5_Pos)                   /*!< PWM_T::WGCTL0: ZPCTL5 Mask                */
S
S#define PWM_WGCTL0_PRDPCTLn_Pos          (16)                                               /*!< PWM_T::WGCTL0: PRDPCTLn Position          */
S#define PWM_WGCTL0_PRDPCTLn_Msk          (0xffful << PWM_WGCTL0_PRDPCTLn_Pos)               /*!< PWM_T::WGCTL0: PRDPCTLn Mask              */
S
S#define PWM_WGCTL0_PRDPCTL0_Pos          (16)                                               /*!< PWM_T::WGCTL0: PRDPCTL0 Position          */
S#define PWM_WGCTL0_PRDPCTL0_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL0_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL0 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL1_Pos          (18)                                               /*!< PWM_T::WGCTL0: PRDPCTL1 Position          */
S#define PWM_WGCTL0_PRDPCTL1_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL1_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL1 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL2_Pos          (20)                                               /*!< PWM_T::WGCTL0: PRDPCTL2 Position          */
S#define PWM_WGCTL0_PRDPCTL2_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL2_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL2 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL3_Pos          (22)                                               /*!< PWM_T::WGCTL0: PRDPCTL3 Position          */
S#define PWM_WGCTL0_PRDPCTL3_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL3_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL3 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL4_Pos          (24)                                               /*!< PWM_T::WGCTL0: PRDPCTL4 Position          */
S#define PWM_WGCTL0_PRDPCTL4_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL4_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL4 Mask              */
S
S#define PWM_WGCTL0_PRDPCTL5_Pos          (26)                                               /*!< PWM_T::WGCTL0: PRDPCTL5 Position          */
S#define PWM_WGCTL0_PRDPCTL5_Msk          (0x3ul << PWM_WGCTL0_PRDPCTL5_Pos)                 /*!< PWM_T::WGCTL0: PRDPCTL5 Mask              */
S
S#define PWM_WGCTL1_CMPUCTLn_Pos          (0)                                                /*!< PWM_T::WGCTL1: CMPUCTLn Position          */
S#define PWM_WGCTL1_CMPUCTLn_Msk          (0xffful << PWM_WGCTL1_CMPUCTLn_Pos)               /*!< PWM_T::WGCTL1: CMPUCTLn Mask              */
S
S#define PWM_WGCTL1_CMPUCTL0_Pos          (0)                                                /*!< PWM_T::WGCTL1: CMPUCTL0 Position          */
S#define PWM_WGCTL1_CMPUCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL0_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL0 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL1_Pos          (2)                                                /*!< PWM_T::WGCTL1: CMPUCTL1 Position          */
S#define PWM_WGCTL1_CMPUCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL1_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL1 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL2_Pos          (4)                                                /*!< PWM_T::WGCTL1: CMPUCTL2 Position          */
S#define PWM_WGCTL1_CMPUCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL2_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL2 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL3_Pos          (6)                                                /*!< PWM_T::WGCTL1: CMPUCTL3 Position          */
S#define PWM_WGCTL1_CMPUCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL3_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL3 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL4_Pos          (8)                                                /*!< PWM_T::WGCTL1: CMPUCTL4 Position          */
S#define PWM_WGCTL1_CMPUCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL4_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL4 Mask              */
S
S#define PWM_WGCTL1_CMPUCTL5_Pos          (10)                                               /*!< PWM_T::WGCTL1: CMPUCTL5 Position          */
S#define PWM_WGCTL1_CMPUCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPUCTL5_Pos)                 /*!< PWM_T::WGCTL1: CMPUCTL5 Mask              */
S
S#define PWM_WGCTL1_CMPDCTLn_Pos          (16)                                               /*!< PWM_T::WGCTL1: CMPDCTLn Position          */
S#define PWM_WGCTL1_CMPDCTLn_Msk          (0xffful << PWM_WGCTL1_CMPDCTLn_Pos)               /*!< PWM_T::WGCTL1: CMPDCTLn Mask              */
S
S#define PWM_WGCTL1_CMPDCTL0_Pos          (16)                                               /*!< PWM_T::WGCTL1: CMPDCTL0 Position          */
S#define PWM_WGCTL1_CMPDCTL0_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL0_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL0 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL1_Pos          (18)                                               /*!< PWM_T::WGCTL1: CMPDCTL1 Position          */
S#define PWM_WGCTL1_CMPDCTL1_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL1_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL1 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL2_Pos          (20)                                               /*!< PWM_T::WGCTL1: CMPDCTL2 Position          */
S#define PWM_WGCTL1_CMPDCTL2_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL2_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL2 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL3_Pos          (22)                                               /*!< PWM_T::WGCTL1: CMPDCTL3 Position          */
S#define PWM_WGCTL1_CMPDCTL3_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL3_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL3 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL4_Pos          (24)                                               /*!< PWM_T::WGCTL1: CMPDCTL4 Position          */
S#define PWM_WGCTL1_CMPDCTL4_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL4_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL4 Mask              */
S
S#define PWM_WGCTL1_CMPDCTL5_Pos          (26)                                               /*!< PWM_T::WGCTL1: CMPDCTL5 Position          */
S#define PWM_WGCTL1_CMPDCTL5_Msk          (0x3ul << PWM_WGCTL1_CMPDCTL5_Pos)                 /*!< PWM_T::WGCTL1: CMPDCTL5 Mask              */
S
S#define PWM_MSKEN_MSKENn_Pos             (0)                                                /*!< PWM_T::MSKEN: MSKENn Position             */
S#define PWM_MSKEN_MSKENn_Msk             (0x3ful << PWM_MSKEN_MSKENn_Pos)                   /*!< PWM_T::MSKEN: MSKENn Mask                 */
S
S#define PWM_MSKEN_MSKEN0_Pos             (0)                                                /*!< PWM_T::MSKEN: MSKEN0 Position             */
S#define PWM_MSKEN_MSKEN0_Msk             (0x1ul << PWM_MSKEN_MSKEN0_Pos)                    /*!< PWM_T::MSKEN: MSKEN0 Mask                 */
S
S#define PWM_MSKEN_MSKEN1_Pos             (1)                                                /*!< PWM_T::MSKEN: MSKEN1 Position             */
S#define PWM_MSKEN_MSKEN1_Msk             (0x1ul << PWM_MSKEN_MSKEN1_Pos)                    /*!< PWM_T::MSKEN: MSKEN1 Mask                 */
S
S#define PWM_MSKEN_MSKEN2_Pos             (2)                                                /*!< PWM_T::MSKEN: MSKEN2 Position             */
S#define PWM_MSKEN_MSKEN2_Msk             (0x1ul << PWM_MSKEN_MSKEN2_Pos)                    /*!< PWM_T::MSKEN: MSKEN2 Mask                 */
S
S#define PWM_MSKEN_MSKEN3_Pos             (3)                                                /*!< PWM_T::MSKEN: MSKEN3 Position             */
S#define PWM_MSKEN_MSKEN3_Msk             (0x1ul << PWM_MSKEN_MSKEN3_Pos)                    /*!< PWM_T::MSKEN: MSKEN3 Mask                 */
S
S#define PWM_MSKEN_MSKEN4_Pos             (4)                                                /*!< PWM_T::MSKEN: MSKEN4 Position             */
S#define PWM_MSKEN_MSKEN4_Msk             (0x1ul << PWM_MSKEN_MSKEN4_Pos)                    /*!< PWM_T::MSKEN: MSKEN4 Mask                 */
S
S#define PWM_MSKEN_MSKEN5_Pos             (5)                                                /*!< PWM_T::MSKEN: MSKEN5 Position             */
S#define PWM_MSKEN_MSKEN5_Msk             (0x1ul << PWM_MSKEN_MSKEN5_Pos)                    /*!< PWM_T::MSKEN: MSKEN5 Mask                 */
S
S#define PWM_MSK_MSKDATn_Pos              (0)                                                /*!< PWM_T::MSK: MSKDATn Position              */
S#define PWM_MSK_MSKDATn_Msk              (0x3ful << PWM_MSK_MSKDATn_Pos)                    /*!< PWM_T::MSK: MSKDATn Mask                  */
S
S#define PWM_MSK_MSKDAT0_Pos              (0)                                                /*!< PWM_T::MSK: MSKDAT0 Position              */
S#define PWM_MSK_MSKDAT0_Msk              (0x1ul << PWM_MSK_MSKDAT0_Pos)                     /*!< PWM_T::MSK: MSKDAT0 Mask                  */
S
S#define PWM_MSK_MSKDAT1_Pos              (1)                                                /*!< PWM_T::MSK: MSKDAT1 Position              */
S#define PWM_MSK_MSKDAT1_Msk              (0x1ul << PWM_MSK_MSKDAT1_Pos)                     /*!< PWM_T::MSK: MSKDAT1 Mask                  */
S
S#define PWM_MSK_MSKDAT2_Pos              (2)                                                /*!< PWM_T::MSK: MSKDAT2 Position              */
S#define PWM_MSK_MSKDAT2_Msk              (0x1ul << PWM_MSK_MSKDAT2_Pos)                     /*!< PWM_T::MSK: MSKDAT2 Mask                  */
S
S#define PWM_MSK_MSKDAT3_Pos              (3)                                                /*!< PWM_T::MSK: MSKDAT3 Position              */
S#define PWM_MSK_MSKDAT3_Msk              (0x1ul << PWM_MSK_MSKDAT3_Pos)                     /*!< PWM_T::MSK: MSKDAT3 Mask                  */
S
S#define PWM_MSK_MSKDAT4_Pos              (4)                                                /*!< PWM_T::MSK: MSKDAT4 Position              */
S#define PWM_MSK_MSKDAT4_Msk              (0x1ul << PWM_MSK_MSKDAT4_Pos)                     /*!< PWM_T::MSK: MSKDAT4 Mask                  */
S
S#define PWM_MSK_MSKDAT5_Pos              (5)                                                /*!< PWM_T::MSK: MSKDAT5 Position              */
S#define PWM_MSK_MSKDAT5_Msk              (0x1ul << PWM_MSK_MSKDAT5_Pos)                     /*!< PWM_T::MSK: MSKDAT5 Mask                  */
S
S#define PWM_BNF_BRK0NFEN_Pos             (0)                                                /*!< PWM_T::BNF: BRK0NFEN Position             */
S#define PWM_BNF_BRK0NFEN_Msk             (0x1ul << PWM_BNF_BRK0NFEN_Pos)                    /*!< PWM_T::BNF: BRK0NFEN Mask                 */
S
S#define PWM_BNF_BRK0NFSEL_Pos            (1)                                                /*!< PWM_T::BNF: BRK0NFSEL Position            */
S#define PWM_BNF_BRK0NFSEL_Msk            (0x7ul << PWM_BNF_BRK0NFSEL_Pos)                   /*!< PWM_T::BNF: BRK0NFSEL Mask                */
S
S#define PWM_BNF_BRK0FCNT_Pos             (4)                                                /*!< PWM_T::BNF: BRK0FCNT Position             */
S#define PWM_BNF_BRK0FCNT_Msk             (0x7ul << PWM_BNF_BRK0FCNT_Pos)                    /*!< PWM_T::BNF: BRK0FCNT Mask                 */
S
S#define PWM_BNF_BRK0PINV_Pos             (7)                                                /*!< PWM_T::BNF: BRK0PINV Position             */
S#define PWM_BNF_BRK0PINV_Msk             (0x1ul << PWM_BNF_BRK0PINV_Pos)                    /*!< PWM_T::BNF: BRK0PINV Mask                 */
S
S#define PWM_BNF_BRK1NFEN_Pos             (8)                                                /*!< PWM_T::BNF: BRK1NFEN Position             */
S#define PWM_BNF_BRK1NFEN_Msk             (0x1ul << PWM_BNF_BRK1NFEN_Pos)                    /*!< PWM_T::BNF: BRK1NFEN Mask                 */
S
S#define PWM_BNF_BRK1NFSEL_Pos            (9)                                                /*!< PWM_T::BNF: BRK1NFSEL Position            */
S#define PWM_BNF_BRK1NFSEL_Msk            (0x7ul << PWM_BNF_BRK1NFSEL_Pos)                   /*!< PWM_T::BNF: BRK1NFSEL Mask                */
S
S#define PWM_BNF_BRK1FCNT_Pos             (12)                                               /*!< PWM_T::BNF: BRK1FCNT Position             */
S#define PWM_BNF_BRK1FCNT_Msk             (0x7ul << PWM_BNF_BRK1FCNT_Pos)                    /*!< PWM_T::BNF: BRK1FCNT Mask                 */
S
S#define PWM_BNF_BRK1PINV_Pos             (15)                                               /*!< PWM_T::BNF: BRK1PINV Position             */
S#define PWM_BNF_BRK1PINV_Msk             (0x1ul << PWM_BNF_BRK1PINV_Pos)                    /*!< PWM_T::BNF: BRK1PINV Mask                 */
S
S#define PWM_BNF_BK0SRC_Pos               (16)                                               /*!< PWM_T::BNF: BK0SRC Position               */
S#define PWM_BNF_BK0SRC_Msk               (0x1ul << PWM_BNF_BK0SRC_Pos)                      /*!< PWM_T::BNF: BK0SRC Mask                   */
S
S#define PWM_BNF_BK1SRC_Pos               (24)                                               /*!< PWM_T::BNF: BK1SRC Position               */
S#define PWM_BNF_BK1SRC_Msk               (0x1ul << PWM_BNF_BK1SRC_Pos)                      /*!< PWM_T::BNF: BK1SRC Mask                   */
S
S#define PWM_FAILBRK_CSSBRKEN_Pos         (0)                                                /*!< PWM_T::FAILBRK: CSSBRKEN Position         */
S#define PWM_FAILBRK_CSSBRKEN_Msk         (0x1ul << PWM_FAILBRK_CSSBRKEN_Pos)                /*!< PWM_T::FAILBRK: CSSBRKEN Mask             */
S
S#define PWM_FAILBRK_BODBRKEN_Pos         (1)                                                /*!< PWM_T::FAILBRK: BODBRKEN Position         */
S#define PWM_FAILBRK_BODBRKEN_Msk         (0x1ul << PWM_FAILBRK_BODBRKEN_Pos)                /*!< PWM_T::FAILBRK: BODBRKEN Mask             */
S
S#define PWM_FAILBRK_RAMBRKEN_Pos         (2)                                                /*!< PWM_T::FAILBRK: RAMBRKEN Position         */
S#define PWM_FAILBRK_RAMBRKEN_Msk         (0x1ul << PWM_FAILBRK_RAMBRKEN_Pos)                /*!< PWM_T::FAILBRK: RAMBRKEN Mask             */
S
S#define PWM_FAILBRK_CORBRKEN_Pos         (3)                                                /*!< PWM_T::FAILBRK: CORBRKEN Position         */
S#define PWM_FAILBRK_CORBRKEN_Msk         (0x1ul << PWM_FAILBRK_CORBRKEN_Pos)                /*!< PWM_T::FAILBRK: CORBRKEN Mask             */
S
S#define PWM_BRKCTL0_1_BRKP0EEN_Pos       (4)                                                /*!< PWM_T::BRKCTL0_1: BRKP0EEN Position       */
S#define PWM_BRKCTL0_1_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0EEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKP0EEN Mask           */
S
S#define PWM_BRKCTL0_1_BRKP1EEN_Pos       (5)                                                /*!< PWM_T::BRKCTL0_1: BRKP1EEN Position       */
S#define PWM_BRKCTL0_1_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1EEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKP1EEN Mask           */
S
S#define PWM_BRKCTL0_1_SYSEBEN_Pos        (7)                                                /*!< PWM_T::BRKCTL0_1: SYSEBEN Position        */
S#define PWM_BRKCTL0_1_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSEBEN_Pos)               /*!< PWM_T::BRKCTL0_1: SYSEBEN Mask            */
S
S#define PWM_BRKCTL0_1_BRKP0LEN_Pos       (12)                                               /*!< PWM_T::BRKCTL0_1: BRKP0LEN Position       */
S#define PWM_BRKCTL0_1_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP0LEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKP0LEN Mask           */
S
S#define PWM_BRKCTL0_1_BRKP1LEN_Pos       (13)                                               /*!< PWM_T::BRKCTL0_1: BRKP1LEN Position       */
S#define PWM_BRKCTL0_1_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL0_1_BRKP1LEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKP1LEN Mask           */
S
S#define PWM_BRKCTL0_1_SYSLBEN_Pos        (15)                                               /*!< PWM_T::BRKCTL0_1: SYSLBEN Position        */
S#define PWM_BRKCTL0_1_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL0_1_SYSLBEN_Pos)               /*!< PWM_T::BRKCTL0_1: SYSLBEN Mask            */
S
S#define PWM_BRKCTL0_1_BRKAEVEN_Pos       (16)                                               /*!< PWM_T::BRKCTL0_1: BRKAEVEN Position       */
S#define PWM_BRKCTL0_1_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL0_1_BRKAEVEN_Pos)              /*!< PWM_T::BRKCTL0_1: BRKAEVEN Mask           */
S
S#define PWM_BRKCTL0_1_BRKAODD_Pos        (18)                                               /*!< PWM_T::BRKCTL0_1: BRKAODD Position        */
S#define PWM_BRKCTL0_1_BRKAODD_Msk        (0x3ul << PWM_BRKCTL0_1_BRKAODD_Pos)               /*!< PWM_T::BRKCTL0_1: BRKAODD Mask            */
S
S#define PWM_BRKCTL2_3_BRKP0EEN_Pos       (4)                                                /*!< PWM_T::BRKCTL2_3: BRKP0EEN Position       */
S#define PWM_BRKCTL2_3_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0EEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKP0EEN Mask           */
S
S#define PWM_BRKCTL2_3_BRKP1EEN_Pos       (5)                                                /*!< PWM_T::BRKCTL2_3: BRKP1EEN Position       */
S#define PWM_BRKCTL2_3_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1EEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKP1EEN Mask           */
S
S#define PWM_BRKCTL2_3_SYSEBEN_Pos        (7)                                                /*!< PWM_T::BRKCTL2_3: SYSEBEN Position        */
S#define PWM_BRKCTL2_3_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSEBEN_Pos)               /*!< PWM_T::BRKCTL2_3: SYSEBEN Mask            */
S
S#define PWM_BRKCTL2_3_BRKP0LEN_Pos       (12)                                               /*!< PWM_T::BRKCTL2_3: BRKP0LEN Position       */
S#define PWM_BRKCTL2_3_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP0LEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKP0LEN Mask           */
S
S#define PWM_BRKCTL2_3_BRKP1LEN_Pos       (13)                                               /*!< PWM_T::BRKCTL2_3: BRKP1LEN Position       */
S#define PWM_BRKCTL2_3_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL2_3_BRKP1LEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKP1LEN Mask           */
S
S#define PWM_BRKCTL2_3_SYSLBEN_Pos        (15)                                               /*!< PWM_T::BRKCTL2_3: SYSLBEN Position        */
S#define PWM_BRKCTL2_3_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL2_3_SYSLBEN_Pos)               /*!< PWM_T::BRKCTL2_3: SYSLBEN Mask            */
S
S#define PWM_BRKCTL2_3_BRKAEVEN_Pos       (16)                                               /*!< PWM_T::BRKCTL2_3: BRKAEVEN Position       */
S#define PWM_BRKCTL2_3_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL2_3_BRKAEVEN_Pos)              /*!< PWM_T::BRKCTL2_3: BRKAEVEN Mask           */
S
S#define PWM_BRKCTL2_3_BRKAODD_Pos        (18)                                               /*!< PWM_T::BRKCTL2_3: BRKAODD Position        */
S#define PWM_BRKCTL2_3_BRKAODD_Msk        (0x3ul << PWM_BRKCTL2_3_BRKAODD_Pos)               /*!< PWM_T::BRKCTL2_3: BRKAODD Mask            */
S
S#define PWM_BRKCTL4_5_BRKP0EEN_Pos       (4)                                                /*!< PWM_T::BRKCTL4_5: BRKP0EEN Position       */
S#define PWM_BRKCTL4_5_BRKP0EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0EEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKP0EEN Mask           */
S
S#define PWM_BRKCTL4_5_BRKP1EEN_Pos       (5)                                                /*!< PWM_T::BRKCTL4_5: BRKP1EEN Position       */
S#define PWM_BRKCTL4_5_BRKP1EEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1EEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKP1EEN Mask           */
S
S#define PWM_BRKCTL4_5_SYSEBEN_Pos        (7)                                                /*!< PWM_T::BRKCTL4_5: SYSEBEN Position        */
S#define PWM_BRKCTL4_5_SYSEBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSEBEN_Pos)               /*!< PWM_T::BRKCTL4_5: SYSEBEN Mask            */
S
S#define PWM_BRKCTL4_5_BRKP0LEN_Pos       (12)                                               /*!< PWM_T::BRKCTL4_5: BRKP0LEN Position       */
S#define PWM_BRKCTL4_5_BRKP0LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP0LEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKP0LEN Mask           */
S
S#define PWM_BRKCTL4_5_BRKP1LEN_Pos       (13)                                               /*!< PWM_T::BRKCTL4_5: BRKP1LEN Position       */
S#define PWM_BRKCTL4_5_BRKP1LEN_Msk       (0x1ul << PWM_BRKCTL4_5_BRKP1LEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKP1LEN Mask           */
S
S#define PWM_BRKCTL4_5_SYSLBEN_Pos        (15)                                               /*!< PWM_T::BRKCTL4_5: SYSLBEN Position        */
S#define PWM_BRKCTL4_5_SYSLBEN_Msk        (0x1ul << PWM_BRKCTL4_5_SYSLBEN_Pos)               /*!< PWM_T::BRKCTL4_5: SYSLBEN Mask            */
S
S#define PWM_BRKCTL4_5_BRKAEVEN_Pos       (16)                                               /*!< PWM_T::BRKCTL4_5: BRKAEVEN Position       */
S#define PWM_BRKCTL4_5_BRKAEVEN_Msk       (0x3ul << PWM_BRKCTL4_5_BRKAEVEN_Pos)              /*!< PWM_T::BRKCTL4_5: BRKAEVEN Mask           */
S
S#define PWM_BRKCTL4_5_BRKAODD_Pos        (18)                                               /*!< PWM_T::BRKCTL4_5: BRKAODD Position        */
S#define PWM_BRKCTL4_5_BRKAODD_Msk        (0x3ul << PWM_BRKCTL4_5_BRKAODD_Pos)               /*!< PWM_T::BRKCTL4_5: BRKAODD Mask            */
S
S#define PWM_POLCTL_PINVn_Pos             (0)                                                /*!< PWM_T::POLCTL: PINVn Position             */
S#define PWM_POLCTL_PINVn_Msk             (0x3ful << PWM_POLCTL_PINVn_Pos)                   /*!< PWM_T::POLCTL: PINVn Mask                 */
S
S#define PWM_POLCTL_PINV0_Pos             (0)                                                /*!< PWM_T::POLCTL: PINV0 Position             */
S#define PWM_POLCTL_PINV0_Msk             (0x1ul << PWM_POLCTL_PINV0_Pos)                    /*!< PWM_T::POLCTL: PINV0 Mask                 */
S
S#define PWM_POLCTL_PINV1_Pos             (1)                                                /*!< PWM_T::POLCTL: PINV1 Position             */
S#define PWM_POLCTL_PINV1_Msk             (0x1ul << PWM_POLCTL_PINV1_Pos)                    /*!< PWM_T::POLCTL: PINV1 Mask                 */
S
S#define PWM_POLCTL_PINV2_Pos             (2)                                                /*!< PWM_T::POLCTL: PINV2 Position             */
S#define PWM_POLCTL_PINV2_Msk             (0x1ul << PWM_POLCTL_PINV2_Pos)                    /*!< PWM_T::POLCTL: PINV2 Mask                 */
S
S#define PWM_POLCTL_PINV3_Pos             (3)                                                /*!< PWM_T::POLCTL: PINV3 Position             */
S#define PWM_POLCTL_PINV3_Msk             (0x1ul << PWM_POLCTL_PINV3_Pos)                    /*!< PWM_T::POLCTL: PINV3 Mask                 */
S
S#define PWM_POLCTL_PINV4_Pos             (4)                                                /*!< PWM_T::POLCTL: PINV4 Position             */
S#define PWM_POLCTL_PINV4_Msk             (0x1ul << PWM_POLCTL_PINV4_Pos)                    /*!< PWM_T::POLCTL: PINV4 Mask                 */
S
S#define PWM_POLCTL_PINV5_Pos             (5)                                                /*!< PWM_T::POLCTL: PINV5 Position             */
S#define PWM_POLCTL_PINV5_Msk             (0x1ul << PWM_POLCTL_PINV5_Pos)                    /*!< PWM_T::POLCTL: PINV5 Mask                 */
S
S#define PWM_POEN_POENn_Pos               (0)                                                /*!< PWM_T::POEN: POENn Position               */
S#define PWM_POEN_POENn_Msk               (0x3ful << PWM_POEN_POENn_Pos)                     /*!< PWM_T::POEN: POENn Mask                   */
S
S#define PWM_POEN_POEN0_Pos               (0)                                                /*!< PWM_T::POEN: POEN0 Position               */
S#define PWM_POEN_POEN0_Msk               (0x1ul << PWM_POEN_POEN0_Pos)                      /*!< PWM_T::POEN: POEN0 Mask                   */
S
S#define PWM_POEN_POEN1_Pos               (1)                                                /*!< PWM_T::POEN: POEN1 Position               */
S#define PWM_POEN_POEN1_Msk               (0x1ul << PWM_POEN_POEN1_Pos)                      /*!< PWM_T::POEN: POEN1 Mask                   */
S
S#define PWM_POEN_POEN2_Pos               (2)                                                /*!< PWM_T::POEN: POEN2 Position               */
S#define PWM_POEN_POEN2_Msk               (0x1ul << PWM_POEN_POEN2_Pos)                      /*!< PWM_T::POEN: POEN2 Mask                   */
S
S#define PWM_POEN_POEN3_Pos               (3)                                                /*!< PWM_T::POEN: POEN3 Position               */
S#define PWM_POEN_POEN3_Msk               (0x1ul << PWM_POEN_POEN3_Pos)                      /*!< PWM_T::POEN: POEN3 Mask                   */
S
S#define PWM_POEN_POEN4_Pos               (4)                                                /*!< PWM_T::POEN: POEN4 Position               */
S#define PWM_POEN_POEN4_Msk               (0x1ul << PWM_POEN_POEN4_Pos)                      /*!< PWM_T::POEN: POEN4 Mask                   */
S
S#define PWM_POEN_POEN5_Pos               (5)                                                /*!< PWM_T::POEN: POEN5 Position               */
S#define PWM_POEN_POEN5_Msk               (0x1ul << PWM_POEN_POEN5_Pos)                      /*!< PWM_T::POEN: POEN5 Mask                   */
S
S#define PWM_SWBRK_BRKETRGn_Pos           (0)                                                /*!< PWM_T::SWBRK: BRKETRGn Position           */
S#define PWM_SWBRK_BRKETRGn_Msk           (0x7ul << PWM_SWBRK_BRKETRGn_Pos)                  /*!< PWM_T::SWBRK: BRKETRGn Mask               */
S
S#define PWM_SWBRK_BRKETRG0_Pos           (0)                                                /*!< PWM_T::SWBRK: BRKETRG0 Position           */
S#define PWM_SWBRK_BRKETRG0_Msk           (0x1ul << PWM_SWBRK_BRKETRG0_Pos)                  /*!< PWM_T::SWBRK: BRKETRG0 Mask               */
S
S#define PWM_SWBRK_BRKETRG2_Pos           (1)                                                /*!< PWM_T::SWBRK: BRKETRG2 Position           */
S#define PWM_SWBRK_BRKETRG2_Msk           (0x1ul << PWM_SWBRK_BRKETRG2_Pos)                  /*!< PWM_T::SWBRK: BRKETRG2 Mask               */
S
S#define PWM_SWBRK_BRKETRG4_Pos           (2)                                                /*!< PWM_T::SWBRK: BRKETRG4 Position           */
S#define PWM_SWBRK_BRKETRG4_Msk           (0x1ul << PWM_SWBRK_BRKETRG4_Pos)                  /*!< PWM_T::SWBRK: BRKETRG4 Mask               */
S
S#define PWM_SWBRK_BRKLTRGn_Pos           (8)                                                /*!< PWM_T::SWBRK: BRKLTRGn Position           */
S#define PWM_SWBRK_BRKLTRGn_Msk           (0x7ul << PWM_SWBRK_BRKLTRGn_Pos)                  /*!< PWM_T::SWBRK: BRKLTRGn Mask               */
S
S#define PWM_SWBRK_BRKLTRG0_Pos           (8)                                                /*!< PWM_T::SWBRK: BRKLTRG0 Position           */
S#define PWM_SWBRK_BRKLTRG0_Msk           (0x1ul << PWM_SWBRK_BRKLTRG0_Pos)                  /*!< PWM_T::SWBRK: BRKLTRG0 Mask               */
S
S#define PWM_SWBRK_BRKLTRG2_Pos           (9)                                                /*!< PWM_T::SWBRK: BRKLTRG2 Position           */
S#define PWM_SWBRK_BRKLTRG2_Msk           (0x1ul << PWM_SWBRK_BRKLTRG2_Pos)                  /*!< PWM_T::SWBRK: BRKLTRG2 Mask               */
S
S#define PWM_SWBRK_BRKLTRG4_Pos           (10)                                               /*!< PWM_T::SWBRK: BRKLTRG4 Position           */
S#define PWM_SWBRK_BRKLTRG4_Msk           (0x1ul << PWM_SWBRK_BRKLTRG4_Pos)                  /*!< PWM_T::SWBRK: BRKLTRG4 Mask               */
S
S#define PWM_INTEN0_ZIENn_Pos             (0)                                                /*!< PWM_T::INTEN0: ZIENn Position             */
S#define PWM_INTEN0_ZIENn_Msk             (0x15ul << PWM_INTEN0_ZIENn_Pos)                   /*!< PWM_T::INTEN0: ZIENn Mask                 */
S
S#define PWM_INTEN0_ZIEN0_Pos             (0)                                                /*!< PWM_T::INTEN0: ZIEN0 Position             */
S#define PWM_INTEN0_ZIEN0_Msk             (0x1ul << PWM_INTEN0_ZIEN0_Pos)                    /*!< PWM_T::INTEN0: ZIEN0 Mask                 */
S
S#define PWM_INTEN0_ZIEN2_Pos             (2)                                                /*!< PWM_T::INTEN0: ZIEN2 Position             */
S#define PWM_INTEN0_ZIEN2_Msk             (0x1ul << PWM_INTEN0_ZIEN2_Pos)                    /*!< PWM_T::INTEN0: ZIEN2 Mask                 */
S
S#define PWM_INTEN0_ZIEN4_Pos             (4)                                                /*!< PWM_T::INTEN0: ZIEN4 Position             */
S#define PWM_INTEN0_ZIEN4_Msk             (0x1ul << PWM_INTEN0_ZIEN4_Pos)                    /*!< PWM_T::INTEN0: ZIEN4 Mask                 */
S
S#define PWM_INTEN0_PIENn_Pos             (8)                                                /*!< PWM_T::INTEN0: PIENn Position             */
S#define PWM_INTEN0_PIENn_Msk             (0x15ul << PWM_INTEN0_PIENn_Pos)                   /*!< PWM_T::INTEN0: PIENn Mask                 */
S
S#define PWM_INTEN0_PIEN0_Pos             (8)                                                /*!< PWM_T::INTEN0: PIEN0 Position             */
S#define PWM_INTEN0_PIEN0_Msk             (0x1ul << PWM_INTEN0_PIEN0_Pos)                    /*!< PWM_T::INTEN0: PIEN0 Mask                 */
S
S#define PWM_INTEN0_PIEN2_Pos             (10)                                               /*!< PWM_T::INTEN0: PIEN2 Position             */
S#define PWM_INTEN0_PIEN2_Msk             (0x1ul << PWM_INTEN0_PIEN2_Pos)                    /*!< PWM_T::INTEN0: PIEN2 Mask                 */
S
S#define PWM_INTEN0_PIEN4_Pos             (12)                                               /*!< PWM_T::INTEN0: PIEN4 Position             */
S#define PWM_INTEN0_PIEN4_Msk             (0x1ul << PWM_INTEN0_PIEN4_Pos)                    /*!< PWM_T::INTEN0: PIEN4 Mask                 */
S
S#define PWM_INTEN0_CMPUIENn_Pos          (16)                                               /*!< PWM_T::INTEN0: CMPUIENn Position          */
S#define PWM_INTEN0_CMPUIENn_Msk          (0x3ful << PWM_INTEN0_CMPUIENn_Pos)                /*!< PWM_T::INTEN0: CMPUIENn Mask              */
S
S#define PWM_INTEN0_CMPUIEN0_Pos          (16)                                               /*!< PWM_T::INTEN0: CMPUIEN0 Position          */
S#define PWM_INTEN0_CMPUIEN0_Msk          (0x1ul << PWM_INTEN0_CMPUIEN0_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN0 Mask              */
S
S#define PWM_INTEN0_CMPUIEN1_Pos          (17)                                               /*!< PWM_T::INTEN0: CMPUIEN1 Position          */
S#define PWM_INTEN0_CMPUIEN1_Msk          (0x1ul << PWM_INTEN0_CMPUIEN1_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN1 Mask              */
S
S#define PWM_INTEN0_CMPUIEN2_Pos          (18)                                               /*!< PWM_T::INTEN0: CMPUIEN2 Position          */
S#define PWM_INTEN0_CMPUIEN2_Msk          (0x1ul << PWM_INTEN0_CMPUIEN2_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN2 Mask              */
S
S#define PWM_INTEN0_CMPUIEN3_Pos          (19)                                               /*!< PWM_T::INTEN0: CMPUIEN3 Position          */
S#define PWM_INTEN0_CMPUIEN3_Msk          (0x1ul << PWM_INTEN0_CMPUIEN3_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN3 Mask              */
S
S#define PWM_INTEN0_CMPUIEN4_Pos          (20)                                               /*!< PWM_T::INTEN0: CMPUIEN4 Position          */
S#define PWM_INTEN0_CMPUIEN4_Msk          (0x1ul << PWM_INTEN0_CMPUIEN4_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN4 Mask              */
S
S#define PWM_INTEN0_CMPUIEN5_Pos          (21)                                               /*!< PWM_T::INTEN0: CMPUIEN5 Position          */
S#define PWM_INTEN0_CMPUIEN5_Msk          (0x1ul << PWM_INTEN0_CMPUIEN5_Pos)                 /*!< PWM_T::INTEN0: CMPUIEN5 Mask              */
S
S#define PWM_INTEN0_IFAIEN4_5_Pos         (23)                                               /*!< PWM_T::INTEN0: IFAIEN4_5 Position         */
S#define PWM_INTEN0_IFAIEN4_5_Msk         (0x1ul << PWM_INTEN0_IFAIEN4_5_Pos)                /*!< PWM_T::INTEN0: IFAIEN4_5 Mask             */
S
S#define PWM_INTEN0_CMPDIENn_Pos          (24)                                               /*!< PWM_T::INTEN0: CMPDIENn Position          */
S#define PWM_INTEN0_CMPDIENn_Msk          (0x3ful << PWM_INTEN0_CMPDIENn_Pos)                /*!< PWM_T::INTEN0: CMPDIENn Mask              */
S
S#define PWM_INTEN0_CMPDIEN0_Pos          (24)                                               /*!< PWM_T::INTEN0: CMPDIEN0 Position          */
S#define PWM_INTEN0_CMPDIEN0_Msk          (0x1ul << PWM_INTEN0_CMPDIEN0_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN0 Mask              */
S
S#define PWM_INTEN0_CMPDIEN1_Pos          (25)                                               /*!< PWM_T::INTEN0: CMPDIEN1 Position          */
S#define PWM_INTEN0_CMPDIEN1_Msk          (0x1ul << PWM_INTEN0_CMPDIEN1_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN1 Mask              */
S
S#define PWM_INTEN0_CMPDIEN2_Pos          (26)                                               /*!< PWM_T::INTEN0: CMPDIEN2 Position          */
S#define PWM_INTEN0_CMPDIEN2_Msk          (0x1ul << PWM_INTEN0_CMPDIEN2_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN2 Mask              */
S
S#define PWM_INTEN0_CMPDIEN3_Pos          (27)                                               /*!< PWM_T::INTEN0: CMPDIEN3 Position          */
S#define PWM_INTEN0_CMPDIEN3_Msk          (0x1ul << PWM_INTEN0_CMPDIEN3_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN3 Mask              */
S
S#define PWM_INTEN0_CMPDIEN4_Pos          (28)                                               /*!< PWM_T::INTEN0: CMPDIEN4 Position          */
S#define PWM_INTEN0_CMPDIEN4_Msk          (0x1ul << PWM_INTEN0_CMPDIEN4_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN4 Mask              */
S
S#define PWM_INTEN0_CMPDIEN5_Pos          (29)                                               /*!< PWM_T::INTEN0: CMPDIEN5 Position          */
S#define PWM_INTEN0_CMPDIEN5_Msk          (0x1ul << PWM_INTEN0_CMPDIEN5_Pos)                 /*!< PWM_T::INTEN0: CMPDIEN5 Mask              */
S
S#define PWM_INTEN1_BRKEIEN0_1_Pos        (0)                                                /*!< PWM_T::INTEN1: BRKEIEN0_1 Position        */
S#define PWM_INTEN1_BRKEIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKEIEN0_1_Pos)               /*!< PWM_T::INTEN1: BRKEIEN0_1 Mask            */
S
S#define PWM_INTEN1_BRKEIEN2_3_Pos        (1)                                                /*!< PWM_T::INTEN1: BRKEIEN2_3 Position        */
S#define PWM_INTEN1_BRKEIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKEIEN2_3_Pos)               /*!< PWM_T::INTEN1: BRKEIEN2_3 Mask            */
S
S#define PWM_INTEN1_BRKEIEN4_5_Pos        (2)                                                /*!< PWM_T::INTEN1: BRKEIEN4_5 Position        */
S#define PWM_INTEN1_BRKEIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKEIEN4_5_Pos)               /*!< PWM_T::INTEN1: BRKEIEN4_5 Mask            */
S
S#define PWM_INTEN1_BRKLIEN0_1_Pos        (8)                                                /*!< PWM_T::INTEN1: BRKLIEN0_1 Position        */
S#define PWM_INTEN1_BRKLIEN0_1_Msk        (0x1ul << PWM_INTEN1_BRKLIEN0_1_Pos)               /*!< PWM_T::INTEN1: BRKLIEN0_1 Mask            */
S
S#define PWM_INTEN1_BRKLIEN2_3_Pos        (9)                                                /*!< PWM_T::INTEN1: BRKLIEN2_3 Position        */
S#define PWM_INTEN1_BRKLIEN2_3_Msk        (0x1ul << PWM_INTEN1_BRKLIEN2_3_Pos)               /*!< PWM_T::INTEN1: BRKLIEN2_3 Mask            */
S
S#define PWM_INTEN1_BRKLIEN4_5_Pos        (10)                                               /*!< PWM_T::INTEN1: BRKLIEN4_5 Position        */
S#define PWM_INTEN1_BRKLIEN4_5_Msk        (0x1ul << PWM_INTEN1_BRKLIEN4_5_Pos)               /*!< PWM_T::INTEN1: BRKLIEN4_5 Mask            */
S
S#define PWM_INTSTS0_ZIFn_Pos             (0)                                                /*!< PWM_T::INTSTS0: ZIFn Position             */
S#define PWM_INTSTS0_ZIFn_Msk             (0x15ul << PWM_INTSTS0_ZIFn_Pos)                   /*!< PWM_T::INTSTS0: ZIFn Mask                 */
S
S#define PWM_INTSTS0_ZIF0_Pos             (0)                                                /*!< PWM_T::INTSTS0: ZIF0 Position             */
S#define PWM_INTSTS0_ZIF0_Msk             (0x1ul << PWM_INTSTS0_ZIF0_Pos)                    /*!< PWM_T::INTSTS0: ZIF0 Mask                 */
S
S#define PWM_INTSTS0_ZIF2_Pos             (2)                                                /*!< PWM_T::INTSTS0: ZIF2 Position             */
S#define PWM_INTSTS0_ZIF2_Msk             (0x1ul << PWM_INTSTS0_ZIF2_Pos)                    /*!< PWM_T::INTSTS0: ZIF2 Mask                 */
S
S#define PWM_INTSTS0_ZIF4_Pos             (4)                                                /*!< PWM_T::INTSTS0: ZIF4 Position             */
S#define PWM_INTSTS0_ZIF4_Msk             (0x1ul << PWM_INTSTS0_ZIF4_Pos)                    /*!< PWM_T::INTSTS0: ZIF4 Mask                 */
S
S#define PWM_INTSTS0_PIFn_Pos             (8)                                                /*!< PWM_T::INTSTS0: PIFn Position             */
S#define PWM_INTSTS0_PIFn_Msk             (0x15ul << PWM_INTSTS0_PIFn_Pos)                   /*!< PWM_T::INTSTS0: PIFn Mask                 */
S
S#define PWM_INTSTS0_PIF0_Pos             (8)                                                /*!< PWM_T::INTSTS0: PIF0 Position             */
S#define PWM_INTSTS0_PIF0_Msk             (0x1ul << PWM_INTSTS0_PIF0_Pos)                    /*!< PWM_T::INTSTS0: PIF0 Mask                 */
S
S#define PWM_INTSTS0_PIF2_Pos             (10)                                               /*!< PWM_T::INTSTS0: PIF2 Position             */
S#define PWM_INTSTS0_PIF2_Msk             (0x1ul << PWM_INTSTS0_PIF2_Pos)                    /*!< PWM_T::INTSTS0: PIF2 Mask                 */
S
S#define PWM_INTSTS0_PIF4_Pos             (12)                                               /*!< PWM_T::INTSTS0: PIF4 Position             */
S#define PWM_INTSTS0_PIF4_Msk             (0x1ul << PWM_INTSTS0_PIF4_Pos)                    /*!< PWM_T::INTSTS0: ZIF4 Mask                 */
S
S#define PWM_INTSTS0_CMPUIFn_Pos          (16)                                               /*!< PWM_T::INTSTS0: CMPUIFn Position          */
S#define PWM_INTSTS0_CMPUIFn_Msk          (0x3ful << PWM_INTSTS0_CMPUIFn_Pos)                /*!< PWM_T::INTSTS0: CMPUIFn Mask              */
S
S#define PWM_INTSTS0_CMPUIF0_Pos          (16)                                               /*!< PWM_T::INTSTS0: CMPUIF0 Position          */
S#define PWM_INTSTS0_CMPUIF0_Msk          (0x1ul << PWM_INTSTS0_CMPUIF0_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF0 Mask              */
S
S#define PWM_INTSTS0_CMPUIF1_Pos          (17)                                               /*!< PWM_T::INTSTS0: CMPUIF1 Position          */
S#define PWM_INTSTS0_CMPUIF1_Msk          (0x1ul << PWM_INTSTS0_CMPUIF1_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF1 Mask              */
S
S#define PWM_INTSTS0_CMPUIF2_Pos          (18)                                               /*!< PWM_T::INTSTS0: CMPUIF2 Position          */
S#define PWM_INTSTS0_CMPUIF2_Msk          (0x1ul << PWM_INTSTS0_CMPUIF2_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF2 Mask              */
S
S#define PWM_INTSTS0_CMPUIF3_Pos          (19)                                               /*!< PWM_T::INTSTS0: CMPUIF3 Position          */
S#define PWM_INTSTS0_CMPUIF3_Msk          (0x1ul << PWM_INTSTS0_CMPUIF3_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF3 Mask              */
S
S#define PWM_INTSTS0_CMPUIF4_Pos          (20)                                               /*!< PWM_T::INTSTS0: CMPUIF4 Position          */
S#define PWM_INTSTS0_CMPUIF4_Msk          (0x1ul << PWM_INTSTS0_CMPUIF4_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF4 Mask              */
S
S#define PWM_INTSTS0_CMPUIF5_Pos          (21)                                               /*!< PWM_T::INTSTS0: CMPUIF5 Position          */
S#define PWM_INTSTS0_CMPUIF5_Msk          (0x1ul << PWM_INTSTS0_CMPUIF5_Pos)                 /*!< PWM_T::INTSTS0: CMPUIF5 Mask              */
S
S#define PWM_INTSTS0_IFAIF4_5_Pos         (23)                                               /*!< PWM_T::INTSTS0: IFAIF4_5 Position         */
S#define PWM_INTSTS0_IFAIF4_5_Msk         (0x1ul << PWM_INTSTS0_IFAIF4_5_Pos)                /*!< PWM_T::INTSTS0: IFAIF4_5 Mask             */
S
S#define PWM_INTSTS0_CMPDIFn_Pos          (24)                                               /*!< PWM_T::INTSTS0: CMPDIFn Position          */
S#define PWM_INTSTS0_CMPDIFn_Msk          (0x3ful << PWM_INTSTS0_CMPDIFn_Pos)                /*!< PWM_T::INTSTS0: CMPDIFn Mask              */
S
S#define PWM_INTSTS0_CMPDIF0_Pos          (24)                                               /*!< PWM_T::INTSTS0: CMPDIF0 Position          */
S#define PWM_INTSTS0_CMPDIF0_Msk          (0x1ul << PWM_INTSTS0_CMPDIF0_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF0 Mask              */
S
S#define PWM_INTSTS0_CMPDIF1_Pos          (25)                                               /*!< PWM_T::INTSTS0: CMPDIF1 Position          */
S#define PWM_INTSTS0_CMPDIF1_Msk          (0x1ul << PWM_INTSTS0_CMPDIF1_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF1 Mask              */
S
S#define PWM_INTSTS0_CMPDIF2_Pos          (26)                                               /*!< PWM_T::INTSTS0: CMPDIF2 Position          */
S#define PWM_INTSTS0_CMPDIF2_Msk          (0x1ul << PWM_INTSTS0_CMPDIF2_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF2 Mask              */
S
S#define PWM_INTSTS0_CMPDIF3_Pos          (27)                                               /*!< PWM_T::INTSTS0: CMPDIF3 Position          */
S#define PWM_INTSTS0_CMPDIF3_Msk          (0x1ul << PWM_INTSTS0_CMPDIF3_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF3 Mask              */
S
S#define PWM_INTSTS0_CMPDIF4_Pos          (28)                                               /*!< PWM_T::INTSTS0: CMPDIF4 Position          */
S#define PWM_INTSTS0_CMPDIF4_Msk          (0x1ul << PWM_INTSTS0_CMPDIF4_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF4 Mask              */
S
S#define PWM_INTSTS0_CMPDIF5_Pos          (29)                                               /*!< PWM_T::INTSTS0: CMPDIF5 Position          */
S#define PWM_INTSTS0_CMPDIF5_Msk          (0x1ul << PWM_INTSTS0_CMPDIF5_Pos)                 /*!< PWM_T::INTSTS0: CMPDIF5 Mask              */
S
S#define PWM_INTSTS1_BRKEIFn_Pos          (0)                                                /*!< PWM_T::INTSTS1: BRKEIFn Position          */
S#define PWM_INTSTS1_BRKEIFn_Msk          (0x3ful << PWM_INTSTS1_BRKEIFn_Pos)                /*!< PWM_T::INTSTS1: BRKEIFn Mask              */
S
S#define PWM_INTSTS1_BRKEIF0_Pos          (0)                                                /*!< PWM_T::INTSTS1: BRKEIF0 Position          */
S#define PWM_INTSTS1_BRKEIF0_Msk          (0x1ul << PWM_INTSTS1_BRKEIF0_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF0 Mask              */
S
S#define PWM_INTSTS1_BRKEIF1_Pos          (1)                                                /*!< PWM_T::INTSTS1: BRKEIF1 Position          */
S#define PWM_INTSTS1_BRKEIF1_Msk          (0x1ul << PWM_INTSTS1_BRKEIF1_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF1 Mask              */
S
S#define PWM_INTSTS1_BRKEIF2_Pos          (2)                                                /*!< PWM_T::INTSTS1: BRKEIF2 Position          */
S#define PWM_INTSTS1_BRKEIF2_Msk          (0x1ul << PWM_INTSTS1_BRKEIF2_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF2 Mask              */
S
S#define PWM_INTSTS1_BRKEIF3_Pos          (3)                                                /*!< PWM_T::INTSTS1: BRKEIF3 Position          */
S#define PWM_INTSTS1_BRKEIF3_Msk          (0x1ul << PWM_INTSTS1_BRKEIF3_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF3 Mask              */
S
S#define PWM_INTSTS1_BRKEIF4_Pos          (4)                                                /*!< PWM_T::INTSTS1: BRKEIF4 Position          */
S#define PWM_INTSTS1_BRKEIF4_Msk          (0x1ul << PWM_INTSTS1_BRKEIF4_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF4 Mask              */
S
S#define PWM_INTSTS1_BRKEIF5_Pos          (5)                                                /*!< PWM_T::INTSTS1: BRKEIF5 Position          */
S#define PWM_INTSTS1_BRKEIF5_Msk          (0x1ul << PWM_INTSTS1_BRKEIF5_Pos)                 /*!< PWM_T::INTSTS1: BRKEIF5 Mask              */
S
S#define PWM_INTSTS1_BRKLIFn_Pos          (8)                                                /*!< PWM_T::INTSTS1: BRKLIFn Position          */
S#define PWM_INTSTS1_BRKLIFn_Msk          (0x3ful << PWM_INTSTS1_BRKLIFn_Pos)                /*!< PWM_T::INTSTS1: BRKLIFn Mask              */
S
S#define PWM_INTSTS1_BRKLIF0_Pos          (8)                                                /*!< PWM_T::INTSTS1: BRKLIF0 Position          */
S#define PWM_INTSTS1_BRKLIF0_Msk          (0x1ul << PWM_INTSTS1_BRKLIF0_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF0 Mask              */
S
S#define PWM_INTSTS1_BRKLIF1_Pos          (9)                                                /*!< PWM_T::INTSTS1: BRKLIF1 Position          */
S#define PWM_INTSTS1_BRKLIF1_Msk          (0x1ul << PWM_INTSTS1_BRKLIF1_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF1 Mask              */
S
S#define PWM_INTSTS1_BRKLIF2_Pos          (10)                                               /*!< PWM_T::INTSTS1: BRKLIF2 Position          */
S#define PWM_INTSTS1_BRKLIF2_Msk          (0x1ul << PWM_INTSTS1_BRKLIF2_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF2 Mask              */
S
S#define PWM_INTSTS1_BRKLIF3_Pos          (11)                                               /*!< PWM_T::INTSTS1: BRKLIF3 Position          */
S#define PWM_INTSTS1_BRKLIF3_Msk          (0x1ul << PWM_INTSTS1_BRKLIF3_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF3 Mask              */
S
S#define PWM_INTSTS1_BRKLIF4_Pos          (12)                                               /*!< PWM_T::INTSTS1: BRKLIF4 Position          */
S#define PWM_INTSTS1_BRKLIF4_Msk          (0x1ul << PWM_INTSTS1_BRKLIF4_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF4 Mask              */
S
S#define PWM_INTSTS1_BRKLIF5_Pos          (13)                                               /*!< PWM_T::INTSTS1: BRKLIF5 Position          */
S#define PWM_INTSTS1_BRKLIF5_Msk          (0x1ul << PWM_INTSTS1_BRKLIF5_Pos)                 /*!< PWM_T::INTSTS1: BRKLIF5 Mask              */
S
S#define PWM_INTSTS1_BRKESTS0_Pos         (16)                                               /*!< PWM_T::INTSTS1: BRKESTS0 Position         */
S#define PWM_INTSTS1_BRKESTS0_Msk         (0x1ul << PWM_INTSTS1_BRKESTS0_Pos)                /*!< PWM_T::INTSTS1: BRKESTS0 Mask             */
S
S#define PWM_INTSTS1_BRKESTS1_Pos         (17)                                               /*!< PWM_T::INTSTS1: BRKESTS1 Position         */
S#define PWM_INTSTS1_BRKESTS1_Msk         (0x1ul << PWM_INTSTS1_BRKESTS1_Pos)                /*!< PWM_T::INTSTS1: BRKESTS1 Mask             */
S
S#define PWM_INTSTS1_BRKESTS2_Pos         (18)                                               /*!< PWM_T::INTSTS1: BRKESTS2 Position         */
S#define PWM_INTSTS1_BRKESTS2_Msk         (0x1ul << PWM_INTSTS1_BRKESTS2_Pos)                /*!< PWM_T::INTSTS1: BRKESTS2 Mask             */
S
S#define PWM_INTSTS1_BRKESTS3_Pos         (19)                                               /*!< PWM_T::INTSTS1: BRKESTS3 Position         */
S#define PWM_INTSTS1_BRKESTS3_Msk         (0x1ul << PWM_INTSTS1_BRKESTS3_Pos)                /*!< PWM_T::INTSTS1: BRKESTS3 Mask             */
S
S#define PWM_INTSTS1_BRKESTS4_Pos         (20)                                               /*!< PWM_T::INTSTS1: BRKESTS4 Position         */
S#define PWM_INTSTS1_BRKESTS4_Msk         (0x1ul << PWM_INTSTS1_BRKESTS4_Pos)                /*!< PWM_T::INTSTS1: BRKESTS4 Mask             */
S
S#define PWM_INTSTS1_BRKESTS5_Pos         (21)                                               /*!< PWM_T::INTSTS1: BRKESTS5 Position         */
S#define PWM_INTSTS1_BRKESTS5_Msk         (0x1ul << PWM_INTSTS1_BRKESTS5_Pos)                /*!< PWM_T::INTSTS1: BRKESTS5 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS0_Pos         (24)                                               /*!< PWM_T::INTSTS1: BRKLSTS0 Position         */
S#define PWM_INTSTS1_BRKLSTS0_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS0_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS0 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS1_Pos         (25)                                               /*!< PWM_T::INTSTS1: BRKLSTS1 Position         */
S#define PWM_INTSTS1_BRKLSTS1_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS1_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS1 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS2_Pos         (26)                                               /*!< PWM_T::INTSTS1: BRKLSTS2 Position         */
S#define PWM_INTSTS1_BRKLSTS2_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS2_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS2 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS3_Pos         (27)                                               /*!< PWM_T::INTSTS1: BRKLSTS3 Position         */
S#define PWM_INTSTS1_BRKLSTS3_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS3_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS3 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS4_Pos         (28)                                               /*!< PWM_T::INTSTS1: BRKLSTS4 Position         */
S#define PWM_INTSTS1_BRKLSTS4_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS4_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS4 Mask             */
S
S#define PWM_INTSTS1_BRKLSTS5_Pos         (29)                                               /*!< PWM_T::INTSTS1: BRKLSTS5 Position         */
S#define PWM_INTSTS1_BRKLSTS5_Msk         (0x1ul << PWM_INTSTS1_BRKLSTS5_Pos)                /*!< PWM_T::INTSTS1: BRKLSTS5 Mask             */
S
S#define PWM_ADCTS0_TRGSEL0_Pos           (0)                                                /*!< PWM_T::ADCTS0: TRGSEL0 Position           */
S#define PWM_ADCTS0_TRGSEL0_Msk           (0xful << PWM_ADCTS0_TRGSEL0_Pos)                  /*!< PWM_T::ADCTS0: TRGSEL0 Mask               */
S
S#define PWM_ADCTS0_TRGEN0_Pos            (7)                                                /*!< PWM_T::ADCTS0: TRGEN0 Position            */
S#define PWM_ADCTS0_TRGEN0_Msk            (0x1ul << PWM_ADCTS0_TRGEN0_Pos)                   /*!< PWM_T::ADCTS0: TRGEN0 Mask                */
S
S#define PWM_ADCTS0_TRGSEL1_Pos           (8)                                                /*!< PWM_T::ADCTS0: TRGSEL1 Position           */
S#define PWM_ADCTS0_TRGSEL1_Msk           (0xful << PWM_ADCTS0_TRGSEL1_Pos)                  /*!< PWM_T::ADCTS0: TRGSEL1 Mask               */
S
S#define PWM_ADCTS0_TRGEN1_Pos            (15)                                               /*!< PWM_T::ADCTS0: TRGEN1 Position            */
S#define PWM_ADCTS0_TRGEN1_Msk            (0x1ul << PWM_ADCTS0_TRGEN1_Pos)                   /*!< PWM_T::ADCTS0: TRGEN1 Mask                */
S
S#define PWM_ADCTS0_TRGSEL2_Pos           (16)                                               /*!< PWM_T::ADCTS0: TRGSEL2 Position           */
S#define PWM_ADCTS0_TRGSEL2_Msk           (0xful << PWM_ADCTS0_TRGSEL2_Pos)                  /*!< PWM_T::ADCTS0: TRGSEL2 Mask               */
S
S#define PWM_ADCTS0_TRGEN2_Pos            (23)                                               /*!< PWM_T::ADCTS0: TRGEN2 Position            */
S#define PWM_ADCTS0_TRGEN2_Msk            (0x1ul << PWM_ADCTS0_TRGEN2_Pos)                   /*!< PWM_T::ADCTS0: TRGEN2 Mask                */
S
S#define PWM_ADCTS0_TRGSEL3_Pos           (24)                                               /*!< PWM_T::ADCTS0: TRGSEL3 Position           */
S#define PWM_ADCTS0_TRGSEL3_Msk           (0xful << PWM_ADCTS0_TRGSEL3_Pos)                  /*!< PWM_T::ADCTS0: TRGSEL3 Mask               */
S
S#define PWM_ADCTS0_TRGEN3_Pos            (31)                                               /*!< PWM_T::ADCTS0: TRGEN3 Position            */
S#define PWM_ADCTS0_TRGEN3_Msk            (0x1ul << PWM_ADCTS0_TRGEN3_Pos)                   /*!< PWM_T::ADCTS0: TRGEN3 Mask                */
S
S#define PWM_ADCTS1_TRGSEL4_Pos           (0)                                                /*!< PWM_T::ADCTS1: TRGSEL4 Position           */
S#define PWM_ADCTS1_TRGSEL4_Msk           (0xful << PWM_ADCTS1_TRGSEL4_Pos)                  /*!< PWM_T::ADCTS1: TRGSEL4 Mask               */
S
S#define PWM_ADCTS1_TRGEN4_Pos            (7)                                                /*!< PWM_T::ADCTS1: TRGEN4 Position            */
S#define PWM_ADCTS1_TRGEN4_Msk            (0x1ul << PWM_ADCTS1_TRGEN4_Pos)                   /*!< PWM_T::ADCTS1: TRGEN4 Mask                */
S
S#define PWM_ADCTS1_TRGSEL5_Pos           (8)                                                /*!< PWM_T::ADCTS1: TRGSEL5 Position           */
S#define PWM_ADCTS1_TRGSEL5_Msk           (0xful << PWM_ADCTS1_TRGSEL5_Pos)                  /*!< PWM_T::ADCTS1: TRGSEL5 Mask               */
S
S#define PWM_ADCTS1_TRGEN5_Pos            (15)                                               /*!< PWM_T::ADCTS1: TRGEN5 Position            */
S#define PWM_ADCTS1_TRGEN5_Msk            (0x1ul << PWM_ADCTS1_TRGEN5_Pos)                   /*!< PWM_T::ADCTS1: TRGEN5 Mask                */
S
S#define PWM_SSCTL_SSENn_Pos              (0)                                                /*!< PWM_T::SSCTL: SSENn Position              */
S#define PWM_SSCTL_SSENn_Msk              (0x15ul << PWM_SSCTL_SSENn_Pos)                    /*!< PWM_T::SSCTL: SSENn Mask                  */
S
S#define PWM_SSCTL_SSEN0_Pos              (0)                                                /*!< PWM_T::SSCTL: SSEN0 Position              */
S#define PWM_SSCTL_SSEN0_Msk              (0x1ul << PWM_SSCTL_SSEN0_Pos)                     /*!< PWM_T::SSCTL: SSEN0 Mask                  */
S
S#define PWM_SSCTL_SSEN2_Pos              (2)                                                /*!< PWM_T::SSCTL: SSEN2 Position              */
S#define PWM_SSCTL_SSEN2_Msk              (0x1ul << PWM_SSCTL_SSEN2_Pos)                     /*!< PWM_T::SSCTL: SSEN2 Mask                  */
S
S#define PWM_SSCTL_SSEN4_Pos              (4)                                                /*!< PWM_T::SSCTL: SSEN4 Position              */
S#define PWM_SSCTL_SSEN4_Msk              (0x1ul << PWM_SSCTL_SSEN4_Pos)                     /*!< PWM_T::SSCTL: SSEN4 Mask                  */
S
S#define PWM_SSCTL_SSRC_Pos               (8)                                                /*!< PWM_T::SSCTL: SSRC Position               */
S#define PWM_SSCTL_SSRC_Msk               (0x3ul << PWM_SSCTL_SSRC_Pos)                      /*!< PWM_T::SSCTL: SSRC Mask                   */
S
S#define PWM_SSTRG_CNTSEN_Pos             (0)                                                /*!< PWM_T::SSTRG: CNTSEN Position             */
S#define PWM_SSTRG_CNTSEN_Msk             (0x1ul << PWM_SSTRG_CNTSEN_Pos)                    /*!< PWM_T::SSTRG: CNTSEN Mask                 */
S
S#define PWM_STATUS_CNTMAXFn_Pos          (0)                                                /*!< PWM_T::STATUS: CNTMAXFn Position          */
S#define PWM_STATUS_CNTMAXFn_Msk          (0x15ul << PWM_STATUS_CNTMAXFn_Pos)                /*!< PWM_T::STATUS: CNTMAXFn Mask              */
S
S#define PWM_STATUS_CNTMAXF0_Pos          (0)                                                /*!< PWM_T::STATUS: CNTMAXF0 Position          */
S#define PWM_STATUS_CNTMAXF0_Msk          (0x1ul << PWM_STATUS_CNTMAXF0_Pos)                 /*!< PWM_T::STATUS: CNTMAXF0 Mask              */
S
S#define PWM_STATUS_CNTMAXF2_Pos          (2)                                                /*!< PWM_T::STATUS: CNTMAXF2 Position          */
S#define PWM_STATUS_CNTMAXF2_Msk          (0x1ul << PWM_STATUS_CNTMAXF2_Pos)                 /*!< PWM_T::STATUS: CNTMAXF2 Mask              */
S
S#define PWM_STATUS_CNTMAXF4_Pos          (4)                                                /*!< PWM_T::STATUS: CNTMAXF4 Position          */
S#define PWM_STATUS_CNTMAXF4_Msk          (0x1ul << PWM_STATUS_CNTMAXF4_Pos)                 /*!< PWM_T::STATUS: CNTMAXF4 Mask              */
S
S#define PWM_STATUS_ADCTRGFn_Pos          (16)                                               /*!< PWM_T::STATUS: ADCTRGFn Position          */
S#define PWM_STATUS_ADCTRGFn_Msk          (0x3ful << PWM_STATUS_ADCTRGFn_Pos)                /*!< PWM_T::STATUS: ADCTRGFn Mask              */
S
S#define PWM_STATUS_ADCTRGF0_Pos          (16)                                               /*!< PWM_T::STATUS: ADCTRGF0 Position          */
S#define PWM_STATUS_ADCTRGF0_Msk          (0x1ul << PWM_STATUS_ADCTRGF0_Pos)                 /*!< PWM_T::STATUS: ADCTRGF0 Mask              */
S
S#define PWM_STATUS_ADCTRGF1_Pos          (17)                                               /*!< PWM_T::STATUS: ADCTRGF1 Position          */
S#define PWM_STATUS_ADCTRGF1_Msk          (0x1ul << PWM_STATUS_ADCTRGF1_Pos)                 /*!< PWM_T::STATUS: ADCTRGF1 Mask              */
S
S#define PWM_STATUS_ADCTRGF2_Pos          (18)                                               /*!< PWM_T::STATUS: ADCTRGF2 Position          */
S#define PWM_STATUS_ADCTRGF2_Msk          (0x1ul << PWM_STATUS_ADCTRGF2_Pos)                 /*!< PWM_T::STATUS: ADCTRGF2 Mask              */
S
S#define PWM_STATUS_ADCTRGF3_Pos          (19)                                               /*!< PWM_T::STATUS: ADCTRGF3 Position          */
S#define PWM_STATUS_ADCTRGF3_Msk          (0x1ul << PWM_STATUS_ADCTRGF3_Pos)                 /*!< PWM_T::STATUS: ADCTRGF3 Mask              */
S
S#define PWM_STATUS_ADCTRGF4_Pos          (20)                                               /*!< PWM_T::STATUS: ADCTRGF4 Position          */
S#define PWM_STATUS_ADCTRGF4_Msk          (0x1ul << PWM_STATUS_ADCTRGF4_Pos)                 /*!< PWM_T::STATUS: ADCTRGF4 Mask              */
S
S#define PWM_STATUS_ADCTRGF5_Pos          (21)                                               /*!< PWM_T::STATUS: ADCTRGF5 Position          */
S#define PWM_STATUS_ADCTRGF5_Msk          (0x1ul << PWM_STATUS_ADCTRGF5_Pos)                 /*!< PWM_T::STATUS: ADCTRGF5 Mask              */
S
S#define PWM_CAPINEN_CAPINENn_Pos         (0)                                                /*!< PWM_T::CAPINEN: CAPINENn Position         */
S#define PWM_CAPINEN_CAPINENn_Msk         (0x3ful << PWM_CAPINEN_CAPINENn_Pos)               /*!< PWM_T::CAPINEN: CAPINENn Mask             */
S
S#define PWM_CAPINEN_CAPINEN0_Pos         (0)                                                /*!< PWM_T::CAPINEN: CAPINEN0 Position         */
S#define PWM_CAPINEN_CAPINEN0_Msk         (0x1ul << PWM_CAPINEN_CAPINEN0_Pos)                /*!< PWM_T::CAPINEN: CAPINEN0 Mask             */
S
S#define PWM_CAPINEN_CAPINEN1_Pos         (1)                                                /*!< PWM_T::CAPINEN: CAPINEN1 Position         */
S#define PWM_CAPINEN_CAPINEN1_Msk         (0x1ul << PWM_CAPINEN_CAPINEN1_Pos)                /*!< PWM_T::CAPINEN: CAPINEN1 Mask             */
S
S#define PWM_CAPINEN_CAPINEN2_Pos         (2)                                                /*!< PWM_T::CAPINEN: CAPINEN2 Position         */
S#define PWM_CAPINEN_CAPINEN2_Msk         (0x1ul << PWM_CAPINEN_CAPINEN2_Pos)                /*!< PWM_T::CAPINEN: CAPINEN2 Mask             */
S
S#define PWM_CAPINEN_CAPINEN3_Pos         (3)                                                /*!< PWM_T::CAPINEN: CAPINEN3 Position         */
S#define PWM_CAPINEN_CAPINEN3_Msk         (0x1ul << PWM_CAPINEN_CAPINEN3_Pos)                /*!< PWM_T::CAPINEN: CAPINEN3 Mask             */
S
S#define PWM_CAPINEN_CAPINEN4_Pos         (4)                                                /*!< PWM_T::CAPINEN: CAPINEN4 Position         */
S#define PWM_CAPINEN_CAPINEN4_Msk         (0x1ul << PWM_CAPINEN_CAPINEN4_Pos)                /*!< PWM_T::CAPINEN: CAPINEN4 Mask             */
S
S#define PWM_CAPINEN_CAPINEN5_Pos         (5)                                                /*!< PWM_T::CAPINEN: CAPINEN5 Position         */
S#define PWM_CAPINEN_CAPINEN5_Msk         (0x1ul << PWM_CAPINEN_CAPINEN5_Pos)                /*!< PWM_T::CAPINEN: CAPINEN5 Mask             */
S
S#define PWM_CAPCTL_CAPENn_Pos            (0)                                                /*!< PWM_T::CAPCTL: CAPENn Position            */
S#define PWM_CAPCTL_CAPENn_Msk            (0x3ful << PWM_CAPCTL_CAPENn_Pos)                  /*!< PWM_T::CAPCTL: CAPENn Mask                */
S
S#define PWM_CAPCTL_CAPEN0_Pos            (0)                                                /*!< PWM_T::CAPCTL: CAPEN0 Position            */
S#define PWM_CAPCTL_CAPEN0_Msk            (0x1ul << PWM_CAPCTL_CAPEN0_Pos)                   /*!< PWM_T::CAPCTL: CAPEN0 Mask                */
S
S#define PWM_CAPCTL_CAPEN1_Pos            (1)                                                /*!< PWM_T::CAPCTL: CAPEN1 Position            */
S#define PWM_CAPCTL_CAPEN1_Msk            (0x1ul << PWM_CAPCTL_CAPEN1_Pos)                   /*!< PWM_T::CAPCTL: CAPEN1 Mask                */
S
S#define PWM_CAPCTL_CAPEN2_Pos            (2)                                                /*!< PWM_T::CAPCTL: CAPEN2 Position            */
S#define PWM_CAPCTL_CAPEN2_Msk            (0x1ul << PWM_CAPCTL_CAPEN2_Pos)                   /*!< PWM_T::CAPCTL: CAPEN2 Mask                */
S
S#define PWM_CAPCTL_CAPEN3_Pos            (3)                                                /*!< PWM_T::CAPCTL: CAPEN3 Position            */
S#define PWM_CAPCTL_CAPEN3_Msk            (0x1ul << PWM_CAPCTL_CAPEN3_Pos)                   /*!< PWM_T::CAPCTL: CAPEN3 Mask                */
S
S#define PWM_CAPCTL_CAPEN4_Pos            (4)                                                /*!< PWM_T::CAPCTL: CAPEN4 Position            */
S#define PWM_CAPCTL_CAPEN4_Msk            (0x1ul << PWM_CAPCTL_CAPEN4_Pos)                   /*!< PWM_T::CAPCTL: CAPEN4 Mask                */
S
S#define PWM_CAPCTL_CAPEN5_Pos            (5)                                                /*!< PWM_T::CAPCTL: CAPEN5 Position            */
S#define PWM_CAPCTL_CAPEN5_Msk            (0x1ul << PWM_CAPCTL_CAPEN5_Pos)                   /*!< PWM_T::CAPCTL: CAPEN5 Mask                */
S
S#define PWM_CAPCTL_CAPINVn_Pos           (8)                                                /*!< PWM_T::CAPCTL: CAPINVn Position           */
S#define PWM_CAPCTL_CAPINVn_Msk           (0x3ful << PWM_CAPCTL_CAPINVn_Pos)                 /*!< PWM_T::CAPCTL: CAPINVn Mask               */
S
S#define PWM_CAPCTL_CAPINV0_Pos           (8)                                                /*!< PWM_T::CAPCTL: CAPINV0 Position           */
S#define PWM_CAPCTL_CAPINV0_Msk           (0x1ul << PWM_CAPCTL_CAPINV0_Pos)                  /*!< PWM_T::CAPCTL: CAPINV0 Mask               */
S
S#define PWM_CAPCTL_CAPINV1_Pos           (9)                                                /*!< PWM_T::CAPCTL: CAPINV1 Position           */
S#define PWM_CAPCTL_CAPINV1_Msk           (0x1ul << PWM_CAPCTL_CAPINV1_Pos)                  /*!< PWM_T::CAPCTL: CAPINV1 Mask               */
S
S#define PWM_CAPCTL_CAPINV2_Pos           (10)                                               /*!< PWM_T::CAPCTL: CAPINV2 Position           */
S#define PWM_CAPCTL_CAPINV2_Msk           (0x1ul << PWM_CAPCTL_CAPINV2_Pos)                  /*!< PWM_T::CAPCTL: CAPINV2 Mask               */
S
S#define PWM_CAPCTL_CAPINV3_Pos           (11)                                               /*!< PWM_T::CAPCTL: CAPINV3 Position           */
S#define PWM_CAPCTL_CAPINV3_Msk           (0x1ul << PWM_CAPCTL_CAPINV3_Pos)                  /*!< PWM_T::CAPCTL: CAPINV3 Mask               */
S
S#define PWM_CAPCTL_CAPINV4_Pos           (12)                                               /*!< PWM_T::CAPCTL: CAPINV4 Position           */
S#define PWM_CAPCTL_CAPINV4_Msk           (0x1ul << PWM_CAPCTL_CAPINV4_Pos)                  /*!< PWM_T::CAPCTL: CAPINV4 Mask               */
S
S#define PWM_CAPCTL_CAPINV5_Pos           (13)                                               /*!< PWM_T::CAPCTL: CAPINV5 Position           */
S#define PWM_CAPCTL_CAPINV5_Msk           (0x1ul << PWM_CAPCTL_CAPINV5_Pos)                  /*!< PWM_T::CAPCTL: CAPINV5 Mask               */
S
S#define PWM_CAPCTL_RCRLDENn_Pos          (16)                                               /*!< PWM_T::CAPCTL: RCRLDENn Position          */
S#define PWM_CAPCTL_RCRLDENn_Msk          (0x3ful << PWM_CAPCTL_RCRLDENn_Pos)                /*!< PWM_T::CAPCTL: RCRLDENn Mask              */
S
S#define PWM_CAPCTL_RCRLDEN0_Pos          (16)                                               /*!< PWM_T::CAPCTL: RCRLDEN0 Position          */
S#define PWM_CAPCTL_RCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN0_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN0 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN1_Pos          (17)                                               /*!< PWM_T::CAPCTL: RCRLDEN1 Position          */
S#define PWM_CAPCTL_RCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN1_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN1 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN2_Pos          (18)                                               /*!< PWM_T::CAPCTL: RCRLDEN2 Position          */
S#define PWM_CAPCTL_RCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN2_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN2 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN3_Pos          (19)                                               /*!< PWM_T::CAPCTL: RCRLDEN3 Position          */
S#define PWM_CAPCTL_RCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN3_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN3 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN4_Pos          (20)                                               /*!< PWM_T::CAPCTL: RCRLDEN4 Position          */
S#define PWM_CAPCTL_RCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN4_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN4 Mask              */
S
S#define PWM_CAPCTL_RCRLDEN5_Pos          (21)                                               /*!< PWM_T::CAPCTL: RCRLDEN5 Position          */
S#define PWM_CAPCTL_RCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_RCRLDEN5_Pos)                 /*!< PWM_T::CAPCTL: RCRLDEN5 Mask              */
S
S#define PWM_CAPCTL_FCRLDENn_Pos          (24)                                               /*!< PWM_T::CAPCTL: FCRLDENn Position          */
S#define PWM_CAPCTL_FCRLDENn_Msk          (0x3ful << PWM_CAPCTL_FCRLDENn_Pos)                /*!< PWM_T::CAPCTL: FCRLDENn Mask              */
S
S#define PWM_CAPCTL_FCRLDEN0_Pos          (24)                                               /*!< PWM_T::CAPCTL: FCRLDEN0 Position          */
S#define PWM_CAPCTL_FCRLDEN0_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN0_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN0 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN1_Pos          (25)                                               /*!< PWM_T::CAPCTL: FCRLDEN1 Position          */
S#define PWM_CAPCTL_FCRLDEN1_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN1_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN1 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN2_Pos          (26)                                               /*!< PWM_T::CAPCTL: FCRLDEN2 Position          */
S#define PWM_CAPCTL_FCRLDEN2_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN2_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN2 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN3_Pos          (27)                                               /*!< PWM_T::CAPCTL: FCRLDEN3 Position          */
S#define PWM_CAPCTL_FCRLDEN3_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN3_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN3 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN4_Pos          (28)                                               /*!< PWM_T::CAPCTL: FCRLDEN4 Position          */
S#define PWM_CAPCTL_FCRLDEN4_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN4_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN4 Mask              */
S
S#define PWM_CAPCTL_FCRLDEN5_Pos          (29)                                               /*!< PWM_T::CAPCTL: FCRLDEN5 Position          */
S#define PWM_CAPCTL_FCRLDEN5_Msk          (0x1ul << PWM_CAPCTL_FCRLDEN5_Pos)                 /*!< PWM_T::CAPCTL: FCRLDEN5 Mask              */
S
S#define PWM_CAPSTS_CRLIFOVn_Pos          (0)                                                /*!< PWM_T::CAPSTS: CRLIFOVn Position          */
S#define PWM_CAPSTS_CRLIFOVn_Msk          (0x3ful << PWM_CAPSTS_CRLIFOVn_Pos)                /*!< PWM_T::CAPSTS: CRLIFOVn Mask              */
S
S#define PWM_CAPSTS_CRLIFOV0_Pos          (0)                                                /*!< PWM_T::CAPSTS: CRLIFOV0 Position          */
S#define PWM_CAPSTS_CRLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV0_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV0 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV1_Pos          (1)                                                /*!< PWM_T::CAPSTS: CRLIFOV1 Position          */
S#define PWM_CAPSTS_CRLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV1_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV1 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV2_Pos          (2)                                                /*!< PWM_T::CAPSTS: CRLIFOV2 Position          */
S#define PWM_CAPSTS_CRLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV2_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV2 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV3_Pos          (3)                                                /*!< PWM_T::CAPSTS: CRLIFOV3 Position          */
S#define PWM_CAPSTS_CRLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV3_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV3 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV4_Pos          (4)                                                /*!< PWM_T::CAPSTS: CRLIFOV4 Position          */
S#define PWM_CAPSTS_CRLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV4_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV4 Mask              */
S
S#define PWM_CAPSTS_CRLIFOV5_Pos          (5)                                                /*!< PWM_T::CAPSTS: CRLIFOV5 Position          */
S#define PWM_CAPSTS_CRLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CRLIFOV5_Pos)                 /*!< PWM_T::CAPSTS: CRLIFOV5 Mask              */
S
S#define PWM_CAPSTS_CFLIFOVn_Pos          (8)                                                /*!< PWM_T::CAPSTS: CFLIFOVn Position          */
S#define PWM_CAPSTS_CFLIFOVn_Msk          (0x3ful << PWM_CAPSTS_CFLIFOVn_Pos)                /*!< PWM_T::CAPSTS: CFLIFOVn Mask              */
S
S#define PWM_CAPSTS_CFLIFOV0_Pos          (8)                                                /*!< PWM_T::CAPSTS: CFLIFOV0 Position          */
S#define PWM_CAPSTS_CFLIFOV0_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV0_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV0 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV1_Pos          (9)                                                /*!< PWM_T::CAPSTS: CFLIFOV1 Position          */
S#define PWM_CAPSTS_CFLIFOV1_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV1_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV1 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV2_Pos          (10)                                               /*!< PWM_T::CAPSTS: CFLIFOV2 Position          */
S#define PWM_CAPSTS_CFLIFOV2_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV2_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV2 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV3_Pos          (11)                                               /*!< PWM_T::CAPSTS: CFLIFOV3 Position          */
S#define PWM_CAPSTS_CFLIFOV3_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV3_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV3 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV4_Pos          (12)                                               /*!< PWM_T::CAPSTS: CFLIFOV4 Position          */
S#define PWM_CAPSTS_CFLIFOV4_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV4_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV4 Mask              */
S
S#define PWM_CAPSTS_CFLIFOV5_Pos          (13)                                               /*!< PWM_T::CAPSTS: CFLIFOV5 Position          */
S#define PWM_CAPSTS_CFLIFOV5_Msk          (0x1ul << PWM_CAPSTS_CFLIFOV5_Pos)                 /*!< PWM_T::CAPSTS: CFLIFOV5 Mask              */
S
S#define PWM_RCAPDAT0_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT0: RCAPDAT Position         */
S#define PWM_RCAPDAT0_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT0_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT0: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT0_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT0: FCAPDAT Position         */
S#define PWM_FCAPDAT0_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT0_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT0: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT1_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT1: RCAPDAT Position         */
S#define PWM_RCAPDAT1_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT1_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT1: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT1_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT1: FCAPDAT Position         */
S#define PWM_FCAPDAT1_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT1_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT1: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT2_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT2: RCAPDAT Position         */
S#define PWM_RCAPDAT2_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT2_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT2: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT2_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT2: FCAPDAT Position         */
S#define PWM_FCAPDAT2_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT2_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT2: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT3_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT3: RCAPDAT Position         */
S#define PWM_RCAPDAT3_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT3_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT3: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT3_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT3: FCAPDAT Position         */
S#define PWM_FCAPDAT3_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT3_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT3: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT4_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT4: RCAPDAT Position         */
S#define PWM_RCAPDAT4_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT4_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT4: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT4_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT4: FCAPDAT Position         */
S#define PWM_FCAPDAT4_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT4_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT4: FCAPDAT Mask             */
S
S#define PWM_RCAPDAT5_RCAPDAT_Pos         (0)                                                /*!< PWM_T::RCAPDAT5: RCAPDAT Position         */
S#define PWM_RCAPDAT5_RCAPDAT_Msk         (0xfffful << PWM_RCAPDAT5_RCAPDAT_Pos)             /*!< PWM_T::RCAPDAT5: RCAPDAT Mask             */
S
S#define PWM_FCAPDAT5_FCAPDAT_Pos         (0)                                                /*!< PWM_T::FCAPDAT5: FCAPDAT Position         */
S#define PWM_FCAPDAT5_FCAPDAT_Msk         (0xfffful << PWM_FCAPDAT5_FCAPDAT_Pos)             /*!< PWM_T::FCAPDAT5: FCAPDAT Mask             */
S
S#define PWM_CAPIEN_CAPRIENn_Pos          (0)                                                /*!< PWM_T::CAPIEN: CAPRIENn Position          */
S#define PWM_CAPIEN_CAPRIENn_Msk          (0x3ful << PWM_CAPIEN_CAPRIENn_Pos)                /*!< PWM_T::CAPIEN: CAPRIENn Mask              */
S
S#define PWM_CAPIEN_CAPRIEN0_Pos          (0)                                                /*!< PWM_T::CAPIEN: CAPRIEN0 Position          */
S#define PWM_CAPIEN_CAPRIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN0_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN0 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN1_Pos          (1)                                                /*!< PWM_T::CAPIEN: CAPRIEN1 Position          */
S#define PWM_CAPIEN_CAPRIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN1_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN1 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN2_Pos          (2)                                                /*!< PWM_T::CAPIEN: CAPRIEN2 Position          */
S#define PWM_CAPIEN_CAPRIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN2_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN2 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN3_Pos          (3)                                                /*!< PWM_T::CAPIEN: CAPRIEN3 Position          */
S#define PWM_CAPIEN_CAPRIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN3_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN3 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN4_Pos          (4)                                                /*!< PWM_T::CAPIEN: CAPRIEN4 Position          */
S#define PWM_CAPIEN_CAPRIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN4_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN4 Mask              */
S
S#define PWM_CAPIEN_CAPRIEN5_Pos          (5)                                                /*!< PWM_T::CAPIEN: CAPRIEN5 Position          */
S#define PWM_CAPIEN_CAPRIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPRIEN5_Pos)                 /*!< PWM_T::CAPIEN: CAPRIEN5 Mask              */
S
S#define PWM_CAPIEN_CAPFIENn_Pos          (8)                                                /*!< PWM_T::CAPIEN: CAPFIENn Position          */
S#define PWM_CAPIEN_CAPFIENn_Msk          (0x3ful << PWM_CAPIEN_CAPFIENn_Pos)                /*!< PWM_T::CAPIEN: CAPFIENn Mask              */
S
S#define PWM_CAPIEN_CAPFIEN0_Pos          (8)                                                /*!< PWM_T::CAPIEN: CAPFIEN0 Position          */
S#define PWM_CAPIEN_CAPFIEN0_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN0_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN0 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN1_Pos          (9)                                                /*!< PWM_T::CAPIEN: CAPFIEN1 Position          */
S#define PWM_CAPIEN_CAPFIEN1_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN1_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN1 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN2_Pos          (10)                                               /*!< PWM_T::CAPIEN: CAPFIEN2 Position          */
S#define PWM_CAPIEN_CAPFIEN2_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN2_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN2 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN3_Pos          (11)                                               /*!< PWM_T::CAPIEN: CAPFIEN3 Position          */
S#define PWM_CAPIEN_CAPFIEN3_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN3_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN3 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN4_Pos          (12)                                               /*!< PWM_T::CAPIEN: CAPFIEN4 Position          */
S#define PWM_CAPIEN_CAPFIEN4_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN4_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN4 Mask              */
S
S#define PWM_CAPIEN_CAPFIEN5_Pos          (13)                                               /*!< PWM_T::CAPIEN: CAPFIEN5 Position          */
S#define PWM_CAPIEN_CAPFIEN5_Msk          (0x1ul << PWM_CAPIEN_CAPFIEN5_Pos)                 /*!< PWM_T::CAPIEN: CAPFIEN5 Mask              */
S
S#define PWM_CAPIF_CRLIFn_Pos             (0)                                                /*!< PWM_T::CAPIF: CRLIFn Position             */
S#define PWM_CAPIF_CRLIFn_Msk             (0x3ful << PWM_CAPIF_CRLIFn_Pos)                   /*!< PWM_T::CAPIF: CRLIFn Mask                 */
S
S#define PWM_CAPIF_CRLIF0_Pos             (0)                                                /*!< PWM_T::CAPIF: CRLIF0 Position             */
S#define PWM_CAPIF_CRLIF0_Msk             (0x1ul << PWM_CAPIF_CRLIF0_Pos)                    /*!< PWM_T::CAPIF: CRLIF0 Mask                 */
S
S#define PWM_CAPIF_CRLIF1_Pos             (1)                                                /*!< PWM_T::CAPIF: CRLIF1 Position             */
S#define PWM_CAPIF_CRLIF1_Msk             (0x1ul << PWM_CAPIF_CRLIF1_Pos)                    /*!< PWM_T::CAPIF: CRLIF1 Mask                 */
S
S#define PWM_CAPIF_CRLIF2_Pos             (2)                                                /*!< PWM_T::CAPIF: CRLIF2 Position             */
S#define PWM_CAPIF_CRLIF2_Msk             (0x1ul << PWM_CAPIF_CRLIF2_Pos)                    /*!< PWM_T::CAPIF: CRLIF2 Mask                 */
S
S#define PWM_CAPIF_CRLIF3_Pos             (3)                                                /*!< PWM_T::CAPIF: CRLIF3 Position             */
S#define PWM_CAPIF_CRLIF3_Msk             (0x1ul << PWM_CAPIF_CRLIF3_Pos)                    /*!< PWM_T::CAPIF: CRLIF3 Mask                 */
S
S#define PWM_CAPIF_CRLIF4_Pos             (4)                                                /*!< PWM_T::CAPIF: CRLIF4 Position             */
S#define PWM_CAPIF_CRLIF4_Msk             (0x1ul << PWM_CAPIF_CRLIF4_Pos)                    /*!< PWM_T::CAPIF: CRLIF4 Mask                 */
S
S#define PWM_CAPIF_CRLIF5_Pos             (5)                                                /*!< PWM_T::CAPIF: CRLIF5 Position             */
S#define PWM_CAPIF_CRLIF5_Msk             (0x1ul << PWM_CAPIF_CRLIF5_Pos)                    /*!< PWM_T::CAPIF: CRLIF5 Mask                 */
S
S#define PWM_CAPIF_CFLIFn_Pos             (8)                                                /*!< PWM_T::CAPIF: CFLIFn Position             */
S#define PWM_CAPIF_CFLIFn_Msk             (0x3ful << PWM_CAPIF_CFLIFn_Pos)                   /*!< PWM_T::CAPIF: CFLIFn Mask                 */
S
S#define PWM_CAPIF_CFLIF0_Pos             (8)                                                /*!< PWM_T::CAPIF: CFLIF0 Position             */
S#define PWM_CAPIF_CFLIF0_Msk             (0x1ul << PWM_CAPIF_CFLIF0_Pos)                    /*!< PWM_T::CAPIF: CFLIF0 Mask                 */
S
S#define PWM_CAPIF_CFLIF1_Pos             (9)                                                /*!< PWM_T::CAPIF: CFLIF1 Position             */
S#define PWM_CAPIF_CFLIF1_Msk             (0x1ul << PWM_CAPIF_CFLIF1_Pos)                    /*!< PWM_T::CAPIF: CFLIF1 Mask                 */
S
S#define PWM_CAPIF_CFLIF2_Pos             (10)                                               /*!< PWM_T::CAPIF: CFLIF2 Position             */
S#define PWM_CAPIF_CFLIF2_Msk             (0x1ul << PWM_CAPIF_CFLIF2_Pos)                    /*!< PWM_T::CAPIF: CFLIF2 Mask                 */
S
S#define PWM_CAPIF_CFLIF3_Pos             (11)                                               /*!< PWM_T::CAPIF: CFLIF3 Position             */
S#define PWM_CAPIF_CFLIF3_Msk             (0x1ul << PWM_CAPIF_CFLIF3_Pos)                    /*!< PWM_T::CAPIF: CFLIF3 Mask                 */
S
S#define PWM_CAPIF_CFLIF4_Pos             (12)                                               /*!< PWM_T::CAPIF: CFLIF4 Position             */
S#define PWM_CAPIF_CFLIF4_Msk             (0x1ul << PWM_CAPIF_CFLIF4_Pos)                    /*!< PWM_T::CAPIF: CFLIF4 Mask                 */
S
S#define PWM_CAPIF_CFLIF5_Pos             (13)                                               /*!< PWM_T::CAPIF: CFLIF5 Position             */
S#define PWM_CAPIF_CFLIF5_Msk             (0x1ul << PWM_CAPIF_CFLIF5_Pos)                    /*!< PWM_T::CAPIF: CFLIF5 Mask                 */
S
S#define PWM_PBUF_PBUF_Pos                (0)                                                /*!< PWM_T::PBUF: PBUF Position                */
S#define PWM_PBUF_PBUF_Msk                (0xfffful << PWM_PBUF_PBUF_Pos)                    /*!< PWM_T::PBUF: PBUF Mask                    */
S
S#define PWM_CMPBUF_CMPBUF_Pos            (0)                                                /*!< PWM_T::CMPBUF: CMPBUF Position            */
S#define PWM_CMPBUF_CMPBUF_Msk            (0xfffful << PWM_CMPBUF_CMPBUF_Pos)                /*!< PWM_T::CMPBUF: CMPBUF Mask                */
S
S/*@}*/ /* end of group PWM_CONST */
S/*@}*/ /* end of group PWM */
S
S
S
S/*---------------------- Serial Peripheral Interface Controller -------------------------*/
S/**
S    @addtogroup SPI Serial Peripheral Interface Controller (SPI)
S    Memory Mapped Structure for SPI Controller
S@{ */
Stypedef struct
S{
S    /**
S     * SPI_CNTRL
S     * ===================================================================================================
S     * Offset: 0x00  Control and Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GO_BUSY   |SPI Transfer Control Bit And Busy Status
S     * |        |          |0 = Data transfer stopped.
S     * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode,
S     * |        |          |    writing 1 to this bit indicates that the slave is ready to communicate with a master.
S     * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.
S     * |        |          |As the transfer is finished, this bit will be cleared automatically.
S     * |        |          |Software can read this bit to check if the SPI is in busy status.
S     * |        |          |In FIFO mode, this bit will be controlled by hardware.
S     * |        |          |Software should not modify this bit.
S     * |        |          |In Slave mode, this bit always returns 1 when this register is read by software.
S     * |        |          |In Master mode, this bit reflects the busy or idle status of SPI.
S     * |        |          |Note:
S     * |        |          |1. When FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY bit.
S     * |        |          |2. When FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data, this bit
S     * |        |          |   will be cleared after the PDMA finishes the data transfer.
S     * |[1]     |RX_NEG    |Receive On Negative Edge
S     * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
S     * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
S     * |[2]     |TX_NEG    |Transmit On Negative Edge
S     * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
S     * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
S     * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
S     * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
S     * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
S     * |        |          |TX_BIT_LEN = 0x08 ... 8 bits.
S     * |        |          |TX_BIT_LEN = 0x09 ... 9 bits.
S     * |        |          |......
S     * |        |          |TX_BIT_LEN = 0x1F ... 31 bits.
S     * |        |          |TX_BIT_LEN = 0x00 ... 32 bits.
S     * |[10]    |LSB       |Send LSB First
S     * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is transmitted/received first.
S     * |        |          |1 = The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the first bit received from
S     * |        |          |    the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
S     * |[11]    |CLKP      |Clock Polarity
S     * |        |          |0 = SPI bus clock is idle low.
S     * |        |          |1 = SPI bus clock is idle high.
S     * |[15:12] |SP_CYCLE  |Suspend Interval (Master Only)
S     * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive transaction in a transfer.
S     * |        |          |The definition of the suspend interval is the interval between the last clock edge of the preceding transaction word
S     * |        |          |and the first clock edge of the following transaction word.
S     * |        |          |The default value is 0x3.
S     * |        |          |The period of the suspend interval is obtained according to the following equation.
S     * |        |          |(SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle
S     * |        |          |Example:
S     * |        |          |SP_CYCLE = 0x0 ... 0.5 SPI bus clock cycle.
S     * |        |          |SP_CYCLE = 0x1 ... 1.5 SPI bus clock cycle.
S     * |        |          |......
S     * |        |          |SP_CYCLE = 0xE ... 14.5 SPI bus clock cycle.
S     * |        |          |SP_CYCLE = 0xF ... 15.5 SPI bus clock cycle.
S     * |        |          |If the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum period of suspend
S     * |        |          |interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.
S     * |[16]    |IF        |Unit Transfer Interrupt Flag
S     * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
S     * |        |          |1 = SPI controller has finished one unit transfer.
S     * |        |          |Note: This bit will be cleared by writing 1 to itself.
S     * |[17]    |IE        |Unit Transfer Interrupt Enable
S     * |        |          |0 = SPI unit transfer interrupt Disabled.
S     * |        |          |1 = SPI unit transfer interrupt Enabled.
S     * |[18]    |SLAVE     |Slave Mode Enable
S     * |        |          |0 = Master mode.
S     * |        |          |1 = Slave mode.
S     * |[19]    |REORDER   |Byte Reorder Function Enable
S     * |        |          |0 = Byte Reorder function Disabled.
S     * |        |          |1 = Byte Reorder function Enabled.
S     * |        |          |A byte suspend interval will be inserted among each byte.
S     * |        |          |The period of the byte suspend interval depends on the setting of SP_CYCLE.
S     * |        |          |Note:
S     * |        |          |1. Byte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
S     * |        |          |2. In Slave mode with level-trigger configuration, the slave select pin must be kept at active state during the
S     * |        |          |   byte suspend interval.
S     * |        |          |3. The Byte Reorder function is not supported when the variable bus clock function or Dual I/O mode is enabled.
S     * |[21]    |FIFO      |FIFO Mode Enable
S     * |        |          |0 = FIFO mode Disabled.
S     * |        |          |1 = FIFO mode Enabled.
S     * |        |          |Note:
S     * |        |          |1. Before enabling FIFO mode, the other related settings should be set in advance.
S     * |        |          |2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically after writing data
S     * |        |          |   to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI controller is in idle.
S     * |        |          |   If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and the GO_BUSY bit will be cleared to 0.
S     * |        |          |3. After clearing this bit to 0, user must wait for at least 2 peripheral clock periods before setting this bit to 1 again.
S     * |[23]    |VARCLK_EN |Variable Clock Enable (Master Only)
S     * |        |          |0 = SPI clock output frequency is fixed and decided only by the value of DIVIDER.
S     * |        |          |1 = SPI clock output frequency is variable.
S     * |        |          |The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
S     * |        |          |Note: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10 (16-bit mode).
S     * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |It is a mutual mirror bit of SPI_STATUS[24].
S     * |        |          |0 = Receive FIFO buffer is not empty.
S     * |        |          |1 = Receive FIFO buffer is empty.
S     * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only)
S     * |        |          |It is a mutual mirror bit of SPI_STATUS[25].
S     * |        |          |0 = Receive FIFO buffer is not full.
S     * |        |          |1 = Receive FIFO buffer is full.
S     * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |It is a mutual mirror bit of SPI_STATUS[26].
S     * |        |          |0 = Transmit FIFO buffer is not empty.
S     * |        |          |1 = Transmit FIFO buffer is empty.
S     * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
S     * |        |          |It is a mutual mirror bit of SPI_STATUS[27].
S     * |        |          |0 = Transmit FIFO buffer is not full.
S     * |        |          |1 = Transmit FIFO buffer is full.
S     */
S    __IO uint32_t CNTRL;
S
S    /**
S     * SPI_DIVIDER
S     * ===================================================================================================
S     * Offset: 0x04  Clock Divider Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |DIVIDER   |Clock Divider 1 Register
S     * |        |          |The value in this field is the frequency divider for generating the SPI peripheral clock and the SPI bus clock of SPI master.
S     * |        |          |The frequency is obtained according to the following equation.
S     * |        |          |If the bit of BCn, SPI_CNTRL2[31], is set to 0,
S     * |        |          |   SPI peripheral clock frequency = SPI peripheral clock source frequency / (DIVIDER + 1) / 2
S     * |        |          |else if BCn is set to 1,
S     * |        |          |   SPI peripheral clock frequency = SPI peripheral clock source frequency / (DIVIDER + 1)
S     * |        |          |The SPI peripheral clock source is defined in the CLKSEL1 register.
S     * |[23:16] |DIVIDER2  |Clock Divider 2 Register (Master Only)
S     * |        |          |The value in this field is the 2nd frequency divider for generating the second clock of the variable clock function.
S     * |        |          |The frequency is obtained according to the following equation:
S     * |        |          |   f_clk2 = SPI peripheral clock frequency / (DIVIDER2 + 1) / 2
S     * |        |          |If the VARCLK_EN bit is cleared to 0, this setting is unmeaning.
S     */
S    __IO uint32_t DIVIDER;
S
S    /**
S     * SPI_SSR
S     * ===================================================================================================
S     * Offset: 0x08  Slave Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |SSR       |Slave Select Control Bits (Master Only)
S     * |        |          |If AUTOSS bit is cleared, writing 1 to any bit of this field sets the SPI0_SS
S     * |        |          |line to an active state and writing 0 sets the line back to inactive state.
S     * |        |          |If the AUTOSS bit is set, writing 0 to any bit location of this field will keep the
S     * |        |          |SPI0_SS line at inactive state; writing 1 to this field will select
S     * |        |          |SPI0_SS line to be automatically driven to active state for the duration of the
S     * |        |          |transmit/receive, and will be driven to inactive state for the rest of the time.
S     * |        |          |The active state of SPI0_SS is specified in SS_LVL.
S     * |[2]     |SS_LVL    |Slave Select Active Level
S     * |        |          |This bit defines the active status of slave select signal (SPI0_SS).
S     * |        |          |0 = The slave select signal SPI0_SS is active on low-level/falling-edge.
S     * |        |          |1 = The slave select signal SPI0_SS is active on high-level/rising-edge.
S     * |[3]     |AUTOSS    |Automatic Slave Select Function Enable (Master Only)
S     * |        |          |0 = If this bit is cleared, slave select signals will be asserted/de-asserted by setting /clearing
S     * |        |          |    SPI_SSR[0].
S     * |        |          |1 = If this bit is set, SPI0_SS signals will be generated automatically.
S     * |        |          |    It means that slave select signal, which is set in SPI_SSR[0], will be asserted by the
S     * |        |          |    SPI controller when transmit/receive is started, and will be de-asserted after each transmit/receive is finished.
S     * |[4]     |SS_LTRIG  |Slave Select Level Trigger Enable (Slave Only)
S     * |        |          |0 = Slave select signal is edge-trigger.
S     * |        |          |    This is the default value.
S     * |        |          |    The SS_LVL bit decides the signal is active after a falling-edge or rising-edge.
S     * |        |          |1 = Slave select signal is level-trigger.
S     * |        |          |    The SS_LVL bit decides the signal is active low or active high.
S     * |[5]     |LTRIG_FLAG|Level Trigger Accomplish Flag
S     * |        |          |In Slave mode, this bit indicates whether the received bit number meets the requirement or not after the current transaction done.
S     * |        |          |0 = Transferred bit length of one transaction does not meet the specified requirement.
S     * |        |          |1 = Transferred bit length meets the specified requirement which defined in TX_BIT_LEN.
S     * |        |          |Note: This bit is READ only.
S     * |        |          |As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI peripheral clock periods plus 1 system clock period.
S     * |        |          |In FIFO mode, this bit has no meaning.
S     */
S    __IO uint32_t SSR;
S
S    __I  uint32_t RESERVE0;
S
S    /**
S     * SPI_RX
S     * ===================================================================================================
S     * Offset: 0x10  Data Receive Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |RX        |Data Receive Register
S     * |        |          |The data receive register holds the datum received from SPI data input pin.
S     * |        |          |If FIFO mode is disabled, the last received data can be accessed through software by reading this register.
S     * |        |          |If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to 1, the receive
S     * |        |          |FIFO buffer can be accessed through software by reading this register. This is a read-only register.
S     */
S    __I  uint32_t RX;
S
S    __I  uint32_t RESERVE1;
S    __I  uint32_t RESERVE2;
S    __I  uint32_t RESERVE3;
S
S    /**
S     * SPI_TX
S     * ===================================================================================================
S     * Offset: 0x20  Data Transmit Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |TX        |Data Transmit Register
S     * |        |          |The data transmit registers hold the data to be transmitted in the next transfer.
S     * |        |          |The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL register.
S     * |        |          |For example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next transfer.
S     * |        |          |If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.
S     * |        |          |Note 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if the SPI
S     * |        |          |        controller attempts to transmit data to a master, the transmit data register should be updated
S     * |        |          |        by software before setting the GO_BUSY bit to 1.
S     * |        |          |Note 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles after user writes to this register.
S     */
S    __O  uint32_t TX;
S
S    __I  uint32_t RESERVE4;
S    __I  uint32_t RESERVE5;
S    __I  uint32_t RESERVE6;
S    __I  uint32_t RESERVE7;
S
S    /**
S     * SPI_VARCLK
S     * ===================================================================================================
S     * Offset: 0x34  Variable Clock Pattern Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |VARCLK    |Variable Clock Pattern
S     * |        |          |This register defines the clock pattern of the SPI transfer.
S     * |        |          |If the variable clock function is disabled, this setting is unmeaning.
S     */
S    __IO uint32_t VARCLK;
S
S    __I  uint32_t RESERVE8;
S
S    /**
S     * SPI_CNTRL2
S     * ===================================================================================================
S     * Offset: 0x3C  Control and Status Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8]     |NOSLVSEL  |Slave 3-Wire Mode Enable
S     * |        |          |This is used to ignore the slave select signal in Slave mode.
S     * |        |          |The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.
S     * |        |          |0 = 4-wire bi-direction interface.
S     * |        |          |1 = 3-wire bi-direction interface.
S     * |        |          |Note: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.
S     * |[9]     |SLV_ABORT |Slave 3-Wire Mode Abort Control
S     * |        |          |In normal operation, there is an interrupt event when the received data meet the required bits which defined in TX_BIT_LEN.
S     * |        |          |If the received bits are less than the requirement and there is no more SPI clock input over the one transfer time in
S     * |        |          |Slave 3-wire mode, the user can set this bit to force the current transfer done and then the user can get a transfer done interrupt event.
S     * |        |          |Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.
S     * |[10]    |SSTA_INTEN|Slave 3-Wire Mode Start Interrupt Enable
S     * |        |          |Used to enable interrupt when the transfer has started in Slave 3-wire mode.
S     * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the transfer start,
S     * |        |          |the user can set the SLV_ABORT bit to force the transfer done.
S     * |        |          |0 = Transaction start interrupt Disabled.
S     * |        |          |1 = Transaction start interrupt Enabled.
S     * |        |          |It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared.
S     * |[11]    |SLV_START_INTSTS|Slave 3-Wire Mode Start Interrupt Status
S     * |        |          |This bit indicates if a transaction has started in Slave 3-wire mode.
S     * |        |          |It is a mutual mirror bit of SPI_STATUS[11].
S     * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
S     * |        |          |1 = A transaction has started in Slave 3-wire mode.
S     * |        |          |It will be cleared automatically when a transaction is done or by writing 1 to this bit.
S     * |[12]    |DUAL_IO_DIR|Dual I/O Mode Direction Control
S     * |        |          |0 = Dual Input mode.
S     * |        |          |1 = Dual Output mode.
S     * |[13]    |DUAL_IO_EN|Dual I/O Mode Enable
S     * |        |          |0 = Dual I/O mode Disabled.
S     * |        |          |1 = Dual I/O mode Enabled.
S     * |[16]    |SS_INT_OPT|Slave Select Inactive Interrupt Option
S     * |        |          |This setting is only available if the SPI controller is configured as level trigger slave device.
S     * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
S     * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
S     * |[31]    |BCn       |SPI Peripheral Clock Backward Compatible Option
S     * |        |          |0 = Backward compatible clock configuration.
S     * |        |          |1 = Clock configuration is not backward compatible.
S     * |        |          |Refer to the description of SPI_DIVIDER register for details.
S     */
S    __IO uint32_t CNTRL2;
S
S    /**
S     * SPI_FIFO_CTL
S     * ===================================================================================================
S     * Offset: 0x40  SPI FIFO Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RX_CLR    |Clear Receive FIFO Buffer
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear receive FIFO buffer.
S     * |        |          |The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1.
S     * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
S     * |[1]     |TX_CLR    |Clear Transmit FIFO Buffer
S     * |        |          |0 = No effect.
S     * |        |          |1 = Clear transmit FIFO buffer.
S     * |        |          |The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1.
S     * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
S     * |[2]     |RX_INTEN  |Receive Threshold Interrupt Enable
S     * |        |          |0 = RX threshold interrupt Disabled.
S     * |        |          |1 = RX threshold interrupt Enabled.
S     * |[3]     |TX_INTEN  |Transmit Threshold Interrupt Enable
S     * |        |          |0 = TX threshold interrupt Disabled.
S     * |        |          |1 = TX threshold interrupt Enabled.
S     * |[6]     |RXOV_INTEN|Receive FIFO Overrun Interrupt Enable
S     * |        |          |0 = Receive FIFO overrun interrupt Disabled.
S     * |        |          |1 = Receive FIFO overrun interrupt Enabled.
S     * |[21]    |TIMEOUT_INTEN|Receive FIFO Time-Out Interrupt Enable
S     * |        |          |0 = Time-out interrupt Disabled.
S     * |        |          |1 = Time-out interrupt Enabled.
S     * |[26:24] |RX_THRESHOLD|Receive FIFO Threshold
S     * |        |          |If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting,
S     * |        |          |the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
S     * |[30:28] |TX_THRESHOLD|Transmit FIFO Threshold
S     * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD
S     * |        |          |setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
S     */
S    __IO uint32_t FIFO_CTL;
S
S    /**
S     * SPI_STATUS
S     * ===================================================================================================
S     * Offset: 0x44  SPI Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RX_INTSTS |Receive FIFO Threshold Interrupt Status (Read Only)
S     * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value of RX_THRESHOLD.
S     * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of RX_THRESHOLD.
S     * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
S     * |[2]     |RX_OVERRUN|Receive FIFO Overrun Status
S     * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be set to 1.
S     * |        |          |Note: This bit will be cleared by writing 1 to itself.
S     * |[4]     |TX_INTSTS |Transmit FIFO Threshold Interrupt Status (Read Only)
S     * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of TX_THRESHOLD.
S     * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting value of TX_THRESHOLD.
S     * |        |          |Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt request.
S     * |[11]    |SLV_START_INTSTS|Slave Start Interrupt Status
S     * |        |          |It is used to dedicate if a transaction has started in Slave 3-wire mode.
S     * |        |          |It is a mutual mirror bit of SPI_CNTRL2[11].
S     * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
S     * |        |          |1 = A transaction has started in Slave 3-wire mode.
S     * |        |          |It will be cleared as a transaction is done or by writing 1 to this bit.
S     * |[15:12] |RX_FIFO_COUNT|Receive FIFO Data Count (Read Only)
S     * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
S     * |[16]    |IF        |SPI Unit Transfer Interrupt Flag
S     * |        |          |It is a mutual mirror bit of SPI_CNTRL[16].
S     * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
S     * |        |          |1 = SPI controller has finished one unit transfer.
S     * |        |          |Note: This bit will be cleared by writing 1 to itself.
S     * |[20]    |TIMEOUT   |Time-Out Interrupt Flag
S     * |        |          |0 = No receive FIFO time-out event.
S     * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI clock
S     * |        |          |period in Master mode or over 576 SPI peripheral clock period in Slave mode.
S     * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared automatically.
S     * |        |          |Note: This bit will be cleared by writing 1 to itself.
S     * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |It is a mutual mirror bit of SPI_CNTRL[24].
S     * |        |          |0 = Receive FIFO buffer is not empty.
S     * |        |          |1 = Receive FIFO buffer is empty.
S     * |[25]    |RX_FULL   |Receive FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |It is a mutual mirror bit of SPI_CNTRL[25].
S     * |        |          |0 = Receive FIFO buffer is not empty.
S     * |        |          |1 = Receive FIFO buffer is empty.
S     * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
S     * |        |          |It is a mutual mirror bit of SPI_CNTRL[26].
S     * |        |          |0 = Transmit FIFO buffer is not empty.
S     * |        |          |1 = Transmit FIFO buffer is empty.
S     * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
S     * |        |          |It is a mutual mirror bit of SPI_CNTRL[27].
S     * |        |          |0 = Transmit FIFO buffer is not full.
S     * |        |          |1 = Transmit FIFO buffer is full.
S     * |[31:28] |TX_FIFO_COUNT|Transmit FIFO Data Count (Read Only)
S     * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
S     */
S    __IO uint32_t STATUS;
S} SPI_T;
S
S/**
S    @addtogroup SPI_CONST SPI Bit Field Definition
S    Constant Definitions for SPI Controller
S@{ */
S
S
S/* SPI_CNTRL Bit Field Definitions */
S#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI_T::CNTRL: TX_FULL Position */
S#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI_T::CNTRL: TX_FULL Mask     */
S
S#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI_T::CNTRL: TX_EMPTY Position */
S#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI_T::CNTRL: TX_EMPTY Mask     */
S
S#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI_T::CNTRL: RX_FULL Position */
S#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI_T::CNTRL: RX_FULL Mask     */
S
S#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI_T::CNTRL: RX_EMPTY Position */
S#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI_T::CNTRL: RX_EMPTY Mask     */
S
S#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI_T::CNTRL: VARCLK_EN Position */
S#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI_T::CNTRL: VARCLK_EN Mask     */
S
S#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI_T::CNTRL: FIFO Position */
S#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI_T::CNTRL: FIFO Mask     */
S
S#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI_T::CNTRL: REORDER Position */
S#define SPI_CNTRL_REORDER_Msk      (1ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI_T::CNTRL: REORDER Mask     */
S
S#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI_T::CNTRL: SLAVE Position */
S#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI_T::CNTRL: SLAVE Mask     */
S
S#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI_T::CNTRL: IE Position */
S#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI_T::CNTRL: IE Mask     */
S
S#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI_T::CNTRL: IF Position */
S#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI_T::CNTRL: IF Mask     */
S
S#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI_T::CNTRL: SP_CYCLE Position */
S#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI_T::CNTRL: SP_CYCLE Mask     */
S
S#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI_T::CNTRL: CLKP Position */
S#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI_T::CNTRL: CLKP Mask     */
S
S#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI_T::CNTRL: LSB Position */
S#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI_T::CNTRL: LSB Mask     */
S
S#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI_T::CNTRL: TX_BIT_LEN Position */
S#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI_T::CNTRL: TX_BIT_LEN Mask     */
S
S#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI_T::CNTRL: TX_NEG Position */
S#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI_T::CNTRL: TX_NEG Mask     */
S
S#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI_T::CNTRL: RX_NEG Position */
S#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI_T::CNTRL: RX_NEG Mask     */
S
S#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI_T::CNTRL: GO_BUSY Position */
S#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI_T::CNTRL: GO_BUSY Mask     */
S
S/* SPI_DIVIDER Bit Field Definitions */
S#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI_T::DIVIDER: DIVIDER2 Position */
S#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI_T::DIVIDER: DIVIDER2 Mask */
S
S#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI_T::DIVIDER: DIVIDER Position */
S#define SPI_DIVIDER_DIVIDER_Msk    (0xFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI_T::DIVIDER: DIVIDER Mask */
S
S/* SPI_SSR Bit Field Definitions */
S#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI_T::SSR: LTRIG_FLAG Position */
S#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI_T::SSR: LTRIG_FLAG Mask */
S
S#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI_T::SSR: SS_LTRIG Position */
S#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI_T::SSR: SS_LTRIG Mask */
S
S#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI_T::SSR: AUTOSS Position */
S#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI_T::SSR: AUTOSS Mask */
S
S#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI_T::SSR: SS_LVL Position */
S#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI_T::SSR: SS_LVL Mask */
S
S#define SPI_SSR_SSR_Pos            0                                 /*!< SPI_T::SSR: SSR Position */
S#define SPI_SSR_SSR_Msk            (1ul << SPI_SSR_SSR_Pos)          /*!< SPI_T::SSR: SSR Mask */
S
S/* SPI_CNTRL2 Bit Field Definitions */
S#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI_T::CNTRL2: BCn Position */
S#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI_T::CNTRL2: BCn Mask */
S
S#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI_T::CNTRL2: SS_INT_OPT Position */
S#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI_T::CNTRL2: SS_INT_OPT Mask */
S
S#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI_T::CNTRL2: DUAL_IO_EN Position */
S#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI_T::CNTRL2: DUAL_IO_EN Mask */
S
S#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI_T::CNTRL2: DUAL_IO_DIR Position */
S#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI_T::CNTRL2: DUAL_IO_DIR Mask */
S
S#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::CNTRL2: SLV_START_INTSTS Position */
S#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI_T::CNTRL2: SLV_START_INTSTS Mask */
S
S#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI_T::CNTRL2: SSTA_INTEN Position */
S#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI_T::CNTRL2: SSTA_INTEN Mask */
S
S#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI_T::CNTRL2: SLV_ABORT Position */
S#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI_T::CNTRL2: SLV_ABORT Mask */
S
S#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI_T::CNTRL2: NOSLVSEL Position */
S#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI_T::CNTRL2: NOSLVSEL Mask */
S
S/* SPI_FIFO_CTL Bit Field Definitions */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Position */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Position */
S#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Position */
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Mask */
S
S#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI_T::FIFO_CTL: RXOV_INTEN Position */
S#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI_T::FIFO_CTL: RXOV_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI_T::FIFO_CTL: TX_INTEN Position */
S#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: TX_INTEN Mask */
S
S#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI_T::FIFO_CTL: RX_INTEN Position */
S#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: RX_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI_T::FIFO_CTL: TX_CLR Position */
S#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI_T::FIFO_CTL: TX_CLR Mask */
S
S#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI_T::FIFO_CTL: RX_CLR Position */
S#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI_T::FIFO_CTL: RX_CLR Mask */
S
S/* SPI_STATUS Bit Field Definitions */
S#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI_T::STATUS: TX_FIFO_COUNT Position */
S#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: TX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI_T::STATUS: TX_FULL Position */
S#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI_T::STATUS: TX_FULL Mask */
S
S#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI_T::STATUS: TX_EMPTY Position */
S#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI_T::STATUS: TX_EMPTY Mask */
S
S#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI_T::STATUS: RX_FULL Position */
S#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI_T::STATUS: RX_FULL Mask */
S
S#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI_T::STATUS: RX_EMPTY Position */
S#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI_T::STATUS: RX_EMPTY Mask */
S
S#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI_T::STATUS: TIMEOUT Position */
S#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI_T::STATUS: TIMEOUT Mask */
S
S#define SPI_STATUS_IF_Pos   16                                                       /*!< SPI_T::STATUS: IF Position */
S#define SPI_STATUS_IF_Msk   (1ul << SPI_STATUS_IF_Pos)                               /*!< SPI_T::STATUS: IF Mask     */
S
S#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI_T::STATUS: RX_FIFO_COUNT Position */
S#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: RX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::STATUS: SLV_START_INTSTS Position */
S#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI_T::STATUS: SLV_START_INTSTS Mask */
S
S#define SPI_STATUS_TX_INTSTS_Pos   4                                                 /*!< SPI_T::STATUS: TX_INTSTS Position */
S#define SPI_STATUS_TX_INTSTS_Msk   (1ul << SPI_STATUS_TX_INTSTS_Pos)                 /*!< SPI_T::STATUS: TX_INTSTS Mask */
S
S#define SPI_STATUS_RX_OVERRUN_Pos   2                                                /*!< SPI_T::STATUS: RX_OVERRUN Position */
S#define SPI_STATUS_RX_OVERRUN_Msk   (1ul << SPI_STATUS_RX_OVERRUN_Pos)               /*!< SPI_T::STATUS: RX_OVERRUN Mask */
S
S#define SPI_STATUS_RX_INTSTS_Pos   0                                                 /*!< SPI_T::STATUS: RX_INTSTS Position */
S#define SPI_STATUS_RX_INTSTS_Msk   (1ul << SPI_STATUS_RX_INTSTS_Pos)                 /*!< SPI_T::STATUS: RX_INTSTS Mask */
S/*@}*/ /* end of group SPI_CONST */
S/*@}*/ /* end of group SPI */
S
S
S
S
S/*---------------------- System Manger Controller -------------------------*/
S/**
S    @addtogroup SYS System Manger Controller (SYS)
S    Memory Mapped Structure for SYS Controller
S@{ */
Stypedef struct
S{
S
S    /**
S     * PDID
S     * ===================================================================================================
S     * Offset: 0x00  Part Device Identification Number Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |PDID      |Part Device Identification Number
S     * |        |          |This register reflects device part number code.
S     * |        |          |Software can read this register to identify which device is used.
S     */
S    __I uint32_t PDID;
S
S    /**
S     * RSTSRC
S     * ===================================================================================================
S     * Offset: 0x04  System Reset Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RSTS_POR  |Power-on Reset Flag
S     * |        |          |The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) controller or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.
S     * |        |          |0 = No reset from POR or CHIP_RST (IPRSTC1[0]).
S     * |        |          |1 = Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the system.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[1]     |RSTS_RESET|Reset Pin Reset Flag
S     * |        |          |The RSTS_RESET flag is set by the "Reset Signal" from the /RESET pin to indicate the previous reset source.
S     * |        |          |0 = No reset from /RESET pin.
S     * |        |          |1 = The Pin /RESET had issued the reset signal to reset the system.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[2]     |RSTS_WDT  |Watchdog Reset Flag
S     * |        |          |The RSTS_WDT flag is set by The "Reset Signal" from the Watchdog Timer to indicate the previous reset source
S     * |        |          |0 = No reset from watchdog timer.
S     * |        |          |1 = The watchdog timer had issued the reset signal to reset the system.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[3]     |RSTS_LVR  |Low Voltage Reset Flag
S     * |        |          |The RSTS_LVR flag Is Set By The "Reset Signal" From The Low-Voltage-Reset Controller To Indicate The Previous Reset Source
S     * |        |          |0 = No reset from LVR.
S     * |        |          |1 = The LVR controller had issued the reset signal to reset the system.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[4]     |RSTS_BOD  |Brown-out Detector Reset Flag
S     * |        |          |The RSTS_BOD flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the previous reset source.
S     * |        |          |0 = No reset from BOD.
S     * |        |          |1 = The BOD had issued the reset signal to reset the system.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[5]     |RSTS_SYS  |SYS Reset Flag
S     * |        |          |The RSTS_SYS flag is set by the "Reset Signal" from the Cortex-M0 kernel to indicate the previous reset source.
S     * |        |          |0 = No reset from Cortex-M0.
S     * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex-M0 kernel.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[7]     |RSTS_CPU  |CPU Reset Flag
S     * |        |          |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and flash. Memory Controller (FMC)
S     * |        |          |0 = No reset from CPU.
S     * |        |          |1 = Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     */
S    __IO uint32_t RSTSRC;
S
S    /**
S     * IPRSTC1
S     * ===================================================================================================
S     * Offset: 0x08  IP Reset Control Register 1
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |CHIP_RST  |CHIP One-Shot Reset (Write Protect)
S     * |        |          |Setting this bit will reset the whole chip, including CPU kernel and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
S     * |        |          |The CHIP_RST is the same as the POR reset, all the chip controllers are reset and the chip setting from flash are also reload.
S     * |        |          |0 = CHIP normal operation.
S     * |        |          |1 = CHIP one-shot reset.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[1]     |CPU_RST   |CPU Kernel One-Shot Reset (Write Protect)
S     * |        |          |Setting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit will automatically return 0 after the two clock cycles
S     * |        |          |0 = CPU normal operation.
S     * |        |          |1 = CPU one-shot reset.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     */
S    __IO uint32_t IPRSTC1;
S
S    /**
S     * IPRSTC2
S     * ===================================================================================================
S     * Offset: 0x0C  IP Reset Control Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |GPIO_RST  |GPIO Controller Reset
S     * |        |          |0 = GPIO controller normal operation.
S     * |        |          |1 = GPIO controller reset.
S     * |[2]     |TMR0_RST  |Timer0 Controller Reset
S     * |        |          |0 = Timer0 controller normal operation.
S     * |        |          |1 = Timer0 controller reset.
S     * |[3]     |TMR1_RST  |Timer1 Controller Reset
S     * |        |          |0 = Timer1 controller normal operation.
S     * |        |          |1 = Timer1 controller reset.
S     * |[4]     |TMR2_RST  |Timer2 Controller Reset
S     * |        |          |0 = Timer2 controller normal operation.
S     * |        |          |1 = Timer2 controller reset.
S     * |[5]     |TMR3_RST  |Timer3 Controller Reset
S     * |        |          |0 = Timer3 controller normal operation.
S     * |        |          |1 = Timer3 controller reset.
S     * |[8]     |I2C0_RST  |I2C0 Controller Reset
S     * |        |          |0 = I2C0 controller normal operation.
S     * |        |          |1 = I2C0 controller reset.
S     * |[9]     |I2C1_RST  |I2C1 Controller Reset
S     * |        |          |0 = I2C1 controller normal operation.
S     * |        |          |1 = I2C1 controller reset.
S     * |[12]    |SPI0_RST  |SPI0 Controller Reset
S     * |        |          |0 = SPI0 controller normal operation.
S     * |        |          |1 = SPI0 controller reset.
S     * |[16]    |UART0_RST |UART0 Controller Reset
S     * |        |          |0 = UART0 controller normal operation.
S     * |        |          |1 = UART0 controller reset.
S     * |[17]    |UART1_RST |UART1 Controller Reset
S     * |        |          |0 = UART1 controller normal operation.
S     * |        |          |1 = UART1 controller reset.
S     * |[18]    |UART2_RST |UART2 Controller Reset
S     * |        |          |0 = UART2 controller normal operation.
S     * |        |          |1 = UART2 controller reset.
S     * |[24]    |CAN0_RST  |CAN0 Controller Reset
S     * |        |          |0 = CAN0 controller normal operation.
S     * |        |          |1 = CAN0 controller reset.     
S     * |[28]    |ADC_RST   |ADC Controller Reset
S     * |        |          |0 = ADC controller normal operation.
S     * |        |          |1 = ADC controller reset.
S     */
S    __IO uint32_t IPRSTC2;
S
S    /**
S     * IPRSTC3
S     * ===================================================================================================
S     * Offset: 0x10  Peripheral Reset Control Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[8]     |UART3_RST |UART3 Controller Reset
S     * |        |          |0 = UART3 controller normal operation.
S     * |        |          |1 = UART3 controller reset.
S     * |[9]     |UART4_RST |UART4 Controller Reset
S     * |        |          |0 = UART4 controller normal operation.
S     * |        |          |1 = UART4 controller reset.
S     * |[10]    |UART5_RST |UART5 Controller Reset
S     * |        |          |0 = UART5 controller normal operation.
S     * |        |          |1 = UART5 controller reset.
S     * |[16]    |PWM0_RST  |PWM0 Controller Reset
S     * |        |          |0 = PWM0 controller normal operation.
S     * |        |          |1 = PWM0 controller reset.
S     * |[17]    |PWM1_RST  |PWM1 Controller Reset
S     * |        |          |0 = PWM1 controller normal operation.
S     * |        |          |1 = PWM1 controller reset.
S     * |[18]    |BPWM0_RST |BPWM0 Controller Reset
S     * |        |          |0 = BPWM0 controller normal operation.
S     * |        |          |1 = BPWM0 controller reset.
S     * |[19]    |BPWM1_RST |BPWM1 Controller Reset
S     * |        |          |0 = BPWM1 controller normal operation.
S     * |        |          |1 = BPWM1 controller reset.
S     */
S    __IO uint32_t IPRSTC3;
S
S    uint32_t RESERVE0;
S
S    /**
S     * BODCR
S     * ===================================================================================================
S     * Offset: 0x18  Brown-out Detector Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |BOD_EN    |Brown-Out Detector Enable Bit (Write Protect)
S     * |        |          |The default value is set by flash memory controller user configuration register CBODEN (CONFIG0[23]) bit.
S     * |        |          |0 = Brown-out Detector function Disabled.
S     * |        |          |1 = Brown-out Detector function Enabled.
S     * |        |          |Note: This bit is the protected bit.
S     * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[2:1]   |BOD_VL    |Brown-Out Detector Threshold Voltage Selection (Write Protect)
S     * |        |          |The default value is set by flash memory controller user configuration register CBOV (CONFIG0[22:21]) bit.
S     * |        |          |00 = Brown-out voltage is 2.2V.
S     * |        |          |01 = Brown-out voltage is 2.7V.
S     * |        |          |10 = Brown-out voltage is 3.7V.
S     * |        |          |11 = Brown-out voltage is 4.4V.
S     * |        |          |Note: This bit is the protected bit.
S     * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[3]     |BOD_RSTEN |Brown-Out Reset Enable Bit (Write Protect)
S     * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
S     * |        |          |1 = Brown-out "RESET" function Enabled.
S     * |        |          |While the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BOD_OUT high).
S     * |        |          |Note1: While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high.
S     * |        |          |BOD interrupt will keep till to the BOD_EN set to 0.
S     * |        |          |BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).
S     * |        |          |Note2: The default value is set by flash controller user configuration register CBORST (CONFIG0[20]) bit.
S     * |        |          |Note3: This bit is the protected bit.
S     * |        |          |It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[4]     |BOD_INTF  |Brown-Out Detector Interrupt Flag
S     * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting.
S     * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the Brown-out interrupt is requested if Brown-out interrupt is enabled.
S     * |        |          |Note: Write 1 to clear this bit to 0.
S     * |[5]     |BOD_LPM   |Brown-Out Detector Low Power Mode (Write Protect)
S     * |        |          |0 = BOD operated in Normal mode (default).
S     * |        |          |1 = BOD Low Power mode Enabled.
S     * |        |          |Note1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the current to about 1/10 but slow the BOD response.
S     * |        |          |Note2: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[6]     |BOD_OUT   |Brown-Out Detector Output Status
S     * |        |          |0 = Brown-out Detector output status is 0.
S     * |        |          |It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0.
S     * |        |          |1 = Brown-out Detector output status is 1.
S     * |        |          |It means the detected voltage is lower than BOD_VL setting.
S     * |        |          |If the BOD_EN is 0, BOD function disabled, this bit always responds to 0.
S     * |[7]     |LVR_EN    |Low Voltage Reset Enable Bit (Write Protect)
S     * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting.
S     * |        |          |LVR function is enabled by default.
S     * |        |          |0 = Low Voltage Reset function Disabled.
S     * |        |          |1 = Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active with 100us delay for LVR output stable (default).
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[10:8]  |BODDGSEL  |Brown-Out Detector Output De-Glitch Time Select (Write Protect)
S     * |        |          |000 = BOD output is sampled by RC10K clock.
S     * |        |          |001 = 4 system clock (HCLK).
S     * |        |          |010 = 8 system clock (HCLK).
S     * |        |          |011 = 16 system clock (HCLK).
S     * |        |          |100 = 32 system clock (HCLK).
S     * |        |          |101 = 64 system clock (HCLK).
S     * |        |          |110 = 128 system clock (HCLK).
S     * |        |          |111 = 256 system clock (HCLK).
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     * |[14:12] |LVRDGSEL  |LVR Output De-Glitch Time Select (Write Protect)
S     * |        |          |000 = Without de-glitch function.
S     * |        |          |001 = 4 system clock (HCLK).
S     * |        |          |010 = 8 system clock (HCLK).
S     * |        |          |011 = 16 system clock (HCLK).
S     * |        |          |100 = 32 system clock (HCLK).
S     * |        |          |101 = 64 system clock (HCLK).
S     * |        |          |110 = 128 system clock (HCLK).
S     * |        |          |111 = 256 system clock (HCLK).
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     */
S    __IO uint32_t BODCR;
S
S    uint32_t RESERVE1[2];
S
S    /**
S     * PORCR
S     * ===================================================================================================
S     * Offset: 0x24  Power-on-Reset Controller Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |POR_DIS_CODE|Power-On-Reset Enable Control (Write Protect)
S     * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again.
S     * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
S     * |        |          |The POR function will be active again when this field is set to another value or chip is reset by other reset source, including:
S     * |        |          |/RESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function
S     * |        |          |Note: This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.
S     */
S    __IO uint32_t PORCR;
S
S    /**
S     * VREFCR
S     * ===================================================================================================
S     * Offset: 0x28  VREF Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |ADC_VREFSEL|ADC VREF Path Control (Write Protect)
S     * |        |          |0 = ADC VREF is from VREF pin.
S     * |        |          |1 = ADC VREF is from AVDD.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection. Refer to the register REGWRPROT at address GCR_BA+0x100.
S     */
S    __IO uint32_t VREFCR;
S
S    uint32_t RESERVE2[1];
S
S    /**
S     * GPA_MFP
S     * ===================================================================================================
S     * Offset: 0x30  GPIOA Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GPA_MFP0  |PA.0 Pin Function Selection
S     * |        |          |Bits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.
S     * |        |          |(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = ADC0 function is selected.
S     * |        |          |(0, 0, 1, 1) = I2C1_SCL function is selected.
S     * |        |          |(0, 1, 0, 1) = UART5_TXD function is selected.
S     * |        |          |(1, 0, 0, 1) = PWM0_CH4 function is selected.
S     * |[1]     |GPA_MFP1  |PA.1 Pin Function Selection
S     * |        |          |Bits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.
S     * |        |          |(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
S     * |        |          |(0, 0, 1, 1) = I2C1_SDA function is selected.
S     * |        |          |(0, 1, 0, 1) = UART5_RXD function is selected.
S     * |        |          |(1, 0, 0, 1) = PWM0_CH5 function is selected.
S     * |[2]     |GPA_MFP2  |PA.2 Pin Function Selection
S     * |        |          |Bits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.
S     * |        |          |(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = ADC2 function is selected.
S     * |        |          |(0, 1, 1) = UART3_TXD function is selected.
S     * |        |          |(1, 0, 1) = PWM1_CH0 function is selected.
S     * |[3]     |GPA_MFP3  |PA.3 Pin Function Selection
S     * |        |          |Bits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.
S     * |        |          |(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = ADC3 function is selected.
S     * |        |          |(0, 1, 1) = UART3_RXD function is selected.
S     * |        |          |(1, 0, 1) = PWM1_CH1 function is selected.
S     * |[4]     |GPA_MFP4  |PA.4 Pin Function Selection
S     * |        |          |Bit GPA_MFP4 determines the PA.4 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = ADC4 function is selected.
S     * |[5]     |GPA_MFP5  |PA.5 Pin Function Selection
S     * |        |          |Bits PA5_UR3RXD (ALT_MFP4[4]) and GPA_MFP5 determine the PA.5 function.
S     * |        |          |(PA5_UR3RXD, GPA_MFP5) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = ADC5 function is selected.
S     * |        |          |(1, 1) = UART3_RXD function is selected.
S     * |[6]     |GPA_MFP6  |PA.6 Pin Function Selection
S     * |        |          |Bits PA6_UR3TXD (ALT_MFP4[5]) and GPA_MFP6 determine the PA.6 function.
S     * |        |          |(PA6_UR3TXD, GPA_MFP6) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = ADC6 function is selected.
S     * |        |          |(1, 1) = UART3_TXD function is selected.
S     * |[7]     |GPA_MFP7  |PA.7 Pin Function Selection
S     * |        |          |Bits PA7_VREF (ALT_MFP4[14]) and GPA_MFP7 determine the PA.7 function.
S     * |        |          |(PA7_VREF, GPA_MFP7) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = ADC7 function is selected.
S     * |        |          |(1, 1) = Vref function is selected.
S     * |[8]     |GPA_MFP8  |PA.8 Pin Function Selection
S     * |        |          |Bits PA8_UR1RTS (ALT_MFP4[0]) and GPA_MFP8 determine the PA.8 function.
S     * |        |          |(PA8_UR1RTS, GPA_MFP8) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C0_SDA function is selected.
S     * |        |          |(1, 1) = UART1_nRTS function is selected.
S     * |[9]     |GPA_MFP9  |PA.9 Pin Function Selection
S     * |        |          |Bits PA9_UR1CTS (ALT_MFP4[1]) and GPA_MFP9 determine the PA.9 function.
S     * |        |          |(PA9_UR1CTS, GPA_MFP9) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C0_SCL function is selected.
S     * |        |          |(1, 1) = UART1_nCTS function is selected.
S     * |[10]    |GPA_MFP10 |PA.10 Pin Function Selection
S     * |        |          |Bits PA10_PWM12 (ALT_MFP3[8]) and GPA_MFP10 determine the PA.10 function.
S     * |        |          |(PA10_PWM12, GPA_MFP10) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C1_SDA function is selected.
S     * |        |          |(1, 1) = PWM1_CH2 function is selected.
S     * |[11]    |GPA_MFP11 |PA.11 Pin Function Selection
S     * |        |          |Bits PA11_PWM13 (ALT_MFP3[9]) and GPA_MFP11 determine the PA.11 function.
S     * |        |          |(PA11_PWM13, GPA_MFP11) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C1_SCL function is selected.
S     * |        |          |(1, 1) = PWM1_CH3 function is selected.
S     * |[12]    |GPA_MFP12 |PA.12 Pin Function Selection
S     * |        |          |Bits PA12_UR5RXD (ALT_MFP4[8]) and GPA_MFP12 determine the PA.12 function.
S     * |        |          |(PA12_UR5RXD, GPA_MFP12) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = PWM0_CH0 function is selected.
S     * |        |          |(1, 1) = UART5_RXD function is selected.
S     * |[13]    |GPA_MFP13 |PA.13 Pin Function Selection
S     * |        |          |Bits PA13_UR5TXD (ALT_MFP4[9]) and GPA_MFP13 determine the PA.13 function.
S     * |        |          |(PA13_UR5TXD, GPA_MFP13) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = PWM0_CH1 function is selected.
S     * |        |          |(1, 1) = UART5_TXD function is selected.
S     * |[14]    |GPA_MFP14 |PA.14 Pin Function Selection
S     * |        |          |Bit GPA_MFP14 determines the PA.14 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = PWM0_CH2 function is selected.
S     * |[15]    |GPA_MFP15 |PA.15 Pin Function Selection
S     * |        |          |Bit GPA_MFP15 determines the PA.15 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = PWM0_CH3 function is selected.
S     * |[31:16] |GPA_TYPEn |Trigger Function Selection
S     * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger function Disabled.
S     * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger function Enabled.
S     */
S    __IO uint32_t GPA_MFP;
S
S    /**
S     * GPB_MFP
S     * ===================================================================================================
S     * Offset: 0x34  GPIOB Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GPB_MFP0  |PB.0 Pin Function Selection
S     * |        |          |Bit GPB_MFP0 determines the PB.0 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = UART0_RXD function is selected.
S     * |[1]     |GPB_MFP1  |PB.1 Pin Function Selection
S     * |        |          |Bit GPB_MFP1 determines the PB.1 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = UART0_TXD function is selected.
S     * |[2]     |GPB_MFP2  |PB.2 Pin Function Selection
S     * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.
S     * |        |          |(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
S     * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
S     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE1 function is selected.
S     * |        |          |(1, 0, 0, 1) = TM2 function is selected.
S     * |[3]     |GPB_MFP3  |PB.3 Pin Function Selection
S     * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.
S     * |        |          |(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
S     * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
S     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE0 function is selected.
S     * |        |          |(1, 0, 0, 1) = TM3 function is selected.
S     * |[4]     |GPB_MFP4  |PB.4 Pin Function Selection
S     * |        |          |Bit GPB_MFP4 determines the PB.4 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = UART1_RXD function is selected.
S     * |[5]     |GPB_MFP5  |PB 5 Pin Function Selection
S     * |        |          |Bit GPB_MFP5 determines the PB.5 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = UART1_TXD function is selected.
S     * |[6]     |GPB_MFP6  |PB.6 Pin Function Selection
S     * |        |          |Bit GPB_MFP6 determines the PB.6 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = UART1_nRTS function is selected.
S     * |[7]     |GPB_MFP7  |PB.7 Pin Function Selection
S     * |        |          |Bit GPB_MFP7 determines the PB.7 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = UART1_nCTS function is selected.
S     * |[8]     |GPB_MFP8  |PB.8 Pin Function Selection
S     * |        |          |Bits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.
S     * |        |          |(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = TM0 function is selected.
S     * |        |          |(0, 1, 1) = CLKO function is selected.
S     * |        |          |(1, 0, 1) = BPWM1_CH2 function is selected.
S     * |[9]     |GPB_MFP9  |PB.9 Pin Function Selection
S     * |        |          |Bit GPB_MFP9 determines the PB.9 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = TM1 function is selected.
S     * |[10]    |GPB_MFP10 |PB.10 Pin Function Selection
S     * |        |          |Bit GPB_MFP10 determines the PB.10 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = TM2 function is selected.
S     * |[11]    |GPB_MFP11 |PB.11 Pin Function Selection
S     * |        |          |Bits PB11_PWM04 (ALT_MFP3[24]) and GPB_MFP11 determine the PB.11 function.
S     * |        |          |(PB11_PWM04, GPB_MFP11) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = TM3 function is selected.
S     * |        |          |(1, 1) = PWM0_CH4 function is selected.
S     * |[12]    |GPB_MFP12 |PB.12 Pin Function Selection
S     * |        |          |Bits PB12_BPWM13 (ALT_MFP3[21]) and GPB_MFP12 determine the PB.12 function.
S     * |        |          |(PB12_BPWM13, GPB_MFP12) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = CLKO function is selected.
S     * |        |          |(1, 1) = BPWM1_CH3 function is selected.
S     * |[14]    |GPB_MFP14 |PB.14 Pin Function Selection
S     * |        |          |Bit GPB_MFP14 determines the PB.14 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = INT0 function is selected.
S     * |[15]    |GPB_MFP15 |PB.15 Pin Function Selection
S     * |        |          |Bits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.
S     * |        |          |(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = INT1 function is selected.
S     * |        |          |(0, 0, 1, 1) = TM0 function is selected.
S     * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
S     * |        |          |(1, 0, 1, 1) = BPWM1_CH5 function is selected.
S     * |[31:16] |GPB_TYPEn |Trigger Function Selection
S     * |        |          |0 = GPIOB[15:0] I/O input Schmitt Trigger function Disabled.
S     * |        |          |1 = GPIOB[15:0] I/O input Schmitt Trigger function Enabled.
S     */
S    __IO uint32_t GPB_MFP;
S
S    /**
S     * GPC_MFP
S     * ===================================================================================================
S     * Offset: 0x38  GPIOC Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GPC_MFP0  |PC.0 Pin Function Selection
S     * |        |          |Bits PC0_BPWM00 (ALT_MFP3[12]) and GPC_MFP0 determine the PC.0 function.
S     * |        |          |(PC0_BPWM00, GPC_MFP0) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = SPI0_SS0 function is selected.
S     * |        |          |(1, 1) = BPWM0_CH0 function is selected.
S     * |[1]     |GPC_MFP1  |PC.1 Pin Function Selection
S     * |        |          |Bits PC1_BPWM01 (ALT_MFP3[13]) and GPC_MFP1 determine the PC.1 function.
S     * |        |          |(PC1_BPWM01, GPC_MFP1) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = SPI0_CLK function is selected.
S     * |        |          |(1, 1) = BPWM0_CH1 function is selected.
S     * |[2]     |GPC_MFP2  |PC.2 Pin Function Selection
S     * |        |          |Bits PC2_BPWM02 (ALT_MFP3[14]) and GPC_MFP2 determine the PC.2 function.
S     * |        |          |(PC2_BPWM02, GPC_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = SPI0_MISO0 function is selected.
S     * |        |          |(1, 1) = BPWM0_CH2 function is selected.
S     * |[3]     |GPC_MFP3  |PC.3 Pin Function Selection
S     * |        |          |Bits PC3_BPWM03 (ALT_MFP3[15]) and GPC_MFP3 determine the PC.3 function.
S     * |        |          |(PC3_BPWM03, GPC_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
S     * |        |          |(1, 1) = BPWM0_CH3 function is selected.
S     * |[6]     |GPC_MFP6  |PC.6 Pin Function Selection
S     * |        |          |Bits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.
S     * |        |          |(PC6_PWM0BK0, PC6_I2C0SDA, GPC_MFP6) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = UART4_TXD function is selected.
S     * |        |          |(0, 1, 1) = I2C0_SDA function is selected.
S     * |        |          |(1, 0, 1) = PWM0_BRAKE0 function is selected.
S     * |[7]     |GPC_MFP7  |PC.7 Pin Function Selection
S     * |        |          |Bits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.
S     * |        |          |(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = UART4_RXD function is selected.
S     * |        |          |(0, 1, 1) = I2C0_SCL function is selected.
S     * |        |          |(1, 0, 1) = PWM0_BRAKE1 function is selected.
S     * |[8]     |GPC_MFP8  |PC.8 Pin Function Selection
S     * |        |          |Bit GPC_MFP8 determines the PC.8 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = PWM0_BRAKE0 function is selected.
S     * |[9]     |GPC_MFP9  |PC.9 Pin Function Selection
S     * |        |          |Bit GPC_MFP9 determines the PC.9 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = PWM0_BRAKE1 function is selected.
S     * |[10]    |GPC_MFP10 |PC.10 Pin Function Selection
S     * |        |          |Bit GPC_MFP10 determines the PC.10 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = PWM1_BRAKE0 function is selected.
S     * |[11]    |GPC_MFP11 |PC.11 Pin Function Selection
S     * |        |          |Bit GPC_MFP11 determines the PC.11 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = PWM1_BRAKE1 function is selected.
S     * |[31:16] |GPC_TYPEn |Trigger Function Selection
S     * |        |          |0 = GPIOC[15:0] I/O input Schmitt Trigger function Disabled.
S     * |        |          |1 = GPIOC[15:0] I/O input Schmitt Trigger function Enabled.
S     */
S    __IO uint32_t GPC_MFP;
S
S    /**
S     * GPD_MFP
S     * ===================================================================================================
S     * Offset: 0x3C  GPIOD Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[6]     |GPD_MFP6  |PD.6 Pin Function Selection
S     * |        |          |Bits PD6_BPWM11 (ALT_MFP3[19]) and GPD_MFP6 determine the PD.6 function.
S     * |        |          |(PD6_BPWM11, GPD_MFP6) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = CAN0_RXD function is selected.
S     * |        |          |(1, 1) = BPWM1_CH1 function is selected.
S     * |[7]     |GPD_MFP7  |PD.7 Pin Function Selection
S     * |        |          |Bits PD7_BPWM10 (ALT_MFP3[18]) and GPD_MFP7 determine the PD.7 function.
S     * |        |          |(PD7_BPWM10, GPD_MFP7) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = CAN0_TXD function is selected.
S     * |        |          |(1, 1) = BPWM1_CH0 function is selected.
S     * |[14]    |GPD_MFP14 |PD.14 Pin Function Selection
S     * |        |          |Bits PD14_BPWM05 (ALT_MFP3[17]) and GPD_MFP14 determine the PD.14 function.
S     * |        |          |(PD14_BPWM05, GPD_MFP14) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = UART2_RXD function is selected.
S     * |        |          |(1, 1) = BPWM0_CH5 function is selected.
S     * |[15]    |GPD_MFP15 |PD.15 Pin Function Selection
S     * |        |          |Bits PD15_BPWM04 (ALT_MFP3[16]) and GPD_MFP15 determine the PD.15 function.
S     * |        |          |(PD15_BPWM04, GPD_MFP15) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = UART2_TXD function is selected.
S     * |        |          |(1, 1) = BPWM0_CH4 function is selected.
S     * |[31:16] |GPD_TYPEn |Trigger Function Selection
S     * |        |          |0 = GPIOD[15:0] I/O input Schmitt Trigger function Disabled.
S     * |        |          |1 = GPIOD[15:0] I/O input Schmitt Trigger function Enabled.
S     */
S    __IO uint32_t GPD_MFP;
S
S    /**
S     * GPE_MFP
S     * ===================================================================================================
S     * Offset: 0x40  GPIOE Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5]     |GPE_MFP5  |PE.5 Pin Function Selection
S     * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
S     * |        |          |(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = PWM0_CH5 function is selected.
S     * |        |          |(0, 1, 1) = TM1 function is selected.
S     * |        |          |(1, 0, 1) = TM1_EXT function is selected.
S     * |[21]    |GPE_TYPE5 |Trigger Function Selection
S     * |        |          |0 = GPIOE[5] I/O input Schmitt Trigger function Disabled.
S     * |        |          |1 = GPIOE[5] I/O input Schmitt Trigger function Enabled.
S     */
S    __IO uint32_t GPE_MFP;
S
S    /**
S     * GPF_MFP
S     * ===================================================================================================
S     * Offset: 0x44  GPIOF Multiple Function and Input Type Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |GPF_MFP0  |PF.0 Pin Function Selection
S     * |        |          |Bit GPF_MFP0 determine the PF.0 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = XT1_OUT function is selected.
S     * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).
S     * |[1]     |GPF_MFP1  |PF.1 Pin Function Selection
S     * |        |          |Bit GPF_MFP1 determine the PF.1 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = XT1_IN function is selected.
S     * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).
S     * |[4]     |GPF_MFP4  |PF.4 Pin Function Selection
S     * |        |          |Bits PF4_PWM14 (ALT_MFP3[10]) and GPF_MFP4 determine the PF.4 function.
S     * |        |          |(PF4_PWM14, GPF_MFP4) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C0_SDA function is selected.
S     * |        |          |(1, 1) = PWM1_CH4 function is selected.
S     * |[5]     |GPF_MFP5  |PF.5 Pin Function Selection
S     * |        |          |Bits PF5_PWM15 (ALT_MFP3[11]) and GPF_MFP5 determine the PF.5 function.
S     * |        |          |(PF5_PWM15, GPF_MFP5) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C0_SCL function is selected.
S     * |        |          |(1, 1) = PWM1_CH5 function is selected.
S     * |[6]     |GPF_MFP6  |PF.6 Pin Function Selection
S     * |        |          |Bit GPF_MFP6 determines the PF.6 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = ICE_CLK function is selected.
S     * |[7]     |GPF_MFP7  |PF.7 Pin Function Selection
S     * |        |          |Bit GPF_MFP7 determines the PF.7 function.
S     * |        |          |0 = GPIO function is selected.
S     * |        |          |1 = ICE_DAT function is selected.
S     * |[8]     |GPF_MFP8  |PF.8 Pin Function Selection
S     * |        |          |Bits PF8_BPWM14 (ALT_MFP3[22]) and GPF_MFP8 determine the PF.8 function.
S     * |        |          |(PF8_BPWM14, GPF_MFP8) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = CLKO function is selected.
S     * |        |          |(1, 0) = BPWM1_CH4 function is selected.
S     * |[24:16] |GPF_TYPEn |Trigger Function Selection
S     * |        |          |0 = GPIOF[8:0] I/O input Schmitt Trigger function Disabled.
S     * |        |          |1 = GPIOF[8:0] I/O input Schmitt Trigger function Enabled.
S     */
S    __IO uint32_t GPF_MFP;
S
S    uint32_t RESERVE3[2];
S
S    /**
S     * ALT_MFP
S     * ===================================================================================================
S     * Offset: 0x50  Alternative Multiple Function Pin Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[24]    |PB15_T0EX |PB.15 Pin Alternative Function Selection
S     * |        |          |Bits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.
S     * |        |          |(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = INT1 function is selected.
S     * |        |          |(0, 0, 1, 1) = TM0 function is selected.
S     * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
S     * |        |          |(1, 0, 1, 1) = BPWM1_CH5 function is selected.
S     * |[25]    |PE5_T1EX  |PE.5 Pin Alternative Function Selection
S     * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
S     * |        |          |(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = PWM0_CH5 function is selected.
S     * |        |          |(0, 1, 1) = TM1 function is selected.
S     * |        |          |(1, 0, 1) = TM1_EXT function is selected.
S     * |[26]    |PB2_T2EX  |PB.2 Pin Alternative Function Selection
S     * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.
S     * |        |          |(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
S     * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
S     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE1 function is selected.
S     * |        |          |(1, 0, 0, 1) = TM2 function is selected.
S     * |[27]    |PB3_T3EX  |PB.3 Pin Alternative Function Selection
S     * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.
S     * |        |          |(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
S     * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
S     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE0 function is selected.
S     * |        |          |(1, 0, 0, 1) = TM3 function is selected.
S     * |[29]    |PB8_CLKO  |PB.8 Pin Alternative Function Selection
S     * |        |          |Bits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.
S     * |        |          |(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = TM0 function is selected.
S     * |        |          |(0, 1, 1) = CLKO function is selected.
S     * |        |          |(1, 0, 1) = BPWM1_CH2 function is selected.
S     */
S    __IO uint32_t ALT_MFP;
S
S    uint32_t RESERVE4[2];
S
S    /**
S     * ALT_MFP2
S     * ===================================================================================================
S     * Offset: 0x5C  Alternative Multiple Function Pin Control Register 2
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[2]     |PB15_TM0  |PB.15 Pin Alternative Function Selection
S     * |        |          |Bits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.
S     * |        |          |(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = INT1 function is selected.
S     * |        |          |(0, 0, 1, 1) = TM0 function is selected.
S     * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
S     * |        |          |(1, 0, 1, 1) = BPWM1_CH5 function is selected.
S     * |[3]     |PE5_TM1   |PE.5 Pin Alternative Function Selection
S     * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
S     * |        |          |(PE5_T1EX, PE5_TM1, GPE_MFP5) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = PWM0_CH5 function is selected.
S     * |        |          |(0, 1, 1) = TM1 function is selected.
S     * |        |          |(1, 0, 1) = TM1_EXT function is selected.
S     * |[4]     |PB2_TM2   |PB.2 Pin Alternative Function Selection
S     * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.
S     * |        |          |(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
S     * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
S     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE1 function is selected.
S     * |        |          |(1, 0, 0, 1) = TM2 function is selected.
S     * |[5]     |PB3_TM3   |PB.3 Pin Alternative Function Selection
S     * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.
S     * |        |          |(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
S     * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
S     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE0 function is selected.
S     * |        |          |(1, 0, 0, 1) = TM3 function is selected.
S     */
S    __IO uint32_t ALT_MFP2;
S
S    /**
S     * ALT_MFP3
S     * ===================================================================================================
S     * Offset: 0x60  Alternative Multiple Function Pin Control Register 3
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4]     |PA0_PWM04 |PA.0 Pin Alternative Function Selection
S     * |        |          |Bits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.
S     * |        |          |(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = ADC0 function is selected.
S     * |        |          |(0, 0, 1, 1) = I2C1_SCL function is selected.
S     * |        |          |(0, 1, 0, 1) = UART5_TXD function is selected.
S     * |        |          |(1, 0, 0, 1) = PWM0_CH4 function is selected.
S     * |[5]     |PA1_PWM05 |PA.1 Pin Alternative Function Selection
S     * |        |          |Bits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.
S     * |        |          |(PA1_PWM05, PA1_UR5RXD , PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
S     * |        |          |(0, 0, 1, 1) = I2C1_SDA function is selected.
S     * |        |          |(0, 1, 0, 1) = UART5_RXD function is selected.
S     * |        |          |(1, 0, 0, 1) = PWM0_CH5 function is selected.
S     * |[6]     |PA2_PWM10 |PA.2 Pin Alternative Function Selection
S     * |        |          |Bits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.
S     * |        |          |(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = ADC2 function is selected.
S     * |        |          |(0, 1, 1) = UART3_TXD function is selected.
S     * |        |          |(1, 0, 1) = PWM1_CH0 function is selected.
S     * |[7]     |PA3_PWM11 |PA.3 Pin Alternative Function Selection
S     * |        |          |Bits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.
S     * |        |          |(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = ADC3 function is selected.
S     * |        |          |(0, 1, 1) = UART3_RXD function is selected.
S     * |        |          |(1, 0, 1) = PWM1_CH1 function is selected.
S     * |[8]     |PA10_PWM12|PA.10 Pin Alternative Function Selection
S     * |        |          |Bits PA10_PWM12 (ALT_MFP3[8]) and GPA_MFP10 determine the PA.10 function.
S     * |        |          |(PA10_PWM12, GPA_MFP10) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C1_SDA function is selected.
S     * |        |          |(1, 1) = PWM1_CH2 function is selected.
S     * |[9]     |PA11_PWM13|PA.11 Pin Alternative Function Selection
S     * |        |          |Bits PA11_PWM13 (ALT_MFP3[9]) and GPA_MFP11 determine the PA.11 function.
S     * |        |          |(PA11_PWM13, GPA_MFP11) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C1_SCL function is selected.
S     * |        |          |(1, 1) = PWM1_CH3 function is selected.
S     * |[10]    |PF4_PWM14 |PF.4 Pin Alternative Function Selection
S     * |        |          |Bits PF4_PWM14 (ALT_MFP3[10]) and GPF_MFP4 determine the PF.4 function.
S     * |        |          |(PF4_PWM14, GPF_MFP4) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C0_SDA function is selected.
S     * |        |          |(1, 1) = PWM1_CH4 function is selected.
S     * |[11]    |PF5_PWM15 |PF.5 Pin Alternative Function Selection
S     * |        |          |Bits PF5_PWM15 (ALT_MFP3[11]) and GPF_MFP5 determine the PF.5 function.
S     * |        |          |(PF5_PWM15, GPF_MFP5) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C0_SCL function is selected.
S     * |        |          |(1, 1) = PWM1_CH5 function is selected.
S     * |[12]    |PC0_BPWM00|PC.0 Pin Alternative Function Selection
S     * |        |          |Bits PC0_BPWM00 (ALT_MFP3[12]) and GPC_MFP0 determine the PC.0 function.
S     * |        |          |(PC0_BPWM00, GPC_MFP0) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = SPI0_SS0 function is selected.
S     * |        |          |(1, 1) = BPWM0_CH0 function is selected.
S     * |[13]    |PC1_BPWM01|PC.1 Pin Alternative Function Selection
S     * |        |          |Bits PC1_BPWM01 (ALT_MFP3[13]) and GPC_MFP1 determine the PC.1 function.
S     * |        |          |(PC1_BPWM01, GPC_MFP1) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = SPI0_CLK function is selected.
S     * |        |          |(1, 1) = BPWM0_CH1 function is selected.
S     * |[14]    |PC2_BPWM02|PC.2 Pin Alternative Function Selection
S     * |        |          |Bits PC2_BPWM02 (ALT_MFP3[14]) and GPC_MFP2 determine the PC.2 function.
S     * |        |          |(PC2_BPWM02, GPC_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = SPI0_MISO0 function is selected.
S     * |        |          |(1, 1) = BPWM0_CH2 function is selected.
S     * |[15]    |PC3_BPWM03|PC.3 Pin Alternative Function Selection
S     * |        |          |Bits PC3_BPWM03 (ALT_MFP3[15]) and GPC_MFP3 determine the PC.3 function.
S     * |        |          |(PC3_BPWM03, GPC_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
S     * |        |          |(1, 1) = BPWM0_CH3 function is selected.
S     * |[16]    |PD15_BPWM04|PD.15 Pin Alternative Function Selection
S     * |        |          |Bits PD15_BPWM04 (ALT_MFP3[16]) and GPD_MFP15 determine the PD.15 function.
S     * |        |          |(PD15_BPWM04, GPD_MFP15) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = UART2_TXD function is selected.
S     * |        |          |(1, 1) = BPWM0_CH4 function is selected.
S     * |[17]    |PD14_BPWM05|PD.14 Pin Alternative Function Selection
S     * |        |          |Bits PD14_BPWM05 (ALT_MFP3[17]) and GPD_MFP14 determine the PD.14 function.
S     * |        |          |(PD14_BPWM05, GPD_MFP14) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = UART2_RXD function is selected.
S     * |        |          |(1, 1) = BPWM0_CH5 function is selected.
S     * |[18]    |PD7_BPWM10|PD.7 Pin Alternative Function Selection
S     * |        |          |Bits PD7_BPWM10 (ALT_MFP3[18]) and GPD_MFP7 determine the PD.7 function.
S     * |        |          |(PD7_BPWM10, GPD_MFP7) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = CAN0_TXD function is selected.
S     * |        |          |(1, 1) = BPWM1_CH0 function is selected.
S     * |[19]    |PD6_BPWM11|PD.6 Pin Alternative Function Selection
S     * |        |          |Bits PD6_BPWM11 (ALT_MFP3[19]) and GPD_MFP6 determine the PD.6 function.
S     * |        |          |(PD6_BPWM11, GPD_MFP6) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = CAN0_RXD function is selected.
S     * |        |          |(1, 1) = BPWM1_CH1 function is selected.
S     * |[20]    |PB8_BPWM12|PB.8 Pin Alternative Function Selection
S     * |        |          |Bits PB8_BPWM12 (ALT_MFP3[20]), PB8_CLKO (ALT_MFP[29]) and GPB_MFP8 determine the PB.8 function.
S     * |        |          |(PB8_BPWM12, PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = TM0 function is selected.
S     * |        |          |(0, 1, 1) = CLKO function is selected.
S     * |        |          |(1, 0, 1) = BPWM1_CH2 function is selected.
S     * |[21]    |PB12_BPWM13|PB.12 Pin Alternative Function Selection
S     * |        |          |Bits PB12_BPWM13 (ALT_MFP3[21]) and GPB_MFP12 determine the PB.12 function.
S     * |        |          |(PB12_BPWM13, GPB_MFP12) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = CLKO function is selected.
S     * |        |          |(1, 1) = BPWM1_CH3 function is selected.
S     * |[22]    |PF8_BPWM14|PF.8 Pin Alternative Function Selection
S     * |        |          |Bits PF8_BPWM14 (ALT_MFP3[22]) and GPF_MFP8 determine the PF.8 function.
S     * |        |          |(PF8_BPWM14, GPF_MFP8) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = CLKO function is selected.
S     * |        |          |(1, 0) = BPWM1_CH4 function is selected.
S     * |[23]    |PB15_BPWM15|PB.15 Pin Alternative Function Selection
S     * |        |          |Bits PB15_BPWM15 (ALT_MFP3[23]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP15 determine the PB.15 function.
S     * |        |          |(PB15_BPWM15, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = INT1 function is selected.
S     * |        |          |(0, 0, 1, 1) = TM0 function is selected.
S     * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
S     * |        |          |(1, 0, 1, 1) = BPWM1_CH5 function is selected.
S     * |[24]    |PB11_PWM04|PB.11 Pin Alternative Function Selection
S     * |        |          |Bits PB11_PWM04 (ALT_MFP3[24]) and GPB_MFP11 determine the PB.11 function.
S     * |        |          |(PB11_PWM04, GPB_MFP11) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = TM3 function is selected.
S     * |        |          |(1, 1) = PWM0_CH4 function is selected.
S     * |[28]    |PC6_PWM0BK0|PC.6 Pin Alternative Function Selection
S     * |        |          |Bits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.
S     * |        |          |(PC6_PWM0BK0, PC6_I2C0SDA, GPB_MFP6) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = UART4_TXD function is selected.
S     * |        |          |(0, 1, 1) = I2C0_SDA function is selected.
S     * |        |          |(1, 0, 1) = PWM0_BRAKE0 function is selected.
S     * |[29]    |PC7_PWM0BK1|PC.7 Pin Alternative Function Selection
S     * |        |          |Bits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.
S     * |        |          |(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = UART4_RXD function is selected.
S     * |        |          |(0, 1, 1) = I2C0_SCL function is selected.
S     * |        |          |(1, 0, 1) = PWM0_BRAKE1 function is selected.
S     * |[30]    |PB3_PWM1BK0|PB.3 Pin Alternative Function Selection
S     * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_PWM1BK0 (ALT_MFP3[30]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP3 determine the PB.3 function.
S     * |        |          |(PB3_TM3, PB3_PWM1BK0, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
S     * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
S     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE0 function is selected.
S     * |        |          |(1, 0, 0, 1) = TM3 function is selected.
S     * |[31]    |PB2_PWM1BK1|PB.2 Pin Alternative Function Selection
S     * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_PWM1BK1 (ALT_MFP3[31]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP2 determine the PB.2 function.
S     * |        |          |(PB2_TM2, PB2_PWM1BK1, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
S     * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
S     * |        |          |(0, 1, 0, 1) = PWM1_BRAKE1 function is selected.
S     * |        |          |(1, 0, 0, 1) = TM2 function is selected.
S     */
S    __IO uint32_t ALT_MFP3;
S
S    /**
S     * ALT_MFP4
S     * ===================================================================================================
S     * Offset: 0x64  Alternative Multiple Function Pin Control Register 4
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |PA8_UR1RTS|PA.8 Pin Alternative Function Selection
S     * |        |          |Bits PA8_UR1RTS (ALT_MFP4[0]) and GPA_MFP8 determine the PA.8 function.
S     * |        |          |(PA8_UR1RTS, GPA_MFP8) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C0_SDA function is selected.
S     * |        |          |(1, 1) = UART1_nRTS function is selected.
S     * |[1]     |PA9_UR1CTS|PA.9 Pin Alternative Function Selection
S     * |        |          |Bits PA9_UR1CTS (ALT_MFP4[1]) and GPA_MFP9 determine the PA.9 function.
S     * |        |          |(PA9_UR1CTS, GPA_MFP9) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = I2C0_SCL function is selected.
S     * |        |          |(1, 1) = UART1_nCTS function is selected.
S     * |[2]     |PA3_UR3RXD|PA.3 Pin Alternative Function Selection
S     * |        |          |Bits PA3_PWM11 (ALT_MFP3[7]), PA3_UR3RXD (ALT_MFP4[2]) and GPA_MFP3 determine the PA.3 function.
S     * |        |          |(PA3_PWM11, PA3_UR3RXD, GPA_MFP3) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = ADC3 function is selected.
S     * |        |          |(0, 1, 1) = UART3_RXD function is selected.
S     * |        |          |(1, 0, 1) = PWM1_CH1 function is selected.
S     * |[3]     |PA2_UR3TXD|PA.2 Pin Alternative Function Selection
S     * |        |          |Bits PA2_PWM10 (ALT_MFP3[6]), PA2_UR3TXD (ALT_MFP4[3]) and GPA_MFP2 determine the PA.2 function.
S     * |        |          |(PA2_PWM10, PA2_UR3TXD, GPA_MFP2) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = ADC2 function is selected.
S     * |        |          |(0, 1, 1) = UART3_TXD function is selected.
S     * |        |          |(1, 0, 1) = PWM1_CH0 function is selected.
S     * |[4]     |PA5_UR3RXD|PA.5 Pin Alternative Function Selection
S     * |        |          |Bits PA5_UR3RXD (ALT_MFP4[4]) and GPA_MFP5 determine the PA.5 function.
S     * |        |          |(PA5_UR3RXD, GPA_MFP5) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = ADC5 function is selected.
S     * |        |          |(1, 1) = UART3_RXD function is selected.
S     * |[5]     |PA6_UR3TXD|PA.6 Pin Alternative Function Selection
S     * |        |          |Bits PA6_UR3TXD (ALT_MFP4[5]) and GPA_MFP6 determine the PA.6 function.
S     * |        |          |(PA6_UR3TXD, GPA_MFP6) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = ADC6 function is selected.
S     * |        |          |(1, 1) = UART3_TXD function is selected.
S     * |[6]     |PA1_UR5RXD|PA.1 Pin Alternative Function Selection
S     * |        |          |Bits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.
S     * |        |          |(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
S     * |        |          |(0, 0, 1, 1) = I2C1_SDA function is selected.
S     * |        |          |(0, 1, 0, 1) = UART5_RXD function is selected.
S     * |        |          |(1, 0, 0, 1) = PWM0_CH5 function is selected.
S     * |[7]     |PA0_UR5TXD|PA.0 Pin Alternative Function Selection
S     * |        |          |Bits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.
S     * |        |          |(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = ADC0 function is selected.
S     * |        |          |(0, 0, 1, 1) = I2C1_SCL function is selected.
S     * |        |          |(0, 1, 0, 1) = UART5_TXD function is selected.
S     * |        |          |(1, 0, 0, 1) = PWM0_CH4 function is selected.
S     * |[8]     |PA12_UR5RXD|PA.12 Pin Alternative Function Selection
S     * |        |          |Bits PA12_UR5RXD (ALT_MFP4[8]) and GPA_MFP12 determine the PA.12 function.
S     * |        |          |(PA12_UR5RXD, GPA_MFP12) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = PWM0_CH0 function is selected.
S     * |        |          |(1, 1) = UART5_RXD function is selected.
S     * |[9]     |PA13_UR5TXD|PA.13 Pin Alternative Function Selection
S     * |        |          |Bits PA13_UR5TXD (ALT_MFP4[9]) and GPA_MFP13 determine the PA.13 function.
S     * |        |          |(PA13_UR5TXD, GPA_MFP13) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = PWM0_CH1 function is selected.
S     * |        |          |(1, 1) = UART5_TXD function is selected.
S     * |[10]    |PC6_I2C0SDA|PC.6 Pin Alternative Function Selection
S     * |        |          |Bits PC6_PWM0BK0 (ALT_MFP3[28]), PC6_I2C0SDA (ALT_MFP4[10]) and GPC_MFP6 determine the PC.6 function.
S     * |        |          |(PC6_PWM0BK0, PC6_I2C0SDA, GPC_MFP6) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = UART4_TXD function is selected.
S     * |        |          |(0, 1, 1) = I2C0_SDA function is selected.
S     * |        |          |(1, 0, 1) = PWM0_BRAKE0 function is selected.
S     * |[11]    |PC7_I2C0SCL|PC.7 Pin Alternative Function Selection
S     * |        |          |Bits PC7_PWM0BK1 (ALT_MFP3[29]), PC7_I2C0SCL (ALT_MFP4[11]) and GPC_MFP7 determine the PC.7 function.
S     * |        |          |(PC7_PWM0BK1, PC7_I2C0SCL, GPC_MFP7) value and function mapping is as following list.
S     * |        |          |(0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 1) = UART4_RXD function is selected.
S     * |        |          |(0, 1, 1) = I2C0_SCL function is selected.
S     * |        |          |(1, 0, 1) = PWM0_BRAKE1 function is selected.
S     * |[12]    |PA0_I2C1SCL|PA.0 Pin Alternative Function Selection
S     * |        |          |Bits PA0_PWM04 (ALT_MFP3[4]), PA0_UR5TXD (ALT_MFP4[7]), PA0_I2C1SCL (ALT_MFP4[12]) and GPA_MFP0 determine the PA.0 function.
S     * |        |          |(PA0_PWM04, PA0_UR5TXD, PA0_I2C1SCL, GPA_MFP0) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = ADC0 function is selected.
S     * |        |          |(0, 0, 1, 1) = I2C1_SCL function is selected.
S     * |        |          |(0, 1, 0, 1) = UART5_TXD function is selected.
S     * |        |          |(1, 0, 0, 1) = PWM0_CH4 function is selected.
S     * |[13]    |PA1_I2C1SDA|PA.1 Pin Alternative Function Selection
S     * |        |          |Bits PA1_PWM05 (ALT_MFP3[5]), PA1_UR5RXD (ALT_MFP4[6]), PA1_I2C1SDA (ALT_MFP4[13]) and GPA_MFP1 determine the PA.1 function.
S     * |        |          |(PA1_PWM05, PA1_UR5RXD, PA1_I2C1SDA, GPA_MFP1) value and function mapping is as following list.
S     * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S     * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
S     * |        |          |(0, 0, 1, 1) = I2C1_SDA function is selected.
S     * |        |          |(0, 1, 0, 1) = UART5_RXD function is selected.
S     * |        |          |(1, 0, 0, 1) = PWM0_CH5 function is selected.
S     * |[14]    |PA7_VREF  |PA.7 Pin Alternative Function Selection
S     * |        |          |Bits PA7_VREF (ALT_MFP4[14]) and GPA_MFP7 determine the PA.7 function.
S     * |        |          |(PA7_VREF, GPA_MFP7) value and function mapping is as following list.
S     * |        |          |(0, 0) = GPIO function is selected.
S     * |        |          |(0, 1) = ADC7 function is selected.
S     * |        |          |(1, 1) = VREF function is selected.
S     */
S    __IO uint32_t ALT_MFP4;
S
S    uint32_t RESERVE5[38];
S
S    /**
S     * REGWRPROT
S     * ===================================================================================================
S     * Offset: 0x100  Register Write Protection Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |REGPROTDIS|Register Write-Protection Disable Index (Read Only)
S     * |        |          |0 = Write-protection is enabled for writing protected registers. Any write to the protected register is ignored.
S     * |        |          |1 = Write-protection is disabled for writing protected registers.
S     * |        |          |The Protected registers are:
S     * |        |          |IPRSTC1: address 0x5000_0008
S     * |        |          |BODCR: address 0x5000_0018
S     * |        |          |PORCR: address 0x5000_0024
S     * |        |          |VREFCR: address 0x5000_0028
S     * |        |          |PWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear)
S     * |        |          |APBCLK bit[0]: address 0x5000_0208 (bit[0] is Watchdog Timer clock enable)
S     * |        |          |CLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source selection)
S     * |        |          |CLKSEL1 bit[1:0]: address 0x5000_0214 (for Watchdog Timer clock source selection)
S     * |        |          |NMISEL bit[8]: address 0x5000_0380 (for NMI_EN NMI interrupt enable)
S     * |        |          |ISPCON: address 0x5000_C000 (Flash ISP Control register)
S     * |        |          |ISPTRG: address 0x5000_C010 (ISP Trigger Control register)
S     * |        |          |FATCON: address 0x5000_C018
S     * |        |          |WTCR: address 0x4000_4000
S     * |        |          |WTCRALT: address 0x4000_4004
S     * |        |          |PWM_CTL0: address 0x4004_0000, 0x4014_0000
S     * |        |          |PWM_DTCTL0_1: address 0x4004_0070, 0x4014_0070
S     * |        |          |PWM_DTCTL2_3: address 0x4004_0074, 0x4014_0074
S     * |        |          |PWM_DTCTL4_5: address 0x4004_0078, 0x4014_0078
S     * |        |          |PWM_BRKCTL0_1: address 0x4004_00C8, 0x4014_00C8
S     * |        |          |PWM_BRKCTL2_3: address 0x4004_00CC, 0x4014_00CC
S     * |        |          |PWM_BRKCTL4_5: address 0x4004_00D0, 0x4014_00D0
S     * |        |          |PWM_SWBRK: address 0x4004_00DC, 0x4014_00DC
S     * |        |          |PWM_INTEN1: address 0x4004_00E4, 0x4014_00E4
S     * |        |          |PWM_INTSTS1: address 0x4004_00EC, 0x4014_00EC
S     * |        |          |BPWM_CTL0: address 0x4004_4000, 0x4014_4000
S     * |        |          |Note: The bits which are write-protected will be noted as" (Write Protect)" beside the description.
S     * |[7:0]   |REGWRPROT |Register Write-Protection Code (Write Only)
S     * |        |          |Some registers have write-protection function.
S     * |        |          |Writing these registers have to disable the protected function by writing the sequence value "59h", "16h", "88h" to this field.
S     * |        |          |After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection registers can be normal write.
S     */
S    __IO uint32_t REGWRPROT;
S} GCR_T;
S
S/**
S    @addtogroup SYS_CONST SYS Bit Field Definition
S    Constant Definitions for SYS Controller
S@{ */
S
S/* GCR RSTSRC Bit Field Definitions */
S#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                   /*!< GCR_T::RSTSRC: RSTS_CPU Position */
S#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)    /*!< GCR_T::RSTSRC: RSTS_CPU Mask */
S
S#define SYS_RSTSRC_RSTS_SYS_Pos                 5                                   /*!< GCR_T::RSTSRC: RSTS_SYS Position */
S#define SYS_RSTSRC_RSTS_SYS_Msk                 (1ul << SYS_RSTSRC_RSTS_SYS_Pos)    /*!< GCR_T::RSTSRC: RSTS_SYS Mask */
S
S#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                   /*!< GCR_T::RSTSRC: RSTS_BOD Position */
S#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)    /*!< GCR_T::RSTSRC: RSTS_BOD Mask */
S
S#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                   /*!< GCR_T::RSTSRC: RSTS_LVR Position */
S#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)    /*!< GCR_T::RSTSRC: RSTS_LVR Mask */
S
S#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                   /*!< GCR_T::RSTSRC: RSTS_WDT Position */
S#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)    /*!< GCR_T::RSTSRC: RSTS_WDT Mask */
S
S#define SYS_RSTSRC_RSTS_RESET_Pos               1                                   /*!< GCR_T::RSTSRC: RSTS_RESET Position */
S#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)  /*!< GCR_T::RSTSRC: RSTS_RESET Mask */
S
S#define SYS_RSTSRC_RSTS_POR_Pos                 0                                   /*!< GCR_T::RSTSRC: RSTS_POR Position */
S#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)    /*!< GCR_T::RSTSRC: RSTS_POR Mask */
S
S/* GCR IPRSTC1 Bit Field Definitions */
S#define SYS_IPRSTC1_CPU_RST_Pos                 1                                   /*!< GCR_T::IPRSTC1: CPU_RST Position */
S#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)    /*!< GCR_T::IPRSTC1: CPU_RST Mask */
S
S#define SYS_IPRSTC1_CHIP_RST_Pos                0                                   /*!< GCR_T::IPRSTC1: CHIP_RST Position */
S#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)   /*!< GCR_T::IPRSTC1: CHIP_RST Mask */
S
S/* GCR IPRSTC2 Bit Field Definitions */
S#define SYS_IPRSTC2_ADC_RST_Pos                 28                                  /*!< GCR_T::IPRSTC2: ADC_RST Position */
S#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)    /*!< GCR_T::IPRSTC2: ADC_RST Mask */
S
S#define SYS_IPRSTC2_CAN0_RST_Pos                24                                  /*!< GCR_T IPRSTC2: CAN0_RST Position */
S#define SYS_IPRSTC2_CAN0_RST_Msk                (1ul << SYS_IPRSTC2_CAN0_RST_Pos)   /*!< GCR_T IPRSTC2: CAN0_RST Mask */
S
S#define SYS_IPRSTC2_UART2_RST_Pos               18                                  /*!< GCR_T::IPRSTC2: UART2_RST Position */
S#define SYS_IPRSTC2_UART2_RST_Msk               (1ul << SYS_IPRSTC2_UART2_RST_Pos)  /*!< GCR_T::IPRSTC2: UART2_RST Mask */
S
S#define SYS_IPRSTC2_UART1_RST_Pos               17                                  /*!< GCR_T::IPRSTC2: UART1_RST Position */
S#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)  /*!< GCR_T::IPRSTC2: UART1_RST Mask */
S
S#define SYS_IPRSTC2_UART0_RST_Pos               16                                  /*!< GCR_T::IPRSTC2: UART0_RST Position */
S#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)  /*!< GCR_T::IPRSTC2: UART0_RST Mask */
S
S#define SYS_IPRSTC2_SPI0_RST_Pos                12                                  /*!< GCR_T::IPRSTC2: SPI0_RST Position */
S#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI0_RST Mask */
S
S#define SYS_IPRSTC2_I2C1_RST_Pos                9                                   /*!< GCR_T::IPRSTC2: I2C1_RST Position */
S#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C1_RST Mask */
S
S#define SYS_IPRSTC2_I2C0_RST_Pos                8                                   /*!< GCR_T::IPRSTC2: I2C0_RST Position */
S#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C0_RST Mask */
S
S#define SYS_IPRSTC2_TMR3_RST_Pos                5                                   /*!< GCR_T::IPRSTC2: TMR3_RST Position */
S#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR3_RST Mask */
S
S#define SYS_IPRSTC2_TMR2_RST_Pos                4                                   /*!< GCR_T::IPRSTC2: TMR2_RST Position */
S#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR2_RST Mask */
S
S#define SYS_IPRSTC2_TMR1_RST_Pos                3                                   /*!< GCR_T::IPRSTC2: TMR1_RST Position */
S#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR1_RST Mask */
S
S#define SYS_IPRSTC2_TMR0_RST_Pos                2                                   /*!< GCR_T::IPRSTC2: TMR0_RST Position */
S#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR0_RST Mask */
S
S#define SYS_IPRSTC2_GPIO_RST_Pos                1                                   /*!< GCR_T::IPRSTC2: GPIO_RST Position */
S#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)   /*!< GCR_T::IPRSTC2: GPIO_RST Mask */
S
S/* GCR IPRSTC3 Bit Field Definitions */
S#define SYS_IPRSTC3_BPWM1_RST_Pos               19                                  /*!< GCR_T::IPRSTC3: BPWM1_RST Position */
S#define SYS_IPRSTC3_BPWM1_RST_Msk               (1ul << SYS_IPRSTC3_BPWM1_RST_Pos)  /*!< GCR_T::IPRSTC3: BPWM1_RST Mask */
S
S#define SYS_IPRSTC3_BPWM0_RST_Pos               18                                  /*!< GCR_T::IPRSTC3: BPWM0_RST Position */
S#define SYS_IPRSTC3_BPWM0_RST_Msk               (1ul << SYS_IPRSTC3_BPWM0_RST_Pos)  /*!< GCR_T::IPRSTC3: BPWM0_RST Mask */
S
S#define SYS_IPRSTC3_PWM1_RST_Pos                17                                  /*!< GCR_T::IPRSTC3: PWM1_RST Position */
S#define SYS_IPRSTC3_PWM1_RST_Msk                (1ul << SYS_IPRSTC3_PWM1_RST_Pos)   /*!< GCR_T::IPRSTC3: PWM1_RST Mask */
S
S#define SYS_IPRSTC3_PWM0_RST_Pos                16                                  /*!< GCR_T::IPRSTC3: PWM0_RST Position */
S#define SYS_IPRSTC3_PWM0_RST_Msk                (1ul << SYS_IPRSTC3_PWM0_RST_Pos)   /*!< GCR_T::IPRSTC3: PWM0_RST Mask */
S
S#define SYS_IPRSTC3_UART5_RST_Pos               10                                  /*!< GCR_T::IPRSTC3: UART5_RST Position */
S#define SYS_IPRSTC3_UART5_RST_Msk               (1ul << SYS_IPRSTC3_UART5_RST_Pos)  /*!< GCR_T::IPRSTC3: UART5_RST Mask */
S
S#define SYS_IPRSTC3_UART4_RST_Pos               9                                   /*!< GCR_T::IPRSTC3: UART4_RST Position */
S#define SYS_IPRSTC3_UART4_RST_Msk               (1ul << SYS_IPRSTC3_UART4_RST_Pos)  /*!< GCR_T::IPRSTC3: UART4_RST Mask */
S
S#define SYS_IPRSTC3_UART3_RST_Pos               8                                   /*!< GCR_T::IPRSTC3: UART3_RST Position */
S#define SYS_IPRSTC3_UART3_RST_Msk               (1ul << SYS_IPRSTC3_UART3_RST_Pos)  /*!< GCR_T::IPRSTC3: UART3_RST Mask */
S
S/* GCR BODCR Bit Field Definitions */
S#define SYS_BODCR_LVR_OUT_DG_SEL_Pos            12                                      /*!< GCR_T::BODCR: LVR_OUT_DG_SEL Position */
S#define SYS_BODCR_LVR_OUT_DG_SEL_Msk            (0x7ul << SYS_BODCR_LVR_OUT_DG_SEL_Pos) /*!< GCR_T::BODCR: LVR_OUT_DG_SEL Mask */
S
S#define SYS_BODCR_BOD_OUT_DG_SEL_Pos            8                                       /*!< GCR_T::BODCR: BOD_OUT_DG_SEL Position */
S#define SYS_BODCR_BOD_OUT_DG_SEL_Msk            (0x7ul << SYS_BODCR_BOD_OUT_DG_SEL_Pos) /*!< GCR_T::BODCR: BOD_OUT_DG_SEL Mask */
S
S#define SYS_BODCR_LVR_EN_Pos                    7                                   /*!< GCR_T::BODCR: LVR_EN Position */
S#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)       /*!< GCR_T::BODCR: LVR_EN Mask */
S
S#define SYS_BODCR_BOD_OUT_Pos                   6                                   /*!< GCR_T::BODCR: BOD_OUT Position */
S#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)      /*!< GCR_T::BODCR: BOD_OUT Mask */
S
S#define SYS_BODCR_BOD_LPM_Pos                   5                                   /*!< GCR_T::BODCR: BOD_LPM Position */
S#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)      /*!< GCR_T::BODCR: BOD_LPM Mask */
S
S#define SYS_BODCR_BOD_INTF_Pos                  4                                   /*!< GCR_T::BODCR: BOD_INTF Position */
S#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)     /*!< GCR_T::BODCR: BOD_INTF Mask */
S
S#define SYS_BODCR_BOD_RSTEN_Pos                 3                                   /*!< GCR_T::BODCR: BOD_RSTEN Position */
S#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)    /*!< GCR_T::BODCR: BOD_RSTEN Mask */
S
S#define SYS_BODCR_BOD_VL_Pos                    1                                   /*!< GCR_T::BODCR: BOD_VL Position */
S#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)       /*!< GCR_T::BODCR: BOD_VL Mask */
S
S#define SYS_BODCR_BOD_EN_Pos                    0                                   /*!< GCR_T::BODCR: BOD_EN Position */
S#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)       /*!< GCR_T::BODCR: BOD_EN Mask */
S
S/* GCR VREFCR Bit Field Definitions */
S#define SYS_VREFCR_ADC_VREFSEL_Pos              4                                       /*!< GCR_T::VREFCR: ADC_VREFSEL Position */
S#define SYS_VREFCR_ADC_VREFSEL_Msk              (1ul << SYS_VREFCR_ADC_VREFSEL_Pos)     /*!< GCR_T::VREFCR: ADC_VREFSEL Mask */
S
S/* GCR PORCR Bit Field Definitions */
S#define SYS_PORCR_POR_DIS_CODE_Pos              0                                           /*!< GCR_T::PORCR: POR_DIS_CODE Position */
S#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)    /*!< GCR_T::PORCR: POR_DIS_CODE Mask */
S
S/* GCR GPAMFP Bit Field Definitions */
S#define SYS_GPA_MFP_GPA_TYPE_Pos                 16                                         /*!< GCR_T::GPA_MFP: GPA_TYPE Position */
S#define SYS_GPA_MFP_GPA_TYPE_Msk                 (0xFFFFul << SYS_GPA_MFP_GPA_TYPE_Pos)     /*!< GCR_T::GPA_MFP: GPA_TYPE Mask */
S
S#define SYS_GPA_MFP_GPA_MFP_Pos                  0                                          /*!< GCR_T::GPA_MFP: GPA_MFP Position */
S#define SYS_GPA_MFP_GPA_MFP_Msk                  (0xFFFFul << SYS_GPA_MFP_GPA_MFP_Pos)      /*!< GCR_T::GPA_MFP: GPA_MFP Mask */
S
S/* GCR GPBMFP Bit Field Definitions */
S#define SYS_GPB_MFP_GPB_TYPE_Pos                 16                                         /*!< GCR_T::GPB_MFP: GPB_TYPE Position */
S#define SYS_GPB_MFP_GPB_TYPE_Msk                 (0xFFFFul << SYS_GPB_MFP_GPB_TYPE_Pos)     /*!< GCR_T::GPB_MFP: GPB_TYPE Mask */
S
S#define SYS_GPB_MFP_GPB_MFP_Pos                  0                                          /*!< GCR_T::GPB_MFP: GPB_MFP Position */
S#define SYS_GPB_MFP_GPB_MFP_Msk                  (0xFFFFul << SYS_GPB_MFP_GPB_MFP_Pos)      /*!< GCR_T::GPB_MFP: GPB_MFP Mask */
S
S/* GCR GPCMFP Bit Field Definitions */
S#define SYS_GPC_MFP_GPC_TYPE_Pos                 16                                         /*!< GCR_T::GPC_MFP: GPC_TYPE Position */
S#define SYS_GPC_MFP_GPC_TYPE_Msk                 (0xFFFFul << SYS_GPC_MFP_GPC_TYPE_Pos)     /*!< GCR_T::GPC_MFP: GPC_TYPE Mask */
S
S#define SYS_GPC_MFP_GPC_MFP_Pos                  0                                          /*!< GCR_T::GPC_MFP: GPC_MFP Position */
S#define SYS_GPC_MFP_GPC_MFP_Msk                  (0xFFFFul << SYS_GPC_MFP_GPC_MFP_Pos)      /*!< GCR_T::GPC_MFP: GPC_MFP Mask */
S
S/* GCR GPDMFP Bit Field Definitions */
S#define SYS_GPD_MFP_GPD_TYPE_Pos                 16                                         /*!< GCR_T::GPD_MFP: GPD_TYPE Position */
S#define SYS_GPD_MFP_GPD_TYPE_Msk                 (0xFFFFul << SYS_GPD_MFP_GPD_TYPE_Pos)     /*!< GCR_T::GPD_MFP: GPD_TYPE Mask */
S
S#define SYS_GPD_MFP_GPD_MFP_Pos                  0                                          /*!< GCR_T::GPD_MFP: GPD_MFP Position */
S#define SYS_GPD_MFP_GPD_MFP_Msk                  (0xFFFFul << SYS_GPD_MFP_GPD_MFP_Pos)      /*!< GCR_T::GPD_MFP: GPD_MFP Mask */
S
S/* GCR GPEMFP Bit Field Definitions */
S#define SYS_GPE_MFP_GPE_TYPE_Pos                 16                                         /*!< GCR_T::GPE_MFP: GPE_TYPE Position */
S#define SYS_GPE_MFP_GPE_TYPE_Msk                 (0xFFFFul << SYS_GPE_MFP_GPE_TYPE_Pos)     /*!< GCR_T::GPE_MFP: GPE_TYPE Mask */
S
S#define SYS_GPE_MFP_GPE_MFP5_Pos                 5                                          /*!< GCR_T::GPE_MFP: GPE_MFP5 Position */
S#define SYS_GPE_MFP_GPE_MFP5_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP5_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP5 Mask */
S
S/* GCR GPFMFP Bit Field Definitions */
S#define SYS_GPF_MFP_GPF_TYPE_Pos                 16                                         /*!< GCR_T::GPF_MFP: GPF_TYPE Position */
S#define SYS_GPF_MFP_GPF_TYPE_Msk                 (0x1Ful << SYS_GPF_MFP_GPF_TYPE_Pos)       /*!< GCR_T::GPF_MFP: GPF_TYPE Mask */
S
S#define SYS_GPF_MFP_GPF_MFP_Pos                  0                                          /*!< GCR_T::GPF_MFP: GPF_MFP Position */
S#define SYS_GPF_MFP_GPF_MFP_Msk                  (0x1Ful << SYS_GPF_MFP_GPF_MFP_Pos)        /*!< GCR_T::GPF_MFP: GPF_MFP Mask */
S
S/* GCR ALTMFP Bit Field Definitions */
S#define SYS_ALT_MFP_PB8_CLKO_Pos                29                                          /*!< GCR_T::ALT_MFP: PB8_CLKO Position */
S#define SYS_ALT_MFP_PB8_CLKO_Msk                (1ul << SYS_ALT_MFP_PB8_CLKO_Pos)           /*!< GCR_T::ALT_MFP: PB8_CLKO Mask */
S
S#define SYS_ALT_MFP_PB3_T3EX_Pos                 27                                         /*!< GCR_T::ALT_MFP: PB3_T3EX Position */
S#define SYS_ALT_MFP_PB3_T3EX_Msk                 (1ul << SYS_ALT_MFP_PB3_T3EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
S
S#define SYS_ALT_MFP_PB2_T2EX_Pos                 26                                         /*!< GCR_T::ALT_MFP: PB2_T2EX Position */
S#define SYS_ALT_MFP_PB2_T2EX_Msk                 (1ul << SYS_ALT_MFP_PB2_T2EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
S
S#define SYS_ALT_MFP_PE5_T1EX_Pos                 25                                         /*!< GCR_T::ALT_MFP: PE5_T1EX Position */
S#define SYS_ALT_MFP_PE5_T1EX_Msk                 (1ul << SYS_ALT_MFP_PE5_T1EX_Pos)          /*!< GCR_T::ALT_MFP: PE5_T1EX Mask */
S
S#define SYS_ALT_MFP_PB15_T0EX_Pos                24                                         /*!< GCR_T::ALT_MFP: PB15_T0EX Position */
S#define SYS_ALT_MFP_PB15_T0EX_Msk                (1ul << SYS_ALT_MFP_PB15_T0EX_Pos)         /*!< GCR_T::ALT_MFP: PB15_T0EX Mask */
S
S/* GCR ALTMFP2 Bit Field Definitions */
S#define SYS_ALT_MFP2_PB3_TM3_Pos                5                                           /*!< GCR_T::ALT_MFP2: PB3_TM3 Position */
S#define SYS_ALT_MFP2_PB3_TM3_Msk                (1ul << SYS_ALT_MFP2_PB3_TM3_Pos)           /*!< GCR_T::ALT_MFP2: PB3_TM3 Mask */
S
S#define SYS_ALT_MFP2_PB2_TM2_Pos                4                                           /*!< GCR_T::ALT_MFP2: PB2_TM2 Position */
S#define SYS_ALT_MFP2_PB2_TM2_Msk                (1ul << SYS_ALT_MFP2_PB2_TM2_Pos)           /*!< GCR_T::ALT_MFP2: PB2_TM2 Mask */
S
S#define SYS_ALT_MFP2_PE5_TM1_Pos                3                                           /*!< GCR_T::ALT_MFP2: PE5_TM1 Position */
S#define SYS_ALT_MFP2_PE5_TM1_Msk                (1ul << SYS_ALT_MFP2_PE5_TM1_Pos)           /*!< GCR_T::ALT_MFP2: PE5_TM1 Mask */
S
S#define SYS_ALT_MFP2_PB15_TM0_Pos               2                                           /*!< GCR_T::ALT_MFP2: PB15_TM0 Position */
S#define SYS_ALT_MFP2_PB15_TM0_Msk               (1ul << SYS_ALT_MFP2_PB15_TM0_Pos)          /*!< GCR_T::ALT_MFP2: PB15_TM0 Mask */
S
S/* GCR ALTMFP3 Bit Field Definitions */
S#define SYS_ALT_MFP3_PB2_PWM1BK1_Pos            31                                          /*!< GCR_T::ALT_MFP3: PB2_PWM1BK1 Position */
S#define SYS_ALT_MFP3_PB2_PWM1BK1_Msk            (1ul << SYS_ALT_MFP3_PB2_PWM1BK1_Pos)       /*!< GCR_T::ALT_MFP3: PB2_PWM1BK1 Mask */
S
S#define SYS_ALT_MFP3_PB3_PWM1BK0_Pos            30                                          /*!< GCR_T::ALT_MFP3: PB3_PWM1BK0 Position */
S#define SYS_ALT_MFP3_PB3_PWM1BK0_Msk            (1ul << SYS_ALT_MFP3_PB3_PWM1BK0_Pos)       /*!< GCR_T::ALT_MFP3: PB3_PWM1BK0 Mask */
S
S#define SYS_ALT_MFP3_PC7_PWM0BK1_Pos            29                                          /*!< GCR_T::ALT_MFP3: PC7_PWM0BK1 Position */
S#define SYS_ALT_MFP3_PC7_PWM0BK1_Msk            (1ul << SYS_ALT_MFP3_PC7_PWM0BK1_Pos)       /*!< GCR_T::ALT_MFP3: PC7_PWM0BK1 Mask */
S
S#define SYS_ALT_MFP3_PC6_PWM0BK0_Pos            28                                          /*!< GCR_T::ALT_MFP3: PC6_PWM0BK0 Position */
S#define SYS_ALT_MFP3_PC6_PWM0BK0_Msk            (1ul << SYS_ALT_MFP3_PC6_PWM0BK0_Pos)       /*!< GCR_T::ALT_MFP3: PC6_PWM0BK0 Mask */
S
S#define SYS_ALT_MFP3_PB11_PWM04_Pos             24                                          /*!< GCR_T::ALT_MFP3: PB11_PWM04 Position */
S#define SYS_ALT_MFP3_PB11_PWM04_Msk             (1ul << SYS_ALT_MFP3_PB11_PWM04_Pos)        /*!< GCR_T::ALT_MFP3: PB11_PWM04 Mask */
S
S#define SYS_ALT_MFP3_PB15_BPWM15_Pos            23                                          /*!< GCR_T::ALT_MFP3: PFB15_BPWM15 Position */
S#define SYS_ALT_MFP3_PB15_BPWM15_Msk            (1ul << SYS_ALT_MFP3_PB15_BPWM15_Pos)       /*!< GCR_T::ALT_MFP3: PB15_BPWM15 Mask */
S
S#define SYS_ALT_MFP3_PF8_BPWM14_Pos             22                                          /*!< GCR_T::ALT_MFP3: PF8_BPWM14 Position */
S#define SYS_ALT_MFP3_PF8_BPWM14_Msk             (1ul << SYS_ALT_MFP3_PF8_BPWM14_Pos)        /*!< GCR_T::ALT_MFP3: PF8_BPWM14 Mask */
S
S#define SYS_ALT_MFP3_PB12_BPWM13_Pos            21                                          /*!< GCR_T::ALT_MFP3: PB12_BPWM13 Position */
S#define SYS_ALT_MFP3_PB12_BPWM13_Msk            (1ul << SYS_ALT_MFP3_PB12_BPWM13_Pos)       /*!< GCR_T::ALT_MFP3: PB12_BPWM13 Mask */
S
S#define SYS_ALT_MFP3_PB8_BPWM12_Pos             20                                          /*!< GCR_T::ALT_MFP3: PB8_BPWM12 Position */
S#define SYS_ALT_MFP3_PB8_BPWM12_Msk             (1ul << SYS_ALT_MFP3_PB8_BPWM12_Pos)        /*!< GCR_T::ALT_MFP3: PB8_BPWM12 Mask */
S
S#define SYS_ALT_MFP3_PD6_BPWM11_Pos             19                                          /*!< GCR_T::ALT_MFP3: PD6_BPWM11 Position */
S#define SYS_ALT_MFP3_PD6_BPWM11_Msk             (1ul << SYS_ALT_MFP3_PD6_BPWM11_Pos)        /*!< GCR_T::ALT_MFP3: PD6_BPWM11 Mask */
S
S#define SYS_ALT_MFP3_PD7_BPWM10_Pos             18                                          /*!< GCR_T::ALT_MFP3: PD7_BPWM10 Position */
S#define SYS_ALT_MFP3_PD7_BPWM10_Msk             (1ul << SYS_ALT_MFP3_PD7_BPWM10_Pos)        /*!< GCR_T::ALT_MFP3: PD7_BPWM10 Mask */
S
S#define SYS_ALT_MFP3_PD14_BPWM05_Pos            17                                          /*!< GCR_T::ALT_MFP3: PD14_BPWM05 Position */
S#define SYS_ALT_MFP3_PD14_BPWM05_Msk            (1ul << SYS_ALT_MFP3_PD14_BPWM05_Pos)       /*!< GCR_T::ALT_MFP3: PD14_BPWM05 Mask */
S
S#define SYS_ALT_MFP3_PD15_BPWM04_Pos            16                                          /*!< GCR_T::ALT_MFP3: PD15_BPWM04 Position */
S#define SYS_ALT_MFP3_PD15_BPWM04_Msk            (1ul << SYS_ALT_MFP3_PD15_BPWM04_Pos)       /*!< GCR_T::ALT_MFP3: PD15_BPWM04 Mask */
S
S#define SYS_ALT_MFP3_PC3_BPWM03_Pos             15                                          /*!< GCR_T::ALT_MFP3: PC3_BPWM03 Position */
S#define SYS_ALT_MFP3_PC3_BPWM03_Msk             (1ul << SYS_ALT_MFP3_PC3_BPWM03_Pos)        /*!< GCR_T::ALT_MFP3: PC3_BPWM03 Mask */
S
S#define SYS_ALT_MFP3_PC2_BPWM02_Pos             14                                          /*!< GCR_T::ALT_MFP3: PC2_BPWM02 Position */
S#define SYS_ALT_MFP3_PC2_BPWM02_Msk             (1ul << SYS_ALT_MFP3_PC2_BPWM02_Pos)        /*!< GCR_T::ALT_MFP3: PC2_BPWM02 Mask */
S
S#define SYS_ALT_MFP3_PC1_BPWM01_Pos             13                                          /*!< GCR_T::ALT_MFP3: PC1_BPWM01 Position */
S#define SYS_ALT_MFP3_PC1_BPWM01_Msk             (1ul << SYS_ALT_MFP3_PC1_BPWM01_Pos)        /*!< GCR_T::ALT_MFP3: PC1_BPWM01 Mask */
S
S#define SYS_ALT_MFP3_PC0_BPWM00_Pos             12                                          /*!< GCR_T::ALT_MFP3: PC0_BPWM00 Position */
S#define SYS_ALT_MFP3_PC0_BPWM00_Msk             (1ul << SYS_ALT_MFP3_PC0_BPWM00_Pos)        /*!< GCR_T::ALT_MFP3: PC0_BPWM00 Mask */
S
S#define SYS_ALT_MFP3_PF5_PWM15_Pos              11                                          /*!< GCR_T::ALT_MFP3: PF5_PWM15 Position */
S#define SYS_ALT_MFP3_PF5_PWM15_Msk              (1ul << SYS_ALT_MFP3_PF5_PWM15_Pos)         /*!< GCR_T::ALT_MFP3: PF5_PWM15 Mask */
S
S#define SYS_ALT_MFP3_PF4_PWM14_Pos              10                                          /*!< GCR_T::ALT_MFP3: PF5_PWM14 Position */
S#define SYS_ALT_MFP3_PF4_PWM14_Msk              (1ul << SYS_ALT_MFP3_PF4_PWM14_Pos)         /*!< GCR_T::ALT_MFP3: PF5_PWM14 Mask */
S
S#define SYS_ALT_MFP3_PA11_PWM13_Pos             9                                           /*!< GCR_T::ALT_MFP3: PA11_PWM13 Position */
S#define SYS_ALT_MFP3_PA11_PWM13_Msk             (1ul << SYS_ALT_MFP3_PA11_PWM13_Pos)        /*!< GCR_T::ALT_MFP3: PA11_PWM13 Mask */
S
S#define SYS_ALT_MFP3_PA10_PWM12_Pos             8                                           /*!< GCR_T::ALT_MFP3: PA10_PWM12 Position */
S#define SYS_ALT_MFP3_PA10_PWM12_Msk             (1ul << SYS_ALT_MFP3_PA10_PWM12_Pos)        /*!< GCR_T::ALT_MFP3: PA10_PWM12 Mask */
S
S#define SYS_ALT_MFP3_PA3_PWM11_Pos              7                                           /*!< GCR_T::ALT_MFP3: PA3_PWM11 Position */
S#define SYS_ALT_MFP3_PA3_PWM11_Msk              (1ul << SYS_ALT_MFP3_PA3_PWM11_Pos)         /*!< GCR_T::ALT_MFP3: PA3_PWM11 Mask */
S
S#define SYS_ALT_MFP3_PA2_PWM10_Pos              6                                           /*!< GCR_T::ALT_MFP3: PA2_PWM10 Position */
S#define SYS_ALT_MFP3_PA2_PWM10_Msk              (1ul << SYS_ALT_MFP3_PA2_PWM10_Pos)         /*!< GCR_T::ALT_MFP3: PA2_PWM10 Mask */
S
S#define SYS_ALT_MFP3_PA1_PWM05_Pos              5                                           /*!< GCR_T::ALT_MFP3: PA1_PWM05 Position */
S#define SYS_ALT_MFP3_PA1_PWM05_Msk              (1ul << SYS_ALT_MFP3_PA1_PWM05_Pos)         /*!< GCR_T::ALT_MFP3: PA1_PWM05 Mask */
S
S#define SYS_ALT_MFP3_PA0_PWM04_Pos              4                                           /*!< GCR_T::ALT_MFP3: PA0_PWM04 Position */
S#define SYS_ALT_MFP3_PA0_PWM04_Msk              (1ul << SYS_ALT_MFP3_PA0_PWM04_Pos)         /*!< GCR_T::ALT_MFP3: PA0_PWM04 Mask */
S
S/* GCR ALTMFP4 Bit Field Definitions */
S#define SYS_ALT_MFP4_PA7_VREF_Pos               14                                          /*!< GCR_T::ALT_MFP4: PA7_VREF Position */
S#define SYS_ALT_MFP4_PA7_VREF_Msk               (1ul << SYS_ALT_MFP4_PA7_VREF_Pos)          /*!< GCR_T::ALT_MFP4: PA7_VREF Mask */
S
S#define SYS_ALT_MFP4_PA1_I2C1SDA_Pos            13                                          /*!< GCR_T::ALT_MFP4: PA1_I2C1SDA Position */
S#define SYS_ALT_MFP4_PA1_I2C1SDA_Msk            (1ul << SYS_ALT_MFP4_PA1_I2C1SDA_Pos)       /*!< GCR_T::ALT_MFP4: PA1_I2C1SDA Mask */
S
S#define SYS_ALT_MFP4_PA0_I2C1SCL_Pos            12                                          /*!< GCR_T::ALT_MFP4: PA0_I2C1SCL Position */
S#define SYS_ALT_MFP4_PA0_I2C1SCL_Msk            (1ul << SYS_ALT_MFP4_PA0_I2C1SCL_Pos)       /*!< GCR_T::ALT_MFP4: PA0_I2C1SCL Mask */
S
S#define SYS_ALT_MFP4_PC7_I2C0SCL_Pos            11                                          /*!< GCR_T::ALT_MFP4: PC7_I2C0SCL Position */
S#define SYS_ALT_MFP4_PC7_I2C0SCL_Msk            (1ul << SYS_ALT_MFP4_PC7_I2C0SCL_Pos)       /*!< GCR_T::ALT_MFP4: PC7_I2C0SCL Mask */
S
S#define SYS_ALT_MFP4_PC6_I2C0SDA_Pos            10                                          /*!< GCR_T::ALT_MFP4: PC6_I2C0SDA Position */
S#define SYS_ALT_MFP4_PC6_I2C0SDA_Msk            (1ul << SYS_ALT_MFP4_PC6_I2C0SDA_Pos)       /*!< GCR_T::ALT_MFP4: PC6_I2C0SDA Mask */
S
S#define SYS_ALT_MFP4_PA13_UR5TXD_Pos            9                                           /*!< GCR_T::ALT_MFP4: PA13_UR5TXD Position */
S#define SYS_ALT_MFP4_PA13_UR5TXD_Msk            (1ul << SYS_ALT_MFP4_PA13_UR5TXD_Pos)       /*!< GCR_T::ALT_MFP4: PA13_UR5TXD Mask */
S
S#define SYS_ALT_MFP4_PA12_UR5RXD_Pos            8                                           /*!< GCR_T::ALT_MFP4: PA12_UR5RXD Position */
S#define SYS_ALT_MFP4_PA12_UR5RXD_Msk            (1ul << SYS_ALT_MFP4_PA12_UR5RXD_Pos)       /*!< GCR_T::ALT_MFP4: PA12_UR5RXD Mask */
S
S#define SYS_ALT_MFP4_PA0_UR5TXD_Pos             7                                           /*!< GCR_T::ALT_MFP4: PA0_UR5TXD Position */
S#define SYS_ALT_MFP4_PA0_UR5TXD_Msk             (1ul << SYS_ALT_MFP4_PA0_UR5TXD_Pos)        /*!< GCR_T::ALT_MFP4: PA0_UR5TXD Mask */
S
S#define SYS_ALT_MFP4_PA1_UR5RXD_Pos             6                                           /*!< GCR_T::ALT_MFP4: PA1_UR5RXD Position */
S#define SYS_ALT_MFP4_PA1_UR5RXD_Msk             (1ul << SYS_ALT_MFP4_PA1_UR5RXD_Pos)        /*!< GCR_T::ALT_MFP4: PA1_UR5RXD Mask */
S
S#define SYS_ALT_MFP4_PA6_UR3TXD_Pos             5                                           /*!< GCR_T::ALT_MFP4: PA6_UR3TXD Position */
S#define SYS_ALT_MFP4_PA6_UR3TXD_Msk             (1ul << SYS_ALT_MFP4_PA6_UR3TXD_Pos)        /*!< GCR_T::ALT_MFP4: PA6_UR3TXD Mask */
S
S#define SYS_ALT_MFP4_PA5_UR3RXD_Pos             4                                           /*!< GCR_T::ALT_MFP4: PA5_UR3RXD Position */
S#define SYS_ALT_MFP4_PA5_UR3RXD_Msk             (1ul << SYS_ALT_MFP4_PA5_UR3RXD_Pos)        /*!< GCR_T::ALT_MFP4: PA5_UR3RXD Mask */
S
S#define SYS_ALT_MFP4_PA2_UR3TXD_Pos             3                                           /*!< GCR_T::ALT_MFP4: PA2_UR3TXD Position */
S#define SYS_ALT_MFP4_PA2_UR3TXD_Msk             (1ul << SYS_ALT_MFP4_PA2_UR3TXD_Pos)        /*!< GCR_T::ALT_MFP4: PA2_UR3TXD Mask */
S
S#define SYS_ALT_MFP4_PA3_UR3RXD_Pos             2                                           /*!< GCR_T::ALT_MFP4: PA3_UR3RXD Position */
S#define SYS_ALT_MFP4_PA3_UR3RXD_Msk             (1ul << SYS_ALT_MFP4_PA3_UR3RXD_Pos)        /*!< GCR_T::ALT_MFP4: PA3_UR3RXD Mask */
S
S#define SYS_ALT_MFP4_PA9_UR1CTS_Pos             1                                           /*!< GCR_T::ALT_MFP4: PA9_UR1CTS Position */
S#define SYS_ALT_MFP4_PA9_UR1CTS_Msk             (1ul << SYS_ALT_MFP4_PA9_UR1CTS_Pos)        /*!< GCR_T::ALT_MFP4: PA9_UR1CTS Mask */
S
S#define SYS_ALT_MFP4_PA8_UR1RTS_Pos             0                                           /*!< GCR_T::ALT_MFP4: PA8_UR1RTS Position */
S#define SYS_ALT_MFP4_PA8_UR1RTS_Msk             (1ul << SYS_ALT_MFP4_PA8_UR1RTS_Pos)        /*!< GCR_T::ALT_MFP4: PA8_UR1RTS Mask */
S
S/* GCR REGWRPROT Bit Field Definitions */
S#define SYS_REGWRPROT_REGWRPROT_Pos             0                                           /*!< GCR_T::REGWRPROT: REGWRPROT Position */
S#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos)     /*!< GCR_T::REGWRPROT: REGWRPROT Mask */
S
S#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                           /*!< GCR_T::REGWRPROT: REGPROTDIS Position */
S#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)       /*!< GCR_T::REGWRPROT: REGPROTDIS Mask */
S
S/*@}*/ /* end of group SYS_CONST */
S
Stypedef struct
S{
S    /**
S     * IRQSRC
S     * ===================================================================================================
S     * Offset: 0x00~0x7C  IRQ0~IRQ31 Interrupt Source Identity
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |INTSRC    |Interrupt Source
S     * |        |          |Define the interrupt sources for interrupt event.
S     */
S    __I uint32_t IRQSRC[32];
S
S    /**
S     * NMISEL
S     * ===================================================================================================
S     * Offset: 0x80  NMI Source Interrupt Select Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[4:0]   |NMISEL    |NMI Interrupt Source Selection
S     * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMISEL.
S     * |[8]     |NMIEN     |NMI Interrupt Enable Bit (Write Protect)
S     * |        |          |0 = NMI interrupt Disabled.
S     * |        |          |1 = NMI interrupt Enabled.
S     * |        |          |Note: This bit is the protected bit, and programming it needs to write "59h", "16h", and "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Refer to the register REGWRPROT at address GCR_BA+0x100.
S     */
S    __IO uint32_t NMISEL;
S
S    /**
S     * MCUIRQ
S     * ===================================================================================================
S     * Offset: 0x84  MCU Interrupt Request Source Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |MCUIRQ    |MCU IRQ Source Register
S     * |        |          |The MCUIRQ collects all the interrupts from the peripherals and generates the synchronous interrupt to Cortex-M0.
S     * |        |          |There are two modes to generate interrupt to Cortex-M0, the normal mode and test mode.
S     * |        |          |The MCUIRQ collects all interrupts from each peripheral and synchronizes them and interrupts the Cortex-M0.
S     * |        |          |When the MCU_IRQ[n] is 0: Set MCU_IRQ[n] 1 will generate an interrupt to Cortex-M0 NVIC[n].
S     * |        |          |When the MCU_IRQ[n] is 1 (mean an interrupt is assert), setting 1 to the MCU_IRQ[n] 1 will clear the interrupt and setting MCUIRQ[n] 0: has no effect.
S     */
S    __IO uint32_t MCUIRQ;
S
S    /**
S     * MCUIRQCR
S     * ===================================================================================================
S     * Offset: 0x88  MCU Interrupt Request Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |FASTIRQ   |Fast IRQ Latency Enable Bit
S     * |        |          |0 = MCU IRQ latency is fixed at 13 clock cycles of HCLK, MCU will enter IRQ handler after this fixed latency when interrupt happened.
S     * |        |          |1 = MCU IRQ latency will not fixed, MCU will enter IRQ handler as soon as possible when interrupt happened.
S     */
S    __IO uint32_t MCUIRQCR;
S
S} GCR_INT_T;
S
S/**
S    @addtogroup INT_CONST System Interrupt Bit Field Definition
S    Constant Definitions for SYS Interrupt Controller
S@{ */
S
S/* INT IRQSRC Bit Field Definitions */
S#define INT_IRQSRC_INTSRC_Pos                   0                                   /*!< GCR_INT_T::IRQSRC: INTSRC Position */
S#define INT_IRQSRC_INTSRC_Msk                   (0xFul << INT_IRQSRC_INTSRC_Pos)    /*!< GCR_INT_T::IRQSRC: INTSRC Mask */
S
S/* INT NMISEL Bit Field Definitions */
S#define INT_NMISEL_NMIEN_Pos                    8                                   /*!< GCR_INT_T::NMISEL: NMIEN Position */
S#define INT_NMISEL_NMIEN_Msk                    (1ul << INT_NMISEL_NMIEN_Pos)       /*!< GCR_INT_T::NMISEL: NMIEN Mask */
S
S#define INT_NMISEL_NMISEL_Pos                   0                                   /*!< GCR_INT_T::NMISEL: NMISEL Position */
S#define INT_NMISEL_NMISEL_Msk                   (0x1Ful << INT_NMISEL_NMISEL_Pos)   /*!< GCR_INT_T::NMISEL: NMISEL Mask */
S
S/* INT MCUIRQ Bit Field Definitions */
S#define INT_MCUIRQ_MCUIRQ_Pos                   0                                       /*!< GCR_INT_T::MCUIRQ: MCUIRQ Position */
S#define INT_MCUIRQ_MCUIRQ_Msk                   (0xFFFFFFFFul << INT_MCUIRQ_MCUIRQ_Pos) /*!< GCR_INT_T::MCUIRQ: MCUIRQ Mask */
S
S/* INT MCUIRQCR Bit Field Definitions */
S#define INT_MCUIRQCR_FASTIRQ_Pos                0                                   /*!< GCR_INT_T::MCUIRQCR: FASTIRQ Position */
S#define INT_MCUIRQCR_FASTIRQ_Msk                (1ul << INT_MCUIRQCR_FASTIRQ_Pos)   /*!< GCR_INT_T::MCUIRQCR: FASTIRQ Mask */
S/*@}*/ /* end of group INT_CONST */
S/*@}*/ /* end of group SYS */
S
S
S
S
S/*----------------------------- Timer Controller (TIMER) -----------------------------*/
S/** @addtogroup TIMER Timer Controller (TIMER)
S  Memory Mapped Structure for Timer Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * TCSR
S     * ===================================================================================================
S     * Offset: 0x00  Timer Control and Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |PRESCALE  |Prescale Counter
S     * |        |          |Timer input clock source is divided by (PRESCALE+1) before it is fed to the Timer up counter.
S     * |        |          |If this field is 0 (PRESCALE = 0), then there is no scaling.
S     * |[16]    |TDR_EN    |Data Load Enable Control
S     * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting.
S     * |        |          |0 = Timer Data Register update Disabled.
S     * |        |          |1 = Timer Data Register update Enabled while Timer counter is active.
S     * |[18]    |TRG_SRC_SEL    |Trigger Source Select Bit
S     * |        |               |This bit is used to select trigger source is form timer time-out interrupt signal or capture interrupt signal.
S     * |        |               |0 = Timer time-out interrupt signal is used to trigger PWM.
S     * |        |               |1 = Capture interrupt signal is used to trigger PWM.
S     * |[19]    |TRG_PWM_EN     |Trigger PWM Enable Bit
S     * |        |               |If this bit is set to 1, timer time-out interrupt or capture interrupt can be triggered PWM.
S     * |        |               |0 = Timer interrupt trigger PWM Disabled.
S     * |        |               |1 = Timer interrupt trigger PWM Enabled.
S     * |[23]    |WAKE_EN   |Wake Up Function Enable Control
S     * |        |          |0 = Wake-up trigger event Disabled.
S     * |        |          |1 = Wake-up trigger event Enabled.
S     * |[24]    |CTB       |Counter Mode Enable Control
S     * |        |          |This bit is for external counting pin function enabled.
S     * |        |          |When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer clock source.
S     * |        |          |0 = External counter mode Disabled.
S     * |        |          |1 = External counter mode Enabled.
S     * |[25]    |CACT      |Timer Active Status (Read Only)
S     * |        |          |This bit indicates the 24-bit up counter status.
S     * |        |          |0 = 24-bit up counter is not active.
S     * |        |          |1 = 24-bit up counter is active.
S     * |[26]    |CRST      |Timer Reset
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1.
S     * |[28:27] |MODE      |Timer Operating Mode
S     * |        |          |00 = The Timer controller is operated in One-shot mode.
S     * |        |          |01 = The Timer controller is operated in Periodic mode.
S     * |        |          |10 = The Timer controller is operated in Toggle-output mode.
S     * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
S     * |[29]    |IE        |Interrupt Enable Control
S     * |        |          |0 = Timer Interrupt function Disabled.
S     * |        |          |1 = Timer Interrupt function Enabled.
S     * |        |          |If this bit is enabled, when the timer interrupt flag (TISR[0] TIF) is set to 1, the timer interrupt signal is generated and inform to CPU.
S     * |[30]    |CEN       |Timer Enable Control
S     * |        |          |0 = Stops/Suspends counting.
S     * |        |          |1 = Starts counting.
S     * |        |          |Note1: In stop status, and then set CEN to 1 will enable the 24-bit up counter to keep counting from the last stop counting value.
S     * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TCSR [28:27] = 00) when the timer interrupt flag (TISR[0] TIF) is generated.
S     * |[31]    |DBGACK_TMR|ICE Debug Mode Acknowledge Disable (Write Protect)
S     * |        |          |0 = ICE debug mode acknowledgment effects TIMER counting.
S     * |        |          |TIMER counter will be held while CPU is held by ICE.
S     * |        |          |1 = ICE debug mode acknowledgment Disabled.
S     * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
S     */
S    __IO uint32_t  TCSR;
S
S    /**
S     * TCMPR
S     * ===================================================================================================
S     * Offset: 0x04  Timer Compare Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |TCMP      |Timer Compared Value
S     * |        |          |TCMP is a 24-bit compared value register.
S     * |        |          |When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.
S     * |        |          |Time-out period = (Period of Timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP).
S     * |        |          |Note1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.
S     * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep counting continuously even if user writes a new value into TCMP field.
S     * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting and using newest TCMP value to be the timer compared value if user writes a new value into TCMP field.
S     */
S    __IO uint32_t  TCMPR;
S
S    /**
S     * TISR
S     * ===================================================================================================
S     * Offset: 0x08  Timer Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TIF       |Timer Interrupt Flag
S     * |        |          |This bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.
S     * |        |          |0 = No effect.
S     * |        |          |1 = TDR value matches the TCMP value.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[1]     |TWF       |Timer Wake-Up Flag
S     * |        |          |This bit indicates the interrupt wake-up flag status of Timer.
S     * |        |          |0 = Timer does not cause CPU wake-up.
S     * |        |          |1 = CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     */
S    __IO uint32_t  TISR;
S
S    /**
S     * TDR
S     * ===================================================================================================
S     * Offset: 0x0C  Timer Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |TDR       |Timer Data Register
S     * |        |          |If TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up counter value.
S     */
S    __I  uint32_t  TDR;
S
S    /**
S     * TCAP
S     * ===================================================================================================
S     * Offset: 0x10  Timer Capture Data Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[23:0]  |TCAP      |Timer Capture Data Register
S     * |        |          |When TEXIF flag is set to 1, the current TDR value will be auto-loaded into this TCAP filed immediately.
S     */
S    __I  uint32_t  TCAP;
S
S    /**
S     * TEXCON
S     * ===================================================================================================
S     * Offset: 0x14  Timer External Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TX_PHASE  |Timer External Count Pin Phase Detect Selection
S     * |        |          |This bit indicates the detection phase of TMx pin.
S     * |        |          |0 = A falling edge of TMx pin will be counted.
S     * |        |          |1 = A rising edge of TMx pin will be counted.
S     * |[2:1]   |TEX_EDGE  |Timer External Capture Pin Edge Detect Selection
S     * |        |          |00 = A 1 to 0 transition on TMx_EXT pin will be detected.
S     * |        |          |01 = A 0 to 1 transition on TMx_EXT pin will be detected.
S     * |        |          |10 = Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected.
S     * |        |          |11 = Reserved.
S     * |[3]     |TEXEN     |Timer External Pin Function Enable
S     * |        |          |This bit enables the RSTCAPSEL function on the TxEX pin.
S     * |        |          |0 = RSTCAPSEL function of TxEX pin will be ignored.
S     * |        |          |1 = RSTCAPSEL function of TxEX pin is active.
S     * |[4]     |RSTCAPSEL |Timer External Reset Counter / Timer External Capture Mode Selection
S     * |        |          |0 = Transition on TMx_EXT pin is using to save the TDR value into TCAP value if TEXIF flag is set to 1.
S     * |        |          |1 = Transition on TMx_EXT pin is using to reset the 24-bit up counter.
S     * |[5]     |TEXIEN    |Timer External Capture Interrupt Enable Control
S     * |        |          |0 = TMx_EXT pin detection Interrupt Disabled.
S     * |        |          |1 = TMx_EXT pin detection Interrupt Enabled.
S     * |        |          |If TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while TEXIF flag is set to 1.
S     * |[6]     |TEXDB     |Timer External Capture Input Pin De-Bounce Enable Control
S     * |        |          |0 = TMx_EXT pin de-bounce Disabled.
S     * |        |          |1 = TMx_EXT pin de-bounce Enabled.
S     * |        |          |If this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.
S     * |[7]     |TCDB      |Timer External Counter Input Pin De-Bounce Enable Control
S     * |        |          |0 = TMx pin de-bounce Disabled.
S     * |        |          |1 = TMx pin de-bounce Enabled.
S     * |        |          |If this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.
S     */
S    __IO uint32_t  TEXCON;
S
S    /**
S     * TEXISR
S     * ===================================================================================================
S     * Offset: 0x18  Timer External Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |TEXIF     |Timer External Capture Interrupt Flag
S     * |        |          |This bit indicates the external capture interrupt flag status.
S     * |        |          |When TEXEN enabled, TMx_EXT pin selected as external capture function, and a transition on TMx_EXT pin matched the TEX_EDGE setting, this flag will set to 1 by hardware.
S     * |        |          |0 = TMx_EXT pin interrupt did not occur.
S     * |        |          |1 = TMx_EXT pin interrupt occurred.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     */
S    __IO uint32_t  TEXISR;
S} TIMER_T;
S
S
S/** @addtogroup TIMER_CONST TIMER Bit Field Definition
S    Constant Definitions for TIMER Controller
S  @{
S */
S
S/* TIMER TCSR Bit Field Definitions */
S#define TIMER_TCSR_DBGACK_TMR_Pos   31                                          /*!< TIMER_T::TCSR: DBGACK_TMR Position */
S#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER_T::TCSR: DBGACK_TMR Mask */
S
S#define TIMER_TCSR_CEN_Pos          30                                          /*!< TIMER_T::TCSR: CEN Position */
S#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)                 /*!< TIMER_T::TCSR: CEN Mask */
S
S#define TIMER_TCSR_IE_Pos           29                                          /*!< TIMER_T::TCSR: IE Position */
S#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)                  /*!< TIMER_T::TCSR: IE Mask */
S
S#define TIMER_TCSR_MODE_Pos         27                                          /*!< TIMER_T::TCSR: MODE Position */
S#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)              /*!< TIMER_T::TCSR: MODE Mask */
S
S#define TIMER_TCSR_CRST_Pos         26                                          /*!< TIMER_T::TCSR: CRST Position */
S#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)                /*!< TIMER_T::TCSR: CRST Mask */
S
S#define TIMER_TCSR_CACT_Pos         25                                          /*!< TIMER_T::TCSR: CACT Position */
S#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)                /*!< TIMER_T::TCSR: CACT Mask */
S
S#define TIMER_TCSR_CTB_Pos          24                                          /*!< TIMER_T::TCSR: CTB Position */
S#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)                 /*!< TIMER_T::TCSR: CTB Mask */
S
S#define TIMER_TCSR_WAKE_EN_Pos      23                                          /*!< TIMER_T::TCSR: WAKE_EN Position */
S#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)             /*!< TIMER_T::TCSR: WAKE_EN Mask */
S
S#define TIMER_TCSR_TRG_PWM_EN_Pos   19                                          /*!< TIMER_T::TCSR: TRG_PWM_EN Position */
S#define TIMER_TCSR_TRG_PWM_EN_Msk   (1ul << TIMER_TCSR_TRG_PWM_EN_Pos)          /*!< TIMER_T::TCSR: TRG_PWM_EN Mask */
S
S#define TIMER_TCSR_TRG_SRC_SEL_Pos  18                                          /*!< TIMER_T::TCSR: TRG_SRC_SEL Position */
S#define TIMER_TCSR_TRG_SRC_SEL_Msk  (1ul << TIMER_TCSR_TRG_SRC_SEL_Pos)         /*!< TIMER_T::TCSR: TRG_SRC_SEL Mask */
S
S#define TIMER_TCSR_TDR_EN_Pos       16                                          /*!< TIMER_T::TCSR: TDR_EN Position */
S#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)              /*!< TIMER_T::TCSR: TDR_EN Mask */
S
S#define TIMER_TCSR_PRESCALE_Pos     0                                           /*!< TIMER_T::TCSR: PRESCALE Position */
S#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)         /*!< TIMER_T::TCSR: PRESCALE Mask */
S
S/* TIMER TCMPR Bit Field Definitions */
S#define TIMER_TCMP_TCMP_Pos         0                                           /*!< TIMER_T::TCMPR: TCMP Position */
S#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)         /*!< TIMER_T::TCMPR: TCMP Mask */
S
S/* TIMER TISR Bit Field Definitions */
S#define TIMER_TISR_TWF_Pos          1                                           /*!< TIMER_T::TISR: TWF Position */
S#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)                 /*!< TIMER_T::TISR: TWF Mask */
S
S#define TIMER_TISR_TIF_Pos          0                                           /*!< TIMER_T::TISR: TIF Position */
S#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)                 /*!< TIMER_T::TISR: TIF Mask */
S
S/* TIMER TDR Bit Field Definitions */
S#define TIMER_TDR_TDR_Pos           0                                           /*!< TIMER_T::TDR: TDR Position */
S#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)           /*!< TIMER_T::TDR: TDR Mask */
S
S/* TIMER TCAP Bit Field Definitions */
S#define TIMER_TCAP_TCAP_Pos         0                                           /*!< TIMER_T::TCAP: TCAP Position */
S#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER_T::TCAP: TCAP Mask */
S
S/* TIMER TEXCON Bit Field Definitions */
S#define TIMER_TEXCON_TCDB_Pos       7                                           /*!< TIMER_T::TEXCON: TCDB Position */
S#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)              /*!< TIMER_T::TEXCON: TCDB Mask */
S
S#define TIMER_TEXCON_TEXDB_Pos      6                                           /*!< TIMER_T::TEXCON: TEXDB Position */
S#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)             /*!< TIMER_T::TEXCON: TEXDB Mask */
S
S#define TIMER_TEXCON_TEXIEN_Pos     5                                           /*!< TIMER_T::TEXCON: TEXIEN Position */
S#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)            /*!< TIMER_T::TEXCON: TEXIEN Mask */
S
S#define TIMER_TEXCON_RSTCAPSEL_Pos  4                                           /*!< TIMER_T::TEXCON: RSTCAPSEL Position */
S#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)         /*!< TIMER_T::TEXCON: RSTCAPSEL Mask */
S
S#define TIMER_TEXCON_TEXEN_Pos      3                                           /*!< TIMER_T::TEXCON: TEXEN Position */
S#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)             /*!< TIMER_T::TEXCON: TEXEN Mask */
S
S#define TIMER_TEXCON_TEX_EDGE_Pos   1                                           /*!< TIMER_T::TEXCON: TEX_EDGE Position */
S#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)        /*!< TIMER_T::TEXCON: TEX_EDGE Mask */
S
S#define TIMER_TEXCON_TX_PHASE_Pos   0                                           /*!< TIMER_T::TEXCON: TX_PHASE Position */
S#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)          /*!< TIMER_T::TEXCON: TX_PHASE Mask */
S
S/* TIMER TEXISR Bit Field Definitions */
S#define TIMER_TEXISR_TEXIF_Pos      0                                           /*!< TIMER_T::TEXISR: TEXIF Position */
S#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)             /*!< TIMER_T::TEXISR: TEXIF Mask */
S/*@}*/ /* end of group TIMER_CONST */
S/*@}*/ /* end of group TIMER */
S
S
S
S
S
S/*------------------------- UART Interface Controller ------------------------*/
S/**
S    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller (UART)
S    Memory Mapped Structure for UART Controller
S@{ */
Stypedef struct
S{
S
S    union
S    {
S        __IO uint32_t DATA;
S
S        /**
S         * THR
S         * ===================================================================================================
S         * Offset: 0x00 Transmit Holding DATA
S         * ---------------------------------------------------------------------------------------------------
S         * |Bits    |Field     |Descriptions
S         * | :----: | :----:   | :---- |
S         * |[7:0]   |THR       |Transmit Holding Register
S         * |        |          |By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB first).
S         */
S        __IO uint32_t THR;
S
S        /**
S         * UA_RBR
S         * ===================================================================================================
S         * Offset: 0x00  UART Receive Buffer Register
S         * ---------------------------------------------------------------------------------------------------
S         * |Bits    |Field     |Descriptions
S         * | :----: | :----:   | :---- |
S         * |[7:0]   |RBR       |Receive Buffer Register (Read Only)
S         * |        |          |By reading this register, the UART will return the 8-bit data received from RX pin (LSB first).
S         */
S        __IO uint32_t RBR;
S    };
S
S    /**
S     * UA_IER
S     * ===================================================================================================
S     * Offset: 0x04  UART Interrupt Enable Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable Control
S     * |        |          |0 = RDA_INT Masked off.
S     * |        |          |1 = RDA_INT Enabled.
S     * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable Control
S     * |        |          |0 = THRE_INT Masked off.
S     * |        |          |1 = THRE_INT Enabled.
S     * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable Control
S     * |        |          |0 = RLS_INT Masked off.
S     * |        |          |1 = RLS_INT Enabled
S     * |[3]     |MODEM_IEN |Modem Status Interrupt Enable Control (Available In UART0/UART1 Channel)
S     * |        |          |0 = MODEM_INT Masked off.
S     * |        |          |1 = MODEM_INT Enabled.
S     * |[4]     |TOUT_IEN  |RX Time-Out Interrupt Enable Control
S     * |        |          |0 = TOUT_INT Masked off.
S     * |        |          |1 = TOUT_INT Enabled.
S     * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable Control
S     * |        |          |0 = BUF_ERR_INT Masked off.
S     * |        |          |1 = BUF_ERR_INT Enabled.
S     * |[6]     |WKCTSIEN  |nCTS Wake-Up Interrupt Enable Bit (Available In UART0/UART1 Channel)
S     * |        |          |0 = nCTS wake-up system function Disabled.
S     * |        |          |1 = Wake-up system function Enabled, when the system is in Power-down mode, an external nCTS change will wake-up system from Power-down mode.
S     * |[8]     |LIN_IEN   |LIN Bus Interrupt Enable
S     * |        |          |0 = Lin bus interrupt Disabled.
S     * |        |          |1 = Lin bus interrupt Enabled.
S     * |        |          |Note: This field is used for LIN function mode.
S     * |[10]    |WKDATIEN  |Incoming Data Wake-Up Interrupt Enable Bit
S     * |        |          |0 = Incoming data wake-up system function Disabled.
S     * |        |          |1 = Incoming data wake-up system function Enabled, when the system is in Power-down mode, incoming data will wake-up system from Power-down mode.
S     * |        |          |Note: Hardware will clear this bit when the incoming data wake-up operation finishes and "system clock" work stable.
S     * |[11]    |TIME_OUT_EN|Time-Out Counter Enable
S     * |        |          |0 = Time-out counter Disabled.
S     * |        |          |1 = Time-out counter Enabled.
S     * |[12]    |AUTO_RTS_EN|RTS Auto Flow Control Enable (Available In UART0/UART1 Channel)
S     * |        |          |0 = RTS auto flow control Disabled.
S     * |        |          |1 = RTS auto flow control Enabled.
S     * |        |          |When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV (UA_FCR [19:16]), the UART will de-assert RTS signal.
S     * |[13]    |AUTO_CTS_EN|CTS Auto Flow Control Enable (Available In UART0/UART1 Channel)
S     * |        |          |0 = CTS auto flow control Disabled.
S     * |        |          |1 = CTS auto flow control Enabled.
S     * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).
S     * |[18]    |ABRIEN    |Auto-Baud Rate Interrupt Enable Bit
S     * |        |          |0 = Auto-baud rate interrupt Disabled.
S     * |        |          |1 = Auto-baud rate interrupt Enabled.
S     */
S    __IO uint32_t IER;
S
S    /**
S     * UA_FCR
S     * ===================================================================================================
S     * Offset: 0x08  UART FIFO Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RFR       |RX Field Software Reset
S     * |        |          |When RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the RX internal state machine and pointers.
S     * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
S     * |[2]     |TFR       |TX Field Software Reset
S     * |        |          |When TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the TX internal state machine and pointers.
S     * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
S     * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
S     * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if RDA_IEN(UA_IER[0]) enabled, and an interrupt will be generated).
S     * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
S     * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
S     * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
S     * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
S     * |        |          |Other = Reserved.
S     * |[8]     |RX_DIS    |Receiver Disable Register
S     * |        |          |The receiver is disabled or not (set 1 to disable receiver).
S     * |        |          |0 = Receiver Enabled.
S     * |        |          |1 = Receiver Disabled.
S     * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode.
S     * |        |          |It should be programmed before RS485_NMM(UA_ALT_CSR[8]) is programmed.
S     * |[19:16] |RTS_TRI_LEV|RTS Trigger Level For Auto-Flow Control Use (Available In UART0/UART1 Channel)
S     * |        |          |0000 = RTS Trigger Level is 1 byte.
S     * |        |          |0001 = RTS Trigger Level is 4 bytes.
S     * |        |          |0010 = RTS Trigger Level is 8 bytes.
S     * |        |          |0011 = RTS Trigger Level is 14 bytes.
S     * |        |          |Other = Reserved.
S     * |        |          |Note: This field is used for RTS auto-flow control.
S     */
S    __IO uint32_t FCR;
S
S    /**
S     * UA_LCR
S     * ===================================================================================================
S     * Offset: 0x0C  UART Line Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |WLS       |Word Length Selection
S     * |        |          |00 = Word length is 5-bit.
S     * |        |          |01 = Word length is 6-bit.
S     * |        |          |10 = Word length is 7-bit
S     * |        |          |11 = Word length is 8-bit
S     * |[2]     |NSB       |Number Of "STOP Bit"
S     * |        |          |0 = One " STOP bit" is generated in the transmitted data.
S     * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
S     * |        |          |When select 6-,7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
S     * |[3]     |PBE       |Parity Bit Enable
S     * |        |          |0 = No parity bit.
S     * |        |          |1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
S     * |[4]     |EPE       |Even Parity Enable
S     * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
S     * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
S     * |        |          |This bit has effect only when PBE (UA_LCR[3]) is set.
S     * |[5]     |SPE       |Stick Parity Enable
S     * |        |          |0 = Stick parity Disabled.
S     * |        |          |1 = If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and checked as logic 0.
S     * |        |          |If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked as 1.
S     * |[6]     |BCB       |Break Control Bit
S     * |        |          |When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0).
S     * |        |          |This bit acts only on TX and has no effect on the transmitter logic.
S     */
S    __IO uint32_t LCR;
S
S    /**
S     * UA_MCR
S     * ===================================================================================================
S     * Offset: 0x10  UART Modem Control Register (Available In UART0/UART1 Channel)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |RTS       |RTS (Request-To-Send) Signal Control
S     * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin output with LEV_RTS bit configuration.
S     * |        |          |0 = RTS signal is active.
S     * |        |          |1 = RTS signal is inactive.
S     * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in UART function mode.
S     * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is enabled in RS-485 function mode.
S     * |[9]     |LEV_RTS   |RTS Pin Active Level 
S     * |        |          |This bit defines the active level state of RTS pin output.
S     * |        |          |0 = RTS pin output is high level active.
S     * |        |          |1 = RTS pin output is low level active.
S     * |[13]    |RTS_ST    |RTS Pin State (Read Only)
S     * |        |          |This bit mirror from RTS pin output of voltage logic status.
S     * |        |          |0 = RTS pin output is low level voltage logic state.
S     * |        |          |1 = RTS pin output is high level voltage logic state.
S     */
S    __IO uint32_t MCR;
S
S    /**
S     * UA_MSR
S     * ===================================================================================================
S     * Offset: 0x14  UART Modem Status Register (Available In UART0/UART1 Channel)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |DCTSF     |Detect CTS State Change Flag (Read Only)
S     * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when MODEM_IEN (UA_IER [3]) is set to 1.
S     * |        |          |0 = CTS input has not change state.
S     * |        |          |1 = CTS input has change state.
S     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S     * |[4]     |CTS_ST    |CTS Pin Status (Read Only) 
S     * |        |          |This bit mirror from CTS pin input of voltage logic status.
S     * |        |          |0 = CTS pin input is low level voltage logic state.
S     * |        |          |1 = CTS pin input is high level voltage logic state.
S     * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function port is selected
S     * |[8]     |LEV_CTS   |CTS Pin Active Level
S     * |        |          |This bit defines the active level state of CTS pin input.
S     * |        |          |0 = CTS pin input is high level active.
S     * |        |          |1 = CTS pin input is low level active.
S     */
S    __IO uint32_t MSR;
S
S    /**
S     * UA_FSR
S     * ===================================================================================================
S     * Offset: 0x18  UART FIFO Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RX_OVER_IF|RX Overflow Error IF (Read Only)
S     * |        |          |This bit is set when RX FIFO overflow.
S     * |        |          |If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 16 bytes of UART0/UART1/UART2, this bit will be set.
S     * |        |          |0 = RX FIFO is not overflow.
S     * |        |          |1 = RX FIFO is overflow.
S     * |        |          |If the number of bytes of received data is greater than 1 byte, 1 byte of UART3/UART4/UART5, this bit will be set.
S     * |        |          |0 = RX Buffer is not overflow.
S     * |        |          |1 = RX Buffer is overflow.
S     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S     * |[1]     |ABRDIF    |Auto-Baud Rate Detect Interrupt (Read Only)
S     * |        |          |0 = Auto-baud rate detect function is not finished.
S     * |        |          |1 = Auto-baud rate detect function is finished.
S     * |        |          |This bit is set to logic "1" when auto-baud rate detect function is finished.
S     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S     * |[2]     |ABRDTOIF  |Auto-Baud Rate Time-Out Interrupt (Read Only)
S     * |        |          |0 = Auto-baud rate counter is underflow.
S     * |        |          |1 = Auto-baud rate counter is overflow.
S     * |        |          |Note1: This bit is set to logic "1" in Auto-baud Rate Detect mode and the baud rate counter is overflow.
S     * |        |          |Note2: This bit is read only, but can be cleared by writing "1" to it.
S     * |[3]     |RS485_ADD_DETF|RS-485 Address Byte Detection Flag (Read Only) (Available In UART0/UART1 Channel)
S     * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 ='1').
S     * |        |          |1 = Receiver detects a data that is an address bit (bit 9 ='1').
S     * |        |          |Note1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1 to enable Address detection mode.
S     * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
S     * |[4]     |PEF       |Parity Error Flag (Read Only)
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
S     * |        |          |0 = No parity error is generated.
S     * |        |          |1 = Parity error is generated.
S     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S     * |[5]     |FEF       |Framing Error Flag (Read Only)
S     * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is reset whenever the CPU writes 1 to this bit.
S     * |        |          |0 = No framing error is generated.
S     * |        |          |1 = Framing error is generated.
S     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S     * |[6]     |BIF       |Break Interrupt Flag (Read Only)
S     * |        |          |This bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
S     * |        |          |0 = No Break interrupt is generated.
S     * |        |          |1 = Break interrupt is generated.
S     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S     * |[13:8]  |RX_POINTER|RX FIFO Pointer (Read Only)
S     * |        |          |This field indicates the RX FIFO Buffer Pointer.
S     * |        |          |When UART receives one byte from external device, then RX_POINTER increases one. '
S     * |        |          |When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.
S     * |        |          |The Maximum value shown in RX_POINTER is 15 (UART0/UART1/UART2).
S     * |        |          |When the using level of RX FIFO Buffer equal to 16, the RX_FULL bit is set to 1 and RX_POINTER will show 0.
S     * |        |          |As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show 15 (UART0/UART1/UART2).
S     * |        |          |When RX Buffer is equal to 1, if one byte data is received, the RX_FULL bit is set to 1 and RX_POINTER will show 1.
S     * |        |          |Once the RX Buffer is read, the RX_POINTER is 0.
S     * |[14]    |RX_EMPTY  |Receiver FIFO Empty (Read Only)
S     * |        |          |This bit initiate RX FIFO empty or not. (UART0/UART1/UART2)
S     * |        |          |0 = RX FIFO is not empty.
S     * |        |          |1 = RX FIFO is empty.
S     * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.
S     * |        |          |This bit initiate RX Buffer empty or not. (UART3/UART4/UART5)
S     * |        |          |0 = RX Buffer is not empty.
S     * |        |          |1 = RX Buffer is empty.
S     * |        |          |Note: When the last byte of RX Buffer has been read by CPU, hardware sets this bit high.
S     * |        |          |It will be cleared when UART receives any new data.
S     * |[15]    |RX_FULL   |Receiver FIFO Full (Read Only)
S     * |        |          |This bit initiates RX FIFO is full or not (UART0/UART1/UART2).
S     * |        |          |0 = RX FIFO is not full.
S     * |        |          |1 = RX FIFO is full.
S     * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to 16 (UART0/UART1/UART2), otherwise is cleared by hardware.
S     * |        |          |This bit initiates RX Buffer is full or not (UART3/UART4/UART5).
S     * |        |          |0 = RX buffer is not full.
S     * |        |          |1 = RX buffer is full.
S     * |        |          |Note: This bit is set when the number of usage in RX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.
S     * |[21:16] |TX_POINTER|TX FIFO Pointer (Read Only)
S     * |        |          |This field indicates the TX FIFO Buffer Pointer.
S     * |        |          |When CPU writes one byte into UA_THR, then TX_POINTER increases one.
S     * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases one.
S     * |        |          |The Maximum value shown in TX_POINTER is 15 (UART0/UART1/UART2).
S     * |        |          |When the using level of TX FIFO Buffer is equal to 16, the TX_FULL bit is set to 1 and TX_POINTER will show 0.
S     * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared to 0 and TX_POINTER will show 15 (UART0/UART1/UART2).
S     * |        |          |TX_POINTER is 0 (UART3/UART4/UART5).
S     * |        |          |When TX Buffer is equal to 1, if one byte data is received, the TX_FULL bit is set to 1 and TX_POINTER will show 1.
S     * |        |          |Once the TX Buffer is read, the TX_POINTER is 0.
S     * |[22]    |TX_EMPTY  |Transmitter FIFO Empty (Read Only)
S     * |        |          |This bit indicates TX FIFO empty or not. (UART0/UART1/UART2)
S     * |        |          |0 = TX FIFO is not empty.
S     * |        |          |1 = TX FIFO is empty.
S     * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high.
S     * |        |          |It will be cleared when writing data into THR (TX FIFO not empty).
S     * |        |          |This bit indicates TX Buffer filled or not. (UART3/UART4/UART5)
S     * |        |          |0 = TX Buffer is not empty.
S     * |        |          |1 = TX Buffer is empty.
S     * |        |          |Note: When the last byte of TX Buffer has been transferred to Transmitter Shift Register, hardware sets this bit high.
S     * |        |          |It will be cleared when writing data into THR (TX FIFO not empty).
S     * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
S     * |        |          |This bit indicates TX FIFO is full or not. (UART0/UART1/UART2)
S     * |        |          |0 = TX FIFO is not full.
S     * |        |          |1 = TX FIFO is full.
S     * |        |          |This bit is set when the number of usage in TX FIFO is equal to 16 (UART0/UART1/UART2), otherwise is cleared by hardware.
S     * |        |          |This bit indicates TX Buffer is full or not.(UART3/UART4/UART5)
S     * |        |          |0 = TX Buffer is not full.
S     * |        |          |1 = TX Buffer is full.
S     * |        |          |This bit is set when the number of usage in TX Buffer is equal to 1 (UART3/UART4/UART5), otherwise is cleared by hardware.
S     * |[24]    |TX_OVER_IF|TX Overflow Error Interrupt Flag (Read Only)
S     * |        |          |If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. (UART0/UART1/UART2)
S     * |        |          |0 = TX FIFO is not overflow.
S     * |        |          |1 = TX FIFO is overflow.
S     * |        |          |If TX Buffer is filled, an additional write to UA_THR will cause this bit to logic 1. (UART3/UART4/UART5)
S     * |        |          |0 = TX Buffer is not overflow.
S     * |        |          |1 = TX Buffer is overflow.
S     * |        |          |Note: This bit is read only, but can be cleared by writing "1" to it.
S     * |[28]    |TE_FLAG   |Transmitter Empty Flag (Read Only)
S     * |        |          |This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART0/UART1/UART2)
S     * |        |          |0 = TX FIFO is not empty.
S     * |        |          |1 = TX FIFO is empty.
S     * |        |          |This bit is set by hardware when TX Buffer (UA_THR) is empty and the STOP bit of the last byte has been transmitted. (UART3/UART4/UART5)
S     * |        |          |0 = TX Buffer is not empty.
S     * |        |          |1 = TX Buffer is empty.
S     * |        |          |Note: This bit is cleared automatically when TX FIFO/TX Buffer is not empty or the last byte transmission has not completed.
S      */
S    __IO uint32_t FSR;
S
S    /**
S     * UA_ISR
S     * ===================================================================================================
S     * Offset: 0x1C  UART Interrupt Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only)
S     * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set.
S     * |        |          |If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
S     * |        |          |0 = No RDA interrupt flag is generated.
S     * |        |          |1 = RDA interrupt flag is generated.
S     * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO drops below the threshold level (RFITL(UA_FCR[7:4]).
S     * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
S     * |        |          |If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.
S     * |        |          |0 = No THRE interrupt flag is generated.
S     * |        |          |1 = THRE interrupt flag is generated.
S     * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).
S     * |[2]     |RLS_IF    |Receive Line Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set).
S     * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
S     * |        |          |0 = No RLS interrupt flag is generated.
S     * |        |          |1 = RLS interrupt flag is generated.
S     * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address byte character (bit9 = '1') bit.
S     * |        |          |At the same time, the bit of UA_FSR[RS485_ADD_DETF] is also set.
S     * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.
S     * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.
S     * |[3]     |MODEM_IF  |MODEM Interrupt Flag (Read Only) (Available In UART0/UART1 Channel)
S     * |        |          |This bit is set when the CTS pin has state change (DCTSF (UA_MSR[0]) = 1).
S     * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
S     * |        |          |0 = No Modem interrupt flag is generated.
S     * |        |          |1 = Modem interrupt flag is generated.
S     * |        |          |Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF(UA_MSR[0]).
S     * |[4]     |TOUT_IF   |Time-Out Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the time-out counter equal to TOIC.
S     * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
S     * |        |          |0 = No Time-out interrupt flag is generated.
S     * |        |          |1 = Time-out interrupt flag is generated.
S     * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it
S     * |[5]     |BUF_ERR_IF|Buffer Error Interrupt Flag (Read Only)
S     * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF (UA_FSR[0]) is set).
S     * |        |          |When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct.
S     * |        |          |If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.
S     * |        |          |0 = No buffer error interrupt flag is generated.
S     * |        |          |1 = Buffer error interrupt flag is generated.0 = No buffer error interrupt flag is generated.
S     * |        |          |1 = Buffer error interrupt flag is generated.
S     * |        |          |Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and RX_OVER_IF(UA_FSR[0]) are cleared
S     * |[6]     |WKIF      |UART Wake-up Interrupt Flag (Read Only)
S     * |        |          |This bit is set when DATWKIF (UA_ISR[17]) or CTSWKIF(UA_ISR[16]) is set to 1.
S     * |        |          |0 = No DATWKIF and CTSWKIF are generated.
S     * |        |          |1 = DATWKIF or CTSWKIF.
S     * |        |          |Note: This bit is read only.
S     * |        |          |This bit is cleared if both of DATWKIF (UA_ISR[17]) and CTSWKIF(UA_ISR[16]) are cleared to 0 by writing 1 to DATWKIF (UA_ISR[17]) and CTSWKIF (UA_ISR[17]).
S     * |[7]     |LIN_IF    |LIN Bus Flag (Read Only)
S     * |        |          |This bit is set when LIN slave header detect (LINS_HDET_F (UA_LIN_SR[0] =1)), LIN break detect (LIN_BKDET_F(UA_LIN_SR[9]=1)), bit error detect (BIT_ERR_F(UA_LIN_SR[9]=1), LIN slave ID parity error (LINS_IDPERR_F(UA_LIN_SR[2] = 1) or LIN slave header error detect (LINS_HERR_F (UA_LIN_SR[1])).
S     * |        |          |If LIN_ IEN (UA_IER [8]) is enabled the LIN interrupt will be generated.
S     * |        |          |0 = None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated.
S     * |        |          |1 = At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated.
S     * |        |          |Note: This bit is read only.
S     * |        |          |This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]), LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and LINS_HERR_F(UA_LIN_SR[1]) all are cleared.
S     * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.
S     * |        |          |0 = No RDA interrupt is generated.
S     * |        |          |1 = RDA interrupt is generated.
S     * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.
S     * |        |          |0 = No THRE interrupt is generated.
S     * |        |          |1 = THRE interrupt is generated.
S     * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.
S     * |        |          |0 = No RLS interrupt is generated.
S     * |        |          |1 = RLS interrupt is generated
S     * |[11]    |MODEM_INT |MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)
S     * |        |          |This bit is set if MODEM_IEN(UA_IER[3] and MODEM_IF(UA_ISR[4]) are both set to 1
S     * |        |          |0 = No Modem interrupt is generated.
S     * |        |          |1 = Modem interrupt is generated.
S     * |[12]    |TOUT_INT  |Time-Out Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.
S     * |        |          |0 = No Tout interrupt is generated.
S     * |        |          |1 = Tout interrupt is generated.
S     * |[13]    |BUF_ERR_INT|Buffer Error Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if BUF_ERR_IEN(UA_IER[5] and BUF_ERR_IF(UA_ISR[5]) are both set to 1.
S     * |        |          |0 = No buffer error interrupt is generated.
S     * |        |          |1 = Buffer error interrupt is generated.
S     * |[15]    |LIN_INT   |LIN Bus Interrupt Indicator (Read Only)
S     * |        |          |This bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.
S     * |        |          |0 = No LIN Bus interrupt is generated.
S     * |        |          |1 = The LIN Bus interrupt is generated.
S     * |[16]    |CTSWKIF   |nCTS Wake-Up Interrupt Flag (Read Only) (Available In UART0/UART1 Channel)
S     * |        |          |0 = Chip stays in power-down state.
S     * |        |          |1 = Chip wake-up from power-down state by nCTS wake-up.
S     * |        |          |Note1: If WKCTSIEN (UA_IER[6])is enabled, the wake-up interrupt is generated.
S     * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
S     * |[17]    |DATWKIF   |Data Wake-Up Interrupt Flag (Read Only)
S     * |        |          |This bit is set if chip wake-up from power-down state by data wake-up.
S     * |        |          |0 = Chip stays in power-down state.
S     * |        |          |1 = Chip wake-up from power-down state by data wake-up.
S     * |        |          |Note1: If WKDATIEN (UA_IER[10]) is enabled, the wake-up interrupt is generated.
S     * |        |          |Note2: This bit is read only, but can be cleared by writing '1' to it.
S     */
S    __IO uint32_t ISR;
S
S    /**
S     * UA_TOR
S     * ===================================================================================================
S     * Offset: 0x20  UART Time-out Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |TOIC      |Time-Out Interrupt Comparator
S     * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word.
S     * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC (UA_TOR[7:0])), a receiver time-out interrupt (INT_TOUT) is generated if TOUT_IEN (UA_IER [4]) enabled.
S     * |        |          |A new incoming data word or RX FIFO empty will clear TOUT_INT(UA_IER[9]).
S     * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is being received, TOIC (UA_TOR[7:0]) value should be set between 40 and 255.
S     * |        |          |So, for example, if TOIC (UA_TOR[7:0]) is set with 40, the time-out interrupt is generated after four characters are not received when 1 stop bit and no parity check is set for UART transfer.
S     * |[15:8]  |DLY       |TX Delay Time Value
S     * |        |          |This field is used to programming the transfer delay time between the last stop bit and next start bit.
S     */
S    __IO uint32_t TOR;
S
S    /**
S     * UA_BAUD
S     * ===================================================================================================
S     * Offset: 0x24  UART Baud Rate Divisor Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[15:0]  |BRD       |Baud Rate Divider
S     * |        |          |The field indicates the baud rate divider
S     * |[27:24] |DIVIDER_X |Divider X
S     * |        |          |The baud rate divider M = X+1.
S     * |[28]    |DIV_X_ONE |Divider X Equal To 1
S     * |        |          |0 = Divider M = X (the equation of M = X+1, but DIVIDER_X[27:24] must >= 8).
S     * |        |          |1 = Divider M = 1 (the equation of M = 1, but BRD [15:0] must >= 3).  
S     * |[29]    |DIV_X_EN  |Divider X Enable
S     * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is
S     * |        |          |Baud Rate = Clock / [M * (BRD + 2)]; The default value of M is 16.
S     * |        |          |0 = Divider X Disabled (the equation of M = 16).
S     * |        |          |1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
S     * |        |          |Note: In IrDA mode, this bit must disable.
S     */
S    __IO uint32_t BAUD;
S
S    /**
S     * UA_IRCR
S     * ===================================================================================================
S     * Offset: 0x28  UART IrDA Control Register 
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1]     |TX_SELECT |TX_SELECT
S     * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled.
S     * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
S     * |[5]     |INV_TX    |IrDA inverse Transmitting Output Signal Control
S     * |        |          |0 = None inverse transmitting signal.
S     * |        |          |1 = Inverse transmitting output signal.
S     * |[6]     |INV_RX    |IrDA inverse Receive Input Signal Control
S     * |        |          |0 = None inverse receiving input signal.
S     * |        |          |1 = Inverse receiving input signal.
S     */
S    __IO uint32_t IRCR;
S
S    /**
S     * UA_ALT_CSR
S     * ===================================================================================================
S     * Offset: 0x2C  UART Alternate Control/Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[3:0]   |LIN_BKFL  |UART LIN Break Field Length (Available In UART0/UART1/UART2)
S     * |        |          |This field indicates a 4-bit LIN TX break field count.
S     * |        |          |Note1: This break field length is UA_LIN_BKFL + 1
S     * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
S     * |[6]     |LIN_RX_EN |LIN RX Enable (Available In UART0/UART1/UART2)
S     * |        |          |0 = LIN RX mode Disabled.
S     * |        |          |1 = LIN RX mode Enabled.
S     * |[7]     |LIN_TX_EN |LIN TX Break Mode Enable (Available In UART0/UART1/UART2)
S     * |        |          |0 = LIN TX Break mode Disabled.
S     * |        |          |1 = LIN TX Break mode Enabled.
S     * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
S     * |[8]     |RS485_NMM |RS-485 Normal Multi-Drop Operation Mode (NMM) (Available In UART0/UART1)
S     * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
S     * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
S     * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
S     * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD) (Available In UART0/UART1)
S     * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
S     * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
S     * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
S     * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD) (Available In UART0/UART1)
S     * |        |          |0 = RS-485 Auto Direction Operation mode (AUO) Disabled.
S     * |        |          |1 = RS-485 Auto Direction Operation mode (AUO) Enabled.
S     * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
S     * |[15]    |RS485_ADD_EN|RS-485 Address Detection Enable (Available In UART0/UART1)
S     * |        |          |This bit is used to enable RS-485 Address Detection mode.
S     * |        |          |0 = Address detection mode Disabled.
S     * |        |          |1 = Address detection mode Enabled.
S     * |        |          |Note: This bit is used for RS-485 any operation mode.
S     * |[17]    |ABRIF     |Auto-Baud Rate Interrupt Flag (Read Only)
S     * |        |          |This bit is set when auto-baud rate detection function finished or the auto-baud rate counter was overflow and if ABRIEN(UA_IEN [18]) is set then the auto-baud rate interrupt will be generated.
S     * |        |          |Note: This bit is read only, but it can be cleared by writing "1" to ABRDTOIF (UA_FSR[2]) and ABRDIF(UA_FSR[1])
S     * |[18]    |ABRDEN    |Auto-Baud Rate Detect Enable Bit
S     * |        |          |0 = Auto-baud rate detect function Disabled.
S     * |        |          |1 = Auto-baud rate detect function Enabled.
S     * |        |          |This bit is cleared automatically after auto-baud detection is finished.
S     * |[20:19] |ABRDBITS  |Auto-Baud Rate Detect Bit Length
S     * |        |          |00 = 1-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x01.
S     * |        |          |01 = 2-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x02.
S     * |        |          |10 = 4-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x08.
S     * |        |          |11 = 8-bit time from Start bit to the 1st rising edge. The input pattern shall be 0x80.
S     * |        |          |Note : The calculation of bit number includes the START bit.
S     * |[31:24] |ADDR_MATCH|Address Match Value Register (Available In UART0/UART1)
S     * |        |          |This field contains the RS-485 address match values.
S     * |        |          |Note: This field is used for RS-485 auto address detection mode.
S     */
S    __IO uint32_t ALT_CSR;
S
S    /**
S     * UA_FUN_SEL
S     * ===================================================================================================
S     * Offset: 0x30  UART Function Select Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |FUN_SEL   |Function Select Enable
S     * |        |          |00 = UART function Enabled.
S     * |        |          |01 = LIN function Enabled. (Available In UART0/UART1/UART2)
S     * |        |          |10 = IrDA function Enabled.
S     * |        |          |11 = RS-485 function Enabled. (Available In UART0/UART1)
S     */
S    __IO uint32_t FUN_SEL;
S
S    /**
S     * UA_LIN_CTL
S     * ===================================================================================================
S     * Offset: 0x34  UART LIN Control Register (Available In UART0/UART1/UART2)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LINS_EN   |LIN Slave Mode Enable Control
S     * |        |          |0 = LIN slave mode Disabled.
S     * |        |          |1 = LIN slave mode Enabled.
S     * |[1]     |LINS_HDET_EN|LIN Slave Header Detection Enable Control
S     * |        |          |0 = LIN slave header detection Disabled.
S     * |        |          |1 = LIN slave header detection Enabled.
S     * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
S     * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), LINS_HDET_F (UA_LIN_SR [0]) flag will be asserted.
S     * |        |          |If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
S     * |[2]     |LINS_ARS_EN|LIN Slave Automatic Resynchronization Mode Enable Control
S     * |        |          |0 = LIN automatic resynchronization Disabled.
S     * |        |          |1 = LIN automatic resynchronization Enabled.
S     * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
S     * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2 (BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1).
S     * |        |          |(Slave mode with automatic resynchronization).
S     * |[3]     |LINS_DUM_EN|LIN Slave Divider Update Method Enable Control
S     * |        |          |0 = UA_BAUD updated is written by software (if no automatic resynchronization update occurs at the same time).
S     * |        |          |1 = UA_BAUD is updated at the next received character. User must set the bit before checksum reception.
S     * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
S     * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
S     * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
S     * |        |          |(Slave mode with automatic resynchronization).
S     * |[4]     |LIN_MUTE_EN|LIN Mute Mode Enable Control
S     * |        |          |0 = LIN mute mode Disabled.
S     * |        |          |1 = LIN mute mode Enabled.
S     * |        |          |Note: The exit from mute mode condition and each control and interactions of this field are explained in (LIN slave mode).
S     * |[8]     |LIN_SHD   |LIN TX Send Header Enable Control
S     * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID field", it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).
S     * |        |          |0 = Send LIN TX header Disabled.
S     * |        |          |1 = Send LIN TX header Enabled.
S     * |        |          |Note1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).
S     * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync + frame ID" selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this bit will be cleared automatically.
S     * |[9]     |LIN_IDPEN |LIN ID Parity Enable Control
S     * |        |          |0 = LIN frame ID parity Disabled.
S     * |        |          |1 = LIN frame ID parity Enabled.
S     * |        |          |Note1: This bit can be used for LIN master to sending header field (LIN_SHD (UA_LIN_CTL[8])) = 1 and LIN_HEAD_SEL (UA_LIN_CTL[23:22]) = 10) or be used for enable LIN slave received frame ID parity checked.
S     * |        |          |Note2: This bit is only use when the operation header transmitter is in LIN_HEAD_SEL (UA_LIN_CTL[23:22]) = 10
S     * |[10]    |LIN_BKDET_EN|LIN Break Detection Enable Control
S     * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter character, the LIN_BKDET_F (UA_LIN_SR[8]) flag is set in UA_LIN_SR register at the end of break field.
S     * |        |          |If the LIN_IEN (UA_IER [8])=1, an interrupt will be generated.
S     * |        |          |0 = LIN break detection Disabled.
S     * |        |          |1 = LIN break detection Enabled.
S     * |[11]    |LIN_RX_DIS|LIN Receiver Disable Control
S     * |        |          |If the receiver is enabled (LIN_RX_DIS (UA_LIN_CTL[11] ) = 0), all received byte data will be accepted and stored in the RX-FIFO, and if the receiver is disabled (LIN_RX_DIS (UA_LIN_CTL[11] = 1), all received byte data will be ignore.
S     * |        |          |0 = LIN receiver Enabled.
S     * |        |          |1 = LIN receiver Disabled.
S     * |        |          |Note: This bit is only valid when operating in LIN function mode (FUN_SEL (UA_FUN_SEL[1:0]) = 01)
S     * |[12]    |BIT_ERR_EN|Bit Error Detect Enable Control
S     * |        |          |0 = Bit error detection function Disabled.
S     * |        |          |1 = Bit error detection Enabled.
S     * |        |          |Note: In LIN function mode, when occur bit error, the BIT_ERR_F (UA_LIN_SR[9]) flag will be asserted.
S     * |        |          |If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
S     * |[19:16] |LIN_BKFL  |LIN Break Field Length
S     * |        |          |This field indicates a 4-bit LIN TX break field count.
S     * |        |          |Note1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16].
S     * |        |          |Note2: This break field length is LIN_BKFL + 1.
S     * |        |          |Note3:
S     * |        |          |According to LIN spec, the reset value is 12 (break field length = 13).
S     * |[21:20] |LIN_BS_LEN|LIN Break/Sync Delimiter Length
S     * |        |          |00 = The LIN break/sync delimiter length is 1 bit time.
S     * |        |          |10 = The LIN break/sync delimiter length is 2 bit time.
S     * |        |          |10 = The LIN break/sync delimiter length is 3 bit time.
S     * |        |          |11 = The LIN break/sync delimiter length is 4 bit time.
S     * |        |          |Note: This bit used for LIN master to sending header field.
S     * |[23:22] |LIN_HEAD_SEL|LIN Header Select
S     * |        |          |00 = The LIN header includes "break field".
S     * |        |          |01 = The LIN header includes "break field" and "sync field".
S     * |        |          |10 = The LIN header includes "break field", "sync field" and "frame ID field".
S     * |        |          |11 = Reserved.
S     * |        |          |Note: This bit is used to master mode for LIN to send header field (LIN_SHD (UA_LIN_CTL [8]) = 1) or used to slave to indicates exit from mute mode condition (LIN_MUTE_EN (UA_LIN_CTL[4] = 1).
S     * |[31:24] |LIN_PID   |LIN PID Register
S     * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be generated by software or hardware depends on LIN_IDPEN (UA_LIN_CTL[9]) = 1.
S     * |        |          |If the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity in this field.
S     * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
S     * |        |          |Note2: This field can be used for LIN master mode or slave mode.
S     */
S    __IO uint32_t LIN_CTL;
S
S    /**
S     * UA_LIN_SR
S     * ===================================================================================================
S     * Offset: 0x38  UART LIN Status Register (Available In UART0/UART1/UART2)
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |LINS_HDET_F|LIN Slave Header Detection Flag (Read Only)
S     * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by writing 1 to it.
S     * |        |          |0 = LIN header not detected.
S     * |        |          |1 = LIN header detected (break + sync + frame ID).
S     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0]) = 1) and enable LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
S     * |        |          |Note3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete header ("break + sync + frame ID"), the LINS_HEDT_F will be set whether the frame ID correct or not.
S     * |[1]     |LINS_HERR_F|LIN Slave Header Error Flag (Read Only)
S     * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared by writing 1 to it.
S     * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode", "sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception time-out".
S     * |        |          |0 = LIN header error not detected.
S     * |        |          |1 = LIN header error detected.
S     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (LINS_EN (UA_LIN_CTL [0]) = 1) and enables LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
S     * |[2]     |LINS_IDPERR_F|LIN Slave ID Parity Error Flag (Read Only)
S     * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
S     * |        |          |0 = No active.
S     * |        |          |1 = Receipted frame ID parity is not correct.
S     * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
S     * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0])= 1) and enable LIN frame ID parity check function LIN_IDPEN (UA_LIN_CTL [9]).
S     * |[3]     |LINS_SYNC_F|LIN Slave Sync Field
S     * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization mode.
S     * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to re-search new frame header by writing 1 to this bit.
S     * |        |          |0 = The current character is not at LIN sync state.
S     * |        |          |1 = The current character is at LIN sync state.
S     * |        |          |Note1: This bit is only valid when in LIN Slave mode (LINS_EN(UA_LIN_CTL[0]) = 1).
S     * |        |          |Note2: This bit is read only, but it can be cleared by writing 1 to it.
S     * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new frame header.
S     * |[8]     |LIN_BKDET_F|LIN Break Detection Flag (Read Only)
S     * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through software.
S     * |        |          |0 = LIN break not detected.
S     * |        |          |1 = LIN break detected.
S     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (LIN_BKDET_EN (UA_LIN_CTL[10]) =1).
S     * |[9]     |BIT_ERR_F |Bit Error Detect Status Flag (Read Only)
S     * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.
S     * |        |          |When occur bit error, if the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
S     * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S     * |        |          |Note2: This bit is only valid when enable bit error detection function (BIT_ERR_EN (UA_LIN_CTL [12]) = 1).
S     */
S    __IO uint32_t LIN_SR;
S} UART_T;
S
S
S/** @addtogroup UART_CONST UART Bit Field Definition
S    Constant Definitions for UART Controller
S  @{
S */
S
S
S/* UART THR Bit Field Definitions */
S#define UART_THR_THR_Pos            0                                       /*!< UART_T::THR: THR Position  */
S#define UART_THR_THR_Msk            (0xFul << UART_THR_THR_Pos)             /*!< UART_T::THR: THR Mask      */
S
S/* UART RBR Bit Field Definitions */
S#define UART_RBR_RBR_Pos            0                                       /*!< UART_T::RBR: RBR Position */
S#define UART_RBR_RBR_Msk            (0xFul << UART_RBR_RBR_Pos)             /*!< UART_T::RBR: RBR Mask      */
S
S/* UART IER Bit Field Definitions */
S#define UART_IER_AERIEN_Pos         18                                      /*!< UART_T::IER: AERIEN Position           */
S#define UART_IER_AERIEN_Msk         (1ul << UART_IER_AERIEN_Pos)            /*!< UART_T::IER: AERIEN Mask                */
S
S#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART_T::IER: AUTO_CTS_EN Position      */
S#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART_T::IER: AUTO_CTS_EN Mask           */
S
S#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART_T::IER: AUTO_RTS_EN Position      */
S#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART_T::IER: AUTO_RTS_EN Mask           */
S
S#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART_T::IER: TIME_OUT_EN Position      */
S#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART_T::IER: TIME_OUT_EN Mask           */
S
S#define UART_IER_WKDATIEN_Pos       10                                      /*!< UART_T::IER: WKDATIEN Position         */
S#define UART_IER_WKDATIEN_Msk       (1ul << UART_IER_WKDATIEN_Pos)          /*!< UART_T::IER: WKDATIEN Mask              */
S
S#define UART_IER_LIN_IEN_Pos        8                                       /*!< UART_T::IER: LIN_IEN Position          */
S#define UART_IER_LIN_IEN_Msk        (1ul << UART_IER_LIN_IEN_Pos)           /*!< UART_T::IER: LIN_IEN Mask               */
S
S#define UART_IER_WKCTSIEN_Pos       6                                       /*!< UART_T::IER: WKCTSIEN Position         */
S#define UART_IER_WKCTSIEN_Msk       (1ul << UART_IER_WKCTSIEN_Pos)          /*!< UART_T::IER: WKCTSIEN Mask              */
S
S#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART_T::IER: BUF_ERR_IEN Position      */
S#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART_T::IER: BUF_ERR_IEN Mask           */
S
S#define UART_IER_TOUT_IEN_Pos        4                                      /*!< UART_T::IER: TOUT_IEN Position          */
S#define UART_IER_TOUT_IEN_Msk        (1ul << UART_IER_TOUT_IEN_Pos)         /*!< UART_T::IER: TOUT_IEN Mask               */
S
S#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART_T::IER: MODEM_IEN Position        */
S#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART_T::IER: MODEM_IEN Mask             */
S
S#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART_T::IER: RLS_IEN Position          */
S#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART_T::IER: RLS_IEN Mask               */
S
S#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART_T::IER: THRE_IEN Position         */
S#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART_T::IER: THRE_IEN Mask              */
S
S#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART_T::IER: RDA_IEN Position           */
S#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART_T::IER: RDA_IEN Mask               */
S
S/* UART FCR Bit Field Definitions */
S#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART_T::FCR: RTS_TRI_LEV Position       */
S#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART_T::FCR: RTS_TRI_LEV Mask           */
S
S#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART_T::FCR: RX_DIS Position            */
S#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART_T::FCR: RX_DIS Mask                */
S
S#define UART_FCR_RFITL_Pos          4                                       /*!< UART_T::FCR: RFITL Position             */
S#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART_T::FCR: RFITL Mask                 */
S
S#define UART_FCR_TFR_Pos            2                                       /*!< UART_T::FCR: TFR Position               */
S#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART_T::FCR: TFR Mask                   */
S
S#define UART_FCR_RFR_Pos            1                                       /*!< UART_T::FCR: RFR Position               */
S#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART_T::FCR: RFR Mask                   */
S
S/* UART LCR Bit Field Definitions */
S#define UART_LCR_BCB_Pos            6                                       /*!< UART_T::LCR: BCB Position               */
S#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART_T::LCR: BCB Mask                   */
S
S#define UART_LCR_SPE_Pos            5                                       /*!< UART_T::LCR: SPE Position               */
S#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART_T::LCR: SPE Mask                   */
S
S#define UART_LCR_EPE_Pos            4                                       /*!< UART_T::LCR: EPE Position               */
S#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART_T::LCR: EPE Mask                   */
S
S#define UART_LCR_PBE_Pos            3                                       /*!< UART_T::LCR: PBE Position               */
S#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART_T::LCR: PBE Mask                   */
S
S#define UART_LCR_NSB_Pos            2                                       /*!< UART_T::LCR: NSB Position               */
S#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART_T::LCR: NSB Mask                   */
S
S#define UART_LCR_WLS_Pos            0                                       /*!< UART_T::LCR: WLS Position               */
S#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART_T::LCR: WLS Mask                   */
S
S/* UART MCR Bit Field Definitions */
S#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART_T::MCR: RTS_ST Position            */
S#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART_T::MCR: RTS_ST Mask                */
S
S#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART_T::MCR: LEV_RTS Position           */
S#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART_T::MCR: LEV_RTS Mask               */
S
S#define UART_MCR_RTS_Pos            1                                       /*!< UART_T::MCR: RTS Position               */
S#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART_T::MCR: RTS Mask                   */
S
S/* UART MSR Bit Field Definitions */
S#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART_T::MSR: LEV_CTS Position           */
S#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART_T::MSR: LEV_CTS Mask               */
S
S#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART_T::MSR: CTS_ST Position            */
S#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART_T::MSR: CTS_ST Mask                */
S
S#define UART_MSR_DCTSF_Pos          0                                       /*!< UART_T::MSR: DCTST Position             */
S#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART_T::MSR: DCTST Mask                 */
S
S/* UART FSR Bit Field Definitions */
S#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART_T::FSR: TE_FLAG Position           */
S#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART_T::FSR: TE_FLAG Mask               */
S
S#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART_T::FSR: TX_OVER_IF Position        */
S#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART_T::FSR: TX_OVER_IF Mask            */
S
S#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART_T::FSR: TX_FULL Position           */
S#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART_T::FSR: TX_FULL Mask               */
S
S#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART_T::FSR: TX_EMPTY Position          */
S#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART_T::FSR: TX_EMPTY Mask              */
S
S#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART_T::FSR: TX_POINTER Position        */
S#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART_T::FSR: TX_POINTER Mask            */
S
S#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART_T::FSR: RX_FULL Position           */
S#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART_T::FSR: RX_FULL Mask               */
S
S#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART_T::FSR: RX_EMPTY Position          */
S#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART_T::FSR: RX_EMPTY Mask              */
S
S#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART_T::FSR: RX_POINTERS Position       */
S#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART_T::FSR: RX_POINTER Mask            */
S
S#define UART_FSR_BIF_Pos            6                                       /*!< UART_T::FSR: BIF Position               */
S#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART_T::FSR: BIF Mask                   */
S
S#define UART_FSR_FEF_Pos            5                                       /*!< UART_T::FSR: FEF Position               */
S#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART_T::FSR: FEF Mask                   */
S
S#define UART_FSR_PEF_Pos            4                                       /*!< UART_T::FSR: PEF Position               */
S#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART_T::FSR: PEF Mask                   */
S
S#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART_T::FSR: RS485_ADD_DETF Position    */
S#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART_T::FSR: RS485_ADD_DETF Mask        */
S
S#define UART_FSR_ABRDTOIF_Pos       2                                       /*!< UART_T::FSR: ABRDTOIF Position          */
S#define UART_FSR_ABRDTOIF_Msk       (1ul << UART_FSR_ABRDTOIF_Pos)          /*!< UART_T::FSR: ABRDTOIF Mask              */
S
S#define UART_FSR_ABRDIF_Pos         1                                       /*!< UART_T::FSR: ABRDIF Position            */
S#define UART_FSR_ABRDIF_Msk         (1ul << UART_FSR_ABRDIF_Pos)            /*!< UART_T::FSR: ABRDIF Mask                */
S
S#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART_T::FSR: RX_OVER_IF Position        */
S#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART_T::FSR: RX_OVER_IF Mask            */
S
S/* UART ISR Bit Field Definitions */
S#define UART_ISR_DATWKIF_Pos        17                                      /*!< UART_T::ISR: DATWKIF Position           */
S#define UART_ISR_DATWKIF_Msk        (1ul << UART_ISR_DATWKIF_Pos)           /*!< UART_T::ISR: DATWKIF Mask               */
S
S#define UART_ISR_CTSWKIF_Pos        16                                      /*!< UART_T::ISR: CTSWKIF Position           */
S#define UART_ISR_CTSWKIF_Msk        (1ul << UART_ISR_CTSWKIF_Pos)           /*!< UART_T::ISR: CTSWKIF Mask               */
S
S#define UART_ISR_LIN_INT_Pos        15                                      /*!< UART_T::ISR: LIN_INT Position           */
S#define UART_ISR_LIN_INT_Msk        (1ul << UART_ISR_LIN_INT_Pos)           /*!< UART_T::ISR: LIN_INT Mask               */
S
S#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART_T::ISR: BUF_ERR_INT Position       */
S#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART_T::ISR: BUF_ERR_INT Mask           */
S
S#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART_T::ISR: TOUT_INT Position          */
S#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART_T::ISR: TOUT_INT Mask              */
S
S#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART_T::ISR: MODEM_INT Position         */
S#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART_T::ISR: MODEM_INT Mask             */
S
S#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART_T::ISR: RLS_INT Position           */
S#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART_T::ISR: RLS_INT Mask               */
S
S#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART_T::ISR: THRE_INT Position          */
S#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART_T::ISR: THRE_INT Mask              */
S
S#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART_T::ISR: RDA_INT Position           */
S#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART_T::ISR: RDA_INT Mask               */
S
S#define UART_ISR_LIN_IF_Pos         7                                       /*!< UART_T::ISR: LIN RX_IF Position         */
S#define UART_ISR_LIN_IF_Msk         (1ul << UART_ISR_LIN_IF_Pos)            /*!< UART_T::ISR: LIN RX_IF Mask             */
S
S#define UART_ISR_WKIF_Pos           6                                       /*!< UART_T::ISR: WKIF Position        */
S#define UART_ISR_WKIF_Msk           (1ul << UART_ISR_WKIF_Pos)              /*!< UART_T::ISR: WKIF Mask            */
S
S#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART_T::ISR: BUF_ERR_IF Position        */
S#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART_T::ISR: BUF_ERR_IF Mask            */
S
S#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART_T::ISR: TOUT_IF Position           */
S#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART_T::ISR: TOUT_IF Mask               */
S
S#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART_T::ISR: MODEM_IF Position          */
S#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART_T::ISR: MODEM_IF Mask              */
S
S#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART_T::ISR: RLS_IF Position            */
S#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART_T::ISR: RLS_IF Mask                */
S
S#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART_T::ISR: THRE_IF Position           */
S#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART_T::ISR: THRE_IF Mask               */
S
S#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART_T::ISR: RDA_IF Position            */
S#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART_T::ISR: RDA_IF Mask                */
S
S
S/* UART TOR Bit Field Definitions */
S#define UART_TOR_DLY_Pos           8                                        /*!< UART_T::TOR: DLY Position               */
S#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART_T::TOR: DLY Mask                   */
S
S#define UART_TOR_TOIC_Pos          0                                        /*!< UART_T::TOR: TOIC Position              */
S#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)
S
S/* UART BAUD Bit Field Definitions */
S#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART BARD: DIV_X_EN Position         */
S#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART BARD: DIV_X_EN Mask             */
S
S#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART BARD: DIV_X_ONE Position        */
S#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART BARD: DIV_X_ONE Mask            */
S
S#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART BARD: DIVIDER_X Position        */
S#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART BARD: DIVIDER_X Mask            */
S
S#define UART_BAUD_BRD_Pos         0                                         /*!< UART BARD: BRD Position              */
S#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART BARD: BRD Mask                  */
S
S/* UART IRCR Bit Field Definitions */
S#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART_T::IRCR: INV_RX Position           */
S#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART_T::IRCR: INV_RX Mask               */
S
S#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART_T::IRCR: INV_TX Position           */
S#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART_T::IRCR: INV_TX Mask               */
S
S#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART_T::IRCR: TX_SELECT Position        */
S#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART_T::IRCR: TX_SELECT Mask            */
S
S/* UART ALT_CSR Bit Field Definitions */
S#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART_T::ALT_CSR: ADDR_MATCH Position    */
S#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART_T::ALT_CSR: ADDR_MATCH Mask        */
S
S#define UART_ALT_CSR_ABRDBITS_Pos       19                                       /*!< UART_T::ALT_CSR: ABRDBITS Position      */
S#define UART_ALT_CSR_ABRDBITS_Msk       (0x3ul << UART_ALT_CSR_ABRDBITS_Pos)     /*!< UART_T::ALT_CSR: ABRDBITS Mask          */
S
S#define UART_ALT_CSR_ABRDEN_Pos         18                                       /*!< UART_T::ALT_CSR: ABRDEN Position        */
S#define UART_ALT_CSR_ABRDEN_Msk         (1ul << UART_ALT_CSR_ABRDEN_Pos)         /*!< UART_T::ALT_CSR: ABRDEN Mask            */
S
S#define UART_ALT_CSR_ABRIF_Pos          17                                       /*!< UART_T::ALT_CSR: ABRIF Position         */
S#define UART_ALT_CSR_ABRIF_Msk          (1ul << UART_ALT_CSR_ABRIF_Pos)          /*!< UART_T::ALT_CSR: ABRIF Mask             */
S
S#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART_T::ALT_CSR: RS485_ADD_EN Position  */
S#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART_T::ALT_CSR: RS485_ADD_EN Mask      */
S
S#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART_T::ALT_CSR: RS485_AUD Position     */
S#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART_T::ALT_CSR: RS485_AUD Mask         */
S
S#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART_T::ALT_CSR: RS485_AAD Position     */
S#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART_T::ALT_CSR: RS485_AAD Mask         */
S
S#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART_T::ALT_CSR: RS485_NMM Position     */
S#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART_T::ALT_CSR: RS485_NMM Mask         */
S
S#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Position     */
S#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Mask         */
S
S#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART_T::ALT_CSR: LIN RX Enable Position     */
S#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN RX Enable Mask         */
S
S#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART_T::ALT_CSR: UART LIN Break Field Length Position     */
S#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART_T::ALT_CSR: UART LIN Break Field Length Mask         */
S
S/* UART FUN_SEL Bit Field Definitions */
S#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART_T::FUN_SEL: FUN_SEL Position       */
S#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART_T::FUN_SEL: FUN_SEL Mask           */
S
S/* UART LIN_CTL Bit Field Definitions */
S#define UART_LIN_CTL_LIN_PID_Pos        24                                        /*!< UART_T::LIN_CTL: LIN_PID Position       */
S#define UART_LIN_CTL_LIN_PID_Msk        (0xFFul << UART_LIN_CTL_LIN_PID_Pos)      /*!< UART_T::LIN_CTL: LIN_PID Mask           */
S
S#define UART_LIN_CTL_LIN_HEAD_SEL_Pos   22                                        /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Position       */
S#define UART_LIN_CTL_LIN_HEAD_SEL_Msk   (0x3ul << UART_LIN_CTL_LIN_HEAD_SEL_Pos)  /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Mask           */
S
S#define UART_LIN_CTL_LIN_BS_LEN_Pos     20                                        /*!< UART_T::LIN_CTL: LIN_BS_LEN Position       */
S#define UART_LIN_CTL_LIN_BS_LEN_Msk     (0x3ul << UART_LIN_CTL_LIN_BS_LEN_Pos)    /*!< UART_T::LIN_CTL: LIN_BS_LEN Mask           */
S
S#define UART_LIN_CTL_LIN_BKFL_Pos       16                                        /*!< UART_T::LIN_CTL: LIN_BKFL Position       */
S#define UART_LIN_CTL_LIN_BKFL_Msk       (0xFul << UART_LIN_CTL_LIN_BKFL_Pos)      /*!< UART_T::LIN_CTL: LIN_BKFL Mask           */
S
S#define UART_LIN_CTL_BIT_ERR_EN_Pos     12                                        /*!< UART_T::LIN_CTL: BIT_ERR_EN Position       */
S#define UART_LIN_CTL_BIT_ERR_EN_Msk     (1ul << UART_LIN_CTL_BIT_ERR_EN_Pos)      /*!< UART_T::LIN_CTL: BIT_ERR_EN Mask           */
S
S#define UART_LIN_CTL_LIN_RX_DIS_Pos     11                                        /*!< UART_T::LIN_CTL: LIN_RX_DIS Position       */
S#define UART_LIN_CTL_LIN_RX_DIS_Msk     (1ul << UART_LIN_CTL_LIN_RX_DIS_Pos)      /*!< UART_T::LIN_CTL: LIN_RX_DIS Mask           */
S
S#define UART_LIN_CTL_LIN_BKDET_EN_Pos   10                                        /*!< UART_T::LIN_CTL: LIN_BKDET_EN Position       */
S#define UART_LIN_CTL_LIN_BKDET_EN_Msk   (1ul << UART_LIN_CTL_LIN_BKDET_EN_Pos)    /*!< UART_T::LIN_CTL: LIN_BKDET_EN Mask           */
S
S#define UART_LIN_CTL_LIN_IDPEN_Pos      9                                         /*!< UART_T::LIN_CTL: LIN_IDPEN Position       */
S#define UART_LIN_CTL_LIN_IDPEN_Msk      (1ul << UART_LIN_CTL_LIN_IDPEN_Pos)       /*!< UART_T::LIN_CTL: LIN_IDPEN Mask           */
S
S#define UART_LIN_CTL_LIN_SHD_Pos        8                                         /*!< UART_T::LIN_CTL: LIN_SHD Position       */
S#define UART_LIN_CTL_LIN_SHD_Msk        (1ul << UART_LIN_CTL_LIN_SHD_Pos)         /*!< UART_T::LIN_CTL: LIN_SHD Mask           */
S
S#define UART_LIN_CTL_LIN_MUTE_EN_Pos    4                                          /*!< UART_T::LIN_CTL: LIN_MUTE_EN Position       */
S#define UART_LIN_CTL_LIN_MUTE_EN_Msk    (1ul << UART_LIN_CTL_LIN_MUTE_EN_Pos)      /*!< UART_T::LIN_CTL: LIN_MUTE_EN Mask           */
S
S#define UART_LIN_CTL_LINS_DUM_EN_Pos    3                                          /*!< UART_T::LIN_CTL: LINS_DUM_EN Position       */
S#define UART_LIN_CTL_LINS_DUM_EN_Msk    (1ul << UART_LIN_CTL_LINS_DUM_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_DUM_EN Mask           */
S
S#define UART_LIN_CTL_LINS_ARS_EN_Pos    2                                          /*!< UART_T::LIN_CTL: LINS_ARS_EN Position       */
S#define UART_LIN_CTL_LINS_ARS_EN_Msk    (1ul << UART_LIN_CTL_LINS_ARS_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_ARS_EN Mask           */
S
S#define UART_LIN_CTL_LINS_HDET_EN_Pos   1                                          /*!< UART_T::LIN_CTL: LINS_HDET_EN Position       */
S#define UART_LIN_CTL_LINS_HDET_EN_Msk   (1ul << UART_LIN_CTL_LINS_HDET_EN_Pos)     /*!< UART_T::LIN_CTL: LINS_HDET_EN Mask           */
S
S#define UART_LIN_CTL_LINS_EN_Pos        0                                          /*!< UART_T::LIN_CTL: LINS_EN Position       */
S#define UART_LIN_CTL_LINS_EN_Msk        (1ul << UART_LIN_CTL_LINS_EN_Pos)          /*!< UART_T::LIN_CTL: LINS_EN Mask           */
S
S/* UART LIN_SR Bit Field Definitions */
S#define UART_LIN_SR_BIT_ERR_F_Pos       9                                           /*!< UART_T::LIN_SR: BIT_ERR_F Position         */
S#define UART_LIN_SR_BIT_ERR_F_Msk       (1ul << UART_LIN_SR_BIT_ERR_F_Pos)          /*!< UART_T::LIN_SR: BIT_ERR_F Mask             */
S
S#define UART_LIN_SR_LINS_BKDET_F_Pos    8                                           /*!< UART_T::LIN_SR: LINS_BKDET_F Position      */
S#define UART_LIN_SR_LINS_BKDET_F_Msk    (1ul << UART_LIN_SR_LINS_BKDET_F_Pos)       /*!< UART_T::LIN_SR: LINS_BKDET_F Mask          */
S
S#define UART_LIN_SR_LINS_SYNC_F_Pos     3                                           /*!< UART_T::LIN_SR: LINS_SYNC_F Position       */
S#define UART_LIN_SR_LINS_SYNC_F_Msk     (1ul << UART_LIN_SR_LINS_SYNC_F_Pos)        /*!< UART_T::LIN_SR: LINS_SYNC_F Mask           */
S
S#define UART_LIN_SR_LINS_IDPERR_F_Pos   2                                           /*!< UART_T::LIN_SR: LINS_IDPERR_F Position     */
S#define UART_LIN_SR_LINS_IDPERR_F_Msk   (1ul << UART_LIN_SR_LINS_IDPERR_F_Pos)      /*!< UART_T::LIN_SR: LINS_IDPERR_F Mask         */
S
S#define UART_LIN_SR_LINS_HERR_F_Pos     1                                           /*!< UART_T::LIN_SR: LINS_HERR_F Position       */
S#define UART_LIN_SR_LINS_HERR_F_Msk     (1ul << UART_LIN_SR_LINS_HERR_F_Pos)        /*!< UART_T::LIN_SR: LINS_HERR_F Mask           */
S
S#define UART_LIN_SR_LINS_HDET_F_Pos     0                                           /*!< UART_T::LIN_SR: LINS_HDET_F Position       */
S#define UART_LIN_SR_LINS_HDET_F_Msk     (1ul << UART_LIN_SR_LINS_HDET_F_Pos)        /*!< UART_T::LIN_SR: LINS_HDET_F Mask           */
S
S/*@}*/ /* end of group UART_CONST */
S/*@}*/ /* end of group UART */
S
S
S
S/*----------------------------- Watchdog Timer (WDT) -----------------------------*/
S/**
S    @addtogroup WDT Watch Dog Timer Controller (WDT)
S    Memory Mapped Structure for WDT Controller
S@{ */
Stypedef struct
S{
S    /**
S     * WTCR
S     * ===================================================================================================
S     * Offset: 0x00  Watchdog Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WTR       |Reset Watchdog Timer Up Counter (Write Protect)
S     * |        |          |0 = No effect.
S     * |        |          |1 = Reset the internal 18-bit WDT up counter value.
S     * |        |          |Note: This bit will be automatically cleared by hardware.
S     * |[1]     |WTRE      |Watchdog Timer Reset Enable (Write Protect)
S     * |        |          |Setting this bit will enable the WDT time-out reset function if the WDT up counter value has not been cleared after the specific WDT reset delay period expires.
S     * |        |          |0 = WDT time-out reset function Disabled.
S     * |        |          |1 = WDT time-out reset function Enabled.
S     * |[2]     |WTRF      |Watchdog Timer Time-out Reset Flag
S     * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
S     * |        |          |0 = WDT time-out reset did not occur.
S     * |        |          |1 = WDT time-out reset occurred.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[3]     |WTIF      |Watchdog Timer Time-out Interrupt Flag
S     * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval.
S     * |        |          |0 = WDT time-out interrupt did not occur.
S     * |        |          |1 = WDT time-out interrupt occurred.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[4]     |WTWKE     |Watchdog Timer Time-out Wake-Up Function Control
S     * |        |          |(Write Protect)
S     * |        |          |If this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out interrupt signal will generate a wake-up trigger event to chip.
S     * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
S     * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
S     * |        |          |Note: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source is selected to 10 kHz oscillator.
S     * |[5]     |WTWKF     |Watchdog Timer Time-out Wake-Up Flag
S     * |        |          |This bit indicates the interrupt wake-up flag status of WDT.
S     * |        |          |0 = WDT does not cause chip wake-up.
S     * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[6]     |WTIE      |Watchdog Timer Time-out Interrupt Enable Control (Write Protect)
S     * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
S     * |        |          |0 = WDT time-out interrupt Disabled.
S     * |        |          |1 = WDT time-out interrupt Enabled.
S     * |[7]     |WTE       |Watchdog Timer Enable Control (Write Protect)
S     * |        |          |0 = WDT Disabled. (This action will reset the internal up counter value.)
S     * |        |          |1 = WDT Enabled.
S     * |        |          |Note: If CWDTEN (CONFIG0[31] Watchdog Enable) bit is set to 0, this bit is forced as 1 and
S     * |        |          | user cannot change this bit to 0.
S     * |[10:8]  |WTIS      |Watchdog Timer Time-out Interval Selection (Write Protect)
S     * |        |          |These three bits select the time-out interval period for the WDT.
S     * |        |          |000 = 2^4 *WDT_CLK.
S     * |        |          |001 = 2^6 * WDT_CLK.
S     * |        |          |010 = 2^8 * WDT_CLK.
S     * |        |          |011 = 2^10 * WDT_CLK.
S     * |        |          |100 = 2^12 * WDT_CLK.
S     * |        |          |101 = 2^14 * WDT_CLK.
S     * |        |          |110 = 2^16 * WDT_CLK.
S     * |        |          |111 = 2^18 * WDT_CLK.
S     * |[31]    |DBGACK_WDT|ICE Debug Mode Acknowledge Disable Control (Write Protect)
S     * |        |          |0 = ICE debug mode acknowledgment effects WDT counting.
S     * |        |          |WDT up counter will be held while CPU is held by ICE.
S     * |        |          |1 = ICE debug mode acknowledgment Disabled.
S     * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
S     */
S    __IO uint32_t  WTCR;
S
S    /**
S     * WTCRALT
S     * ===================================================================================================
S     * Offset: 0x04  Watchdog Timer Alternative Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[1:0]   |WTRDSEL   |Watchdog Timer Reset Delay Selection (Write Protect)
S     * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter to prevent WDT time-out reset happened.
S     * |        |          |User can select a suitable value of WDT Reset Delay Period for different WDT time-out period.
S     * |        |          |These bits are protected bit.
S     * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection.
S     * |        |          |Reference the register REGWRPROT at address GCR_BASE+0x100.
S     * |        |          |00 = Watchdog Timer Reset Delay Period is 1026 * WDT_CLK.
S     * |        |          |01 = Watchdog Timer Reset Delay Period is 130 * WDT_CLK.
S     * |        |          |10 = Watchdog Timer Reset Delay Period is 18 * WDT_CLK.
S     * |        |          |11 = Watchdog Timer Reset Delay Period is 3 * WDT_CLK.
S     * |        |          |Note: This register will be reset to 0 if WDT time-out reset happened.
S     */
S    __IO uint32_t  WTCRALT;
S} WDT_T;
S
S/**
S    @addtogroup WDT_CONST WDT Bit Field Definition
S    Constant Definitions for WDT Controller
S@{ */
S
S
S/* WDT WTCR Bit Field Definitions */
S#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT_T::WTCR: DBGACK_WDT Position */
S#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT_T::WTCR: DBGACK_WDT Mask */
S
S#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT_T::WTCR: WTIS Position */
S#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT_T::WTCR: WTIS Mask */
S
S#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT_T::WTCR: WTE Position */
S#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT_T::WTCR: WTE Mask */
S
S#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT_T::WTCR: WTIE Position */
S#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT_T::WTCR: WTIE Mask */
S
S#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT_T::WTCR: WTWKF Position */
S#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT_T::WTCR: WTWKF Mask */
S
S#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT_T::WTCR: WTWKE Position */
S#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT_T::WTCR: WTWKE Mask */
S
S#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT_T::WTCR: WTIF Position */
S#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT_T::WTCR: WTIF Mask */
S
S#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT_T::WTCR: WTRF Position */
S#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT_T::WTCR: WTRF Mask */
S
S#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT_T::WTCR: WTRE Position */
S#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT_T::WTCR: WTRE Mask */
S
S#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT_T::WTCR: WTR Position */
S#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT_T::WTCR: WTR Mask */
S
S/* WDT WTCRALT Bit Field Definitions */
S#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT_T::WTCRALT: WTRDSEL Position */
S#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT_T::WTCRALT: WTRDSEL Mask */
S/*@}*/ /* end of group WDT_CONST */
S/*@}*/ /* end of group WDT */
S
S
S/*----------------------------- Window Watchdog Timer (WWDT) -----------------------------*/
S/** @addtogroup WWDT Window Watchdog Timer (WWDT)
S    Memory Mapped Structure for WWDT Controller
S  @{
S */
Stypedef struct
S{
S    /**
S     * WWDTRLD
S     * ===================================================================================================
S     * Offset: 0x00  Window Watchdog Timer Reload Counter Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[31:0]  |WWDTRLD   |WWDT Reload Counter Register
S     * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
S     * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT
S     * |        |          | counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT
S     * |        |          | counter value is larger than WINCMP, WWDT reset signal will generate immediately.
S     */
S    __IO uint32_t  WWDTRLD;
S
S    /**
S     * WWDTCR
S     * ===================================================================================================
S     * Offset: 0x04  Window Watchdog Timer Control Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WWDTEN    |WWDT Enable Control
S     * |        |          |0 = WWDT counter is stopped.
S     * |        |          |1 = WWDT counter is starting counting.
S     * |[1]     |WWDTIE    |WWDT Interrupt Enable Control
S     * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform to CPU.
S     * |        |          |0 = WWDT counter compare match interrupt Disabled.
S     * |        |          |1 = WWDT counter compare match interrupt Enabled.
S     * |[11:8]  |PERIODSEL |WWDT Counter Prescale Period Selection
S     * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT.
S     * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT.
S     * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT.
S     * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT.
S     * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT.
S     * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT.
S     * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT.
S     * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT.
S     * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT.
S     * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT.
S     * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT.
S     * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT.
S     * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT.
S     * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT.
S     * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT.
S     * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT.
S     * |[21:16] |WINCMP    |WWDT Window Compare Register
S     * |        |          |Set this register to adjust the valid reload window.
S     * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value between 0 and WINCMP.
S     * |        |          |If user writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal will generate immediately.
S     * |[31]    |DBGACK_WWDT|ICE Debug Mode Acknowledge Disable Control
S     * |        |          |0 = ICE debug mode acknowledgment effects WWDT counting.
S     * |        |          |WWDT down counter will be held while CPU is held by ICE.
S     * |        |          |1 = ICE debug mode acknowledgment Disabled.
S     * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
S     */
S    __IO uint32_t  WWDTCR;
S
S    /**
S     * WWDTSR
S     * ===================================================================================================
S     * Offset: 0x08  Window Watchdog Timer Status Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
S     * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches WINCMP value.
S     * |        |          |0 = No effect.
S     * |        |          |1 = WWDT counter value matches WINCMP value.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     * |[1]     |WWDTRF    |WWDT Time-out Reset Flag
S     * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
S     * |        |          |0 = WWDT time-out reset did not occur.
S     * |        |          |1 = WWDT time-out reset occurred.
S     * |        |          |Note: This bit is cleared by writing 1 to it.
S     */
S    __IO uint32_t  WWDTSR;
S
S    /**
S     * WWDTCVR
S     * ===================================================================================================
S     * Offset: 0x0C  Window Watchdog Timer Counter Value Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[5:0]   |WWDTCVAL  |WWDT Counter Value
S     * |        |          |WWDTCVAL will be updated continuously to monitor 6-bit down counter value.
S     */
S    __I  uint32_t  WWDTCVR;
S} WWDT_T;
S
S/** @addtogroup WWDT_CONST Bit Field Definition
S  @{
S */
S
S
S/* WWDT WWDTRLD Bit Field Definitions */
S#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT_T::WWDTRLD: WWDTRLD Position */
S#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT_T::WWDTRLD: WWDTRLD Mask */
S
S/* WWDT WWDTCR Bit Field Definitions */
S#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT_T::WWDTCR: DBGACK_WWDT Position */
S#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT_T::WWDTCR: DBGACK_WWDT Mask */
S
S#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT_T::WWDTCR: WINCMP Position */
S#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT_T::WWDTCR: WINCMP Mask */
S
S#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT_T::WWDTCR: PERIODSEL Position */
S#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT_T::WWDTCR: PERIODSEL Mask */
S
S#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT_T::WWDTCR: WWDTIE Position */
S#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT_T::WWDTCR: WWDTIE Mask */
S
S#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT_T::WWDTCR: WWDTEN Position */
S#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT_T::WWDTCR: WWDTEN Mask */
S
S/* WWDT WWDTSR Bit Field Definitions */
S#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT_T::WWDTSR: WWDTRF Position */
S#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT_T::WWDTSR: WWDTRF Mask */
S
S#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT_T::WWDTSR: WWDTIF Position */
S#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT_T::WWDTSR: WWDTIF Mask */
S
S/* WWDT WWDTCVR Bit Field Definitions */
S#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT_T::WWDTCVR: WWDTCVAL Position */
S#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT_T::WWDTCVR: WWDTCVAL Mask */
S/*@}*/ /* end of group WWDT_CONST */
S/*@}*/ /* end of group WWDT */
S
S
S
S
S
S/*@}*/ /* end of group REGISTER */
S
S
S/******************************************************************************/
S/*                         Peripheral memory map                              */
S/******************************************************************************/
S/** @addtogroup PERIPHERAL_MEM_MAP Peripheral Memory Map
S  Memory Mapped Structure for Peripheral
S  @{
S */
S/* Peripheral and SRAM base address */
S#define FLASH_BASE          ((     uint32_t)0x00000000)
S#define SRAM_BASE           ((     uint32_t)0x20000000)
S#define AHB_BASE            ((     uint32_t)0x50000000)
S#define APB1_BASE           ((     uint32_t)0x40000000)
S#define APB2_BASE           ((     uint32_t)0x40100000)
S
S/* Peripheral memory map */
S#define GPIO_BASE           (AHB_BASE        + 0x4000)                  /*!< GPIO Base Address                                   */
S#define PA_BASE             (GPIO_BASE               )                  /*!< GPIO PORTA Base Address                             */
S#define PB_BASE             (GPIO_BASE       + 0x0040)                  /*!< GPIO PORTB Base Address                             */
S#define PC_BASE             (GPIO_BASE       + 0x0080)                  /*!< GPIO PORTC Base Address                             */
S#define PD_BASE             (GPIO_BASE       + 0x00C0)                  /*!< GPIO PORTD Base Address                             */
S#define PE_BASE             (GPIO_BASE       + 0x0100)                  /*!< GPIO PORTE Base Address                             */
S#define PF_BASE             (GPIO_BASE       + 0x0140)                  /*!< GPIO PORTF Base Address                             */
S#define GPIO_DBNCECON_BASE  (GPIO_BASE       + 0x0180)                  /*!< GPIO De-bounce Cycle Control Base Address           */
S#define GPIO_PIN_DATA_BASE  (GPIO_BASE       + 0x0200)                  /*!< GPIO Pin Data Input/Output Control Base Address     */
S
S
S#define UART0_BASE           (APB1_BASE      + 0x50000)                 /*!< UART0 Base Address                              */
S#define UART1_BASE           (APB2_BASE      + 0x50000)                 /*!< UART1 Base Address                              */
S#define UART2_BASE           (APB2_BASE      + 0x54000)                 /*!< UART2 Base Address                              */
S#define UART3_BASE           (APB1_BASE      + 0x54000)                 /*!< UART3 Base Address                              */
S#define UART4_BASE           (APB1_BASE      + 0x58000)                 /*!< UART4 Base Address                              */
S#define UART5_BASE           (APB2_BASE      + 0x58000)                 /*!< UART5 Base Address                              */
S
S
S#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
S#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
S#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
S#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
S
S#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watchdog Timer Base Address                      */
S
S#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watchdog Timer Base Address               */
S
S#define SPI0_BASE            (APB1_BASE      + 0x30000)                 /*!< SPI0 Base Address                                */
S
S#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
S#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
S
S#define ADC_BASE             (APB1_BASE      + 0xE0000)                 /*!< ADC Base Address                                 */
S
S#define CLK_BASE             (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
S
S#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
S
S#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
S
S#define FMC_BASE             (AHB_BASE       + 0x0C000)
S
S#define CAN0_BASE            (APB2_BASE      + 0x80000)                 /*!< CAN0 Base Address                                */
S#define CAN1_BASE            (APB2_BASE      + 0x84000)                 /*!< CAN1 Base Address                                */
S
S#define PWM0_BASE            (APB1_BASE      + 0x40000)                 /*!< PWM0 Base Address                                */
S#define PWM1_BASE            (APB2_BASE      + 0x40000)                 /*!< PWM1 Base Address                                */
S
S#define BPWM0_BASE           (APB1_BASE      + 0x44000)                 /*!< BPWM0 Base Address                                */
S#define BPWM1_BASE           (APB2_BASE      + 0x44000)                 /*!< BPWM1 Base Address                                */
S
S/*@}*/ /* end of group PERIPHERAL_MEM_MAP */
S
S/******************************************************************************/
S/*                         Peripheral Definitions                             */
S/******************************************************************************/
S
S/** @addtogroup PERIPHERAL Peripheral Definitions
S  The Definitions of Peripheral
S  @{
S */
S#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
S#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
S#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
S#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
S#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
S#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
S#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */
S
S
S#define UART0               ((UART_T *) UART0_BASE)                     /*!< UART0 Configuration Struct                       */
S#define UART1               ((UART_T *) UART1_BASE)                     /*!< UART1 Configuration Struct                       */
S#define UART2               ((UART_T *) UART2_BASE)                     /*!< UART2 Configuration Struct                       */
S#define UART3               ((UART_T *) UART3_BASE)                     /*!< UART3 Configuration Struct                       */
S#define UART4               ((UART_T *) UART4_BASE)                     /*!< UART4 Configuration Struct                       */
S#define UART5               ((UART_T *) UART5_BASE)                     /*!< UART5 Configuration Struct                       */
S
S#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< Timer0 Configuration Struct                      */
S#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< Timer1 Configuration Struct                      */
S#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< Timer2 Configuration Struct                      */
S#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< Timer3 Configuration Struct                      */
S
S#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watchdog Timer Configuration Struct              */
S
S#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watchdog Timer Configuration Struct       */
S
S#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
S
S#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
S#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
S
S#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
S
S#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
S
S#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
S
S#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
S
S#define FMC                 ((FMC_T *) FMC_BASE)
S
S#define CAN                 ((CAN_T *) CAN0_BASE)
S#define CAN0                ((CAN_T *) CAN0_BASE)                       /*!< CAN0 Configuration Struct                        */
S#define CAN1                ((CAN_T *) CAN1_BASE)                       /*!< CAN1 Configuration Struct                        */
S
S#define PWM0                ((PWM_T *) PWM0_BASE)                       /*!< PWM0 Configuration Struct                        */
S#define PWM1                ((PWM_T *) PWM1_BASE)                       /*!< PWM1 Configuration Struct                        */
S
S#define BPWM0               ((BPWM_T *) BPWM0_BASE)                     /*!< BPWM0 Configuration Struct                       */
S#define BPWM1               ((BPWM_T *) BPWM1_BASE)                     /*!< BPWM1 Configuration Struct                       */
S
S
S/*@}*/ /* end of group PERIPHERAL */
S
S//=============================================================================
S/** @addtogroup IO_ROUTINE I/O routines
S  The Declaration of I/O routines
S  @{
S */
S
S#define UNLOCKREG(x)        do{*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x88;}while(*((__IO uint32_t *)(GCR_BASE + 0x100))==0)
S#define LOCKREG(x)          *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x00
S
S#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
S#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
S
S
Stypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Stypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Stypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
S
S/**
S  * @brief Get a 8-bit unsigned value from specified address
S  * @param[in] addr Address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified address
S  */
S#define M8(addr)  (*((vu8  *) (addr)))
S
S/**
S  * @brief Get a 16-bit unsigned value from specified address
S  * @param[in] addr Address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified address
S  * @note The input address must be 16-bit aligned
S  */
S#define M16(addr) (*((vu16 *) (addr)))
S
S/**
S  * @brief Get a 32-bit unsigned value from specified address
S  * @param[in] addr Address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified address
S  * @note The input address must be 32-bit aligned
S  */
S#define M32(addr) (*((vu32 *) (addr)))
S
S/**
S  * @brief Set a 32-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 32-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 32-bit aligned
S  */
S#define outpw(port,value)     *((volatile unsigned int *)(port)) = (value)
S
S/**
S  * @brief Get a 32-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified I/O port
S  * @note The input port must be 32-bit aligned
S  */
S#define inpw(port)            (*((volatile unsigned int *)(port)))
S
S/**
S  * @brief Set a 16-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 16-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 16-bit aligned
S  */
S#define outps(port,value)     *((volatile unsigned short *)(port)) = (value)
S
S/**
S  * @brief Get a 16-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified I/O port
S  * @note The input port must be 16-bit aligned
S  */
S#define inps(port)            (*((volatile unsigned short *)(port)))
S
S/**
S  * @brief Set a 8-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 8-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  */
S#define outpb(port,value)     *((volatile unsigned char *)(port)) = (value)
S
S/**
S  * @brief Get a 8-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified I/O port
S  */
S#define inpb(port)            (*((volatile unsigned char *)(port)))
S
S/**
S  * @brief Set a 32-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 32-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 32-bit aligned
S  */
S#define outp32(port,value)    *((volatile unsigned int *)(port)) = (value)
S
S/**
S  * @brief Get a 32-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified I/O port
S  * @note The input port must be 32-bit aligned
S  */
S#define inp32(port)           (*((volatile unsigned int *)(port)))
S
S/**
S  * @brief Set a 16-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 16-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 16-bit aligned
S  */
S#define outp16(port,value)    *((volatile unsigned short *)(port)) = (value)
S
S/**
S  * @brief Get a 16-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified I/O port
S  * @note The input port must be 16-bit aligned
S  */
S#define inp16(port)           (*((volatile unsigned short *)(port)))
S
S/**
S  * @brief Set a 8-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 8-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  */
S#define outp8(port,value)     *((volatile unsigned char *)(port)) = (value)
S
S/**
S  * @brief Get a 8-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified I/O port
S  */
S#define inp8(port)            (*((volatile unsigned char *)(port)))
S
S/*@}*/ /* end of group IO_ROUTINE */
S
S
S
S
S/** @addtogroup legacy_Constants Legacy Constants
S  Legacy Constants
S  @{
S*/
S
S
S#define E_SUCCESS   0
S#ifndef NULL
S#define NULL        0
S#endif
S
S#define TRUE        1
S#define FALSE       0
S
S#define ENABLE     1
S#define DISABLE    0
S
S/* Define one bit mask */
S#define BIT0    0x00000001
S#define BIT1    0x00000002
S#define BIT2    0x00000004
S#define BIT3    0x00000008
S#define BIT4    0x00000010
S#define BIT5    0x00000020
S#define BIT6    0x00000040
S#define BIT7    0x00000080
S#define BIT8    0x00000100
S#define BIT9    0x00000200
S#define BIT10   0x00000400
S#define BIT11   0x00000800
S#define BIT12   0x00001000
S#define BIT13   0x00002000
S#define BIT14   0x00004000
S#define BIT15   0x00008000
S#define BIT16   0x00010000
S#define BIT17   0x00020000
S#define BIT18   0x00040000
S#define BIT19   0x00080000
S#define BIT20   0x00100000
S#define BIT21   0x00200000
S#define BIT22   0x00400000
S#define BIT23   0x00800000
S#define BIT24   0x01000000
S#define BIT25   0x02000000
S#define BIT26   0x04000000
S#define BIT27   0x08000000
S#define BIT28   0x10000000
S#define BIT29   0x20000000
S#define BIT30   0x40000000
S#define BIT31   0x80000000
S
S/* Byte Mask Definitions */
S#define BYTE0_Msk               (0x000000FF)
S#define BYTE1_Msk               (0x0000FF00)
S#define BYTE2_Msk               (0x00FF0000)
S#define BYTE3_Msk               (0xFF000000)
S
S#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
S#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
S#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
S#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
S
S/*@}*/ /* end of group legacy_Constants */
S
S
S/******************************************************************************/
S/*                         Peripheral header files                            */
S/******************************************************************************/
S#include "SYS.h"
S#include "ADC.h"
S#include "CAN.h"
S#include "FMC.h"
S#include "GPIO.h"
S#include "I2C.h"
S#include "PWM.h"
S#include "BPWM.h"
S#include "SPI.h"
S#include "TIMER.h"
S#include "WDT.h"
S#include "WWDT.h"
S#include "UART.h"
S#include "CLK.h"
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif // End of __NUC131_H__
N
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 16 "..\..\..\Library\StdDriver\inc\ADC.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup NUC131_ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADCR Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCR_ADEN_CONVERTER_DISABLE   (0UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter disable          */
N#define ADC_ADCR_ADEN_CONVERTER_ENABLE    (1UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter enable           */
N
N#define ADC_ADCR_ADMD_SINGLE            (0UL<<ADC_ADCR_ADMD_Pos)     /*!< Single mode                */
N#define ADC_ADCR_ADMD_SINGLE_CYCLE      (2UL<<ADC_ADCR_ADMD_Pos)     /*!< Single cycle scan mode     */
N#define ADC_ADCR_ADMD_CONTINUOUS        (3UL<<ADC_ADCR_ADMD_Pos)     /*!< Continuous scan mode       */
N
N#define ADC_ADCR_DIFFEN_SINGLE_END      (0UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Single end input mode      */
N#define ADC_ADCR_DIFFEN_DIFFERENTIAL    (1UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Differential input type    */
N
N#define ADC_ADCR_DMOF_UNSIGNED_OUTPUT   (0UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the straight binary format as the output format of the conversion result   */
N#define ADC_ADCR_DMOF_TWOS_COMPLEMENT   (1UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the 2's complement format as the output format of the conversion result    */
N
N#define ADC_ADCR_TRGEN_DISABLE          (0UL<<ADC_ADCR_TRGEN_Pos)    /*!< Disable triggering of A/D conversion by external STADC pin or PWM   */
N#define ADC_ADCR_TRGEN_ENABLE           (1UL<<ADC_ADCR_TRGEN_Pos)    /*!< Enable triggering of A/D conversion by external STADC pin or PWM  */
N
N#define ADC_ADCR_TRGS_STADC             (0UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by external STADC pin */
N#define ADC_ADCR_TRGS_PWM               (3UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by PWM */
N
N#define ADC_ADCR_TRGCOND_LOW_LEVEL      (0UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Low level active     */
N#define ADC_ADCR_TRGCOND_HIGH_LEVEL     (1UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC High level active    */
N#define ADC_ADCR_TRGCOND_FALLING_EDGE   (2UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Falling edge active  */
N#define ADC_ADCR_TRGCOND_RISING_EDGE    (3UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Rising edge active   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCHER Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL         (0UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the external analog input                   */
N#define ADC_ADCHER_PRESEL_INT_BANDGAP              (1UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the internal bandgap voltage                */
N#define ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR   (2UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the output of internal temperature sensor   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCMPR Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCMPR_CMPD(x)                    ((x) << ADC_ADCMPR_CMPD_Pos)          /*!< Compare value for compare function            */
N#define ADC_ADCMPR_CMPMATCNT(x)               (((x)-1) << ADC_ADCMPR_CMPMATCNT_Pos) /*!< Match count for compare function              */
N#define ADC_ADCMPR_CMPCH(x)                   ((x) << ADC_ADCMPR_CMPCH_Pos)         /*!< Compare channel for compare function          */
N#define ADC_ADCMPR_CMPCOND_LESS_THAN          (0<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "less than"          */
N#define ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL   (1<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "greater than or equal to" */
N#define ADC_ADCMPR_CMPIE_INTERRUPT_ENABLE     (ADC_ADCMPR_CMPIE_Msk)                /*!< The compare function interrupt enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Interrupt Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADF_INT         (ADC_ADSR_ADF_Msk)          /*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT        (ADC_ADSR_CMPF0_Msk)        /*!< ADC comparator 0 interrupt */
N#define ADC_CMP1_INT        (ADC_ADSR_CMPF1_Msk)        /*!< ADC comparator 1 interrupt */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Operation Mode Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_SINGLE_MODE         0   /*!< ADC single mode            */
N#define ADC_SINGLE_CYCLE_MODE   2   /*!< ADC single-cycle scan mode */
N#define ADC_CONTINUOUS_MODE     3   /*!< ADC continuous scan mode   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Trigger Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LOW_LEVEL      0   /*!< ADC external trigger condition is low level trigger    */
N#define ADC_HIGH_LEVEL     1   /*!< ADC external trigger condition is high level trigger   */
N#define ADC_FALLING_EDGE   2   /*!< ADC external trigger condition is falling edge trigger */
N#define ADC_RISING_EDGE    3   /*!< ADC external trigger condition is rising edge trigger  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Compare Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LESS_THAN          0   /*!< ADC compare condition is "less than the compare value"                */
N#define ADC_GREATER_OR_EQUAL   1   /*!< ADC compare condition is "greater than or equal to the compare value" */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Constant Definitions of ADC Channel 7 Input Source                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_CH7_EXT_INPUT_SIGNAL         0   /*!< External input signal       */
N#define ADC_CH7_INT_BANDGAP              1   /*!< Internal band-gap voltage   */
N#define ADC_CH7_INT_TEMPERATURE_SENSOR   2   /*!< Internal temperature sensor */
N
N
N/*@}*/ /* end of group NUC131_ADC_EXPORTED_CONSTANTS */
N
N/** @addtogroup NUC131_ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Configure the analog input source of channel 7.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Source Decides the analog input source of channel 7. Valid values are:
N  *                       - \ref ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL        : External analog input.
N  *                       - \ref ADC_ADCHER_PRESEL_INT_BANDGAP             : Internal bandgap voltage.
N  *                       - \ref ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR  : Output of internal temperature sensor.
N  * @return None
N  * @details Channel 7 supports 3 input sources: External analog voltage, internal Band-gap voltage, and internal temperature sensor output.
N  * @note While using VBG as channel 7 source, ADC module clock must /b not exceed 300kHz.
N  */
N#define ADC_CONFIG_CH7(adc, u32Source) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_PRESEL_Msk) | (u32Source))
N
N/**
N  * @brief Get conversion data of specified channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  ADC Channel, valid value are from 0 to 7.
N  * @return 16-bit data.
N  * @details Read RSLT bit field to get conversion data.
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) (((adc)->ADDR[(u32ChNum)] & ADC_ADDR_RSLT_Msk)>>ADC_ADDR_RSLT_Pos)
N
N/**
N  * @brief Return the user-specified interrupt flags.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return User specified interrupt flags.
N  * @details Get the status of the ADC interrupt flag.
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) ((adc)->ADSR & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return None
N  * @details ADF (ADSR[0])/CMPF0 (ADSR[1])/CMPF0 (ADSR[2]) can be cleared by writing 1 to itself.
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) ((adc)->ADSR = (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @retval 0 ADC is not busy.
N  * @retval 1 ADC is busy.
N  * @details BUSY(ADSR[3])is mirror of as ADST bit (ADCR[11]).
N  */
N#define ADC_IS_BUSY(adc) ((adc)->ADSR & ADC_ADSR_BUSY_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is over written or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @retval 0 ADC data is not overrun.
N  * @retval 1 ADC data us overrun.
N  * @details OVERRUN (ADSR[23:16]) is a mirror to OVERRUN (ADDR0~7[16]).
N  */
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) ((adc)->ADSR & ((u32ChNum)<<ADC_ADSR_OVERRUN_Pos) ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @retval 0 ADC data is not valid.
N  * @retval 1 ADC data us valid.
N  * @details VALID (ADDR0~7[17]) is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
N  */
N#define ADC_IS_DATA_VALID(adc, u32ChNum) ((adc)->ADSR & (0x1<<(ADC_ADSR_VALID_Pos+(u32ChNum))) ? 1 : 0)
N
N/**
N  * @brief Power down ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Disable A/D converter analog circuit for saving power consumption.
N  * @note None
N  */
N#define ADC_POWER_DOWN(adc) ((adc)->ADCR &= ~ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Power on ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Before starting A/D conversion function, ADEN bit (ADCR[0]) should be set to 1.
N  */
N#define ADC_POWER_ON(adc) ((adc)->ADCR |= ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Configure the comparator 0 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value.
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 0 flag if channel 5 conversion result is greater or
N  *          equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                          (u32Condition) | \
N                                                         ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                         (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                          ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                           (u32Condition) |                                                          ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                          (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                          ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 0.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set CMPEN (ADCMPR0[0]) to 1 to disable ADC controller to compare CMPD (ADCMPR0[27:16]).
N  */
N#define ADC_DISABLE_CMP0(adc) ((adc)->ADCMPR[0] = 0)
N
N/**
N  * @brief Configure the comparator 1 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value.
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 1 flag if channel 5 conversion result is greater or
N  *          equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                          (u32Condition) | \
N                                                         ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                         (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                          ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                           (u32Condition) |                                                          ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                          (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                          ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 1.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set CMPEN (ADCMPR1[0]) to 1 to disable ADC controller to compare CMPD (ADCMPR1[27:16]).
N  */
N#define ADC_DISABLE_CMP1(adc) ((adc)->ADCMPR[1] = 0)
N
N/**
N  * @brief Set ADC input channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1..., bit 7 is channel 7.
N  * @return None
N  * @details Enabled channel will be converted while ADC starts.
N  * @note NUC131 series MCU ADC can only convert 1 channel at a time. If more than 1 channels are enabled, only channel
N  *       with smallest number will be convert.
N  */
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_CHEN_Msk) | (u32Mask))
N
N/**
N  * @brief Set the output format mode.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Format Decides the output format. Valid values are:
N  *                       - \ref ADC_ADCR_DMOF_UNSIGNED_OUTPUT      :Select the straight binary format as the output format of the conversion result.
N  *                       - \ref ADC_ADCR_DMOF_TWOS_COMPLEMENT      :Select the 2's complement format as the output format of the conversion result.
N  * @return None
N  * @details  The macro is used to set A/D differential input mode output format.
N  */
N#define ADC_SET_DMOF(adc, u32Format) ((adc)->ADCR = ((adc)->ADCR & ~ADC_ADCR_DMOF_Msk) | (u32Format))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details ADST (ADCR[11]) can be set to 1 from three sources: software, PWM Center-aligned trigger and external pin STADC.
N  */
N#define ADC_START_CONV(adc) ((adc)->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details ADST (ADCR[11]) will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode.
N  *          In continuous scan mode, A/D conversion is continuously performed until software writes 0 to this bit or chip reset.
N  */
N#define ADC_STOP_CONV(adc) ((adc)->ADCR &= ~ADC_ADCR_ADST_Msk)
N
Nvoid ADC_Open(ADC_T *adc,
N              uint32_t u32InputMode,
N              uint32_t u32OpMode,
N              uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N
N
N
N/*@}*/ /* end of group NUC131_ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_ADC_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11291 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "CAN.h"
L 1 "..\..\..\Library\StdDriver\inc\CAN.h" 1
N/**************************************************************************//**
N * @file     can.h
N * @version  V3.00
N * $Revision: 6 $
N * $Date: 2/19/16 2:33p $
N * @brief    NUC131 Series CAN Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __CAN_H__
N#define __CAN_H__
N
N#include "NUC131.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_CAN_Driver CAN Driver
N  @{
N*/
N
N/** @addtogroup NUC131_CAN_EXPORTED_CONSTANTS CAN Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* CAN Test Mode Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_NORMAL_MODE   0
N#define    CAN_BASIC_MODE    1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Message ID Type Constant Definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_STD_ID    0
N#define    CAN_EXT_ID    1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Message Frame Type Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_REMOTE_FRAME    0
N#define    CAN_DATA_FRAME    1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CAN message structure                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint32_t  IdType;
N    uint32_t  FrameType;
N    uint32_t  Id;
N    uint8_t   DLC;
N    uint8_t   Data[8];
N} STR_CANMSG_T;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CAN mask message structure                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint8_t   u8Xtd;
N    uint8_t   u8Dir;
N    uint32_t  u32Id;
N    uint8_t   u8IdType;
N} STR_CANMASK_T;
N
N#define MSG(id)  (id)
N
N
N/*@}*/ /* end of group NUC131_CAN_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_CAN_EXPORTED_FUNCTIONS CAN Exported Functions
N  @{
N*/
N
N/**
N * @brief Get interrupt status.
N *
N * @param[in] can The pointer to CAN module base address.
N *
N * @return CAN module status register value.
N *
N * @details Status Interrupt is generated by bits BOff (CAN_STATUS[7]), EWarn (CAN_STATUS[6]),
N *          EPass (CAN_STATUS[5]), RxOk (CAN_STATUS[4]), TxOk (CAN_STATUS[3]), and LEC (CAN_STATUS[2:0]).
N */
N#define CAN_GET_INT_STATUS(can) ((can)->STATUS)
N
N/**
N * @brief Get specified interrupt pending status.
N *
N * @param[in] can The pointer to CAN module base address.
N *
N * @return The source of the interrupt.
N *
N * @details If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt
N *          with the highest priority, disregarding their chronological order.
N */
N#define CAN_GET_INT_PENDING_STATUS(can) ((can)->IIDR)
N
N/**
N * @brief Disable wake-up function.
N *
N * @param[in] can The pointer to CAN module base address.
N *
N * @return None
N *
N * @details  The macro is used to disable wake-up function.
N */
N#define CAN_DISABLE_WAKEUP(can) ((can)->WU_EN = 0)
N
N/**
N * @brief Enable wake-up function.
N *
N * @param[in] can The pointer to CAN module base address.
N *
N * @return None
N *
N * @details User can wake-up system when there is a falling edge in the CAN_Rx pin.
N */
N#define CAN_ENABLE_WAKEUP(can) ((can)->WU_EN = CAN_WUEN_WAKUP_EN_Msk)
N
N/**
N * @brief Get specified Message Object new data into bit value.
N *
N * @param[in] can The pointer to CAN module base address.
N * @param[in] u32MsgNum Specified Message Object number, valid value are from 0 to 31.
N *
N * @return Specified Message Object new data into bit value.
N *
N * @details The NewDat bit (CAN_IFn_MCON[15]) of a specific Message Object can be set/reset by the software through the IFn Message Interface Registers
N *          or by the Message Handler after reception of a Data Frame or after a successful transmission.
N */
N#define CAN_GET_NEW_DATA_IN_BIT(can, u32MsgNum) ((u32MsgNum) < 16 ? (can)->NDAT1 & (1 << (u32MsgNum)) : (can)->NDAT2 & (1 << ((u32MsgNum)-16)))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define CAN functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate);
Nuint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode);
Nvoid CAN_Close(CAN_T *tCAN);
Nvoid CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum);
Nvoid CAN_EnableInt(CAN_T *tCAN, uint32_t u32Mask);
Nvoid CAN_DisableInt(CAN_T *tCAN, uint32_t u32Mask);
Nint32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID);
Nint32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32IDType, uint32_t u32ID);
Nint32_t CAN_SetRxMsgAndMsk(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32IDType, uint32_t u32ID, uint32_t u32IDMask);
Nint32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum);
N
N
N/*@}*/ /* end of group NUC131_CAN_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_CAN_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CAN_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11292 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "FMC.h"
L 1 "..\..\..\Library\StdDriver\inc\FMC.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V3.0
N * $Revision: 8 $
N * $Date: 15/05/19 3:41p $
N * @brief    NUC131 Series Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#include "NUC131.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup NUC131_FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4K Bytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCON constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCON_BS_LDROM     0x2     /*!< ISPCON setting to select to boot from LDROM */
N#define FMC_ISPCON_BS_APROM     0x0     /*!< ISPCON setting to select to boot from APROM */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ        0x00     /*!< ISP Command: Read Flash       */
N#define FMC_ISPCMD_PROGRAM     0x21     /*!< ISP Command: Program Flash    */
N#define FMC_ISPCMD_PAGE_ERASE  0x22     /*!< ISP Command: Page Erase Flash */
N#define FMC_ISPCMD_VECMAP      0x2e     /*!< ISP Command: Set VECMAP       */
N#define FMC_ISPCMD_READ_UID    0x04     /*!< ISP Command: Read Unique ID   */
N#define FMC_ISPCMD_READ_CID    0x0B     /*!< ISP Command: Read Company ID   */
N#define FMC_ISPCMD_READ_DID    0x0C     /*!< ISP Command: Read Device ID    */
N
N
N/*@}*/ /* end of group NUC131_FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup NUC131_FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Enable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCON control register to enable ISP function.
N *
N */
N#define FMC_ENABLE_ISP()          (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)
N
N
N/**
N * @brief      Disable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear ISPEN bit of ISPCON control register to disable ISP function.
N *
N */
N#define FMC_DISABLE_ISP()         (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)
N
N
N/**
N * @brief      Enable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set LDUEN bit of ISPCON control register to enable LDROM update function.
N *             User needs to set LDUEN bit before they can update LDROM.
N *
N */
N#define FMC_ENABLE_LD_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)
N
N
N
N/**
N * @brief      Disable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCON control register to disable LDROM update function.
N *
N */
N#define FMC_DISABLE_LD_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)  /*!< Disable LDROM Update Function  */
N
N
N
N/**
N * @brief      Enable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set CFGUEN bit of ISPCON control register to enable User Configuration update function.
N *             User needs to set CFGUEN bit before they can update User Configuration area.
N *
N */
N#define FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk)
N
N/**
N * @brief      Disable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear CFGUEN bit of ISPCON control register to disable User Configuration update function.
N *
N */
N#define FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk)           /*!< Disable CONFIG Update Function */
N
N
N/**
N * @brief      Enable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set APUEN bit of ISPCON control register to enable APROM update function.
N *             User needs to set APUEN bit before they can update APROM in APROM boot mode.
N *
N */
N#define FMC_ENABLE_AP_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)
N
N
N/**
N * @brief      Disable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear APUEN bit of ISPCON control register to disable APROM update function.
N *
N */
N#define FMC_DISABLE_AP_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)            /*!< Disable APROM Update Function  */
N
N/**
N * @brief      Get ISP fail flag
N *
N * @param      None
N *
N * @retval     0 Previous ISP command execution result is successful
N * @retval     1 Previous ISP command execution result is fail
N *
N * @details    ISPFF flag of ISPCON is used to indicate ISP command success or fail.
N *             This function will return the ISPFF flag to identify ISP command OK or fail.
N *
N */
N#define FMC_GET_FAIL_FLAG()       ((FMC->ISPCON & FMC_ISPCON_ISPFF_Msk) ? 1 : 0)
N
N
N/**
N * @brief      Select booting from APROM
N *
N * @param      None
N *
N * @return     None
N *
N * @details    If MCU is working without IAP, user need to set BS bit of ISPCON and reset CPU to execute the code of LDROM/APROM.
N *             This function is used to set BS bit of ISPCON to boot to APROM.
N *
N * @note       To valid new BS bit setting, user also need to trigger CPU reset or System Reset Request after setting BS bit.
N *
N */
N#define FMC_SET_APROM_BOOT()      (FMC->ISPCON &= ~FMC_ISPCON_BS_Msk)
N
N/**
N * @brief      Select booting from APROM
N *
N * @param      None
N *
N * @return     None
N *
N * @details    If MCU is working without IAP, user need to set/clear BS bit of ISPCON and reset CPU to execute the code of APROM/LDROM.
N *             This function is used to clear BS bit of ISPCON to boot to LDROM.
N *
N * @note       To valid new BS bit setting, user also need to trigger CPU reset or System Reset Request after clear BS bit.
N *
N */
N#define FMC_SET_LDROM_BOOT()      (FMC->ISPCON |= FMC_ISPCON_BS_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Program 32-bit data into specified address of flash
N *
N * @param[in]  u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32data  32-bit Data to program
N *
N * @return     None
N *
N * @details    To program word data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write(uint32_t u32addr, uint32_t u32data)
Xstatic __inline void FMC_Write(uint32_t u32addr, uint32_t u32data)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;   /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x21;    
N    FMC->ISPADR = u32addr;              /* Set Target ROM Address. The address must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;               
N    FMC->ISPDAT = u32data;              /* Set Data to Program */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = u32data;               
N    FMC->ISPTRG = 0x1;                  /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                   
N    __ISB();                            /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                             
N    while(FMC->ISPTRG);                 /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                  
N}
N
N/**
N * @brief       Read 32-bit Data from specified address of flash
N *
N * @param[in]   u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N *
N * @return      The data of specified address
N *
N * @details     To read word data from Flash include APROM, LDROM, Data Flash, and CONFIG.
N *
N */
Nstatic __INLINE uint32_t FMC_Read(uint32_t u32addr)
Xstatic __inline uint32_t FMC_Read(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x00;  
N    FMC->ISPADR = u32addr;         /* Set Target ROM Address. The address must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;          
N    FMC->ISPTRG = 0x1;             /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;              
N    __ISB();                       /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                        
N    while(FMC->ISPTRG);            /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);             
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N * @brief      Flash page erase
N *
N * @param[in]  u32addr  Flash address including APROM, LDROM, Data Flash, and CONFIG
N *
N * @details    To do flash page erase. The target address could be APROM, LDROM, Data Flash, or CONFIG.
N *             The page size is 512 bytes.
N *
N * @retval      0 Success
N * @retval     -1 Erase failed
N *
N */
Nstatic __INLINE int32_t FMC_Erase(uint32_t u32addr)
Xstatic __inline int32_t FMC_Erase(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x22;  
N    FMC->ISPADR = u32addr;               /* Set Target ROM Address. The address must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;                
N    FMC->ISPTRG = 0x1;                   /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                    
N    __ISB();                             /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                              
N    while(FMC->ISPTRG);                  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                   
N
N    /* Check ISPFF flag to know whether erase OK or fail. */
N    if(FMC->ISPCON & FMC_ISPCON_ISPFF_Msk)
X    if(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCON & (1ul << 6))
N    {
N        FMC->ISPCON |= FMC_ISPCON_ISPFF_Msk;
X        ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCON |= (1ul << 6);
N        return -1;
N    }
N    return 0;
N}
N
N/**
N * @brief       Read Unique ID
N *
N * @param[in]   u8index  UID index. 0 = UID[31:0], 1 = UID[63:32], 2 = UID[95:64]
N *
N * @return      The 32-bit unique ID data of specified UID index.
N *
N * @details     To read out 96-bit Unique ID.
N *
N */
Nstatic __INLINE uint32_t FMC_ReadUID(uint8_t u8index)
Xstatic __inline uint32_t FMC_ReadUID(uint8_t u8index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;  
N    FMC->ISPADR = (u8index << 2);      /* Set UID Address. It must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (u8index << 2);       
N    FMC->ISPTRG = 0x1;                 /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                  
N    __ISB();                           /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                            
N    while(FMC->ISPTRG);                /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                 
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N  * @brief    Read company ID
N  *
N  * @param    None
N  *
N  * @return   The company ID (32-bit)
N  *
N  * @details  The company ID of Nuvoton is fixed to be 0xDA
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadCID(void)
Xstatic __inline uint32_t FMC_ReadCID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_CID;           /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0B;            
N    FMC->ISPADR = 0x0;                           /* Must keep 0x0 when read CID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0x0;                            
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;          /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);           
N    __ISB();                                     /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                      
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) ;  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0)) ;   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N  * @brief    Read device ID
N  *
N  * @param    None
N  *
N  * @return   The device ID (32-bit)
N  *
N  * @details  This function is used to read device ID.
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadDID(void)
Xstatic __inline uint32_t FMC_ReadDID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_DID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0C;           
N    FMC->ISPADR = 0;                            /* Must keep 0x0 when read DID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0;                             
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N
N/**
N  * @brief    Read product ID
N  *
N  * @param    None
N  *
N  * @return   The product ID (32-bit)
N  *
N  * @details  This function is used to read product ID.
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadPID(void)
Xstatic __inline uint32_t FMC_ReadPID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_DID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0C;           
N    FMC->ISPADR = 0x04;                         /* Must keep 0x4 when read PID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0x04;                          
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief      To read UCID
N  *
N  * @param[in]  u32Index    Index of the UCID to read. u32Index must be 0, 1, 2, or 3.
N  *
N  * @return     The UCID of specified index
N  *
N  * @details    This function is used to read unique chip ID (UCID).
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadUCID(uint32_t u32Index)
Xstatic __inline uint32_t FMC_ReadUCID(uint32_t u32Index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;           
N    FMC->ISPADR = (0x04 * u32Index) + 0x10;     /* The UCID is at offset 0x10 with word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (0x04 * u32Index) + 0x10;      
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N
N/**
N * @brief       Set vector mapping address
N *
N * @param[in]   u32PageAddr  The page address to remap to address 0x0. The address must be page alignment.
N *
N * @return      None
N *
N * @details     This function is used to set VECMAP to map specified page to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
Xstatic __inline void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_VECMAP; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x2e;  
N    FMC->ISPADR = u32PageAddr;       /* The address of specified page which will be map to address 0x0. It must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32PageAddr;        
N    FMC->ISPTRG = 0x1;               /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                
N    __ISB();                         /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                          
N    while(FMC->ISPTRG);              /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);               
N}
N
N
N/**
N * @brief       Get current vector mapping address.
N *
N * @param       None
N *
N * @return      The current vector mapping address.
N *
N * @details     To get VECMAP value which is the page address for remapping to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE uint32_t FMC_GetVECMAP(void)
Xstatic __inline uint32_t FMC_GetVECMAP(void)
N{
N    return (FMC->ISPSTA & FMC_ISPSTA_VECMAP_Msk);
X    return (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPSTA & (0xFFFul << 9));
N}
N
Nextern void FMC_Open(void);
Nextern void FMC_Close(void);
Nextern void FMC_EnableAPUpdate(void);
Nextern void FMC_DisableAPUpdate(void);
Nextern void FMC_EnableConfigUpdate(void);
Nextern void FMC_DisableConfigUpdate(void);
Nextern void FMC_EnableLDUpdate(void);
Nextern void FMC_DisableLDUpdate(void);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern void FMC_SetBootSource(int32_t i32BootSrc);
Nextern int32_t FMC_GetBootSource(void);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
N
N/*@}*/ /* end of group NUC131_FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_FMC_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif
N
L 11293 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "GPIO.h"
L 1 "..\..\..\Library\StdDriver\inc\GPIO.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V3.00
N * $Revision: 11 $
N * $Date: 15/01/16 1:46p $
N * @brief    NUC131 Series General Purpose I/O Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup NUC131_GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N#define GPIO_PIN_MAX            16 /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT          0x0UL /*!< Input Mode */
N#define GPIO_PMD_OUTPUT         0x1UL /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN     0x2UL /*!< Open-Drain Mode */
N#define GPIO_PMD_QUASI          0x3UL /*!< Quasi-bidirectional Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING         0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING        0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE      0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH           0x01010000UL /*!< Interrupt enable by Level-High */
N#define GPIO_INT_LOW            0x01000001UL /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE           0UL /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL          1UL /*!< IMD Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_CLK_ON         0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */
N#define GPIO_INT_CLK_OFF        0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */
N
N#define GPIO_DBCLKSRC_LIRC      0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBCLKSRC_HCLK      0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the HCLK */
N
N#define GPIO_DBCLKSEL_1         0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBCLKSEL_2         0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBCLKSEL_4         0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBCLKSEL_8         0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBCLKSEL_16        0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBCLKSEL_32        0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBCLKSEL_64        0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBCLKSEL_128       0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBCLKSEL_256       0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBCLKSEL_512       0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBCLKSEL_1024      0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCLKSEL_2048      0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCLKSEL_4096      0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCLKSEL_8192      0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCLKSEL_16384     0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCLKSEL_32768     0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N
N/* Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N   Example 1:
N
N       PA0 = 1;
N
N   It is used to set GPIO PA.0 to high;
N
N   Example 2:
N
N       if (PA0)
N           PA0 = 0;
N
N   If GPIO PA.0 pin status is high, then set GPIO PA.0 data output to low.
N */
N#define GPIO_PIN_DATA(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x40*(port))) + ((pin)<<2))))
N#define PA0             GPIO_PIN_DATA(0, 0 ) /*!< Specify PA.0 Pin Data Input/Output */
N#define PA1             GPIO_PIN_DATA(0, 1 ) /*!< Specify PA.1 Pin Data Input/Output */
N#define PA2             GPIO_PIN_DATA(0, 2 ) /*!< Specify PA.2 Pin Data Input/Output */
N#define PA3             GPIO_PIN_DATA(0, 3 ) /*!< Specify PA.3 Pin Data Input/Output */
N#define PA4             GPIO_PIN_DATA(0, 4 ) /*!< Specify PA.4 Pin Data Input/Output */
N#define PA5             GPIO_PIN_DATA(0, 5 ) /*!< Specify PA.5 Pin Data Input/Output */
N#define PA6             GPIO_PIN_DATA(0, 6 ) /*!< Specify PA.6 Pin Data Input/Output */
N#define PA7             GPIO_PIN_DATA(0, 7 ) /*!< Specify PA.7 Pin Data Input/Output */
N#define PA8             GPIO_PIN_DATA(0, 8 ) /*!< Specify PA.8 Pin Data Input/Output */
N#define PA9             GPIO_PIN_DATA(0, 9 ) /*!< Specify PA.9 Pin Data Input/Output */
N#define PA10            GPIO_PIN_DATA(0, 10) /*!< Specify PA.10 Pin Data Input/Output */
N#define PA11            GPIO_PIN_DATA(0, 11) /*!< Specify PA.11 Pin Data Input/Output */
N#define PA12            GPIO_PIN_DATA(0, 12) /*!< Specify PA.12 Pin Data Input/Output */
N#define PA13            GPIO_PIN_DATA(0, 13) /*!< Specify PA.13 Pin Data Input/Output */
N#define PA14            GPIO_PIN_DATA(0, 14) /*!< Specify PA.14 Pin Data Input/Output */
N#define PA15            GPIO_PIN_DATA(0, 15) /*!< Specify PA.15 Pin Data Input/Output */
N#define PB0             GPIO_PIN_DATA(1, 0 ) /*!< Specify PB.0 Pin Data Input/Output */
N#define PB1             GPIO_PIN_DATA(1, 1 ) /*!< Specify PB.1 Pin Data Input/Output */
N#define PB2             GPIO_PIN_DATA(1, 2 ) /*!< Specify PB.2 Pin Data Input/Output */
N#define PB3             GPIO_PIN_DATA(1, 3 ) /*!< Specify PB.3 Pin Data Input/Output */
N#define PB4             GPIO_PIN_DATA(1, 4 ) /*!< Specify PB.4 Pin Data Input/Output */
N#define PB5             GPIO_PIN_DATA(1, 5 ) /*!< Specify PB.5 Pin Data Input/Output */
N#define PB6             GPIO_PIN_DATA(1, 6 ) /*!< Specify PB.6 Pin Data Input/Output */
N#define PB7             GPIO_PIN_DATA(1, 7 ) /*!< Specify PB.7 Pin Data Input/Output */
N#define PB8             GPIO_PIN_DATA(1, 8 ) /*!< Specify PB.8 Pin Data Input/Output */
N#define PB9             GPIO_PIN_DATA(1, 9 ) /*!< Specify PB.9 Pin Data Input/Output */
N#define PB10            GPIO_PIN_DATA(1, 10) /*!< Specify PB.10 Pin Data Input/Output */
N#define PB11            GPIO_PIN_DATA(1, 11) /*!< Specify PB.11 Pin Data Input/Output */
N#define PB12            GPIO_PIN_DATA(1, 12) /*!< Specify PB.12 Pin Data Input/Output */
N#define PB13            GPIO_PIN_DATA(1, 13) /*!< Specify PB.13 Pin Data Input/Output */
N#define PB14            GPIO_PIN_DATA(1, 14) /*!< Specify PB.14 Pin Data Input/Output */
N#define PB15            GPIO_PIN_DATA(1, 15) /*!< Specify PB.15 Pin Data Input/Output */
N#define PC0             GPIO_PIN_DATA(2, 0 ) /*!< Specify PC.0 Pin Data Input/Output */
N#define PC1             GPIO_PIN_DATA(2, 1 ) /*!< Specify PC.1 Pin Data Input/Output */
N#define PC2             GPIO_PIN_DATA(2, 2 ) /*!< Specify PC.2 Pin Data Input/Output */
N#define PC3             GPIO_PIN_DATA(2, 3 ) /*!< Specify PC.3 Pin Data Input/Output */
N#define PC6             GPIO_PIN_DATA(2, 6 ) /*!< Specify PC.6 Pin Data Input/Output */
N#define PC7             GPIO_PIN_DATA(2, 7 ) /*!< Specify PC.7 Pin Data Input/Output */
N#define PC8             GPIO_PIN_DATA(2, 8 ) /*!< Specify PC.8 Pin Data Input/Output */
N#define PC9             GPIO_PIN_DATA(2, 9 ) /*!< Specify PC.9 Pin Data Input/Output */
N#define PC10            GPIO_PIN_DATA(2, 10) /*!< Specify PC.10 Pin Data Input/Output */
N#define PC11            GPIO_PIN_DATA(2, 11) /*!< Specify PC.11 Pin Data Input/Output */
N#define PC14            GPIO_PIN_DATA(2, 14) /*!< Specify PC.14 Pin Data Input/Output */
N#define PC15            GPIO_PIN_DATA(2, 15) /*!< Specify PC.15 Pin Data Input/Output */
N#define PD6             GPIO_PIN_DATA(3, 6 ) /*!< Specify PD.6 Pin Data Input/Output */
N#define PD7             GPIO_PIN_DATA(3, 7 ) /*!< Specify PD.7 Pin Data Input/Output */
N#define PD14            GPIO_PIN_DATA(3, 14) /*!< Specify PD.14 Pin Data Input/Output */
N#define PD15            GPIO_PIN_DATA(3, 15) /*!< Specify PD.15 Pin Data Input/Output */
N#define PE5             GPIO_PIN_DATA(4, 5 ) /*!< Specify PE.5 Pin Data Input/Output */
N#define PF0             GPIO_PIN_DATA(5, 0 ) /*!< Specify PF.0 Pin Data Input/Output */
N#define PF1             GPIO_PIN_DATA(5, 1 ) /*!< Specify PF.1 Pin Data Input/Output */
N#define PF4             GPIO_PIN_DATA(5, 4 ) /*!< Specify PF.4 Pin Data Input/Output */
N#define PF5             GPIO_PIN_DATA(5, 5 ) /*!< Specify PF.5 Pin Data Input/Output */
N#define PF6             GPIO_PIN_DATA(5, 6 ) /*!< Specify PF.6 Pin Data Input/Output */
N#define PF7             GPIO_PIN_DATA(5, 7 ) /*!< Specify PF.7 Pin Data Input/Output */
N#define PF8             GPIO_PIN_DATA(5, 8 ) /*!< Specify PF.8 Pin Data Input/Output */
N
N
N/*@}*/ /* end of group NUC131_GPIO_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA and PB GPIO port. \n
N *                          It could be BIT0 ~ BIT3, BIT6 ~ BIT11, BIT14 and BIT15 for PC GPIO port. \n
N *                          It could be BIT6, BIT7, BIT14 and BIT15 for PD GPIO port. \n
N *                          It could be BIT5 for PE GPIO port. \n
N *                          It could be BIT0, BIT1 and BIT4 ~ BIT8 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(port, u32PinMask)         ((port)->ISRC = (u32PinMask))
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA and PB GPIO port. \n
N *                          It could be BIT0 ~ BIT3, BIT6 ~ BIT11, BIT14 and BIT15 for PC GPIO port. \n
N *                          It could be BIT6, BIT7, BIT14 and BIT15 for PD GPIO port. \n
N *                          It could be BIT5 for PE GPIO port. \n
N *                          It could be BIT0, BIT1 and BIT4 ~ BIT8 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(port, u32PinMask)     ((port)->DBEN &= ~(u32PinMask))
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA and PB GPIO port. \n
N *                          It could be BIT0 ~ BIT3, BIT6 ~ BIT11, BIT14 and BIT15 for PC GPIO port. \n
N *                          It could be BIT6, BIT7, BIT14 and BIT15 for PD GPIO port. \n
N *                          It could be BIT5 for PE GPIO port. \n
N *                          It could be BIT0, BIT1 and BIT4 ~ BIT8 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(port, u32PinMask)      ((port)->DBEN |= (u32PinMask))
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA and PB GPIO port. \n
N *                          It could be BIT0 ~ BIT3, BIT6 ~ BIT11, BIT14 and BIT15 for PC GPIO port. \n
N *                          It could be BIT6, BIT7, BIT14 and BIT15 for PD GPIO port. \n
N *                          It could be BIT5 for PE GPIO port. \n
N *                          It could be BIT0, BIT1 and BIT4 ~ BIT8 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(port, u32PinMask) ((port)->OFFD |= ((u32PinMask)<<16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA and PB GPIO port. \n
N *                          It could be BIT0 ~ BIT3, BIT6 ~ BIT11, BIT14 and BIT15 for PC GPIO port. \n
N *                          It could be BIT6, BIT7, BIT14 and BIT15 for PD GPIO port. \n
N *                          It could be BIT5 for PE GPIO port. \n
N *                          It could be BIT0, BIT1 and BIT4 ~ BIT8 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(port, u32PinMask)  ((port)->OFFD &= ~((u32PinMask)<<16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA and PB GPIO port. \n
N *                          It could be BIT0 ~ BIT3, BIT6 ~ BIT11, BIT14 and BIT15 for PC GPIO port. \n
N *                          It could be BIT6, BIT7, BIT14 and BIT15 for PD GPIO port. \n
N *                          It could be BIT5 for PE GPIO port. \n
N *                          It could be BIT0, BIT1 and BIT4 ~ BIT8 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(port, u32PinMask)    ((port)->DMASK &= ~(u32PinMask))
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA and PB GPIO port. \n
N *                          It could be BIT0 ~ BIT3, BIT6 ~ BIT11, BIT14 and BIT15 for PC GPIO port. \n
N *                          It could be BIT6, BIT7, BIT14 and BIT15 for PD GPIO port. \n
N *                          It could be BIT5 for PE GPIO port. \n
N *                          It could be BIT0, BIT1 and BIT4 ~ BIT8 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(port, u32PinMask)  ((port)->DMASK |= (u32PinMask))
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port. \n
N *                          It could be BIT0 ~ BIT15 for PA and PB GPIO port. \n
N *                          It could be BIT0 ~ BIT3, BIT6 ~ BIT11, BIT14 and BIT15 for PC GPIO port. \n
N *                          It could be BIT6, BIT7, BIT14 and BIT15 for PD GPIO port. \n
N *                          It could be BIT5 for PE GPIO port. \n
N *                          It could be BIT0, BIT1 and BIT4 ~ BIT8 for PF GPIO port.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(port, u32PinMask)     ((port)->ISRC & (u32PinMask))
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   u32ClkSrc   The de-bounce counter clock source. It could be GPIO_DBCLKSRC_HCLK or GPIO_DBCLKSRC_LIRC.
N * @param[in]   u32ClkSel   The de-bounce sampling cycle selection. It could be \n
N *                              GPIO_DBCLKSEL_1, GPIO_DBCLKSEL_2, GPIO_DBCLKSEL_4, GPIO_DBCLKSEL_8, \n
N *                              GPIO_DBCLKSEL_16, GPIO_DBCLKSEL_32, GPIO_DBCLKSEL_64, GPIO_DBCLKSEL_128, \n
N *                              GPIO_DBCLKSEL_256, GPIO_DBCLKSEL_512, GPIO_DBCLKSEL_1024, GPIO_DBCLKSEL_2048, \n
N *                              GPIO_DBCLKSEL_4096, GPIO_DBCLKSEL_8192, GPIO_DBCLKSEL_16384, GPIO_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBCLKSRC_LIRC, GPIO_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (4)*(1/(10*1000)) s = 4*0.0001 s = 400 us,
N *              and system will sampling interrupt input once per 400 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(u32ClkSrc, u32ClkSel)    (GPIO->DBNCECON = (GPIO_DBNCECON_ICLK_ON_Msk | (u32ClkSrc) | (u32ClkSel)))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N *
N * @return      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(port)  ((port)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Data     GPIO port data.
N *
N * @return      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(port, u32Data)    ((port)->DOUT = (u32Data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin      Pxy
N *
N * @return      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin) ((u32Pin) ^= 1)
N
N/**
N * @brief       Enable External GPIO Interrupt 0
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port. \n
N *                              It could be 0 ~ 15 for PA and PB GPIO port. \n
N *                              It could be 0 ~ 3, 6 ~ 11, BIT14 and BIT15 for PC GPIO port. \n
N *                              It could be 6, 7, 14 and BIT15 for PD GPIO port. \n
N *                              It could be 5 for PE GPIO port. \n
N *                              It could be 0, 1 and 4 ~ 8 for PF GPIO port. \n
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT0    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO Interrupt 0
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port. \n
N *                              It could be 0 ~ 15 for PA and PB GPIO port. \n
N *                              It could be 0 ~ 3, 6 ~ 11, BIT14 and BIT15 for PC GPIO port. \n
N *                              It could be 6, 7, 14 and BIT15 for PD GPIO port. \n
N *                              It could be 5 for PE GPIO port. \n
N *                              It could be 0, 1 and 4 ~ 8 for PF GPIO port. \n
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT0   GPIO_DisableInt
N
N
N/**
N * @brief       Enable External GPIO Interrupt 1
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port. \n
N *                              It could be 0 ~ 15 for PA and PB GPIO port. \n
N *                              It could be 0 ~ 3, 6 ~ 11, BIT14 and BIT15 for PC GPIO port. \n
N *                              It could be 6, 7, 14 and BIT15 for PD GPIO port. \n
N *                              It could be 5 for PE GPIO port. \n
N *                              It could be 0, 1 and 4 ~ 8 for PF GPIO port. \n
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT1    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO Interrupt 1
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port. \n
N *                              It could be 0 ~ 15 for PA and PB GPIO port. \n
N *                              It could be 0 ~ 3, 6 ~ 11, BIT14 and BIT15 for PC GPIO port. \n
N *                              It could be 6, 7, 14 and BIT15 for PD GPIO port. \n
N *                              It could be 5 for PE GPIO port. \n
N *                              It could be 0, 1 and 4 ~ 8 for PF GPIO port. \n
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT1   GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *port, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *port, uint32_t u32Pin);
N
N
N/*@}*/ /* end of group NUC131_GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_GPIO_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11294 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "I2C.h"
L 1 "..\..\..\Library\StdDriver\inc\I2C.h" 1
N/**************************************************************************//**
N * @file     I2C.h
N * @version  V3.0
N * $Revision: 7 $
N * $Date: 15/01/16 1:56p $
N * @brief    NUC131 Series I2C Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#include "NUC131.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_I2C_Driver I2C Driver
N  @{
N*/
N
N/** @addtogroup NUC131_I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2CON constant definitions.                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_I2CON_STA_STO_SI        0x38UL /*!< I2CON setting for I2C control bits. It would set STA, STO and SI bits     */
N#define I2C_I2CON_STA_STO_SI_AA     0x3CUL /*!< I2CON setting for I2C control bits. It would set STA, STO, SI and AA bits */
N#define I2C_I2CON_STA_SI            0x28UL /*!< I2CON setting for I2C control bits. It would set STA and SI bits          */
N#define I2C_I2CON_STA_SI_AA         0x2CUL /*!< I2CON setting for I2C control bits. It would set STA, SI and AA bits      */
N#define I2C_I2CON_STO_SI            0x18UL /*!< I2CON setting for I2C control bits. It would set STO and SI bits          */
N#define I2C_I2CON_STO_SI_AA         0x1CUL /*!< I2CON setting for I2C control bits. It would set STO, SI and AA bits      */
N#define I2C_I2CON_SI                0x08UL /*!< I2CON setting for I2C control bits. It would set SI bit                   */
N#define I2C_I2CON_SI_AA             0x0CUL /*!< I2CON setting for I2C control bits. It would set SI and AA bits           */
N#define I2C_I2CON_STA               0x20UL /*!< I2CON setting for I2C control bits. It would set STA bit                  */
N#define I2C_I2CON_STO               0x10UL /*!< I2CON setting for I2C control bits. It would set STO bit                  */
N#define I2C_I2CON_AA                0x04UL /*!< I2CON setting for I2C control bits. It would set AA bit                   */
N
N#define I2C_GCMODE_ENABLE           1      /*!< Enable  I2C GC Mode                                                       */
N#define I2C_GCMODE_DISABLE          0      /*!< Disable I2C GC Mode                                                       */
N
N/*@}*/ /* end of group NUC131_I2C_EXPORTED_CONSTANTS */
N
N/** @addtogroup NUC131_I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N/**
N *    @brief        The macro is used to set I2C bus condition at One Time
N *
N *    @param[in]    i2c        Specify I2C port
N *    @param[in]    u8Ctrl     A byte writes to I2C control register
N *
N *    @return       None
N *
N *    @details      Set I2CON register to control I2C bus conditions of START, STOP, SI, ACK.
N */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ((i2c)->I2CON = ((i2c)->I2CON & ~0x3c) | (u8Ctrl))
N
N/**
N *    @brief        The macro is used to set START condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus START condition in I2CON register.
N */
N#define I2C_START(i2c)  ((i2c)->I2CON = ((i2c)->I2CON | I2C_I2CON_SI_Msk) | I2C_I2CON_STA_Msk)
N
N/**
N *    @brief        The macro is used to set STOP condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus STOP condition in I2CON register.
N */
N#define I2C_STOP(i2c)   ((i2c)->I2CON = ((i2c)->I2CON | I2C_I2CON_SI_Msk) | I2C_I2CON_STO_Msk)
N
N/**
N *    @brief        The macro is used to wait I2C bus status get ready
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      When a new status is presented of I2C bus, the SI flag will be set in I2CON register.
N */
N#define I2C_WAIT_READY(i2c)     while(!((i2c)->I2CON & I2C_I2CON_SI_Msk))
N
N/**
N *    @brief        The macro is used to Read I2C Bus Data Register
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       A byte of I2C data register
N *
N *    @details      I2C controller read data from bus and save it in I2CDAT register.
N */
N#define I2C_GET_DATA(i2c)   ((i2c)->I2CDAT)
N
N/**
N *    @brief        Write a Data to I2C Data Register
N *
N *    @param[in]    i2c         Specify I2C port
N *    @param[in]    u8Data      A byte that writes to data register
N *
N *    @return       None
N *
N *    @details      When write a data to I2CDAT register, the I2C controller will shift it to I2C bus.
N */
N#define I2C_SET_DATA(i2c, u8Data) ((i2c)->I2CDAT = (u8Data))
N
N/**
N *    @brief        Get I2C Bus status code
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       I2C status code
N *
N *    @details      To get this status code to monitor I2C bus event.
N */
N#define I2C_GET_STATUS(i2c) ((i2c)->I2CSTATUS)
N
N/**
N *    @brief        Get Time-out flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       I2C Bus time-out is not happened
N *    @retval       1       I2C Bus time-out is happened
N *
N *    @details      When I2C bus occurs time-out event, the time-out flag will be set.
N */
N#define I2C_GET_TIMEOUT_FLAG(i2c)   ( ((i2c)->I2CTOC & I2C_I2CTOC_TIF_Msk) == I2C_I2CTOC_TIF_Msk ? 1:0 )
N
N/**
N *    @brief        To get wake-up flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       Chip is not woken-up from power-down mode
N *    @retval       1       Chip is woken-up from power-down mode
N *
N *    @details      I2C bus occurs wake-up event, wake-up flag will be set.
N */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->I2CWKUPSTS & I2C_I2CWKUPSTS_WKUPIF_Msk) == I2C_I2CWKUPSTS_WKUPIF_Msk ? 1:0  )
N
N/**
N *    @brief        To clear wake-up flag
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @return       None
N *
N *    @details      If wake-up flag is set, use this macro to clear it.
N */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c)  ((i2c)->I2CWKUPSTS |= I2C_I2CWKUPSTS_WKUPIF_Msk)
N
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nuint8_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
N
N/*@}*/ /* end of group NUC131_I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_I2C_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N#endif //__I2C_H__
L 11295 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "PWM.h"
L 1 "..\..\..\Library\StdDriver\inc\PWM.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V3.00
N * $Revision: 12 $
N * $Date: 15/05/13 3:00p $
N * @brief    NUC131 series PWM driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup NUC131_PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                          (6)        /*!< PWM channel number */
N#define PWM_CH_0_MASK                            (0x1UL)    /*!< PWM channel 0 mask \hideinitializer */
N#define PWM_CH_1_MASK                            (0x2UL)    /*!< PWM channel 1 mask \hideinitializer */
N#define PWM_CH_2_MASK                            (0x4UL)    /*!< PWM channel 2 mask \hideinitializer */
N#define PWM_CH_3_MASK                            (0x8UL)    /*!< PWM channel 3 mask \hideinitializer */
N#define PWM_CH_4_MASK                            (0x10UL)   /*!< PWM channel 4 mask \hideinitializer */
N#define PWM_CH_5_MASK                            (0x20UL)   /*!< PWM channel 5 mask \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Counter Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_UP_COUNTER                           (0UL)      /*!< Up counter type */
N#define PWM_DOWN_COUNTER                         (1UL)      /*!< Down counter type */
N#define PWM_UP_DOWN_COUNTER                      (2UL)      /*!< Up-Down counter type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Aligned Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_EDGE_ALIGNED                         (1UL)      /*!< PWM working in edge aligned type(down count) */
N#define PWM_CENTER_ALIGNED                       (2UL)      /*!< PWM working in center aligned type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Output Level Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_OUTPUT_NOTHING                       (0UL)      /*!< PWM output nothing */
N#define PWM_OUTPUT_LOW                           (1UL)      /*!< PWM output low */
N#define PWM_OUTPUT_HIGH                          (2UL)      /*!< PWM output high */
N#define PWM_OUTPUT_TOGGLE                        (3UL)      /*!< PWM output toggle */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Trigger Source Select Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_TRIGGER_ADC_EVEN_ZERO_POINT                     (0UL)     /*!< PWM trigger ADC while counter of even channel matches zero point */
N#define PWM_TRIGGER_ADC_EVEN_PERIOD_POINT                   (1UL)     /*!< PWM trigger ADC while counter of even channel matches period point */
N#define PWM_TRIGGER_ADC_EVEN_ZERO_OR_PERIOD_POINT           (2UL)     /*!< PWM trigger ADC while counter of even channel matches zero or period point */
N#define PWM_TRIGGER_ADC_EVEN_COMPARE_UP_COUNT_POINT         (3UL)     /*!< PWM trigger ADC while counter of even channel matches up count to comparator point */
N#define PWM_TRIGGER_ADC_EVEN_COMPARE_DOWN_COUNT_POINT       (4UL)     /*!< PWM trigger ADC while counter of even channel matches down count to comparator point */
N#define PWM_TRIGGER_ADC_ODD_COMPARE_UP_COUNT_POINT          (8UL)     /*!< PWM trigger ADC while counter of odd channel matches up count to comparator point */
N#define PWM_TRIGGER_ADC_ODD_COMPARE_DOWN_COUNT_POINT        (9UL)     /*!< PWM trigger ADC while counter of odd channel matches down count to comparator point */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Fail brake Control Constant Definitions                                                                */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_FB_EDGE_BKP0                         (PWM_BRKCTL0_1_BRKP0EEN_Msk)    /*!< BKP0 pin as edge-detect fault brake source */
N#define PWM_FB_EDGE_BKP1                         (PWM_BRKCTL0_1_BRKP1EEN_Msk)    /*!< BKP1 pin as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_CSS                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_CSSBRKEN_Msk)    /*!< System fail condition: clock security system detection as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_BOD                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_BODBRKEN_Msk)    /*!< System fail condition: brown-out detection as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_RAM                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_RAMBRKEN_Msk)    /*!< System fail condition: SRAM parity error detection as edge-detect fault brake source */
N#define PWM_FB_EDGE_SYS_COR                      (PWM_BRKCTL0_1_SYSEBEN_Msk | PWM_FAILBRK_CORBRKEN_Msk)    /*!< System fail condition: core lockup detection as edge-detect fault brake source */
N
N#define PWM_FB_LEVEL_BKP0                        (PWM_BRKCTL0_1_BRKP0LEN_Msk)    /*!< BKP0 pin as level-detect fault brake source */
N#define PWM_FB_LEVEL_BKP1                        (PWM_BRKCTL0_1_BRKP1LEN_Msk)    /*!< BKP1 pin as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_CSS                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_CSSBRKEN_Msk)    /*!< System fail condition: clock security system detection as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_BOD                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_BODBRKEN_Msk)    /*!< System fail condition: brown-out detection as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_RAM                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_RAMBRKEN_Msk)    /*!< System fail condition: SRAM parity error detection as level-detect fault brake source */
N#define PWM_FB_LEVEL_SYS_COR                     (PWM_BRKCTL0_1_SYSLBEN_Msk | PWM_FAILBRK_CORBRKEN_Msk)    /*!< System fail condition: core lockup detection as level-detect fault brake source */
N
N#define PWM_FB_EDGE                              (0UL)    /*!< edge-detect fault brake */
N#define PWM_FB_LEVEL                             (8UL)    /*!< level-detect fault brake */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Capture Control Constant Definitions                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CAPTURE_INT_RISING_LATCH             (1UL)        /*!< PWM capture interrupt if channel has rising transition */
N#define PWM_CAPTURE_INT_FALLING_LATCH            (0x100UL)    /*!< PWM capture interrupt if channel has falling transition */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Duty Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_DUTY_INT_DOWN_COUNT_MATCH_CMP        (PWM_INTEN0_CMPDIEN0_Msk)   /*!< PWM duty interrupt triggered if down count match comparator */
N#define PWM_DUTY_INT_UP_COUNT_MATCH_CMP          (PWM_INTEN0_CMPUIEN0_Msk)   /*!< PWM duty interrupt triggered if up down match comparator */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Load Mode Constant Definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_LOAD_MODE_IMMEDIATE                  (PWM_CTL0_IMMLDEN0_Msk)    /*!< PWM immediately load mode \hideinitializer */
N#define PWM_LOAD_MODE_CENTER                     (PWM_CTL0_CTRLD0_Msk)      /*!< PWM center load mode \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Noise Filter Clock Divide Select Constant Definitions                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_NF_CLK_DIV_1                         (0UL)    /*!< Noise filter clock is HCLK divide by 1 \hideinitializer */
N#define PWM_NF_CLK_DIV_2                         (1UL)    /*!< Noise filter clock is HCLK divide by 2 \hideinitializer */
N#define PWM_NF_CLK_DIV_4                         (2UL)    /*!< Noise filter clock is HCLK divide by 4 \hideinitializer */
N#define PWM_NF_CLK_DIV_8                         (3UL)    /*!< Noise filter clock is HCLK divide by 8 \hideinitializer */
N#define PWM_NF_CLK_DIV_16                        (4UL)    /*!< Noise filter clock is HCLK divide by 16 \hideinitializer */
N#define PWM_NF_CLK_DIV_32                        (5UL)    /*!< Noise filter clock is HCLK divide by 32 \hideinitializer */
N#define PWM_NF_CLK_DIV_64                        (6UL)    /*!< Noise filter clock is HCLK divide by 64 \hideinitializer */
N#define PWM_NF_CLK_DIV_128                       (7UL)    /*!< Noise filter clock is HCLK divide by 128 \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Clock Source Select Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CLKSRC_PWM_CLK                       (0UL)    /*!< PWM Clock source selects to PWM0_CLK or PWM1_CLK \hideinitializer */
N#define PWM_CLKSRC_TIMER0                        (1UL)    /*!< PWM Clock source selects to TIMER0 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER1                        (2UL)    /*!< PWM Clock source selects to TIMER1 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER2                        (3UL)    /*!< PWM Clock source selects to TIMER2 overflow \hideinitializer */
N#define PWM_CLKSRC_TIMER3                        (4UL)    /*!< PWM Clock source selects to TIMER3 overflow \hideinitializer */
N
N/*@}*/ /* end of group NUC131_PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief This macro enable complementary mode
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to enable complementary mode of PWM module.
N * \hideinitializer
N */
N#define PWM_ENABLE_COMPLEMENTARY_MODE(pwm) ((pwm)->CTL1 = (pwm)->CTL1 | PWM_CTL1_OUTMODEn_Msk)
N
N/**
N * @brief This macro disable complementary mode, and enable independent mode.
N * @param[in] pwm The pointer of the specified PWM module
N * @return None
N * @details This macro is used to disable complementary mode of PWM module.
N * \hideinitializer
N */
N#define PWM_DISABLE_COMPLEMENTARY_MODE(pwm) ((pwm)->CTL1 = (pwm)->CTL1 & ~PWM_CTL1_OUTMODEn_Msk)
N
N/**
N * @brief Enable timer synchronous mode of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable timer synchronous mode of specified channel(s). Every two channels share the same setting.
N * \hideinitializer
N */
N//#define PWM_ENABLE_TIMER_SYNC(pwm, u32ChannelMask) ((pwm)->SSCTL |= (u32ChannelMask))
N#define PWM_ENABLE_TIMER_SYNC(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->SSCTL |= (1UL << ((i >> 1) << 1)); \
N        } \
N    }while(0)
X#define PWM_ENABLE_TIMER_SYNC(pwm, u32ChannelMask)     do{         int i;        for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->SSCTL |= (1UL << ((i >> 1) << 1));         }     }while(0)
N
N/**
N * @brief Disable timer synchronous mode of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to disable timer synchronous mode of specified channel(s). Every two channels share the same setting.
N * \hideinitializer
N */
N#define PWM_DISABLE_TIMER_SYNC(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->SSCTL &= ~(1UL << ((i >> 1) << 1)); \
N        } \
N    }while(0)
X#define PWM_DISABLE_TIMER_SYNC(pwm, u32ChannelMask)     do{         int i;        for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->SSCTL &= ~(1UL << ((i >> 1) << 1));         }     }while(0)
N
N/**
N * @brief This macro enable output inverter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable output inverter of specified channel(s).
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) ((pwm)->POLCTL = (u32ChannelMask))
N
N/**
N * @brief This macro get captured rising data
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return None
N * @details This macro is used to get captured rising data of specified channel.
N * \hideinitializer
N */
N#define PWM_GET_CAPTURE_RISING_DATA(pwm, u32ChannelNum) (*(__IO uint32_t *) (&((pwm)->RCAPDAT0) + 2 * (u32ChannelNum)))
N
N/**
N * @brief This macro get captured falling data
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @return None
N * @details This macro is used to get captured falling data of specified channel.
N * \hideinitializer
N */
N#define PWM_GET_CAPTURE_FALLING_DATA(pwm, u32ChannelNum) (*(__IO uint32_t *) (&((pwm)->FCAPDAT0) + 2 * (u32ChannelNum)))
N
N/**
N * @brief This macro mask output logic to high or low
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32LevelMask Output logic to high or low
N * @return None
N * @details This macro is used to mask output logic to high or low of specified channel(s).
N * @note If u32ChannelMask parameter is 0, then mask function will be disabled.
N * \hideinitializer
N */
N#define PWM_MASK_OUTPUT(pwm, u32ChannelMask, u32LevelMask) \
N    { \
N        (pwm)->MSKEN = (u32ChannelMask); \
N        (pwm)->MSK = (u32LevelMask); \
N    }
X#define PWM_MASK_OUTPUT(pwm, u32ChannelMask, u32LevelMask)     {         (pwm)->MSKEN = (u32ChannelMask);         (pwm)->MSK = (u32LevelMask);     }
N
N/**
N * @brief This macro set the prescaler of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFFF
N * @return None
N * @details This macro is used to set the prescaler of specified channel.
N * @note Every even channel N, and channel (N + 1) share a prescaler. So if channel 0 prescaler changed,
N *       channel 1 will also be affected.
N * \hideinitializer
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) (*(__IO uint32_t *) (&((pwm)->CLKPSC0_1) + ((u32ChannelNum) >> 1)) = (u32Prescaler))
N
N/**
N * @brief This macro set the comparator of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32CMR Comparator of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set the comparator of specified channel.
N * @note This new setting will take effect on next PWM period.
N * \hideinitializer
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) ((pwm)->CMPDAT[(u32ChannelNum)] = (u32CMR))
N
N/**
N * @brief This macro set the period of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0, 2, 4. Every two channels share the same setting.
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set the period of specified channel.
N * @note This new setting will take effect on next PWM period.
N * @note PWM counter will stop if period length set to 0.
N * \hideinitializer
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  ((pwm)->PERIOD[(((u32ChannelNum) >> 1) << 1)] = (u32CNR))
N
N/**
N * @brief This macro set the PWM aligned type
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel. Every two channels share the same setting.
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *              - \ref PWM_EDGE_ALIGNED
N *              - \ref PWM_CENTER_ALIGNED
N * @return None
N * @details This macro is used to set the PWM aligned type of specified channel(s).
N * \hideinitializer
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N   do{ \
N        int i; \
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->CTL1 = (((pwm)->CTL1 & ~(3UL << ((i >> 1) << 2))) | ((u32AlignedType) << ((i >> 1) << 2))); \
N        } \
N    }while(0)
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)    do{         int i;         for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->CTL1 = (((pwm)->CTL1 & ~(3UL << ((i >> 1) << 2))) | ((u32AlignedType) << ((i >> 1) << 2)));         }     }while(0)
N
N/**
N * @brief Clear counter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel. Every two channels share the same setting.
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to clear counter of specified channel(s).
N * \hideinitializer
N */
N#define PWM_CLR_COUNTER(pwm, u32ChannelMask) \
N   do{ \
N        int i; \
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                ((pwm)->CNTCLR |= (1UL << ((i >> 1) << 1))); \
N        } \
N    }while(0)
X#define PWM_CLR_COUNTER(pwm, u32ChannelMask)    do{         int i;         for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i))                 ((pwm)->CNTCLR |= (1UL << ((i >> 1) << 1)));         }     }while(0)
N
N/**
N * @brief Set output level at zero, compare up, period(center) and compare down of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32ZeroLevel output level at zero point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32CmpUpLevel output level at compare up point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32PeriodLevel output level at period(center) point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @param[in] u32CmpDownLevel output level at compare down point, valid values are:
N *              - \ref PWM_OUTPUT_NOTHING
N *              - \ref PWM_OUTPUT_LOW
N *              - \ref PWM_OUTPUT_HIGH
N *              - \ref PWM_OUTPUT_TOGGLE
N * @return None
N * @details This macro is used to Set output level at zero, compare up, period(center) and compare down of specified channel(s).
N * \hideinitializer
N */
N#define PWM_SET_OUTPUT_LEVEL(pwm, u32ChannelMask, u32ZeroLevel, u32CmpUpLevel, u32PeriodLevel, u32CmpDownLevel) \
N   do{ \
N        int i; \
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) { \
N                (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (2 * i))) | ((u32ZeroLevel) << (2 * i))); \
N                (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (PWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))) | ((u32PeriodLevel) << (PWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))); \
N                (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (2 * i))) | ((u32CmpUpLevel) << (2 * i))); \
N                (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (PWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))) | ((u32CmpDownLevel) << (PWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))); \
N            } \
N        } \
N    }while(0)
X#define PWM_SET_OUTPUT_LEVEL(pwm, u32ChannelMask, u32ZeroLevel, u32CmpUpLevel, u32PeriodLevel, u32CmpDownLevel)    do{         int i;         for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i)) {                 (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (2 * i))) | ((u32ZeroLevel) << (2 * i)));                 (pwm)->WGCTL0 = (((pwm)->WGCTL0 & ~(3UL << (PWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))) | ((u32PeriodLevel) << (PWM_WGCTL0_PRDPCTLn_Pos + (2 * i))));                 (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (2 * i))) | ((u32CmpUpLevel) << (2 * i)));                 (pwm)->WGCTL1 = (((pwm)->WGCTL1 & ~(3UL << (PWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))) | ((u32CmpDownLevel) << (PWM_WGCTL1_CMPDCTLn_Pos + (2 * i))));             }         }     }while(0)
N
N/**
N * @brief Trigger brake event from specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 2 and bit 2 represents channel 4
N * @param[in] u32BrakeType Type of brake trigger. It supports PWM_FB_EDGE and PWM_FB_LEVEL.
N *              - \ref PWM_FB_EDGE
N *              - \ref PWM_FB_LEVEL
N * @return None
N * @details This macro is used to trigger brake event from specified channel(s).
N * \hideinitializer
N */
N#define PWM_TRIGGER_BRAKE(pwm, u32ChannelMask, u32BrakeType) ((pwm)->SWBRK |= ((u32ChannelMask) << (u32BrakeType)))
N
N/**
N * @brief Set Dead zone clock source
N * @param[in] pwm The pointer of the specified PWM module
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~5
N * @param[in] u32AfterPrescaler Dead zone clock source is from prescaler output. Valid values are TRUE (after prescaler) or FALSE (before prescaler).
N * @return None
N * @details This macro is used to set Dead zone clock source. Every two channels share the same setting.
N * @note The write-protection function should be disabled before using this function.
N * \hideinitializer
N */
N#define PWM_SET_DEADZONE_CLK_SRC(pwm, u32ChannelNum, u32AfterPrescaler) \
N    (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) = (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) & ~PWM_DTCTL0_1_DTCKSEL_Msk) | \
N    ((u32AfterPrescaler) << PWM_DTCTL0_1_DTCKSEL_Pos))
X#define PWM_SET_DEADZONE_CLK_SRC(pwm, u32ChannelNum, u32AfterPrescaler)     (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) = (*(__IO uint32_t *) (&((pwm)->DTCTL0_1) + ((u32ChannelNum) >> 1)) & ~PWM_DTCTL0_1_DTCKSEL_Msk) |     ((u32AfterPrescaler) << PWM_DTCTL0_1_DTCKSEL_Pos))
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define PWM functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t PWM_ConfigCaptureChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge);
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableFaultBrake(PWM_T *pwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource);
Nvoid PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
Nvoid PWM_DisableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
Nvoid PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nuint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_DisableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_SetClockSource(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel);
Nvoid PWM_EnableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel);
Nvoid PWM_DisableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_EnableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_DisableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum);
Nvoid PWM_SetBrakePinSource(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule);
Nuint32_t PWM_GetWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N
N/*@}*/ /* end of group NUC131_PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_PWM_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11296 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "BPWM.h"
L 1 "..\..\..\Library\StdDriver\inc\BPWM.h" 1
N/**************************************************************************//**
N * @file     bpwm.h
N * @version  V1.00
N * $Revision: 8 $
N * $Date: 15/05/13 3:00p $
N * @brief    NUC131 series PWM driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __BPWM_H__
N#define __BPWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_BPWM_Driver BPWM Driver
N  @{
N*/
N
N/** @addtogroup NUC131_BPWM_EXPORTED_CONSTANTS BPWM Exported Constants
N  @{
N*/
N#define BPWM_CHANNEL_NUM                          (6)        /*!< BPWM channel number */
N#define BPWM_CH_0_MASK                            (0x1UL)    /*!< BPWM channel 0 mask \hideinitializer */
N#define BPWM_CH_1_MASK                            (0x2UL)    /*!< BPWM channel 1 mask \hideinitializer */
N#define BPWM_CH_2_MASK                            (0x4UL)    /*!< BPWM channel 2 mask \hideinitializer */
N#define BPWM_CH_3_MASK                            (0x8UL)    /*!< BPWM channel 3 mask \hideinitializer */
N#define BPWM_CH_4_MASK                            (0x10UL)   /*!< BPWM channel 4 mask \hideinitializer */
N#define BPWM_CH_5_MASK                            (0x20UL)   /*!< BPWM channel 5 mask \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Counter Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BPWM_UP_COUNTER                           (0UL)      /*!< Up counter type */
N#define BPWM_DOWN_COUNTER                         (1UL)      /*!< Down counter type */
N#define BPWM_UP_DOWN_COUNTER                      (2UL)      /*!< Up-Down counter type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Aligned Type Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BPWM_EDGE_ALIGNED                         (1UL)      /*!< BPWM working in edge aligned type(down count) */
N#define BPWM_CENTER_ALIGNED                       (2UL)      /*!< BPWM working in center aligned type */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Output Level Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BPWM_OUTPUT_NOTHING                       (0UL)      /*!< BPWM output nothing */
N#define BPWM_OUTPUT_LOW                           (1UL)      /*!< BPWM output low */
N#define BPWM_OUTPUT_HIGH                          (2UL)      /*!< BPWM output high */
N#define BPWM_OUTPUT_TOGGLE                        (3UL)      /*!< BPWM output toggle */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Trigger Source Select Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BPWM_TRIGGER_ADC_EVEN_ZERO_POINT                     (0UL)     /*!< BPWM trigger ADC while counter of even channel matches zero point */
N#define BPWM_TRIGGER_ADC_EVEN_PERIOD_POINT                   (1UL)     /*!< BPWM trigger ADC while counter of even channel matches period point */
N#define BPWM_TRIGGER_ADC_EVEN_ZERO_OR_PERIOD_POINT           (2UL)     /*!< BPWM trigger ADC while counter of even channel matches zero or period point */
N#define BPWM_TRIGGER_ADC_EVEN_COMPARE_UP_COUNT_POINT         (3UL)     /*!< BPWM trigger ADC while counter of even channel matches up count to comparator point */
N#define BPWM_TRIGGER_ADC_EVEN_COMPARE_DOWN_COUNT_POINT       (4UL)     /*!< BPWM trigger ADC while counter of even channel matches down count to comparator point */
N#define BPWM_TRIGGER_ADC_ODD_COMPARE_UP_COUNT_POINT          (8UL)     /*!< BPWM trigger ADC while counter of odd channel matches up count to comparator point */
N#define BPWM_TRIGGER_ADC_ODD_COMPARE_DOWN_COUNT_POINT        (9UL)     /*!< BPWM trigger ADC while counter of odd channel matches down count to comparator point */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Capture Control Constant Definitions                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BPWM_CAPTURE_INT_RISING_LATCH             (1UL)        /*!< BPWM capture interrupt if channel has rising transition */
N#define BPWM_CAPTURE_INT_FALLING_LATCH            (0x100UL)    /*!< BPWM capture interrupt if channel has falling transition */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Duty Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BPWM_DUTY_INT_DOWN_COUNT_MATCH_CMP        (BPWM_INTEN_CMPDIEN0_Msk)   /*!< BPWM duty interrupt triggered if down count match comparator */
N#define BPWM_DUTY_INT_UP_COUNT_MATCH_CMP          (BPWM_INTEN_CMPUIEN0_Msk)   /*!< BPWM duty interrupt triggered if up down match comparator */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Load Mode Constant Definitions                                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BPWM_LOAD_MODE_IMMEDIATE                  (BPWM_CTL0_IMMLDEN0_Msk)    /*!< BPWM immediately load mode \hideinitializer */
N#define BPWM_LOAD_MODE_CENTER                     (BPWM_CTL0_CTRLD0_Msk)      /*!< BPWM center load mode \hideinitializer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Clock Source Select Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define BPWM_CLKSRC_BPWM_CLK                      (0UL)    /*!< BPWM Clock source selects to BPWM0_CLK or BPWM1_CLK \hideinitializer */
N#define BPWM_CLKSRC_TIMER0                        (1UL)    /*!< BPWM Clock source selects to TIMER0 overflow \hideinitializer */
N#define BPWM_CLKSRC_TIMER1                        (2UL)    /*!< BPWM Clock source selects to TIMER1 overflow \hideinitializer */
N#define BPWM_CLKSRC_TIMER2                        (3UL)    /*!< BPWM Clock source selects to TIMER2 overflow \hideinitializer */
N#define BPWM_CLKSRC_TIMER3                        (4UL)    /*!< BPWM Clock source selects to TIMER3 overflow \hideinitializer */
N
N/*@}*/ /* end of group NUC131_BPWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_BPWM_EXPORTED_FUNCTIONS BPWM Exported Functions
N  @{
N*/
N
N/**
N * @brief Enable timer synchronous mode of specified channel(s)
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelMask Combination of enabled channels. This parameter is not used.
N * @return None
N * @details This macro is used to enable timer synchronous mode of specified channel(s).
N * @note All channels share channel 0's setting.
N * \hideinitializer
N */
N#define BPWM_ENABLE_TIMER_SYNC(bpwm, u32ChannelMask) ((bpwm)->SSCTL |= BPWM_SSCTL_SSEN0_Msk)
N
N/**
N * @brief Disable timer synchronous mode of specified channel(s)
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelMask Combination of enabled channels. This parameter is not used.
N * @return None
N * @details This macro is used to disable timer synchronous mode of specified channel(s).
N * @note All channels share channel 0's setting.
N * \hideinitializer
N */
N#define BPWM_DISABLE_TIMER_SYNC(bpwm, u32ChannelMask) ((bpwm)->SSCTL &= ~BPWM_SSCTL_SSEN0_Msk)
N
N/**
N * @brief This macro enable output inverter of specified channel(s)
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * \hideinitializer
N */
N#define BPWM_ENABLE_OUTPUT_INVERTER(bpwm, u32ChannelMask) ((bpwm)->POLCTL = (u32ChannelMask))
N
N/**
N * @brief This macro get captured rising data
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelNum BPWM channel number. Valid values are between 0~5
N * @return None
N * \hideinitializer
N */
N#define BPWM_GET_CAPTURE_RISING_DATA(bpwm, u32ChannelNum) (*(__IO uint32_t *) (&((bpwm)->RCAPDAT0) + 2 * (u32ChannelNum)))
N
N/**
N * @brief This macro get captured falling data
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelNum BPWM channel number. Valid values are between 0~5
N * @return None
N * \hideinitializer
N */
N#define BPWM_GET_CAPTURE_FALLING_DATA(bpwm, u32ChannelNum) (*(__IO uint32_t *) (&((bpwm)->FCAPDAT0) + 2 * (u32ChannelNum)))
N
N/**
N * @brief This macro mask output logic to high or low
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32LevelMask Output logic to high or low
N * @return None
N * @details This macro is used to mask output logic to high or low of specified channel(s).
N * @note If u32ChannelMask parameter is 0, then mask function will be disabled.
N * \hideinitializer
N */
N#define BPWM_MASK_OUTPUT(bpwm, u32ChannelMask, u32LevelMask) \
N    { \
N        (bpwm)->MSKEN = (u32ChannelMask); \
N        (bpwm)->MSK = (u32LevelMask); \
N    }
X#define BPWM_MASK_OUTPUT(bpwm, u32ChannelMask, u32LevelMask)     {         (bpwm)->MSKEN = (u32ChannelMask);         (bpwm)->MSK = (u32LevelMask);     }
N
N/**
N * @brief This macro set the prescaler of all channels
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelNum BPWM channel number. This parameter is not used.
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFFF
N * @return None
N * \hideinitializer
N */
N#define BPWM_SET_PRESCALER(bpwm, u32ChannelNum, u32Prescaler) ((bpwm)->CLKPSC = (u32Prescaler))
N
N/**
N * @brief This macro set the duty of the selected channel
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelNum BPWM channel number. Valid values are between 0~5
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next BPWM period
N * \hideinitializer
N */
N#define BPWM_SET_CMR(bpwm, u32ChannelNum, u32CMR) ((bpwm)->CMPDAT[(u32ChannelNum)] = (u32CMR))
N
N/**
N * @brief This macro set the period of all channels
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelNum BPWM channel number. This parameter is not used.
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @note This new setting will take effect on next BPWM period
N * @note BPWM counter will stop if period length set to 0
N * \hideinitializer
N */
N#define BPWM_SET_CNR(bpwm, u32ChannelNum, u32CNR) ((bpwm)->PERIOD = (u32CNR))
N
N/**
N * @brief This macro set the BPWM aligned type
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelMask Combination of enabled channels. This parameter is not used.
N * @param[in] u32AlignedType BPWM aligned type, valid values are:
N *              - \ref BPWM_EDGE_ALIGNED
N *              - \ref BPWM_CENTER_ALIGNED
N * @return None
N * @note All channels share channel 0's setting.
N * \hideinitializer
N */
N#define BPWM_SET_ALIGNED_TYPE(bpwm, u32ChannelMask, u32AlignedType) ((bpwm)->CTL1 = (u32AlignedType))
N
N/**
N * @brief Clear counter of channel 0
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelMask Combination of enabled channels. This parameter is not used.
N * @return None
N * @details This macro is used to clear counter of channel 0
N * \hideinitializer
N */
N#define BPWM_CLR_COUNTER(bpwm, u32ChannelMask) ((bpwm)->CNTCLR = (BPWM_CNTCLR_CNTCLR0_Msk))
N
N/**
N * @brief Set output level at zero, compare up, period(center) and compare down of specified channel(s)
N * @param[in] bpwm The pointer of the specified BPWM module
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32ZeroLevel output level at zero point, valid values are:
N *              - \ref BPWM_OUTPUT_NOTHING
N *              - \ref BPWM_OUTPUT_LOW
N *              - \ref BPWM_OUTPUT_HIGH
N *              - \ref BPWM_OUTPUT_TOGGLE
N * @param[in] u32CmpUpLevel output level at compare up point, valid values are:
N *              - \ref BPWM_OUTPUT_NOTHING
N *              - \ref BPWM_OUTPUT_LOW
N *              - \ref BPWM_OUTPUT_HIGH
N *              - \ref BPWM_OUTPUT_TOGGLE
N * @param[in] u32PeriodLevel output level at period(center) point, valid values are:
N *              - \ref BPWM_OUTPUT_NOTHING
N *              - \ref BPWM_OUTPUT_LOW
N *              - \ref BPWM_OUTPUT_HIGH
N *              - \ref BPWM_OUTPUT_TOGGLE
N * @param[in] u32CmpDownLevel output level at compare down point, valid values are:
N *              - \ref BPWM_OUTPUT_NOTHING
N *              - \ref BPWM_OUTPUT_LOW
N *              - \ref BPWM_OUTPUT_HIGH
N *              - \ref BPWM_OUTPUT_TOGGLE
N * @return None
N * @details This macro is used to Set output level at zero, compare up, period(center) and compare down of specified channel(s)
N * \hideinitializer
N */
N#define BPWM_SET_OUTPUT_LEVEL(bpwm, u32ChannelMask, u32ZeroLevel, u32CmpUpLevel, u32PeriodLevel, u32CmpDownLevel) \
N   do{ \
N        int i; \
N        for(i = 0; i < 6; i++) { \
N            if((u32ChannelMask) & (1 << i)) { \
N                (bpwm)->WGCTL0 = (((bpwm)->WGCTL0 & ~(3UL << (2 * i))) | ((u32ZeroLevel) << (2 * i))); \
N                (bpwm)->WGCTL0 = (((bpwm)->WGCTL0 & ~(3UL << (BPWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))) | ((u32PeriodLevel) << (BPWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))); \
N                (bpwm)->WGCTL1 = (((bpwm)->WGCTL1 & ~(3UL << (2 * i))) | ((u32CmpUpLevel) << (2 * i))); \
N                (bpwm)->WGCTL1 = (((bpwm)->WGCTL1 & ~(3UL << (BPWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))) | ((u32CmpDownLevel) << (BPWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))); \
N            } \
N        } \
N    }while(0)
X#define BPWM_SET_OUTPUT_LEVEL(bpwm, u32ChannelMask, u32ZeroLevel, u32CmpUpLevel, u32PeriodLevel, u32CmpDownLevel)    do{         int i;         for(i = 0; i < 6; i++) {             if((u32ChannelMask) & (1 << i)) {                 (bpwm)->WGCTL0 = (((bpwm)->WGCTL0 & ~(3UL << (2 * i))) | ((u32ZeroLevel) << (2 * i)));                 (bpwm)->WGCTL0 = (((bpwm)->WGCTL0 & ~(3UL << (BPWM_WGCTL0_PRDPCTLn_Pos + (2 * i)))) | ((u32PeriodLevel) << (BPWM_WGCTL0_PRDPCTLn_Pos + (2 * i))));                 (bpwm)->WGCTL1 = (((bpwm)->WGCTL1 & ~(3UL << (2 * i))) | ((u32CmpUpLevel) << (2 * i)));                 (bpwm)->WGCTL1 = (((bpwm)->WGCTL1 & ~(3UL << (BPWM_WGCTL1_CMPDCTLn_Pos + (2 * i)))) | ((u32CmpDownLevel) << (BPWM_WGCTL1_CMPDCTLn_Pos + (2 * i))));             }         }     }while(0)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define BPWM functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t BPWM_ConfigCaptureChannel(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge);
Nuint32_t BPWM_ConfigOutputChannel(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle);
Nvoid BPWM_Start(BPWM_T *bpwm, uint32_t u32ChannelMask);
Nvoid BPWM_Stop(BPWM_T *bpwm, uint32_t u32ChannelMask);
Nvoid BPWM_ForceStop(BPWM_T *bpwm, uint32_t u32ChannelMask);
Nvoid BPWM_EnableADCTrigger(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid BPWM_DisableADCTrigger(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_ClearADCTriggerFlag(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t BPWM_GetADCTriggerFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_EnableCapture(BPWM_T *bpwm, uint32_t u32ChannelMask);
Nvoid BPWM_DisableCapture(BPWM_T *bpwm, uint32_t u32ChannelMask);
Nvoid BPWM_EnableOutput(BPWM_T *bpwm, uint32_t u32ChannelMask);
Nvoid BPWM_DisableOutput(BPWM_T *bpwm, uint32_t u32ChannelMask);
Nvoid BPWM_EnableCaptureInt(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid BPWM_DisableCaptureInt(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid BPWM_ClearCaptureIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t BPWM_GetCaptureIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_EnableDutyInt(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid BPWM_DisableDutyInt(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_ClearDutyIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nuint32_t BPWM_GetDutyIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_EnablePeriodInt(BPWM_T *bpwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid BPWM_DisablePeriodInt(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_ClearPeriodIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nuint32_t BPWM_GetPeriodIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_EnableZeroInt(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_DisableZeroInt(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_ClearZeroIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nuint32_t BPWM_GetZeroIntFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_EnableLoadMode(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
Nvoid BPWM_DisableLoadMode(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
Nvoid BPWM_SetClockSource(BPWM_T *bpwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel);
Nuint32_t BPWM_GetWrapAroundFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
Nvoid BPWM_ClearWrapAroundFlag(BPWM_T *bpwm, uint32_t u32ChannelNum);
N
N
N/*@}*/ /* end of group NUC131_BPWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_BPWM_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__BPWM_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11297 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "SPI.h"
L 1 "..\..\..\Library\StdDriver\inc\SPI.h" 1
N/**************************************************************************//**
N * @file     spi.h
N * @version  V3.0
N * $Revision: 7 $
N * $Date: 14/12/24 2:37p $
N * @brief    NUC131 Series SPI Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup NUC131_SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CNTRL_TX_NEG_Msk)                          /*!< CLKP=0; RX_NEG=0; TX_NEG=1 */
N#define SPI_MODE_1        (SPI_CNTRL_RX_NEG_Msk)                          /*!< CLKP=0; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_2        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_RX_NEG_Msk)     /*!< CLKP=1; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_3        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_TX_NEG_Msk)     /*!< CLKP=1; RX_NEG=0; TX_NEG=1 */
N
N#define SPI_SLAVE         (SPI_CNTRL_SLAVE_Msk)                           /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                           /*!< Set as master */
N
N#define SPI_SS0               (1<<SPI_SSR_SSR_Pos)                        /*!< Select SPIn_SS0 */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSR_SS_LVL_Msk)                        /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                       /*!< SS active low */
N
N#define SPI_UNIT_INT_MASK                (0x01)                           /*!< Unit transfer interrupt mask */
N#define SPI_SSTA_INT_MASK                (0x02)                           /*!< Slave 3-Wire mode start interrupt mask */
N#define SPI_FIFO_TX_INT_MASK             (0x04)                           /*!< FIFO TX interrupt mask */
N#define SPI_FIFO_RX_INT_MASK             (0x08)                           /*!< FIFO RX interrupt mask */
N#define SPI_FIFO_RXOV_INT_MASK           (0x10)                           /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_TIMEOUT_INT_MASK        (0x20)                           /*!< FIFO RX timeout interrupt mask */
N
N#define SPI_BUSY_MASK                    (0x01)                           /*!< Busy status mask */
N#define SPI_RX_EMPTY_MASK                (0x02)                           /*!< RX empty status mask */
N#define SPI_RX_FULL_MASK                 (0x04)                           /*!< RX full status mask */
N#define SPI_TX_EMPTY_MASK                (0x08)                           /*!< TX empty status mask */
N#define SPI_TX_FULL_MASK                 (0x10)                           /*!< TX full status mask */
N
N/*@}*/ /* end of group NUC131_SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Abort the current transfer in Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set the SLV_ABORT bit of SPI_CNTRL2 register to abort the current transfer in Slave 3-wire mode.
N  */
N#define SPI_ABORT_3WIRE_TRANSFER(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_SLV_ABORT_Msk)
N
N/**
N  * @brief      Clear the Slave 3-wire mode start interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Write 1 to SLV_START_INTSTS bit of SPI_STATUS register to clear the Slave 3-wire mode start interrupt flag.
N  */
N#define SPI_CLR_3WIRE_START_INT_FLAG(spi)   ((spi)->STATUS = SPI_STATUS_SLV_START_INTSTS_Msk)
N
N/**
N  * @brief      Clear the unit transfer interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Write 1 to IF bit of SPI_STATUS register to clear the unit transfer interrupt flag.
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi)   ((spi)->STATUS = SPI_STATUS_IF_Msk)
N
N/**
N  * @brief      Disable Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear NOSLVSEL bit of SPI_CNTRL2 register to disable Slave 3-wire mode.
N  */
N#define SPI_DISABLE_3WIRE_MODE(spi)   ((spi)->CNTRL2 &= ~SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N  * @brief      Disable Dual I/O mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear DUAL_IO_EN bit of SPI_CNTRL2 register to disable Dual I/O mode.
N  */
N#define SPI_DISABLE_DUAL_MODE(spi)   ((spi)->CNTRL2 &= ~SPI_CNTRL2_DUAL_IO_EN_Msk)
N
N/**
N  * @brief      Enable Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set NOSLVSEL bit of SPI_CNTRL2 register to enable Slave 3-wire mode.
N  */
N#define SPI_ENABLE_3WIRE_MODE(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N  * @brief      Enable Dual input mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear DUAL_IO_DIR bit and set DUAL_IO_EN bit of SPI_CNTRL2 register to enable Dual input mode.
N  */
N#define SPI_ENABLE_DUAL_INPUT_MODE(spi)   ((spi)->CNTRL2 = ((spi)->CNTRL2 & (~SPI_CNTRL2_DUAL_IO_DIR_Msk)) | SPI_CNTRL2_DUAL_IO_EN_Msk)
N
N/**
N  * @brief      Enable Dual output mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set DUAL_IO_DIR bit and DUAL_IO_EN bit of SPI_CNTRL2 register to enable Dual output mode.
N  */
N#define SPI_ENABLE_DUAL_OUTPUT_MODE(spi)   ((spi)->CNTRL2 |= (SPI_CNTRL2_DUAL_IO_EN_Msk | SPI_CNTRL2_DUAL_IO_DIR_Msk))
N
N/**
N  * @brief      Get the count of available data in RX FIFO.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     The count of available data in RX FIFO.
N  * @details    Read RX_FIFO_COUNT (SPI_STATUS[15:12]) to get the count of available data in RX FIFO.
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi)   (((spi)->STATUS & SPI_STATUS_RX_FIFO_COUNT_Msk) >> SPI_STATUS_RX_FIFO_COUNT_Pos)
N
N/**
N  * @brief      Get the RX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 RX FIFO is not empty.
N  * @retval     1 RX FIFO is empty.
N  * @details    Read RX_EMPTY bit of SPI_STATUS register to get the RX FIFO empty flag.
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_RX_EMPTY_Msk)>>SPI_STATUS_RX_EMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not empty.
N  * @retval     1 TX FIFO is empty.
N  * @details    Read TX_EMPTY bit of SPI_STATUS register to get the TX FIFO empty flag.
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TX_EMPTY_Msk)>>SPI_STATUS_TX_EMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO full flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not full.
N  * @retval     1 TX FIFO is full.
N  * @details    Read TX_FULL bit of SPI_STATUS register to get the TX FIFO full flag.
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TX_FULL_Msk)>>SPI_STATUS_TX_FULL_Pos)
N
N/**
N  * @brief      Get the datum read from RX register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX register.
N  * @details    Read SPI_RX register to get the received datum.
N  */
N#define SPI_READ_RX(spi)   ((spi)->RX)
N
N/**
N  * @brief      Write datum to TX register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None.
N  * @details    Write u32TxData to TX register.
N  */
N#define SPI_WRITE_TX(spi, u32TxData)   ((spi)->TX = (u32TxData))
N
N/**
N  * @brief      Set SPIn_SS0 pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0 pin to high state.
N  */
N#define SPI_SET_SS0_HIGH(spi)   ((spi)->SSR = ((spi)->SSR & (~SPI_SSR_AUTOSS_Msk)) | (SPI_SSR_SS_LVL_Msk | SPI_SS0))
N
N/**
N  * @brief      Set SPIn_SS0 pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0 pin to low state.
N  */
N#define SPI_SET_SS0_LOW(spi)   ((spi)->SSR = ((spi)->SSR & (~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk))) | SPI_SS0)
N
N/**
N  * @brief      Enable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set REORDER bit of SPI_CNTRL register to enable Byte Reorder function.
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi)   ((spi)->CNTRL |= SPI_CNTRL_REORDER_Msk)
N
N/**
N  * @brief      Disable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear REORDER bit of SPI_CNTRL register to disable Byte Reorder function.
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_REORDER_Msk)
N
N/**
N  * @brief      Set the length of suspend interval.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32SuspCycle Decides the length of suspend interval. It could be 0 ~ 15.
N  * @return     None.
N  * @details    Set the length of suspend interval according to u32SuspCycle.
N  *             The length of suspend interval is ((u32SuspCycle + 0.5) * the length of one SPI bus clock cycle).
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle)   ((spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_SP_CYCLE_Msk) | ((u32SuspCycle) << SPI_CNTRL_SP_CYCLE_Pos))
N
N/**
N  * @brief      Set the SPI transfer sequence with LSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set LSB bit of SPI_CNTRL register to set the SPI transfer sequence with LSB first.
N  */
N#define SPI_SET_LSB_FIRST(spi)   ((spi)->CNTRL |= SPI_CNTRL_LSB_Msk)
N
N/**
N  * @brief      Set the SPI transfer sequence with MSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear LSB bit of SPI_CNTRL register to set the SPI transfer sequence with MSB first.
N  */
N#define SPI_SET_MSB_FIRST(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_LSB_Msk)
N
N/**
N  * @brief      Set the data width of a SPI transaction.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32Width The bit width of transfer data.
N  * @return     None.
N  * @details    The data width can be 8 ~ 32 bits.
N  */
N#define SPI_SET_DATA_WIDTH(spi, u32Width)   ((spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_TX_BIT_LEN_Msk) | (((u32Width)&0x1F) << SPI_CNTRL_TX_BIT_LEN_Pos))
N
N/**
N  * @brief      Get the SPI busy state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 SPI controller is not busy.
N  * @retval     1 SPI controller is busy.
N  * @details    This macro will return the busy state of SPI controller.
N  */
N#define SPI_IS_BUSY(spi)   ( ((spi)->CNTRL & SPI_CNTRL_GO_BUSY_Msk)>>SPI_CNTRL_GO_BUSY_Pos )
N
N/**
N  * @brief      Set the GO_BUSY bit to trigger SPI transfer.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    If FIFO mode is disabled, user can use this macro to trigger the data transfer after all configuration is ready.
N  *             If FIFO mode is enabled, user should not use this macro to trigger the data transfer. SPI controller will trigger the data transfer
N  *             automatically after user write to SPI_TX register.
N  */
N#define SPI_TRIGGER(spi)   ((spi)->CNTRL |= SPI_CNTRL_GO_BUSY_Msk)
N
N
N
N/* Function prototype declaration */
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nvoid SPI_DisableFIFO(SPI_T *spi);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask);
N
N
N
N/**
N  * @} End of SPI Device Function Interface
N  */
N
N/**
N  * @} End of NUC131 Function Interface
N  */
N
N
N#endif
N
L 11298 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "TIMER.h"
L 1 "..\..\..\Library\StdDriver\inc\TIMER.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/01/16 3:21p $
N * @brief    NUC131 series Timer driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup NUC131_TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  TIMER Operation Mode, External Counter and Capture Mode Constant Definitions                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define TIMER_ONESHOT_MODE                      (0UL << TIMER_TCSR_MODE_Pos)        /*!< Timer working in one-shot mode */
N#define TIMER_PERIODIC_MODE                     (1UL << TIMER_TCSR_MODE_Pos)        /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                       (2UL << TIMER_TCSR_MODE_Pos)        /*!< Timer working in toggle-output mode */
N#define TIMER_CONTINUOUS_MODE                   (3UL << TIMER_TCSR_MODE_Pos)        /*!< Timer working in continuous counting mode */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE        (0UL << TIMER_TEXCON_RSTCAPSEL_Pos) /*!< Timer capture event to get timer counter value */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE        (1UL << TIMER_TEXCON_RSTCAPSEL_Pos) /*!< Timer capture event to reset timer counter */
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Falling edge detection to trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Rising edge detection to trigger timer capture */
N#define TIMER_CAPTURE_FALLING_AND_RISING_EDGE   (2UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Both falling and rising edge detection to trigger timer capture */
N#define TIMER_COUNTER_FALLING_EDGE              (0UL << TIMER_TEXCON_TX_PHASE_Pos)  /*!< Counter increase on falling edge detection */
N#define TIMER_COUNTER_RISING_EDGE               (1UL << TIMER_TEXCON_TX_PHASE_Pos)  /*!< Counter increase on rising edge detection */
N
N/*@}*/ /* end of group NUC131_TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set Timer Compared Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer compare value. Valid values are between 2 to 0xFFFFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set timer compared value to adjust timer time-out interval.
N  * @note       Never write 0x0 or 0x1 in this field, or the core will run into unknown state. \n
N  *             If update timer compared value in continuous counting mode, timer counter value will keep counting continuously. \n
N  *             But if timer is operating at other modes, the timer up counter will restart counting and start from 0.
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value)        ((timer)->TCMPR = (u32Value))
N
N/**
N  * @brief      Set Timer Prescale Value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer prescale value. Valid values are between 0 to 0xFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set timer prescale value and timer source clock will be divided by (prescale + 1) \n
N  *             before it is fed into timer.
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value)   ((timer)->TCSR = ((timer)->TCSR & ~TIMER_TCSR_PRESCALE_Msk) | (u32Value))
N
N/**
N  * @brief      Check specify Timer Status
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer 24-bit up counter is inactive
N  * @retval     1   Timer 24-bit up counter is active
N  *
N  * @details    This macro is used to check if specify Timer counter is inactive or active.
N  */
N#define TIMER_IS_ACTIVE(timer)                      (((timer)->TCSR & TIMER_TCSR_CACT_Msk) ? 1 : 0)
N
N/**
N  * @brief      Start Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to start Timer counting.
N  */
Nstatic __INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_CEN_Msk;
X    timer->TCSR |= (1ul << 30);
N}
N
N/**
N  * @brief      Stop Timer Counting
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to stop/suspend Timer counting.
N  */
Nstatic __INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_CEN_Msk;
X    timer->TCSR &= ~(1ul << 30);
N}
N
N/**
N  * @brief      Enable Timer Interrupt Wake-up Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer interrupt wake-up function and interrupt source could be time-out interrupt, \n
N  *             counter event interrupt or capture trigger interrupt.
N  * @note       To wake the system from Power-down mode, timer clock source must be LIRC.
N  */
Nstatic __INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR |= (1ul << 23);
N}
N
N/**
N  * @brief      Disable Timer Wake-up Function
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer interrupt wake-up function.
N  */
Nstatic __INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR &= ~(1ul << 23);
N}
N
N/**
N  * @brief      Enable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the detect de-bounce function of capture pin.
N  */
Nstatic __INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON |= (1ul << 6);
N}
N
N/**
N  * @brief      Disable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the detect de-bounce function of capture pin.
N  */
Nstatic __INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON &= ~(1ul << 6);
N}
N
N/**
N  * @brief      Enable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the detect de-bounce function of counter pin.
N  */
Nstatic __INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON |= (1ul << 7);
N}
N
N/**
N  * @brief      Disable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the detect de-bounce function of counter pin.
N  */
Nstatic __INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON &= ~(1ul << 7);
N}
N
N/**
N  * @brief      Enable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_IE_Msk;
X    timer->TCSR |= (1ul << 29);
N}
N
N/**
N  * @brief      Disable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_IE_Msk;
X    timer->TCSR &= ~(1ul << 29);
N}
N
N/**
N  * @brief      Enable Capture Trigger Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON |= (1ul << 5);
N}
N
N/**
N  * @brief      Disable Capture Trigger Interrupt
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON &= ~(1ul << 5);
N}
N
N/**
N  * @brief      Get Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer time-out interrupt did not occur
N  * @retval     1   Timer time-out interrupt occurred
N  *
N  * @details    This function indicates timer time-out interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return ((timer->TISR & TIMER_TISR_TIF_Msk) ? 1 : 0);
X    return ((timer->TISR & (1ul << 0)) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears timer time-out interrupt flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TIF_Msk;
X    timer->TISR = (1ul << 0);
N}
N
N/**
N  * @brief      Get Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer capture interrupt did not occur
N  * @retval     1   Timer capture interrupt occurred
N  *
N  * @details    This function indicates timer capture trigger interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->TEXISR;
N}
N
N/**
N  * @brief      Clear Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears timer capture trigger interrupt flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->TEXISR = TIMER_TEXISR_TEXIF_Msk;
X    timer->TEXISR = (1ul << 0);
N}
N
N/**
N  * @brief      Get Timer Wake-up Flag
N  *
N  * @param[in]  timer   The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer does not cause CPU wake-up
N  * @retval     1   Timer interrupt event cause CPU wake-up
N  *
N  * @details    This function indicates timer interrupt event has waked up system or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return ((timer->TISR & TIMER_TISR_TWF_Msk) ? 1 : 0);
X    return ((timer->TISR & (1ul << 1)) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Wake-up Flag
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears the timer wake-up system flag to 0.
N  */
Nstatic __INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TWF_Msk;
X    timer->TISR = (1ul << 1);
N}
N
N/**
N  * @brief      Get Capture value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     24-bit Capture Value
N  *
N  * @details    This function reports the current 24-bit timer capture value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->TCAP;
N}
N
N/**
N  * @brief      Get Counter value
N  *
N  * @param[in]  timer       The pointer of the specified Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     24-bit Counter Value
N  *
N  * @details    This function reports the current 24-bit timer counter value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->TDR;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
N
N/*@}*/ /* end of group NUC131_TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_TIMER_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11299 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "WDT.h"
L 1 "..\..\..\Library\StdDriver\inc\WDT.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 14/06/10 10:49a $
N * @brief    NUC131 series WDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup NUC131_WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WDT Time-out Interval Period Constant Definitions                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_TIMEOUT_2POW4           (0UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6           (1UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8           (2UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10          (3UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12          (4UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14          (5UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16          (6UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18          (7UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^18 * WDT clocks */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WDT Reset Delay Period Constant Definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_RESET_DELAY_1026CLK     (0UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 1026 * WDT clocks */
N#define WDT_RESET_DELAY_130CLK      (1UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 130 * WDT clocks */
N#define WDT_RESET_DELAY_18CLK       (2UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 18 * WDT clocks */
N#define WDT_RESET_DELAY_3CLK        (3UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 3 * WDT clocks */
N
N/*@}*/ /* end of group NUC131_WDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out reset system flag.
N  */
N#define WDT_CLEAR_RESET_FLAG()          (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTRF_Msk)
N
N/**
N  * @brief      Clear WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out interrupt flag.
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG()    (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTIF_Msk)
N
N/**
N  * @brief      Clear WDT Wake-up Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clears WDT time-out wake-up system flag.
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk)) | WDT_WTCR_WTWKF_Msk)
N
N/**
N  * @brief      Get WDT Time-out Reset Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out reset system did not occur
N  * @retval     1   WDT time-out reset system occurred
N  *
N  * @details    This macro indicates system has been reset by WDT time-out reset or not.
N  */
N#define WDT_GET_RESET_FLAG()            ((WDT->WTCR & WDT_WTCR_WTRF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt did not occur
N  * @retval     1   WDT time-out interrupt occurred
N  *
N  * @details    This macro indicates WDT time-out interrupt occurred or not.
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG()      ((WDT->WTCR & WDT_WTCR_WTIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Wake-up Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt does not cause CPU wake-up
N  * @retval     1   WDT time-out interrupt event cause CPU wake-up
N  *
N  * @details    This macro indicates WDT time-out interrupt event has waked up system or not.
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG()   ((WDT->WTCR & WDT_WTCR_WTWKF_Msk)? 1 : 0)
N
N/**
N  * @brief      Reset WDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reset the internal 18-bit WDT up counter value.
N  * @note       If WDT is activated and time-out reset system function is enabled also, user should \n
N  *             reset the 18-bit WDT up counter value to avoid generate WDT time-out reset signal to \n
N  *             reset system before the WDT time-out reset delay period expires.
N  */
N#define WDT_RESET_COUNTER()             (WDT->WTCR  = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk | WDT_WTCR_WTRF_Msk)) | WDT_WTCR_WTR_Msk)
N
N/**
N  * @brief      Stop WDT Counting
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will stop WDT counting and disable WDT module.
N  */
Nstatic __INLINE void WDT_Close(void)
Xstatic __inline void WDT_Close(void)
N{
N    WDT->WTCR = 0;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR = 0;
N    return;
N}
N
N/**
N  * @brief      Enable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will enable the WDT time-out interrupt function.
N  */
Nstatic __INLINE void WDT_EnableInt(void)
Xstatic __inline void WDT_EnableInt(void)
N{
N    WDT->WTCR |= WDT_WTCR_WTIE_Msk;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR |= (1ul << 6);
N    return;
N}
N
N/**
N  * @brief      Disable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function will disable the WDT time-out interrupt function.
N  */
Nstatic __INLINE void WDT_DisableInt(void)
Xstatic __inline void WDT_DisableInt(void)
N{
N    // Do not touch write 1 clear bits
N    WDT->WTCR &= ~(WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk);
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR &= ~((1ul << 6) | (1ul << 2) | (1ul << 3) | (1ul << 5));
N    return;
N}
N
Nvoid WDT_Open(uint32_t u32TimeoutInterval, uint32_t u32ResetDelay, uint32_t u32EnableReset, uint32_t u32EnableWakeup);
N
N/*@}*/ /* end of group NUC131_WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_WDT_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11300 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "WWDT.h"
L 1 "..\..\..\Library\StdDriver\inc\WWDT.h" 1
N/**************************************************************************//**
N * @file     wwdt.h
N * @version  V3.00
N * $Revision: 3 $
N * $Date: 14/10/03 4:54p $
N * @brief    NUC131 series WWDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WWDT_H__
N#define __WWDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_WWDT_Driver WWDT Driver
N  @{
N*/
N
N/** @addtogroup NUC131_WWDT_EXPORTED_CONSTANTS WWDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WWDT Prescale Period Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_PRESCALER_1        (0 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 1 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2        (1 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 2 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_4        (2 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 4 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_8        (3 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 8 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_16       (4 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 16 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_32       (5 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 32 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_64       (6 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 64 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_128      (7 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 128 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_192      (8 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 192 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_256      (9 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 256 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_384      (10 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 384 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_512      (11 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 512 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_768      (12 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 768 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1024     (13 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 1024 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1536     (14 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 1536 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2048     (15 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 2048 * (64*WWDT_CLK) */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  WWDT Reload Counter Keyword Constant Definitions                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_RELOAD_WORD        (0x00005AA5)                      /*!< Fill this value to WWDTRLD register to reload WWDT counter */
N
N/*@}*/ /* end of group NUC131_WWDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_WWDT_EXPORTED_FUNCTIONS WWDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT time-out reset system flag.
N  */
N#define WWDT_CLEAR_RESET_FLAG()     (WWDT->WWDTSR = WWDT_WWDTSR_WWDTRF_Msk)
N
N/**
N  * @brief      Clear WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT compared match interrupt flag.
N  */
N#define WWDT_CLEAR_INT_FLAG()       (WWDT->WWDTSR = WWDT_WWDTSR_WWDTIF_Msk)
N
N/**
N  * @brief      Get WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT time-out reset system did not occur
N  * @retval     1   WWDT time-out reset system occurred
N  *
N  * @details    This macro is used to indicate system has been reset by WWDT time-out reset or not.
N  */
N#define WWDT_GET_RESET_FLAG()       ((WWDT->WWDTSR & WWDT_WWDTSR_WWDTRF_Msk)? 1:0)
N
N/**
N  * @brief      Get WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT compare match interrupt did not occur
N  * @retval     1   WWDT compare match interrupt occurred
N  *
N  * @details    This macro is used to indicate WWDT counter value matches CMPDAT value or not.
N  */
N#define WWDT_GET_INT_FLAG()         ((WWDT->WWDTSR & WWDT_WWDTSR_WWDTIF_Msk)? 1:0)
N
N/**
N  * @brief      Get WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     WWDT Counter Value
N  *
N  * @details    This macro reflects the current WWDT counter value.
N  */
N#define WWDT_GET_COUNTER()          (WWDT->WWDTCVR)
N
N/**
N  * @brief      Reload WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reload the WWDT counter value to 0x3F.
N  * @note       User can only write WWDTRLD register to reload WWDT counter value when current WWDT counter value \n
N  *             between 0 and CMPDAT value. If user writes WWDTRLD when current WWDT counter value is larger than CMPDAT, \n
N  *             WWDT reset signal will generate immediately to reset system.
N  */
N#define WWDT_RELOAD_COUNTER()       (WWDT->WWDTRLD = WWDT_RELOAD_WORD)
N
Nvoid WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);
N
N/*@}*/ /* end of group NUC131_WWDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_WWDT_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WWDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 11301 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "UART.h"
L 1 "..\..\..\Library\StdDriver\inc\UART.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V3.0
N * $Revision: 17 $
N * $Date: 15/03/10 11:51a $
N * @brief    NUC131 Series UART Interface Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __UART_H__
N#define __UART_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup NUC131_UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART FIFO size constants definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART0_FIFO_SIZE 16 /*!< UART0 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART1_FIFO_SIZE 16 /*!< UART1 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART2_FIFO_SIZE 16 /*!< UART2 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART3_FIFO_SIZE 1  /*!< UART3 supports separated receive/transmit 1/1 byte buffer */
N#define UART4_FIFO_SIZE 1  /*!< UART4 supports separated receive/transmit 1/1 byte buffer */
N#define UART5_FIFO_SIZE 1  /*!< UART5 supports separated receive/transmit 1/1 byte buffer */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE        (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 byte */
N#define UART_FCR_RFITL_4BYTES       (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bytes */
N#define UART_FCR_RFITL_8BYTES       (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bytes */
N#define UART_FCR_RFITL_14BYTES      (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bytes */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE        (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 byte */
N#define UART_FCR_RTS_TRI_LEV_4BYTES       (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bytes */
N#define UART_FCR_RTS_TRI_LEV_8BYTES       (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bytes */
N#define UART_FCR_RTS_TRI_LEV_14BYTES      (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bytes */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5     (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6     (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7     (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8     (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length */
N#define UART_STOP_BIT_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_LOW_LEV_ACTIVE    (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Active */
N#define UART_RTS_IS_HIGH_LEV_ACTIVE   (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Active */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_IRCR constants definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_IRCR_TX_SELECT         (0x1 << UART_IRCR_TX_SELECT_Pos) /*!< Set IrDA function Tx mode */
N#define UART_IRCR_RX_SELECT         (0x0 << UART_IRCR_TX_SELECT_Pos) /*!< Set IrDA function Rx mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART    (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_LIN     (0x1 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set LIN Function             */
N#define UART_FUNC_SEL_IrDA    (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485   (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LIN_CTL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_LIN_CTL_LINS_EN        (0x1UL << UART_LIN_CTL_LINS_EN_Pos)       /*!< UA_LIN_CTL setting to set LIN Slave Mode Enable */
N#define UART_LIN_CTL_LINS_HDET_EN   (0x1UL << UART_LIN_CTL_LINS_HDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Slave Header Detection Enable */
N#define UART_LIN_CTL_LINS_ARS_EN    (0x1UL << UART_LIN_CTL_LINS_ARS_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Automatic Resynchronization Mode Enable */
N#define UART_LIN_CTL_LINS_DUM_EN    (0x1UL << UART_LIN_CTL_LINS_DUM_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Divider Update Method Enable */
N#define UART_LIN_CTL_LIN_MUTE_EN    (0x1UL << UART_LIN_CTL_LIN_MUTE_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Mute Mode Enable */
N#define UART_LIN_CTL_LIN_SHD        (0x1UL << UART_LIN_CTL_LIN_SHD_Pos)       /*!< UA_LIN_CTL setting to set LIN TX Send Header Enable */
N#define UART_LIN_CTL_LIN_IDPEN      (0x1UL << UART_LIN_CTL_LIN_IDPEN_Pos)     /*!< UA_LIN_CTL setting to set LIN ID Parity Enable */
N#define UART_LIN_CTL_LIN_BKDET_EN   (0x1UL << UART_LIN_CTL_LIN_BKDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Detection Enable */
N#define UART_LIN_CTL_LIN_RX_DIS     (0x1UL << UART_LIN_CTL_LIN_RX_DIS_Pos)    /*!< UA_LIN_CTL setting to set LIN Receiver Disable */
N#define UART_LIN_CTL_BIT_ERR_EN     (0x1UL << UART_LIN_CTL_BIT_ERR_EN_Pos)    /*!< UA_LIN_CTL setting to set Bit Error Detect Enable */
N#define UART_LIN_CTL_LIN_BKFL(x)    (((x)-1) << UART_LIN_CTL_LIN_BKFL_Pos)    /*!< UA_LIN_CTL setting to set LIN Break Field Length, x = 10 ~ 15, default value is 12 */
N#define UART_LIN_CTL_LIN_BS_LEN(x)  (((x)-1) << UART_LIN_CTL_LIN_BS_LEN_Pos)  /*!< UA_LIN_CTL setting to set LIN Break/Sync Delimiter Length, x = 1 ~ 4 */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK             (0x0UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC        (0x1UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field and sync field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC_ID     (0x2UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field, sync field and ID field*/
N#define UART_LIN_CTL_LIN_LIN_PID(x) ((x) << UART_LIN_CTL_LIN_PID_Pos)       /*!< UA_LIN_CTL setting to set LIN PID value */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART BAUDRATE MODE constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0     (0) /*!< Set UART Baudrate Mode is Mode0 */
N#define UART_BAUD_MODE2     (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk) /*!< Set UART Baudrate Mode is Mode2 */
N
N
N/*@}*/ /* end of group NUC131_UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N
N/**
N *    @brief        Calculate UART baudrate mode0 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode0 divider
N *
N *    @details      This macro calculate UART baudrate mode0 divider.
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)*8)) / (u32BaudRate) >> 4)-2)
N
N/**
N *    @brief        Calculate UART baudrate mode2 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode2 divider
N *
N *    @details      This macro calculate UART baudrate mode2 divider.
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)/2)) / (u32BaudRate))-2)
N
N
N/**
N *    @brief        Write data
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *    @param[in]    u8Data  Data byte to transmit.
N *
N *    @return       None
N *
N *    @details      This macro write Data to Tx data register.
N */
N#define UART_WRITE(uart, u8Data)    ((uart)->THR = (u8Data))
N
N/**
N *    @brief        Read data
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       The oldest data byte in RX FIFO.
N *
N *    @details      This macro read Rx data register.
N */
N#define UART_READ(uart)    ((uart)->RBR)
N
N
N/**
N *    @brief        Get Tx empty
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @retval       0   Tx FIFO is not empty
N *    @retval       >=1 Tx FIFO is empty
N *
N *    @details      This macro get Tx empty register value.
N */
N#define UART_GET_TX_EMPTY(uart)    ((uart)->FSR & UART_FSR_TX_EMPTY_Msk)
N
N
N/**
N *    @brief        Get Rx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Rx FIFO is not empty
N *    @retval       >=1 Rx FIFO is empty
N *
N *    @details      This macro get Rx empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    ((uart)->FSR & UART_FSR_RX_EMPTY_Msk)
N
N/**
N *    @brief        Check specified uart port transmission is over.
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Transmission is not over.
N *    @retval       1 Transmission is over.
N *
N *    @details      This macro return if Tx FIFO is empty and specified uart port transmission is over nor not.
N */
N#define UART_IS_TX_EMPTY(uart)    (((uart)->FSR & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos)
N
N
N/**
N *    @brief        Wait specified uart port transmission is over
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       None
N *
N *    @details      This macro wait specified uart port transmission is over.
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!((((uart)->FSR) & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos))
N
N/**
N *    @brief        Check RX is ready or not
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0 The number of bytes in the RX FIFO is less than the RFITL
N *    @retval       1 The number of bytes in the RX FIFO equals or larger than RFITL
N *
N *    @details      This macro check receive data available interrupt flag is set or not.
N */
N#define UART_IS_RX_READY(uart)    (((uart)->ISR & UART_ISR_RDA_IF_Msk)>>UART_ISR_RDA_IF_Pos)
N
N
N/**
N *    @brief        Check TX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       1 TX FIFO is full
N *    @retval       0 TX FIFO is not full
N *
N *    @details      This macro check TX FIFO is full or not.
N */
N#define UART_IS_TX_FULL(uart)    (((uart)->FSR & UART_FSR_TX_FULL_Msk)>>UART_FSR_TX_FULL_Pos)
N
N/**
N *    @brief        Check RX FIFO is full or not
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       1 RX FIFO is full
N *    @retval       0 RX FIFO is not full
N *
N *    @details      This macro check RX FIFO is full or not.
N */
N#define UART_IS_RX_FULL(uart)    (((uart)->FSR & UART_FSR_RX_FULL_Msk)>>UART_FSR_RX_FULL_Pos)
N
N
N/**
N *    @brief        Get Tx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Tx FIFO is not full.
N *    @retval       >=1 Tx FIFO is full.
N *
N *    @details      This macro get Tx full register value.
N */
N#define UART_GET_TX_FULL(uart)    ((uart)->FSR & UART_FSR_TX_FULL_Msk)
N
N
N/**
N *    @brief        Get Rx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Rx FIFO is not full.
N *    @retval       >=1 Rx FIFO is full.
N *
N *    @details      This macro get Rx full register value.
N */
N#define UART_GET_RX_FULL(uart)    ((uart)->FSR & UART_FSR_RX_FULL_Msk)
N
N
N/**
N *    @brief        Enable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module.
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - UART_IER_AERIEN_Msk       : Auto baud rate interrupt
N *                              - UART_IER_WKDATIEN_Msk     : Data wakeup interrupt
N *                              - UART_IER_LIN_IEN_Msk      : Lin bus interrupt
N *                              - UART_IER_WKCTSIEN_Msk     : CTS wakeup interrupt
N *                              - UART_IER_BUF_ERR_IEN_Msk  : Buffer Error interrupt
N *                              - UART_IER_TOUT_IEN_Msk     : Rx time-out interrupt
N *                              - UART_IER_MODEM_IEN_Msk    : Modem interrupt
N *                              - UART_IER_RLS_IEN_Msk      : Rx Line status interrupt
N *                              - UART_IER_THRE_IEN_Msk     : Tx empty interrupt
N *                              - UART_IER_RDA_IEN_Msk      : Rx ready interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    ((uart)->IER |= (u32eIntSel))
N
N
N/**
N *    @brief        Disable specified UART interrupt
N *
N *    @param[in]    uart        The pointer of the specified UART module.
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - UART_IER_AERIEN_Msk       : Auto baud rate interrupt
N *                              - UART_IER_WKDATIEN_Msk     : Data wakeup interrupt
N *                              - UART_IER_LIN_IEN_Msk      : Lin bus interrupt
N *                              - UART_IER_WKCTSIEN_Msk     : CTS wakeup interrupt
N *                              - UART_IER_BUF_ERR_IEN_Msk  : Buffer Error interrupt
N *                              - UART_IER_TOUT_IEN_Msk     : Rx time-out interrupt
N *                              - UART_IER_MODEM_IEN_Msk    : Modem interrupt
N *                              - UART_IER_RLS_IEN_Msk      : Rx Line status interrupt
N *                              - UART_IER_THRE_IEN_Msk     : Tx empty interrupt
N *                              - UART_IER_RDA_IEN_Msk      : Rx ready interrupt
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    ((uart)->IER &= ~ (u32eIntSel))
N
N
N/**
N *    @brief        Get specified interrupt indicator status
N *
N *    @param[in]    uart            Get specified interrupt flag/status
N *    @param[in]    u32eIntTypeFlag Interrupt Type Flag, should be
N *                                  - \ref UART_ISR_DATWKIF_Msk     : Data Wake-Up Interrupt Flag
N *                                  - \ref UART_ISR_CTSWKIF_Msk     : nCTS Wake-Up Interrupt Flag 
N *                                  - \ref UART_ISR_LIN_INT_Msk     : LIN Bus Interrupt Indicator
N *                                  - \ref UART_ISR_BUF_ERR_INT_Msk : Buffer Error Interrupt Indicator
N *                                  - \ref UART_ISR_TOUT_INT_Msk    : Time-out Interrupt Indicator
N *                                  - \ref UART_ISR_MODEM_INT_Msk   : Modem Status Interrupt Indicator
N *                                  - \ref UART_ISR_RLS_INT_Msk     : Receive Line Status Interrupt Indicator
N *                                  - \ref UART_ISR_THRE_INT_Msk    : Transmit Holding Register Empty Interrupt Indicator
N *                                  - \ref UART_ISR_RDA_INT_Msk     : Receive Data Available Interrupt Indicator
N *                                  - \ref UART_ISR_LIN_IF_Msk      : LIN Bus Interrupt Flag
N *                                  - \ref UART_ISR_WKIF_Msk        : UART Wake-Up Flag 
N *                                  - \ref UART_ISR_BUF_ERR_IF_Msk  : Buffer Error Interrupt Flag
N *                                  - \ref UART_ISR_TOUT_IF_Msk     : Rx Time-out Interrupt Flag
N *                                  - \ref UART_ISR_MODEM_IF_Msk    : Modem Interrupt Flag
N *                                  - \ref UART_ISR_RLS_IF_Msk      : Receive Line Status Interrupt Flag
N *                                  - \ref UART_ISR_THRE_IF_Msk     : Tx Empty Interrupt Flag
N *                                  - \ref UART_ISR_RDA_IF_Msk      : Rx Ready Interrupt Flag
N *
N *    @retval       0 The specified interrupt is not happened.
N *    @retval       1 The specified interrupt is happened.
N *
N *    @details      This macro get specified interrupt flag or interrupt indicator status.
N */
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    (((uart)->ISR & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief        Set RTS pin to low
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to low.
N */
N__STATIC_INLINE void UART_CLEAR_RTS(UART_T* uart)
Xstatic __inline void UART_CLEAR_RTS(UART_T* uart)
N{
N    uart->MCR |= UART_MCR_LEV_RTS_Msk;
X    uart->MCR |= (1ul << 9);
N    uart->MCR &= ~UART_MCR_RTS_Msk;
X    uart->MCR &= ~(1ul << 1);
N}
N
N/**
N *    @brief        Set RTS pin to high
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to high.
N */
N__STATIC_INLINE void UART_SET_RTS(UART_T* uart)
Xstatic __inline void UART_SET_RTS(UART_T* uart)
N{
N    uart->MCR |= UART_MCR_LEV_RTS_Msk | UART_MCR_RTS_Msk;
X    uart->MCR |= (1ul << 9) | (1ul << 1);
N}
N
N
N/**
N *    @brief        Clear RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @return       None
N *
N *    @details      This macro clear RS-485 address byte detection flag.
N */
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    ((uart)->FSR = UART_FSR_RS485_ADD_DETF_Msk)
N
N
N/**
N *    @brief        Get RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0 Receiver detects a data that is not an address bit.
N *    @retval       1 Receiver detects a data that is an address bit.
N *
N *    @details      This macro get RS-485 address byte detection flag.
N */
N#define UART_RS485_GET_ADDR_FLAG(uart)    (((uart)->FSR  & UART_FSR_RS485_ADD_DETF_Msk) >> UART_FSR_RS485_ADD_DETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart);
Nvoid UART_DisableFlowCtrl(UART_T* uart);
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_EnableFlowCtrl(UART_T* uart);
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nvoid UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength);
Nuint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group NUC131_UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_UART_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
L 11302 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N#include "CLK.h"
L 1 "..\..\..\Library\StdDriver\inc\CLK.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V3.0
N * $Revision: 17 $
N * $Date: 17/07/24 1:24p $
N * @brief    NUC131 Series Clock Control Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup NUC131_CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N#define FREQ_25MHZ         25000000
N#define FREQ_50MHZ         50000000
N#define FREQ_100MHZ       100000000
N#define FREQ_200MHZ       200000000
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLK_S_HXT          (0x0UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as external X'tal */
N#define CLK_CLKSEL0_HCLK_S_PLL          (0x2UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as PLL output */
N#define CLK_CLKSEL0_HCLK_S_LIRC         (0x3UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL0_HCLK_S_HIRC         (0x7UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL0_STCLK_S_HXT         (0x0UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as external X'tal */
N#define CLK_CLKSEL0_STCLK_S_HXT_DIV2    (0x2UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as external X'tal/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK_DIV2   (0x3UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLK_S_HIRC_DIV2   (0x7UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as internal 22.1184MHz RC clock/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK        (0x1UL<<SysTick_CTRL_CLKSOURCE_Pos)  /*!< Setting STCLK clock source as HCLK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDT_S_HCLK_DIV2048  (0x2UL<<CLK_CLKSEL1_WDT_S_Pos)    /*!< Setting WDT clock source as HCLK/2048 */
N#define CLK_CLKSEL1_WDT_S_LIRC          (0x3UL<<CLK_CLKSEL1_WDT_S_Pos)    /*!< Setting WDT clock source as internal 10KHz RC clock */
N
N#define CLK_CLKSEL1_ADC_S_HXT           (0x0UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as external X'tal */
N#define CLK_CLKSEL1_ADC_S_PLL           (0x1UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as PLL */
N#define CLK_CLKSEL1_ADC_S_HCLK          (0x2UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as HCLK */
N#define CLK_CLKSEL1_ADC_S_HIRC          (0x3UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL1_SPI0_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI0_S_Pos)   /*!< Setting SPI0 clock source as PLL */
N#define CLK_CLKSEL1_SPI0_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI0_S_Pos)   /*!< Setting SPI0 clock source as HCLK */
N
N#define CLK_CLKSEL1_TMR0_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR0_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as external trigger */
N#define CLK_CLKSEL1_TMR0_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR0_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR1_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as HCLK */
N#define CLK_CLKSEL1_TMR1_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as external trigger */
N#define CLK_CLKSEL1_TMR1_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR2_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR2_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as HCLK */
N#define CLK_CLKSEL1_TMR2_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as external trigger */
N#define CLK_CLKSEL1_TMR2_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR2_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR3_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR3_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as HCLK */
N#define CLK_CLKSEL1_TMR3_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as external trigger */
N#define CLK_CLKSEL1_TMR3_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR3_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL1_UART_S_HXT          (0x0UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external X'tal */
N#define CLK_CLKSEL1_UART_S_PLL          (0x1UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external PLL */
N#define CLK_CLKSEL1_UART_S_HIRC         (0x3UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external internal 22.1184MHz RC clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_FRQDIV_S_HXT        (0x0UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as external X'tal */
N#define CLK_CLKSEL2_FRQDIV_S_HCLK       (0x2UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as HCLK */
N#define CLK_CLKSEL2_FRQDIV_S_HIRC       (0x3UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL2_WWDT_S_HCLK_DIV2048 (0x2UL<<CLK_CLKSEL2_WWDT_S_Pos)   /*!< Setting WWDT clock source as HCLK/2048 */
N#define CLK_CLKSEL2_WWDT_S_LIRC         (0x3UL<<CLK_CLKSEL2_WWDT_S_Pos)   /*!< Setting WWDT clock source as internal 10KHz RC clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL3 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL3_PWM0_S_PLL          (0x0UL<<CLK_CLKSEL3_PWM0_S_Pos)    /*!< Setting PWM0 clock source as PLL */
N#define CLK_CLKSEL3_PWM0_S_PCLK         (0x1UL<<CLK_CLKSEL3_PWM0_S_Pos)    /*!< Setting PWM0 clock source as PCLK */
N#define CLK_CLKSEL3_PWM1_S_PLL          (0x0UL<<CLK_CLKSEL3_PWM1_S_Pos)    /*!< Setting PWM1 clock source as PLL */
N#define CLK_CLKSEL3_PWM1_S_PCLK         (0x1UL<<CLK_CLKSEL3_PWM1_S_Pos)    /*!< Setting PWM1 clock source as PCLK */
N
N#define CLK_CLKSEL3_BPWM0_S_PLL         (0x0UL<<CLK_CLKSEL3_BPWM0_S_Pos)    /*!< Setting BPWM0 clock source as PLL */
N#define CLK_CLKSEL3_BPWM0_S_PCLK        (0x1UL<<CLK_CLKSEL3_BPWM0_S_Pos)    /*!< Setting BPWM0 clock source as PCLK */
N#define CLK_CLKSEL3_BPWM1_S_PLL         (0x0UL<<CLK_CLKSEL3_BPWM1_S_Pos)    /*!< Setting BPWM1 clock source as PLL */
N#define CLK_CLKSEL3_BPWM1_S_PCLK        (0x1UL<<CLK_CLKSEL3_BPWM1_S_Pos)    /*!< Setting BPWM1 clock source as PCLK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV_HCLK(x)  ((x)-1)                             /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */
N#define CLK_CLKDIV_UART(x) (((x)-1) << CLK_CLKDIV_UART_N_Pos)   /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */
N#define CLK_CLKDIV_ADC(x)  (((x)-1) << CLK_CLKDIV_ADC_N_Pos)    /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCON constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PLLCON_PLL_SRC_HXT   0x00000000UL    /*!< For PLL clock source is HXT.  3.2MHz < FIN < 150MHz */
N#define CLK_PLLCON_PLL_SRC_HIRC  0x00080000UL    /*!< For PLL clock source is HIRC. 3.2MHz < FIN < 150MHz */
N
N#define CLK_PLLCON_NR(x)         (((x)-2)<<9)    /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 15MHz */
N#define CLK_PLLCON_NF(x)          ((x)-2)        /*!< x must be constant and 2 <= x <= 513. 100MHz < FIN*NF/NR < 200MHz. (120MHz < FIN*NF/NR < 200MHz is preferred.) */
N
N#define CLK_PLLCON_NO_1          0x0000UL        /*!< For output divider is 1 */
N#define CLK_PLLCON_NO_2          0x4000UL        /*!< For output divider is 2 */
N#define CLK_PLLCON_NO_4          0xC000UL        /*!< For output divider is 4 */
N
N#if (__HXT == 12000000)
X#if ((12000000UL) == 12000000)
N#define CLK_PLLCON_50MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(3) | CLK_PLLCON_NF( 25) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_48MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(7) | CLK_PLLCON_NF(112) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_36MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(7) | CLK_PLLCON_NF( 84) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 36MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_32MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(6) | CLK_PLLCON_NF( 64) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 32MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_25MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(3) | CLK_PLLCON_NF( 25) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 25MHz PLL output with 12MHz X'tal */
N#else
S# error "The PLL pre-definitions are only valid when external crystal is 12MHz"
N#endif
N
N#define CLK_PLLCON_50MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF( 59) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50.1918MHz PLL output with 22.1184MHz IRC */
N#define CLK_PLLCON_48MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF(113) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48.064985MHz PLL output with 22.1184MHz IRC*/
N#define CLK_PLLCON_36MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(12) | CLK_PLLCON_NF( 78) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 35.9424MHz PLL output with 22.1184MHz IRC */
N#define CLK_PLLCON_32MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR( 9) | CLK_PLLCON_NF( 52) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 31.9488MHz PLL output with 22.1184MHz IRC*/
N#define CLK_PLLCON_25MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF( 59) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 25.0959MHz PLL output with 22.1184MHz IRC*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* APBCLK(31:30)|CLKSEL(29:28)|CLKSEL_Msk(27:25) |CLKSEL_Pos(24:20)|CLKDIV(19:18)|CLKDIV_Msk(17:10)|CLKDIV_Pos(9:5)|IP_EN_Pos(4:0) */
N
N#define MODULE_APBCLK(x)        (((x) >>30) & 0x3)    /*!< Calculate APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK, 0x2:APBCLK1 */
N#define MODULE_CLKSEL(x)        (((x) >>28) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk(x)    (((x) >>25) & 0x7)    /*!< Calculate CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos(x)    (((x) >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV(x)        (((x) >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index, 0x0:CLKDIV */
N#define MODULE_CLKDIV_Msk(x)    (((x) >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos(x)    (((x) >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos(x)     (((x) >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */
N#define MODULE_NoMsk            0x0                 /*!< Not mask on MODULE index */
N#define NA                      MODULE_NoMsk        /*!< Not Available */
N
N#define MODULE_APBCLK_ENC(x)        (((x) & 0x03) << 30)   /*!< MODULE index, 0x0:AHBCLK, 0x1:APBCLK, 0x2:APBCLK1 */
N#define MODULE_CLKSEL_ENC(x)        (((x) & 0x03) << 28)   /*!< CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk_ENC(x)    (((x) & 0x07) << 25)   /*!< CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos_ENC(x)    (((x) & 0x1f) << 20)   /*!< CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV_ENC(x)        (((x) & 0x03) << 18)   /*!< APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk_ENC(x)    (((x) & 0xff) << 10)   /*!< CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos_ENC(x)    (((x) & 0x1f) <<  5)   /*!< CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos_ENC(x)     (((x) & 0x1f) <<  0)   /*!< APBCLK offset on MODULE index */
N
N
N#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISP_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ISP Module */
X#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISP_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WDT Module */
X#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos)  |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR0 Module */
X#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR0_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR1 Module */
X#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR1_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR2_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR2 Module */
X#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR2_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR3_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR3 Module */
X#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR3_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define FDIV_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_FDIV_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< FDIV Module */
X#define FDIV_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_FDIV_EN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C0 Module */
X#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C0_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C1 Module */
X#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C1_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 4)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI0 Module */
X#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI0_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 4)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART0_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART0 Module */
X#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART0_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART1_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART1 Module */
X#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART1_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART2_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART2 Module */
X#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART2_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define CAN0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_CAN0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< CAN0 Module */
X#define CAN0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_CAN0_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define ADC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ADC_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))    /*!< ADC Module */
X#define ADC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ADC_EN_Pos)  |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))     
N
N#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WWDT Module */
X#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define UART3_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_UART3_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART3 Module */
X#define UART3_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_UART3_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART4_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_UART4_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART4 Module */
X#define UART4_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_UART4_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define UART5_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_UART5_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART5 Module */
X#define UART5_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_UART5_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N
N#define PWM0_MODULE    (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_PWM0_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM0 Module */
X#define PWM0_MODULE    (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_PWM0_EN_Pos)|                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define PWM1_MODULE    (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_PWM1_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(17)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM1 Module */
X#define PWM1_MODULE    (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_PWM1_EN_Pos)|                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(17)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define BPWM0_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_BPWM0_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(18)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< BPWM0 Module */
X#define BPWM0_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_BPWM0_EN_Pos)|                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(18)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N#define BPWM1_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_BPWM1_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(19)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< BPWM1 Module */
X#define BPWM1_MODULE   (MODULE_APBCLK_ENC(2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_BPWM1_EN_Pos)|                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(19)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N
N/*@}*/ /* end of group NUC131_CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup NUC131_CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Get PLL clock frequency
N  * @param      None
N  * @return     PLL frequency
N  * @details    This function get PLL frequency. The frequency unit is Hz.
N  */
N__STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
Xstatic __inline uint32_t CLK_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq = 0, u32PllReg;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4};
N
N    u32PllReg = CLK->PLLCON;
X    u32PllReg = ((CLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCON;
N
N    if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
X    if(u32PllReg & ((1ul << 16) | (1ul << 18)))
N        return 0;           /* PLL is in power down mode or fix low */
N
N    if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
X    if(u32PllReg & 0x00080000UL)
N        u32FIN = __HIRC;    /* PLL source clock from HIRC */
X        u32FIN = (22118400UL);     
N    else
N        u32FIN = __HXT;     /* PLL source clock from HXT */
X        u32FIN = (12000000UL);      
N
N    if(u32PllReg & CLK_PLLCON_BP_Msk)
X    if(u32PllReg & (1ul << 17))
N        return u32FIN;      /* PLL is in bypass mode */
N
N    /* PLL is output enabled in normal work mode */
N    u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
X    u32NO = au8NoTbl[((u32PllReg & (3ul << 14)) >> 14)];
N    u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
X    u32NF = ((u32PllReg & (0x1FFul << 0)) >> 0) + 2;
N    u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
X    u32NR = ((u32PllReg & (0x1Ful << 9)) >> 9) + 2;
N
N    /* u32FIN is shifted 2 bits to avoid overflow */
N    u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
N
N    return u32PllFreq;
N}
N
N/**
N  * @brief      This function execute delay function.
N  * @param[in]  us  Delay time. The Max value is 2^24 / CPU Clock(MHz). Ex:
N  *                             50MHz => 335544us, 48MHz => 349525us, 28MHz => 699050us ...
N  * @return     None
N  * @details    Use the SysTick to generate the delay time and the UNIT is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  */
N__STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
Xstatic __inline void CLK_SysTickDelay(uint32_t us)
N{
N    SysTick->LOAD = us * CyclesPerUs;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = us * CyclesPerUs;
N    SysTick->VAL  = (0x00);
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2) | (1UL << 0);
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
X    while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16)) == 0);
N    
N    /* Disable SysTick counter */
N    SysTick->CTRL = 0;    
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0;    
N}
N
N/**
N  * @brief      This function execute long delay function.
N  * @param[in]  us  Delay time. 
N  * @return     None
N  * @details    Use the SysTick to generate the long delay time and the UNIT is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  *             User can use SystemCoreClockUpdate() to calculate CyclesPerUs automatically before using this function.
N  */
N__STATIC_INLINE void CLK_SysTickLongDelay(uint32_t us)
Xstatic __inline void CLK_SysTickLongDelay(uint32_t us)
N{
N    uint32_t delay;
N        
N    /* It should <= 335544us for each delay loop */
N    delay = 335544UL;
N
N    do
N    {
N        if(us > delay)
N        {
N            us -= delay;
N        }
N        else
N        {
N            delay = us;
N            us = 0UL;
N        }        
N        
N        SysTick->LOAD = delay * CyclesPerUs;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = delay * CyclesPerUs;
N        SysTick->VAL  = (0x0UL);
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x0UL);
N        SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2) | (1UL << 0);
N
N        /* Waiting for down-count to zero */
N        while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0UL);
X        while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16)) == 0UL);
N
N        /* Disable SysTick counter */
N        SysTick->CTRL = 0UL;
X        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0UL;
N    
N    }while(us > 0UL);
N    
N}
N
N
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetPCLKFreq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
Nvoid CLK_DisableSysTick(void);
N
N
N/*@}*/ /* end of group NUC131_CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_CLK_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N
N
N#endif //__CLK_H__
N
N
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 11303 "..\..\..\Library\Device\Nuvoton\NUC131\Include\NUC131.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // End of __NUC131_H__
N
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 13 "..\..\..\Library\StdDriver\src\sys.c" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup NUC131_Device_Driver NUC131 Device Driver
N  @{
N*/
N
N/** @addtogroup NUC131_SYS_Driver SYS Driver
N  @{
N*/
N
N
N/** @addtogroup NUC131_SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear reset source
N  * @param[in]  u32Src is system reset source. Including :
N  *             - \ref SYS_RSTSRC_RSTS_CPU_Msk
N  *             - \ref SYS_RSTSRC_RSTS_SYS_Msk
N  *             - \ref SYS_RSTSRC_RSTS_BOD_Msk
N  *             - \ref SYS_RSTSRC_RSTS_LVR_Msk
N  *             - \ref SYS_RSTSRC_RSTS_WDT_Msk
N  *             - \ref SYS_RSTSRC_RSTS_RESET_Msk
N  *             - \ref SYS_RSTSRC_RSTS_POR_Msk
N  * @return     None
N  * @details    This function clear the selected system reset source.
N  */
Nvoid SYS_ClearResetSrc(uint32_t u32Src)
N{
N    SYS->RSTSRC |= u32Src;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->RSTSRC |= u32Src;
N}
N
N/**
N  * @brief      Get Brown-out detector output status
N  * @param      None
N  * @retval     0 System voltage is higher than BOD_VL setting or BOD_EN is 0.
N  * @retval     1 System voltage is lower than BOD_VL setting.
N  * @details    This function get Brown-out detector output status.
N  */
Nuint32_t SYS_GetBODStatus(void)
N{
N    return (SYS->BODCR & SYS_BODCR_BOD_OUT_Msk) ? 1 : 0;
X    return (((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->BODCR & (1ul << 6)) ? 1 : 0;
N}
N
N/**
N  * @brief      Get reset status register value
N  * @param      None
N  * @return     Reset source
N  * @details    This function get the system reset status register value.
N  */
Nuint32_t SYS_GetResetSrc(void)
N{
N    return (SYS->RSTSRC);
X    return (((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->RSTSRC);
N}
N
N/**
N  * @brief      Check if register lock is set
N  * @param      None
N  * @retval     0 Write-protection function is disabled.
N  * @retval     1 Write-protection function is enabled.
N  * @details    This function check register write-protection bit setting.
N  */
Nuint32_t SYS_IsRegLocked(void)
N{
N    return !(SYS->REGWRPROT & SYS_REGWRPROT_REGPROTDIS_Msk);
X    return !(((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT & (1ul << 0));
N}
N
N/**
N  * @brief      Get product ID
N  * @param      None
N  * @return     Product ID
N  * @details    This function get product ID.
N  */
Nuint32_t  SYS_ReadPDID(void)
N{
N    return SYS->PDID;
X    return ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->PDID;
N}
N
N/**
N  * @brief      Reset chip with chip reset
N  * @param      None
N  * @return     None
N  * @details    This function reset chip with chip reset.
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid SYS_ResetChip(void)
N{
N    SYS->IPRSTC1 |= SYS_IPRSTC1_CHIP_RST_Msk;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC1 |= (1ul << 0);
N}
N
N/**
N  * @brief      Reset chip with CPU reset
N  * @param      None
N  * @return     None
N  * @details    This function reset CPU with CPU reset.
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid SYS_ResetCPU(void)
N{
N    SYS->IPRSTC1 |= SYS_IPRSTC1_CPU_RST_Msk;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC1 |= (1ul << 1);
N}
N
N/**
N  * @brief      Reset Module
N  * @param[in]  u32ModuleIndex is module index. Including :
N  *             - \ref GPIO_RST
N  *             - \ref TMR0_RST
N  *             - \ref TMR1_RST
N  *             - \ref TMR2_RST
N  *             - \ref TMR3_RST
N  *             - \ref I2C0_RST
N  *             - \ref I2C1_RST
N  *             - \ref SPI0_RST
N  *             - \ref UART0_RST
N  *             - \ref UART1_RST
N  *             - \ref UART2_RST
N  *             - \ref UART3_RST
N  *             - \ref UART4_RST
N  *             - \ref UART5_RST
N  *             - \ref CAN0_RST
N  *             - \ref ADC_RST
N  *             - \ref PWM0_RST
N  *             - \ref PWM1_RST
N  *             - \ref BPWM0_RST
N  *             - \ref BPWM1_RST
N  * @return     None
N  * @details    This function reset selected modules.
N  */
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex)
N{
N    /* Generate reset signal to the corresponding module */
N    *(volatile uint32_t *)((uint32_t)&SYS->IPRSTC1 + (u32ModuleIndex >> 24)) |= 1 << (u32ModuleIndex & 0x00ffffff);
X    *(volatile uint32_t *)((uint32_t)&((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC1 + (u32ModuleIndex >> 24)) |= 1 << (u32ModuleIndex & 0x00ffffff);
N
N    /* Release corresponding module from reset state */
N    *(volatile uint32_t *)((uint32_t)&SYS->IPRSTC1 + (u32ModuleIndex >> 24)) &= ~(1 << (u32ModuleIndex & 0x00ffffff));
X    *(volatile uint32_t *)((uint32_t)&((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC1 + (u32ModuleIndex >> 24)) &= ~(1 << (u32ModuleIndex & 0x00ffffff));
N}
N
N/**
N  * @brief      Enable and set Brown-out detector function
N  * @param[in]  i32Mode is reset or interrupt mode. Including :
N  *             - \ref SYS_BODCR_BOD_RST_EN
N  *             - \ref SYS_BODCR_BOD_INTERRUPT_EN
N  * @param[in]  u32BODLevel is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCR_BOD_VL_4_4V
N  *             - \ref SYS_BODCR_BOD_VL_3_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_2V
N  * @return     None
N  * @details    This function configure Brown-out detector reset or interrupt mode, enable Brown-out function and set Brown-out voltage level.
N  *             The register write-protection function should be disabled before using this function.
N  *
N  */
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel)
N{
N    /* Enable Brown-out Detector function */
N    SYS->BODCR |= SYS_BODCR_BOD_EN_Msk;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->BODCR |= (1ul << 0);
N
N    /* Enable Brown-out interrupt or reset function */
N    SYS->BODCR = (SYS->BODCR & ~SYS_BODCR_BOD_RSTEN_Msk) | i32Mode;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->BODCR = (((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->BODCR & ~(1ul << 3)) | i32Mode;
N
N    /* Select Brown-out Detector threshold voltage */
N    SYS->BODCR = (SYS->BODCR & ~SYS_BODCR_BOD_VL_Msk) | u32BODLevel;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->BODCR = (((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->BODCR & ~(3ul << 1)) | u32BODLevel;
N}
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This function disable Brown-out detector function.
N  *             The register write-protection function should be disabled before using this function.
N  */
Nvoid SYS_DisableBOD(void)
N{
N    SYS->BODCR &= ~SYS_BODCR_BOD_EN_Msk;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->BODCR &= ~(1ul << 0);
N}
N
N
N
N/*@}*/ /* end of group NUC131_SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group NUC131_SYS_Driver */
N
N/*@}*/ /* end of group NUC131_Device_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
